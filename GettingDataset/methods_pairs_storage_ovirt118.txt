1100
#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#method_after
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#end_block

#method_before
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (isInternalExecution() || !isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#method_after
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (!isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#end_block

#method_before
protected boolean isQuotaDependant() {
    return getActionType().getQuotaDependency() != VdcActionType.QuotaDependency.NONE;
}
#method_after
protected boolean isQuotaDependant() {
    boolean result;
    if (getActionType().getQuotaDependency() == VdcActionType.QuotaDependency.NONE)
        result = false;
    else if (!isInternalExecution())
        result = true;
    else if (getActionType().isQuotaDependentAsInternalCommand())
        result = true;
    else
        result = false;
    return result;
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, String groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, groupIds, actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, HashSet<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#end_block

#method_before
protected AsyncTaskType getTaskType() {
    throw new UnsupportedOperationException();
}
#method_after
protected AsyncTaskType getTaskType() {
    return AsyncTaskType.notSupported;
}
#end_block

#method_before
public AsyncTaskType getAsyncTaskType() {
    return getTaskType();
}
#method_after
public AsyncTaskType getAsyncTaskType() {
    if (getTaskType() == AsyncTaskType.notSupported) {
        throw new UnsupportedOperationException();
    }
    return getTaskType();
}
#end_block

#method_before
protected void persistCommand(VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    TaskManagerUtil.persistCommand(getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), parentParameters.getCommandId(), getActionType(), getParameters(), commandStatus);
}
#method_after
protected void persistCommand(VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    TaskManagerUtil.persistCommand(getCommandId(), parentParameters.getCommandId(), getActionType(), getParameters(), commandStatus);
}
#end_block

#method_before
protected void setCommandStatus(CommandStatus status) {
    this.commandStatus = status;
    TaskManagerUtil.updateCommandStatus(getCommandId(), commandStatus);
}
#method_after
protected void setCommandStatus(CommandStatus status) {
    this.commandStatus = status;
    TaskManagerUtil.updateCommandStatus(getCommandId(), getTaskType(), commandStatus);
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(CommandEntity entity) {
    return getCustomMapSqlParameterSource().addValue("command_id", Guid.isNullOrEmpty(entity.getId()) ? Guid.Empty : entity.getId()).addValue("command_type", entity.getCommandType().getValue()).addValue("parent_command_id", Guid.isNullOrEmpty(entity.getParentCommandId()) ? Guid.Empty : entity.getParentCommandId()).addValue("root_command_id", Guid.isNullOrEmpty(entity.getRootCommandId()) ? Guid.Empty : entity.getRootCommandId()).addValue("action_parameters", serializeParameters(entity.getActionParameters())).addValue("action_parameters_class", entity.getActionParameters() == null ? null : entity.getActionParameters().getClass().getName()).addValue("status", entity.getCommandStatus().toString());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(CommandEntity entity) {
    return getCustomMapSqlParameterSource().addValue("command_id", Guid.isNullOrEmpty(entity.getId()) ? Guid.Empty : entity.getId()).addValue("command_type", entity.getCommandType().getValue()).addValue("root_command_id", Guid.isNullOrEmpty(entity.getRootCommandId()) ? Guid.Empty : entity.getRootCommandId()).addValue("action_parameters", serializeParameters(entity.getActionParameters())).addValue("action_parameters_class", entity.getActionParameters() == null ? null : entity.getActionParameters().getClass().getName()).addValue("status", entity.getCommandStatus().toString());
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((commandId == null) ? 0 : commandId.hashCode());
    result = prime * result + ((commandType == null) ? 0 : commandType.hashCode());
    result = prime * result + ((parentCommandId == null) ? 0 : parentCommandId.hashCode());
    result = prime * result + ((rootCommandId == null) ? 0 : rootCommandId.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (Guid.isNullOrEmpty(commandId) ? 0 : commandId.hashCode());
    result = prime * result + ((commandType == null) ? 0 : commandType.hashCode());
    result = prime * result + (Guid.isNullOrEmpty(rootCommandId) ? 0 : rootCommandId.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    CommandEntity other = (CommandEntity) obj;
    return ObjectUtils.objectsEqual(commandId, other.commandId) && commandType == other.commandType && ObjectUtils.objectsEqual(parentCommandId, other.parentCommandId) && ObjectUtils.objectsEqual(rootCommandId, other.rootCommandId);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    CommandEntity other = (CommandEntity) obj;
    return ObjectUtils.objectsEqual(commandId, other.commandId) && commandType == other.commandType && ObjectUtils.objectsEqual(getGuid(rootCommandId), getGuid(other.rootCommandId));
}
#end_block

#method_before
public static SPMAsyncTask construct(CommandCoordinator coco, AsyncTaskCreationInfo creationInfo) {
    AsyncTasks asyncTask = coco.getByVdsmTaskId(creationInfo.getVdsmTaskId());
    if (asyncTask == null || asyncTask.getActionParameters() == null) {
        Guid parentCmdId = asyncTask == null ? Guid.Empty : asyncTask.getParentCommandId();
        CommandStatus cmdStatus = asyncTask == null ? CommandStatus.UNKNOWN : asyncTask.getCommandStatus();
        asyncTask = new AsyncTasks(VdcActionType.Unknown, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, creationInfo.getVdsmTaskId(), new VdcActionParametersBase(), new VdcActionParametersBase(), creationInfo.getStepId(), asyncTask == null ? Guid.newGuid() : asyncTask.getCommandId(), asyncTask == null ? Guid.newGuid() : asyncTask.getRootCommandId(), creationInfo.getStoragePoolID(), creationInfo.getTaskType());
        asyncTask.setParentCommandId(parentCmdId);
        asyncTask.setCommandStatus(cmdStatus);
        creationInfo.setTaskType(AsyncTaskType.unknown);
    }
    AsyncTaskParameters asyncTaskParams = new AsyncTaskParameters(creationInfo, asyncTask);
    return construct(coco, creationInfo.getTaskType(), asyncTaskParams, true);
}
#method_after
public static SPMAsyncTask construct(CommandCoordinator coco, AsyncTaskCreationInfo creationInfo) {
    AsyncTasks asyncTask = coco.getByVdsmTaskId(creationInfo.getVdsmTaskId());
    if (asyncTask == null || asyncTask.getActionParameters() == null) {
        CommandStatus cmdStatus = asyncTask == null ? CommandStatus.UNKNOWN : asyncTask.getCommandStatus();
        asyncTask = new AsyncTasks(VdcActionType.Unknown, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, creationInfo.getVdsmTaskId(), new VdcActionParametersBase(), new VdcActionParametersBase(), creationInfo.getStepId(), asyncTask == null ? Guid.newGuid() : asyncTask.getCommandId(), asyncTask == null ? Guid.newGuid() : asyncTask.getRootCommandId(), creationInfo.getStoragePoolID(), creationInfo.getTaskType(), cmdStatus);
        creationInfo.setTaskType(AsyncTaskType.unknown);
    }
    AsyncTaskParameters asyncTaskParams = new AsyncTaskParameters(creationInfo, asyncTask);
    return construct(coco, creationInfo.getTaskType(), asyncTaskParams, true);
}
#end_block

#method_before
public static AsyncTaskManager getInstance(CommandCoordinator coco) {
    if (taskManager == null) {
        synchronized (LOCK) {
            if (taskManager == null) {
                taskManager = new AsyncTaskManager(coco);
            }
        }
    }
    return taskManager;
}
#method_after
public static AsyncTaskManager getInstance() {
    return taskManager;
}
#end_block

#method_before
synchronized private void removeClearedAndOldTasks() {
    Set<Guid> poolsOfActiveTasks = new HashSet<Guid>();
    Set<Guid> poolsOfClearedAndOldTasks = new HashSet<Guid>();
    ConcurrentMap<Guid, SPMTask> activeTaskMap = new ConcurrentHashMap<Guid, SPMTask>();
    for (SPMTask task : _tasks.values()) {
        if (!cachingOver(task)) {
            activeTaskMap.put(task.getVdsmTaskId(), task);
            poolsOfActiveTasks.add(task.getStoragePoolID());
        } else {
            poolsOfClearedAndOldTasks.add(task.getStoragePoolID());
        }
    }
    // Check if _tasks need to be updated with less tasks (activated tasks).
    if (poolsOfClearedAndOldTasks.size() > 0) {
        setNewMap(activeTaskMap);
        poolsOfClearedAndOldTasks.removeAll(poolsOfActiveTasks);
    }
    for (Guid storagePoolID : poolsOfClearedAndOldTasks) {
        log.infoFormat("Cleared all tasks of pool {0}.", storagePoolID);
    }
}
#method_after
synchronized private void removeClearedAndOldTasks() {
    Set<Guid> poolsOfActiveTasks = new HashSet<Guid>();
    Set<Guid> poolsOfClearedAndOldTasks = new HashSet<Guid>();
    ConcurrentMap<Guid, SPMTask> activeTaskMap = new ConcurrentHashMap<>();
    for (SPMTask task : _tasks.values()) {
        if (!cachingOver(task)) {
            activeTaskMap.put(task.getVdsmTaskId(), task);
            poolsOfActiveTasks.add(task.getStoragePoolID());
        } else {
            poolsOfClearedAndOldTasks.add(task.getStoragePoolID());
        }
    }
    // Check if _tasks need to be updated with less tasks (activated tasks).
    if (poolsOfClearedAndOldTasks.size() > 0) {
        setNewMap(activeTaskMap);
        poolsOfClearedAndOldTasks.removeAll(poolsOfActiveTasks);
    }
    for (Guid storagePoolID : poolsOfClearedAndOldTasks) {
        log.infoFormat("Cleared all tasks of pool {0}.", storagePoolID);
    }
}
#end_block

#method_before
private void persistCommand(CommandEntity cmdEntity) {
    this.persistCommand(cmdEntity.getId(), cmdEntity.getParentCommandId(), cmdEntity.getRootCommandId(), cmdEntity.getCommandType(), cmdEntity.getActionParameters(), cmdEntity.getCommandStatus());
}
#method_after
@Override
public void persistCommand(CommandEntity cmdEntity) {
    this.persistCommand(cmdEntity.getId(), cmdEntity.getRootCommandId(), cmdEntity.getCommandType(), cmdEntity.getActionParameters(), cmdEntity.getCommandStatus());
}
#end_block

#method_before
@Override
public void persistCommand(Guid commandId, Guid parentCommandId, Guid rootCommandId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status) {
    commandsCache.put(commandId, parentCommandId, rootCommandId, actionType, params, status);
}
#method_after
@Override
public void persistCommand(Guid commandId, Guid rootCommandId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status) {
    commandsCache.put(commandId, rootCommandId, actionType, params, status);
}
#end_block

#method_before
@Override
public CommandBase<?> retrieveCommand(Guid commandId) {
    CommandBase<?> command = null;
    CommandEntity cmdEntity = commandsCache.get(commandId);
    if (cmdEntity != null) {
        command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getActionParameters());
        // if the parentCommand Id is not null but parent parameters is null we rebuild the command hierarchy
        if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && command.getParameters().getParentParameters() == null) {
            CommandBase<?> parentCommand = retrieveCommand(cmdEntity.getParentCommandId());
            if (parentCommand != null) {
                command.getParameters().setParentParameters(parentCommand.getParameters());
            }
        }
    }
    return command;
}
#method_after
@Override
public CommandBase<?> retrieveCommand(Guid commandId) {
    CommandBase<?> command = null;
    CommandEntity cmdEntity = commandsCache.get(commandId);
    if (cmdEntity != null) {
        command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getActionParameters());
    }
    return command;
}
#end_block

#method_before
public void updateCommandStatus(final Guid commandId, final CommandStatus status) {
    commandsCache.updateCommandStatus(commandId, status);
}
#method_after
public void updateCommandStatus(final Guid commandId, final AsyncTaskType taskType, final CommandStatus status) {
    commandsCache.updateCommandStatus(commandId, taskType, status);
}
#end_block

#method_before
public List<AsyncTasks> getAllAsyncTasksFromDb() {
    List<AsyncTasks> asyncTasks = DbFacade.getInstance().getAsyncTaskDao().getAll();
    for (AsyncTasks asyncTask : asyncTasks) {
        copyFromCommandEntity(asyncTask, commandsCache.get(asyncTask.getCommandId()));
    }
    return asyncTasks;
}
#method_after
public List<AsyncTasks> getAllAsyncTasksFromDb() {
    return coCoAsyncTaskHelper.getAllAsyncTasksFromDb(this);
}
#end_block

#method_before
public void saveAsyncTaskToDb(final AsyncTasks asyncTask) {
    DbFacade.getInstance().getAsyncTaskDao().save(asyncTask);
    persistCommand(copyToCommandEntity(asyncTask, commandsCache.get(asyncTask.getCommandId())));
}
#method_after
public void saveAsyncTaskToDb(final AsyncTasks asyncTask) {
    coCoAsyncTaskHelper.saveAsyncTaskToDb(asyncTask);
}
#end_block

#method_before
public AsyncTasks getAsyncTaskFromDb(Guid asyncTaskId) {
    AsyncTasks asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(asyncTaskId);
    if (asyncTask != null) {
        copyFromCommandEntity(asyncTask, commandsCache.get(asyncTask.getCommandId()));
    }
    return asyncTask;
}
#method_after
public AsyncTasks getAsyncTaskFromDb(Guid asyncTaskId) {
    return coCoAsyncTaskHelper.getAsyncTaskFromDb(asyncTaskId);
}
#end_block

#method_before
public int removeTaskFromDbByTaskId(final Guid taskId) throws RuntimeException {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Integer>() {

        @Override
        public Integer runInTransaction() {
            AsyncTasks asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(taskId);
            int retVal = DbFacade.getInstance().getAsyncTaskDao().remove(taskId);
            if (asyncTask != null && !Guid.isNullOrEmpty(asyncTask.getCommandId())) {
                commandsCache.remove(asyncTask.getCommandId());
            }
            return retVal;
        }
    });
}
#method_after
public int removeTaskFromDbByTaskId(final Guid taskId) throws RuntimeException {
    return coCoAsyncTaskHelper.removeTaskFromDbByTaskId(taskId);
}
#end_block

#method_before
public AsyncTasks getByVdsmTaskId(Guid vdsmTaskId) {
    AsyncTasks asyncTask = DbFacade.getInstance().getAsyncTaskDao().getByVdsmTaskId(vdsmTaskId);
    if (asyncTask != null) {
        copyFromCommandEntity(asyncTask, commandsCache.get(asyncTask.getCommandId()));
    }
    return asyncTask;
}
#method_after
public AsyncTasks getByVdsmTaskId(Guid vdsmTaskId) {
    return coCoAsyncTaskHelper.getByVdsmTaskId(vdsmTaskId);
}
#end_block

#method_before
public int removeByVdsmTaskId(final Guid vdsmTaskId) {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Integer>() {

        @Override
        public Integer runInTransaction() {
            AsyncTasks asyncTask = DbFacade.getInstance().getAsyncTaskDao().getByVdsmTaskId(vdsmTaskId);
            int retVal = DbFacade.getInstance().getAsyncTaskDao().removeByVdsmTaskId(vdsmTaskId);
            if (asyncTask != null && !Guid.isNullOrEmpty(asyncTask.getCommandId())) {
                commandsCache.remove(asyncTask.getCommandId());
            }
            return retVal;
        }
    });
}
#method_after
public int removeByVdsmTaskId(final Guid vdsmTaskId) {
    return coCoAsyncTaskHelper.removeByVdsmTaskId(vdsmTaskId);
}
#end_block

#method_before
public void addOrUpdateTaskInDB(final AsyncTasks asyncTask) {
    persistCommand(copyToCommandEntity(asyncTask, commandsCache.get(asyncTask.getCommandId())));
    DbFacade.getInstance().getAsyncTaskDao().saveOrUpdate(asyncTask);
}
#method_after
public void addOrUpdateTaskInDB(final AsyncTasks asyncTask) {
    coCoAsyncTaskHelper.addOrUpdateTaskInDB(asyncTask);
}
#end_block

#method_before
public SPMAsyncTask createTask(AsyncTaskType taskType, AsyncTaskParameters taskParameters) {
    return AsyncTaskFactory.construct(this, taskType, taskParameters, false);
}
#method_after
public SPMAsyncTask createTask(AsyncTaskType taskType, AsyncTaskParameters taskParameters) {
    return coCoAsyncTaskHelper.createTask(taskType, taskParameters);
}
#end_block

#method_before
public AsyncTasks getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTasks asyncTask = null;
    if (!taskId.equals(Guid.Empty)) {
        asyncTask = getAsyncTaskFromDb(taskId);
    }
    if (asyncTask != null) {
        VdcActionParametersBase parentParameters = command.getParentParameters(parentCommand);
        asyncTask.setaction_type(parentCommand);
        asyncTask.setVdsmTaskId(asyncTaskCreationInfo.getVdsmTaskId());
        asyncTask.setActionParameters(parentParameters);
        asyncTask.setTaskParameters(command.getParameters());
        asyncTask.setStepId(asyncTaskCreationInfo.getStepId());
        asyncTask.setCommandId(command.getCommandId());
        asyncTask.setRootCommandId(parentParameters.getCommandId());
        asyncTask.setStoragePoolId(asyncTaskCreationInfo.getStoragePoolID());
        asyncTask.setTaskType(asyncTaskCreationInfo.getTaskType());
        asyncTask.setParentCommandId(command.getParameters().getParentParameters() == null ? Guid.Empty : command.getParameters().getParentParameters().getCommandId());
        asyncTask.setCommandStatus(command.getCommandStatus());
        asyncTask.setCommandType(this.getEndActionType(asyncTask));
    } else {
        asyncTask = createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
    }
    return asyncTask;
}
#method_after
public AsyncTasks getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public AsyncTasks createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = command.getParentParameters(parentCommand);
    AsyncTasks asyncTask = new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getVdsmTaskId(), parentParameters, command.getParameters(), asyncTaskCreationInfo.getStepId(), command.getCommandId(), parentParameters.getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType());
    asyncTask.setParentCommandId(command.getParameters().getParentParameters() == null ? Guid.Empty : command.getParameters().getParentParameters().getCommandId());
    asyncTask.setCommandStatus(command.getCommandStatus());
    asyncTask.setCommandType(this.getEndActionType(asyncTask));
    return asyncTask;
}
#method_after
public AsyncTasks createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Step taskStep = ExecutionHandler.addTaskStep(command.getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
    if (taskStep != null) {
        asyncTaskCreationInfo.setStepId(taskStep.getId());
    }
    SPMAsyncTask task = concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
    task.setEntitiesMap(entitiesMap);
    AsyncTaskUtils.addOrUpdateTaskInDB(task);
    getAsyncTaskManager().lockAndAddTaskToManager(task);
    Guid vdsmTaskId = task.getVdsmTaskId();
    ExecutionHandler.updateStepExternalId(taskStep, vdsmTaskId, ExternalSystemType.VDSM);
    return vdsmTaskId;
}
#method_after
public Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return coCoAsyncTaskHelper.createTask(taskId, command, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#end_block

#method_before
public SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand));
    p.setEntityInfo(command.getParameters().getEntityInfo());
    return createTask(internalGetTaskType(command), p);
}
#method_after
public SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public void cancelTasks(final CommandBase command) {
    if (command.hasTasks()) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                log.infoFormat("Rollback for command: {0}.", command.getClass().getName());
                try {
                    getAsyncTaskManager().cancelTasks(command.getReturnValue().getVdsmTaskIdList());
                } catch (Exception e) {
                    log.errorFormat("Failed to cancel tasks for command: {0}.", command.getClass().getName());
                }
            }
        });
    }
}
#method_after
public void cancelTasks(final CommandBase command) {
    coCoAsyncTaskHelper.cancelTasks(command, log);
}
#end_block

#method_before
public void revertTasks(CommandBase command) {
    if (command.getParameters().getVdsmTaskIds() != null) {
        // list to send to the pollTasks method
        ArrayList<Guid> taskIdAsList = new ArrayList<Guid>();
        for (Guid taskId : command.getParameters().getVdsmTaskIds()) {
            taskIdAsList.add(taskId);
            ArrayList<AsyncTaskStatus> tasksStatuses = getAsyncTaskManager().pollTasks(taskIdAsList);
            // call revert task only if ended successfully
            if (tasksStatuses.get(0).getTaskEndedSuccessfully()) {
                getBackend().getResourceManager().RunVdsCommand(VDSCommandType.SPMRevertTask, new SPMTaskGuidBaseVDSCommandParameters(command.getStoragePool().getId(), taskId));
            }
            taskIdAsList.clear();
        }
    }
}
#method_after
public void revertTasks(CommandBase command) {
    coCoAsyncTaskHelper.revertTasks(command);
}
#end_block

#method_before
public VdcReturnValueBase endAction(SPMTask task, ExecutionContext context) {
    AsyncTasks dbAsyncTask = task.getParameters().getDbAsyncTask();
    VdcActionType actionType = getEndActionType(dbAsyncTask);
    VdcActionParametersBase parameters = dbAsyncTask.getActionParameters();
    CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters);
    command.setContext(new CommandContext(context));
    return new DecoratedCommand(this, command, (CommandAsyncTask) task).endAction();
}
#method_after
public VdcReturnValueBase endAction(SPMTask task, ExecutionContext context) {
    return coCoAsyncTaskHelper.endAction(task, context);
}
#end_block

#method_before
public static void persistCommand(Guid commandId, Guid parentCommandId, Guid rootCommandId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status) {
    coco.persistCommand(commandId, parentCommandId, rootCommandId, actionType, params, status);
}
#method_after
public static void persistCommand(Guid commandId, Guid rootCommandId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status) {
    coco.persistCommand(commandId, rootCommandId, actionType, params, status);
}
#end_block

#method_before
public static void updateCommandStatus(Guid commandId, CommandStatus status) {
    coco.updateCommandStatus(commandId, status);
}
#method_after
public static void updateCommandStatus(Guid commandId, AsyncTaskType taskType, CommandStatus status) {
    coco.updateCommandStatus(commandId, taskType, status);
}
#end_block

#method_before
public void initializeCache() {
    if (!cacheInitialized) {
        synchronized (LOCK) {
            if (!cacheInitialized) {
                List<CommandEntity> cmdEntities = DbFacade.getInstance().getCommandEntityDao().getAll();
                for (CommandEntity cmdEntity : cmdEntities) {
                    commandMap.put(cmdEntity.getId(), cmdEntity);
                }
                cacheInitialized = true;
            }
        }
    }
}
#method_after
private void initializeCache() {
    if (!cacheInitialized) {
        synchronized (LOCK) {
            if (!cacheInitialized) {
                List<CommandEntity> cmdEntities = DbFacade.getInstance().getCommandEntityDao().getAll();
                for (CommandEntity cmdEntity : cmdEntities) {
                    commandMap.put(cmdEntity.getId(), cmdEntity);
                }
                cacheInitialized = true;
            }
        }
    }
}
#end_block

#method_before
@Override
public void put(Guid commandId, Guid parentCommandId, Guid rootCommandId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status) {
    CommandEntity cmdEntity = buildGetCommandEntity(commandId, parentCommandId, rootCommandId, actionType, params, status);
    commandMap.put(commandId, cmdEntity);
    DbFacade.getInstance().getCommandEntityDao().saveOrUpdate(cmdEntity);
}
#method_after
@Override
public void put(Guid commandId, Guid rootCommandId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status) {
    CommandEntity cmdEntity = buildCommandEntity(commandId, rootCommandId, actionType, params, status);
    commandMap.put(commandId, cmdEntity);
    DbFacade.getInstance().getCommandEntityDao().saveOrUpdate(cmdEntity);
}
#end_block

#method_before
public void updateCommandStatus(Guid commandId, CommandStatus status) {
    CommandEntity cmdEntity = get(commandId);
    if (cmdEntity != null) {
        cmdEntity.setCommandStatus(status);
    }
}
#method_after
public void updateCommandStatus(Guid commandId, AsyncTaskType taskType, CommandStatus status) {
    CommandEntity cmdEntity = get(commandId);
    if (cmdEntity != null) {
        cmdEntity.setCommandStatus(status);
        if (taskType.equals(AsyncTaskType.notSupported)) {
            DbFacade.getInstance().getCommandEntityDao().saveOrUpdate(cmdEntity);
        }
    }
}
#end_block

#method_before
public Guid executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandCallBack callBack) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters);
    executor.execute(new Runnable() {

        @Override
        public void run() {
            executeCommand(command, callBack);
        }
    });
    return command.getCommandId();
}
#method_after
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters);
    return executor.submit(new Callable<VdcReturnValueBase>() {

        @Override
        public VdcReturnValueBase call() throws Exception {
            return executeCommand(command);
        }
    });
}
#end_block

#method_before
private void executeCommand(final CommandBase<?> command, final CommandCallBack callBack) {
    if (callBack != null) {
        command.persistCommand(command.getParameters().getParentCommand());
        cmdCallBackMap.put(command.getCommandId(), callBack);
    }
    VdcReturnValueBase result = getBackendCommandObjectsHandler().runAction(command, null);
    if (callBack != null) {
        if (result.getSucceeded()) {
            command.setCommandStatus(CommandStatus.SUCCEEDED);
        }
        callBack.setExecutionResult(result);
    }
}
#method_after
private VdcReturnValueBase executeCommand(final CommandBase<?> command) {
    CommandCallBack callBack = command.getCallBack();
    if (callBack != null) {
        command.persistCommand(command.getParameters().getParentCommand(), true);
        cmdCallBackMap.put(command.getCommandId(), callBack);
    }
    VdcReturnValueBase result = BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, null);
    if (callBack != null) {
        updateCommandStatus(command, result);
        callBack.executed(result);
    }
    return result;
}
#end_block

#method_before
public Guid executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandCallBack callBack) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters);
    executor.execute(new Runnable() {

        @Override
        public void run() {
            executeCommand(command, callBack);
        }
    });
    return command.getCommandId();
}
#method_after
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters);
    return executor.submit(new Callable<VdcReturnValueBase>() {

        @Override
        public VdcReturnValueBase call() throws Exception {
            return executeCommand(command);
        }
    });
}
#end_block

#method_before
private void executeCommand(final CommandBase<?> command, final CommandCallBack callBack) {
    VdcReturnValueBase result = getBackendCommandObjectsHandler().runAction(command, null);
    if (callBack != null) {
        if (result.getSucceeded()) {
            command.setCommandStatus(CommandStatus.SUCCEEDED);
        }
        callBack.setExecutionResult(result);
    }
}
#method_after
private VdcReturnValueBase executeCommand(final CommandBase<?> command) {
    CommandCallBack callBack = command.getCallBack();
    VdcReturnValueBase result = getBackendCommandObjectsHandler().runAction(command, null);
    if (callBack != null) {
        callBack.executed(result);
    }
    return result;
}
#end_block

#method_before
public BackendCommandObjectsHandler getBackendCommandObjectsHandler() {
    try {
        InitialContext ctx = new InitialContext();
        return (BackendCommandObjectsHandler) ctx.lookup(BACKEND_COMMAND_OBJECTS_HANDLER_JNDI_NAME);
    } catch (NamingException e) {
        log.error("Getting backend command objects handler failed" + e.getMessage());
        log.debug("", e);
        return null;
    }
}
#method_after
private BackendCommandObjectsHandler getBackendCommandObjectsHandler() {
    try {
        InitialContext ctx = new InitialContext();
        return (BackendCommandObjectsHandler) ctx.lookup(BACKEND_COMMAND_OBJECTS_HANDLER_JNDI_NAME);
    } catch (NamingException e) {
        log.error("Getting backend command objects handler failed" + e.getMessage());
        log.debug("", e);
        return null;
    }
}
#end_block

#method_before
private void clearAsyncTasksWithOutVdsmId() {
    if (!getReturnValue().getTaskPlaceHolderIdList().isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTasks task = getAsyncTaskDao().get(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        TaskManagerUtil.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#method_after
private void clearAsyncTasksWithOutVdsmId() {
    if (!getReturnValue().getTaskPlaceHolderIdList().isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTasks task = TaskManagerUtil.getAsyncTaskFromDb(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        TaskManagerUtil.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#end_block

#method_before
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#method_after
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, String groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, groupIds, actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, HashSet<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#end_block

#method_before
private void saveTaskAndPutInMap(String taskKey, AsyncTasks task) {
    getAsyncTaskDao().save(task);
    taskKeyToTaskIdMap.put(taskKey, task.getTaskId());
}
#method_after
private void saveTaskAndPutInMap(String taskKey, AsyncTasks task) {
    TaskManagerUtil.saveAsyncTaskToDb(task);
    taskKeyToTaskIdMap.put(taskKey, task.getTaskId());
}
#end_block

#method_before
protected AsyncTaskType getTaskType() {
    return AsyncTaskType.notsupported;
}
#method_after
protected AsyncTaskType getTaskType() {
    return AsyncTaskType.notSupported;
}
#end_block

#method_before
public AsyncTaskType getAsyncTaskType() {
    if (getTaskType() == AsyncTaskType.notsupported) {
        throw new UnsupportedOperationException();
    }
    return getTaskType();
}
#method_after
public AsyncTaskType getAsyncTaskType() {
    if (getTaskType() == AsyncTaskType.notSupported) {
        throw new UnsupportedOperationException();
    }
    return getTaskType();
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    TaskManagerUtil.persistCommand(getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), parentParameters.getCommandId(), getActionType(), getParameters(), commandStatus);
}
#method_after
protected void persistCommand(VdcActionType parentCommand) {
    persistCommand(parentCommand, false);
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    TaskManagerUtil.persistCommand(getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), parentParameters.getCommandId(), getActionType(), getParameters(), commandStatus);
}
#method_after
protected void persistCommand(VdcActionType parentCommand, boolean enableCallBack) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    TaskManagerUtil.persistCommand(getCommandId(), parentParameters.getCommandId(), getActionType(), getParameters(), commandStatus, enableCallBack);
}
#end_block

#method_before
public void setCommandStatus(CommandStatus status) {
    this.commandStatus = status;
    TaskManagerUtil.updateCommandStatus(getCommandId(), getTaskType(), commandStatus);
}
#method_after
protected void setCommandStatus(CommandStatus status) {
    this.commandStatus = status;
    TaskManagerUtil.updateCommandStatus(getCommandId(), getTaskType(), commandStatus);
}
#end_block

#method_before
public static void persistCommand(Guid commandId, Guid parentCommandId, Guid rootCommandId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status) {
    coco.persistCommand(commandId, parentCommandId, rootCommandId, actionType, params, status);
}
#method_after
public static void persistCommand(Guid commandId, Guid rootCommandId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status, boolean enableCallBack) {
    coco.persistCommand(commandId, rootCommandId, actionType, params, status, enableCallBack);
}
#end_block

#method_before
public void executeAsyncCommand(VdcActionType actionType, VdcActionParametersBase parameters, CommandCallBack callBack) {
    coco.executeAsyncCommand(actionType, parameters, callBack);
}
#method_after
public static void executeAsyncCommand(VdcActionType actionType, VdcActionParametersBase parameters) {
    coco.executeAsyncCommand(actionType, parameters);
}
#end_block

#method_before
private void persistCommand(CommandEntity cmdEntity) {
    this.persistCommand(cmdEntity.getId(), cmdEntity.getParentCommandId(), cmdEntity.getRootCommandId(), cmdEntity.getCommandType(), cmdEntity.getActionParameters(), cmdEntity.getCommandStatus());
}
#method_after
@Override
public void persistCommand(CommandEntity cmdEntity) {
    this.persistCommand(cmdEntity.getId(), cmdEntity.getRootCommandId(), cmdEntity.getCommandType(), cmdEntity.getActionParameters(), cmdEntity.getCommandStatus(), cmdEntity.isEnableCallBack());
}
#end_block

#method_before
@Override
public void persistCommand(Guid commandId, Guid parentCommandId, Guid rootCommandId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status) {
    commandsCache.put(commandId, parentCommandId, rootCommandId, actionType, params, status);
}
#method_after
@Override
public void persistCommand(Guid commandId, Guid rootCommandId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status, boolean enableCallBack) {
    commandsCache.put(commandId, rootCommandId, actionType, params, status, enableCallBack);
}
#end_block

#method_before
public Guid executeAsyncCommand(VdcActionType actionType, VdcActionParametersBase parameters, CommandCallBack callBack) {
    return cmdExecutor.executeAsyncCommand(actionType, parameters, callBack);
}
#method_after
@Override
public Future<VdcReturnValueBase> executeAsyncCommand(VdcActionType actionType, VdcActionParametersBase parameters) {
    return cmdExecutor.executeAsyncCommand(actionType, parameters);
}
#end_block

#method_before
@Override
public CommandBase<?> retrieveCommand(Guid commandId) {
    CommandBase<?> command = null;
    CommandEntity cmdEntity = commandsCache.get(commandId);
    if (cmdEntity != null) {
        command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getActionParameters());
        // if the parentCommand Id is not null but parent parameters is null we rebuild the command hierarchy
        if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && command.getParameters().getParentParameters() == null) {
            CommandBase<?> parentCommand = retrieveCommand(cmdEntity.getParentCommandId());
            if (parentCommand != null) {
                command.getParameters().setParentParameters(parentCommand.getParameters());
            }
        }
    }
    return command;
}
#method_after
@Override
public CommandBase<?> retrieveCommand(Guid commandId) {
    CommandBase<?> command = null;
    CommandEntity cmdEntity = commandsCache.get(commandId);
    if (cmdEntity != null) {
        command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getActionParameters());
    }
    return command;
}
#end_block

#method_before
public List<AsyncTasks> getAllAsyncTasksFromDb() {
    List<AsyncTasks> asyncTasks = DbFacade.getInstance().getAsyncTaskDao().getAll();
    for (AsyncTasks asyncTask : asyncTasks) {
        copyFromCommandEntity(asyncTask, commandsCache.get(asyncTask.getCommandId()));
    }
    return asyncTasks;
}
#method_after
public List<AsyncTasks> getAllAsyncTasksFromDb() {
    return coCoAsyncTaskHelper.getAllAsyncTasksFromDb(this);
}
#end_block

#method_before
public void saveAsyncTaskToDb(final AsyncTasks asyncTask) {
    DbFacade.getInstance().getAsyncTaskDao().save(asyncTask);
    persistCommand(copyToCommandEntity(asyncTask, commandsCache.get(asyncTask.getCommandId())));
}
#method_after
public void saveAsyncTaskToDb(final AsyncTasks asyncTask) {
    coCoAsyncTaskHelper.saveAsyncTaskToDb(asyncTask);
}
#end_block

#method_before
public AsyncTasks getAsyncTaskFromDb(Guid asyncTaskId) {
    AsyncTasks asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(asyncTaskId);
    if (asyncTask != null) {
        copyFromCommandEntity(asyncTask, commandsCache.get(asyncTask.getCommandId()));
    }
    return asyncTask;
}
#method_after
public AsyncTasks getAsyncTaskFromDb(Guid asyncTaskId) {
    return coCoAsyncTaskHelper.getAsyncTaskFromDb(asyncTaskId);
}
#end_block

#method_before
public int removeTaskFromDbByTaskId(final Guid taskId) throws RuntimeException {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Integer>() {

        @Override
        public Integer runInTransaction() {
            AsyncTasks asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(taskId);
            int retVal = DbFacade.getInstance().getAsyncTaskDao().remove(taskId);
            if (asyncTask != null && !Guid.isNullOrEmpty(asyncTask.getCommandId())) {
                commandsCache.remove(asyncTask.getCommandId());
            }
            return retVal;
        }
    });
}
#method_after
public int removeTaskFromDbByTaskId(final Guid taskId) throws RuntimeException {
    return coCoAsyncTaskHelper.removeTaskFromDbByTaskId(taskId);
}
#end_block

#method_before
public AsyncTasks getByVdsmTaskId(Guid vdsmTaskId) {
    AsyncTasks asyncTask = DbFacade.getInstance().getAsyncTaskDao().getByVdsmTaskId(vdsmTaskId);
    if (asyncTask != null) {
        copyFromCommandEntity(asyncTask, commandsCache.get(asyncTask.getCommandId()));
    }
    return asyncTask;
}
#method_after
public AsyncTasks getByVdsmTaskId(Guid vdsmTaskId) {
    return coCoAsyncTaskHelper.getByVdsmTaskId(vdsmTaskId);
}
#end_block

#method_before
public int removeByVdsmTaskId(final Guid vdsmTaskId) {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Integer>() {

        @Override
        public Integer runInTransaction() {
            AsyncTasks asyncTask = DbFacade.getInstance().getAsyncTaskDao().getByVdsmTaskId(vdsmTaskId);
            int retVal = DbFacade.getInstance().getAsyncTaskDao().removeByVdsmTaskId(vdsmTaskId);
            if (asyncTask != null && !Guid.isNullOrEmpty(asyncTask.getCommandId())) {
                commandsCache.remove(asyncTask.getCommandId());
            }
            return retVal;
        }
    });
}
#method_after
public int removeByVdsmTaskId(final Guid vdsmTaskId) {
    return coCoAsyncTaskHelper.removeByVdsmTaskId(vdsmTaskId);
}
#end_block

#method_before
public void addOrUpdateTaskInDB(final AsyncTasks asyncTask) {
    persistCommand(copyToCommandEntity(asyncTask, commandsCache.get(asyncTask.getCommandId())));
    DbFacade.getInstance().getAsyncTaskDao().saveOrUpdate(asyncTask);
}
#method_after
public void addOrUpdateTaskInDB(final AsyncTasks asyncTask) {
    coCoAsyncTaskHelper.addOrUpdateTaskInDB(asyncTask);
}
#end_block

#method_before
public SPMAsyncTask createTask(AsyncTaskType taskType, AsyncTaskParameters taskParameters) {
    return AsyncTaskFactory.construct(this, taskType, taskParameters, false);
}
#method_after
public SPMAsyncTask createTask(AsyncTaskType taskType, AsyncTaskParameters taskParameters) {
    return coCoAsyncTaskHelper.createTask(taskType, taskParameters);
}
#end_block

#method_before
public AsyncTasks getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTasks asyncTask = null;
    if (!taskId.equals(Guid.Empty)) {
        asyncTask = getAsyncTaskFromDb(taskId);
    }
    if (asyncTask != null) {
        VdcActionParametersBase parentParameters = command.getParentParameters(parentCommand);
        asyncTask.setaction_type(parentCommand);
        asyncTask.setVdsmTaskId(asyncTaskCreationInfo.getVdsmTaskId());
        asyncTask.setActionParameters(parentParameters);
        asyncTask.setTaskParameters(command.getParameters());
        asyncTask.setStepId(asyncTaskCreationInfo.getStepId());
        asyncTask.setCommandId(command.getCommandId());
        asyncTask.setRootCommandId(parentParameters.getCommandId());
        asyncTask.setStoragePoolId(asyncTaskCreationInfo.getStoragePoolID());
        asyncTask.setTaskType(asyncTaskCreationInfo.getTaskType());
        asyncTask.setParentCommandId(command.getParameters().getParentParameters() == null ? Guid.Empty : command.getParameters().getParentParameters().getCommandId());
        asyncTask.setCommandStatus(command.getCommandStatus());
        asyncTask.setCommandType(this.getEndActionType(asyncTask));
    } else {
        asyncTask = createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
    }
    return asyncTask;
}
#method_after
public AsyncTasks getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public AsyncTasks createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = command.getParentParameters(parentCommand);
    AsyncTasks asyncTask = new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getVdsmTaskId(), parentParameters, command.getParameters(), asyncTaskCreationInfo.getStepId(), command.getCommandId(), parentParameters.getCommandId(), command.getParameters().getParentParameters() == null ? Guid.Empty : command.getParameters().getParentParameters().getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType(), command.getCommandStatus());
    return asyncTask;
}
#method_after
public AsyncTasks createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Step taskStep = ExecutionHandler.addTaskStep(command.getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
    if (taskStep != null) {
        asyncTaskCreationInfo.setStepId(taskStep.getId());
    }
    SPMAsyncTask task = concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
    task.setEntitiesMap(entitiesMap);
    AsyncTaskUtils.addOrUpdateTaskInDB(task);
    getAsyncTaskManager().lockAndAddTaskToManager(task);
    Guid vdsmTaskId = task.getVdsmTaskId();
    ExecutionHandler.updateStepExternalId(taskStep, vdsmTaskId, ExternalSystemType.VDSM);
    return vdsmTaskId;
}
#method_after
public Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return coCoAsyncTaskHelper.createTask(taskId, command, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#end_block

#method_before
public SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand));
    p.setEntityInfo(command.getParameters().getEntityInfo());
    return createTask(internalGetTaskType(command), p);
}
#method_after
public SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public void cancelTasks(final CommandBase command) {
    if (command.hasTasks()) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                log.infoFormat("Rollback for command: {0}.", command.getClass().getName());
                try {
                    getAsyncTaskManager().cancelTasks(command.getReturnValue().getVdsmTaskIdList());
                } catch (Exception e) {
                    log.errorFormat("Failed to cancel tasks for command: {0}.", command.getClass().getName());
                }
            }
        });
    }
}
#method_after
public void cancelTasks(final CommandBase command) {
    coCoAsyncTaskHelper.cancelTasks(command, log);
}
#end_block

#method_before
public void revertTasks(CommandBase command) {
    if (command.getParameters().getVdsmTaskIds() != null) {
        // list to send to the pollTasks method
        ArrayList<Guid> taskIdAsList = new ArrayList<Guid>();
        for (Guid taskId : command.getParameters().getVdsmTaskIds()) {
            taskIdAsList.add(taskId);
            ArrayList<AsyncTaskStatus> tasksStatuses = getAsyncTaskManager().pollTasks(taskIdAsList);
            // call revert task only if ended successfully
            if (tasksStatuses.get(0).getTaskEndedSuccessfully()) {
                getBackend().getResourceManager().RunVdsCommand(VDSCommandType.SPMRevertTask, new SPMTaskGuidBaseVDSCommandParameters(command.getStoragePool().getId(), taskId));
            }
            taskIdAsList.clear();
        }
    }
}
#method_after
public void revertTasks(CommandBase command) {
    coCoAsyncTaskHelper.revertTasks(command);
}
#end_block

#method_before
public VdcReturnValueBase endAction(SPMTask task, ExecutionContext context) {
    AsyncTasks dbAsyncTask = task.getParameters().getDbAsyncTask();
    VdcActionType actionType = getEndActionType(dbAsyncTask);
    VdcActionParametersBase parameters = dbAsyncTask.getActionParameters();
    CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters);
    command.setContext(new CommandContext(context));
    return new DecoratedCommand(command).endAction();
}
#method_after
public VdcReturnValueBase endAction(SPMTask task, ExecutionContext context) {
    return coCoAsyncTaskHelper.endAction(task, context);
}
#end_block

#method_before
@Override
public void initialize() {
    log.info("Start initializing " + getClass().getSimpleName());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    log.info("Running ovirt-engine " + Config.<String>getValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.InitDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initOsRepository();
    initSearchDependencies();
    initHandlers();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark incomplete jobs as {0}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    Integer sessionTimeoutInterval = Config.<Integer>getValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimeoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimeoutInterval, sessionTimeoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>getValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    poolMonitoringJobId = SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    int autoStartVmsRunnerIntervalInSeconds = Config.<Integer>getValue(ConfigValues.AutoStartVmsRunnerIntervalInSeconds);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(AutoStartVmsRunner.getInstance(), "startFailedAutoStartVms", new Class[] {}, new Object[] {}, autoStartVmsRunnerIntervalInSeconds, autoStartVmsRunnerIntervalInSeconds, TimeUnit.SECONDS);
    int quotaCacheIntervalInMinutes = Config.<Integer>getValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    // initializes attestation
    initAttestation();
}
#method_after
@Override
public void initialize() {
    log.info("Start initializing " + getClass().getSimpleName());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    log.info("Running ovirt-engine " + Config.<String>getValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.InitDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initOsRepository();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark incomplete jobs as {0}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>getValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    poolMonitoringJobId = SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    int autoStartVmsRunnerIntervalInSeconds = Config.<Integer>getValue(ConfigValues.AutoStartVmsRunnerIntervalInSeconds);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(AutoStartVmsRunner.getInstance(), "startFailedAutoStartVms", new Class[] {}, new Object[] {}, autoStartVmsRunnerIntervalInSeconds, autoStartVmsRunnerIntervalInSeconds, TimeUnit.SECONDS);
    int quotaCacheIntervalInMinutes = Config.<Integer>getValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    // initializes attestation
    initAttestation();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
}
#end_block

#method_before
public static CommandEntityCleanupManager getInstance() {
    return _instance;
}
#method_after
public static CommandEntityCleanupManager getInstance() {
    return instance;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist()) {
        return false;
    }
    if (!isDiskExist(oldDisk)) {
        return false;
    }
    List<VM> vmsDiskPluggedTo = getVmDAO().getForDisk(oldDisk.getId()).get(Boolean.TRUE);
    if (vmsDiskPluggedTo != null && !vmsDiskPluggedTo.isEmpty()) {
        buildSharedLockMap(vmsDiskPluggedTo);
        buildExclusiveLockMap(vmsDiskPluggedTo);
        acquireLockInternal();
        // Check if all VMs are in status down.
        for (VM vm : vmsDiskPluggedTo) {
            if (vm.getStatus() != VMStatus.Down) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
                return false;
            }
        }
    }
    return checkCanPerformRegularUpdate();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist()) {
        return false;
    }
    if (!isDiskExist(oldDisk)) {
        return false;
    }
    List<VM> vmsDiskPluggedTo = getVmDAO().getForDisk(oldDisk.getId()).get(Boolean.TRUE);
    if (vmsDiskPluggedTo != null && !vmsDiskPluggedTo.isEmpty()) {
        buildSharedLockMap(vmsDiskPluggedTo);
        buildExclusiveLockMap(vmsDiskPluggedTo);
        acquireLockInternal();
        // Check if all VMs are in status down.
        for (VM vm : vmsDiskPluggedTo) {
            if (vm.getStatus() != VMStatus.Down) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
            }
        }
    }
    return checkCanPerformRegularUpdate();
}
#end_block

#method_before
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = newDisk.isShareable();
    boolean isOldDiskSharable = oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (getSnapshotDao().exists(getVmId(), SnapshotStatus.IN_PREVIEW)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    if (!isOldDiskSharable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(oldDisk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        DiskImage diskImage = (DiskImage) newDisk;
        if (!isVolumeFormatSupportedForShareable(diskImage.getvolume_format())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
            return false;
        }
        // If user want to update the disk to be sharable then update the vm snapshot id to be null.
        ((DiskImage) oldDisk).setvm_snapshot_id(null);
    } else if (isOldDiskSharable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#method_after
private boolean validateShareableDisk() {
    if (DiskStorageType.LUN == oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = newDisk.isShareable();
    boolean isOldDiskShareable = oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (getSnapshotDao().exists(getVmId(), SnapshotStatus.IN_PREVIEW)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    if (!isOldDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(oldDisk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        DiskImage diskImage = (DiskImage) newDisk;
        if (!isVolumeFormatSupportedForShareable(diskImage.getvolume_format())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
            return false;
        }
        // If user want to update the disk to be shareable then update the vm snapshot id to be null.
        ((DiskImage) oldDisk).setvm_snapshot_id(null);
    } else if (isOldDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (isImagesAlreadyOnTarget() && !validateImagesOnStorage(vmFromConfiguration, ovfEntityData)) {
        return false;
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    if (isImagesAlreadyOnTarget() && !validateUnregisteredEntity(vmFromConfiguration, ovfEntityData)) {
        return false;
    }
    setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), getVm().getImages());
    return super.canDoAction();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    initVmTemplate();
    if (isImagesAlreadyOnTarget() && !validateImagesOnStorage(vmTemplateFromConfiguration, ovfEntityData)) {
        return false;
    }
    ArrayList<DiskImage> disks = new ArrayList(getVmTemplate().getDiskTemplateMap().values());
    setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), disks);
    getParameters().setImages(disks);
    getVmTemplate().setImages(disks);
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    initVmTemplate();
    if (isImagesAlreadyOnTarget() && !validateUnregisteredEntity(vmTemplateFromConfiguration, ovfEntityData)) {
        return false;
    }
    ArrayList<DiskImage> disks = new ArrayList(getVmTemplate().getDiskTemplateMap().values());
    setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), disks);
    getParameters().setImages(disks);
    getVmTemplate().setImages(disks);
    return super.canDoAction();
}
#end_block

#method_before
protected void ensureDomainMap(Collection<DiskImage> images, Guid defaultDomainId) {
    if (imageToDestinationDomainMap == null) {
        imageToDestinationDomainMap = new HashMap<Guid, Guid>();
    }
    if (imageToDestinationDomainMap.isEmpty() && images != null && defaultDomainId != null && !Guid.Empty.equals(defaultDomainId)) {
        for (DiskImage image : images) {
            imageToDestinationDomainMap.put(image.getId(), defaultDomainId);
        }
    }
}
#method_after
protected void ensureDomainMap(Collection<DiskImage> images, Guid defaultDomainId) {
    if (imageToDestinationDomainMap == null) {
        imageToDestinationDomainMap = new HashMap<Guid, Guid>();
    }
    if (imageToDestinationDomainMap.isEmpty() && images != null && defaultDomainId != null) {
        for (DiskImage image : images) {
            if (isImagesAlreadyOnTarget()) {
                imageToDestinationDomainMap.put(image.getId(), image.getStorageIds().get(0));
            } else if (!Guid.Empty.equals(defaultDomainId)) {
                imageToDestinationDomainMap.put(image.getId(), defaultDomainId);
            }
        }
    }
}
#end_block

#method_before
private boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getVm().getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!isImagesAlreadyOnTarget() && !validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getSourceDomainId(image))));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#method_after
private boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!isImagesAlreadyOnTarget() && !validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getSourceDomainId(image))));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#end_block

#method_before
protected boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getVm().getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getStoragePoolId() != null ? image.getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getSourceDomainId(image);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DoesImageExist, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (Boolean.FALSE.equals(retValue.getReturnValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
        }
    }
    return true;
}
#method_after
protected boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getStoragePoolId() != null ? image.getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getSourceDomainId(image);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DoesImageExist, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (Boolean.FALSE.equals(retValue.getReturnValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
        }
    }
    return true;
}
#end_block

#method_before
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk);
                updateManagedDeviceMap(disk, getVm().getStaticData().getManagedDeviceMap());
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#method_after
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk);
                updateManagedDeviceMap(disk, getVm().getStaticData().getManagedDeviceMap());
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (isImagesAlreadyOnTarget() && !validateImagesOnStorage(vmFromConfiguration, ovfEntityData)) {
        return false;
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    if (isImagesAlreadyOnTarget() && !validateUnregisteredEntity(vmFromConfiguration, ovfEntityData)) {
        return false;
    }
    setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), getVm().getImages());
    return super.canDoAction();
}
#end_block

#method_before
@Override
public void executeCommand() {
    super.executeCommand();
    if (getSucceeded()) {
        if (isImagesAlreadyOnTarget()) {
            getUnregisteredOVFDataDao().removeEntity(ovfEntityData.getEntityId(), ovfEntityData.getStorageDomainId());
        } else if (!vmDisksToAttach.isEmpty()) {
            AuditLogDirector.log(this, attemptToAttachDisksToImportedVm(vmDisksToAttach));
        }
    }
    setActionReturnValue(getVm().getId());
}
#method_after
@Override
public void executeCommand() {
    super.executeCommand();
    if (getSucceeded()) {
        if (isImagesAlreadyOnTarget()) {
            getUnregisteredOVFDataDao().removeEntity(ovfEntityData.getEntityId(), null);
        } else if (!vmDisksToAttach.isEmpty()) {
            AuditLogDirector.log(this, attemptToAttachDisksToImportedVm(vmDisksToAttach));
        }
    }
    setActionReturnValue(getVm().getId());
}
#end_block

#method_before
@Override
protected void handleError() {
    MoveVMsToUnknown();
    // if fence failed on spm, move storage pool to non operational
    if (getVds().getSpmStatus() != VdsSpmStatus.None) {
        log.infoFormat("Fence failed on vds {0} which is spm of pool {1} - moving pool to non operational", getVds().getName(), getVds().getStoragePoolId());
        Backend.getInstance().runInternalAction(VdcActionType.SetStoragePoolStatus, new SetStoragePoolStatusParameters(getVds().getStoragePoolId(), StoragePoolStatus.NotOperational, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM));
    }
    _vmsMovedToUnknown = true;
    log.errorFormat("Failed to run Fence script on vds:{0}, VMs moved to UnKnown instead.", getVdsName());
    AlertIfPowerManagementOperationSkipped(RESTART, null);
}
#method_after
@Override
protected void handleError() {
    // if fence failed on spm, move storage pool to non operational
    if (getVds().getSpmStatus() != VdsSpmStatus.None) {
        log.infoFormat("Fence failed on vds {0} which is spm of pool {1} - moving pool to non operational", getVds().getName(), getVds().getStoragePoolId());
        Backend.getInstance().runInternalAction(VdcActionType.SetStoragePoolStatus, new SetStoragePoolStatusParameters(getVds().getStoragePoolId(), StoragePoolStatus.NotOperational, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM));
    }
    log.errorFormat("Failed to run Fence script on vds:{0}.", getVdsName());
    AlertIfPowerManagementOperationSkipped(RESTART, null);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? _vmsMovedToUnknown ? AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN : AuditLogType.VDS_RECOVER : AuditLogType.VDS_RECOVER_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.VDS_RECOVER : AuditLogType.VDS_RECOVER_FAILED;
}
#end_block

#method_before
private boolean InitializeStorage() {
    boolean returnValue = false;
    // connect any storage
    if (getStoragePool() == null || StoragePoolStatus.Uninitialized == getStoragePool().getStatus() || StoragePoolStatus.Maintenance == getStoragePool().getStatus()) {
        returnValue = true;
        connectPoolSucceeded = true;
    } else {
        HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(getStoragePool(), getVds());
        Backend.getInstance().runInternalAction(VdcActionType.ConnectHostToStoragePoolServers, params);
        returnValue = connectHostToPool();
        connectPoolSucceeded = returnValue;
    }
    return returnValue;
}
#method_after
private boolean InitializeStorage() {
    boolean returnValue = false;
    // connect any storage
    if (getStoragePool() == null || StoragePoolStatus.Uninitialized == getStoragePool().getStatus() || StoragePoolStatus.Maintenance == getStoragePool().getStatus()) {
        returnValue = true;
        connectPoolSucceeded = true;
    } else {
        ConnectHostToStoragePoolServersParameters params = new ConnectHostToStoragePoolServersParameters(getStoragePool(), getVds());
        Backend.getInstance().runInternalAction(VdcActionType.ConnectHostToStoragePoolServers, params);
        returnValue = connectHostToPool();
        connectPoolSucceeded = returnValue;
    }
    return returnValue;
}
#end_block

#method_before
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDAO().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDAO().getStorageDomainByTypeAndPool(storagePoolId, StorageDomainType.Master);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.Inactive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSError error = null;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), storagePoolId, vds.getVdsSpmId(), masterDomain.getId(), storagePool.getmaster_domain_version()));
        if (!vdsReturnValue.getSucceeded()) {
            error = vdsReturnValue.getVdsError();
        }
    } catch (VdcBLLException e) {
        error = e.getVdsError();
    }
    if (error != null) {
        if (error.getCode() != VdcBllErrors.CannotConnectMultiplePools && masterDomainInactiveOrUnknown) {
            log.infoFormat("Could not connect host {0} to pool {1}, as the master domain is in inactive/unknown status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.errorFormat("Could not connect host {0} to pool {1} with the message: {2}", vds.getName(), storagePool.getName(), error.getMessage());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        result.setSuccess(proceedVdsStats(!masterDomainInactiveOrUnknown));
        if (!result.isSuccess()) {
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#method_after
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDAO().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDAO().getStorageDomainByTypeAndPool(storagePoolId, StorageDomainType.Master);
    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(storagePoolId);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.Inactive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSError error = null;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, storagePool, masterDomain.getId(), storagePoolIsoMap));
        if (!vdsReturnValue.getSucceeded()) {
            error = vdsReturnValue.getVdsError();
        }
    } catch (VdcBLLException e) {
        error = e.getVdsError();
    }
    if (error != null) {
        if (error.getCode() != VdcBllErrors.CannotConnectMultiplePools && masterDomainInactiveOrUnknown) {
            log.infoFormat("Could not connect host {0} to pool {1}, as the master domain is in inactive/unknown status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.errorFormat("Could not connect host {0} to pool {1} with the message: {2}", vds.getName(), storagePool.getName(), error.getMessage());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        result.setSuccess(proceedVdsStats(!masterDomainInactiveOrUnknown));
        if (!result.isSuccess()) {
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVds().getKdumpStatus() != KdumpStatus.ENABLED) {
        log.infoFormat("Kdump detection support is not configured on host {0}({1}).", getVdsName(), getVdsId());
        return false;
    }
    return getVds().isPmKdumpDetection();
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVds().getKdumpStatus() != KdumpStatus.ENABLED) {
        addCanDoActionMessage(VdcBllMessages.KDUMP_DETECTION_NOT_CONFIGURED_ON_VDS);
        return false;
    }
    boolean detectionEnabled = getVds().isPmKdumpDetection();
    if (!detectionEnabled) {
        addCanDoActionMessage(VdcBllMessages.KDUMP_DETECTION_NOT_ENABLED_FOR_VDS);
    }
    return detectionEnabled;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Kdump detection will not be executed on host {0}({1}) since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    // check if fence_kdump listener is alive
    checkListenerAlive();
    boolean detected = false;
    int interval = Config.<Integer>getValue(ConfigValues.FenceKdumpMessageInterval) * 1000;
    Calendar cal = Calendar.getInstance();
    cal.add(Calendar.SECOND, Config.<Integer>getValue(ConfigValues.KdumpStartedTimeout));
    long timeout = cal.getTimeInMillis();
    VdsKdumpStatus kdumpStatus = getDbFacade().getVdsKdumpStatusDao().get(getVdsId());
    while (!detected && timeout > System.currentTimeMillis()) {
        detected = kdumpStatus != null;
        if (!detected) {
            ThreadUtils.sleep(interval);
        }
        kdumpStatus = getDbFacade().getVdsKdumpStatusDao().get(getVdsId());
    }
    if (detected) {
        AuditLogableBase base = new AuditLogableBase();
        base.setVds(getVds());
        AuditLogDirector.log(base, AuditLogType.KDUMP_FLOW_DETECTED_ON_VDS);
    } else {
        log.infoFormat("Kdump not detected on host {0}({1}).", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    // kdump detected set status to reboot and wait until kdump fisnihes
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Reboot));
    while (kdumpStatus.getStatus() != KdumpFlowStatus.FINISHED) {
        ThreadUtils.sleep(interval);
        kdumpStatus = getDbFacade().getVdsKdumpStatusDao().get(getVdsId());
    }
    AuditLogableBase base = new AuditLogableBase();
    base.setVds(getVds());
    AuditLogDirector.log(base, AuditLogType.KDUMP_FLOW_FINISHED_ON_VDS);
    // kdump finished successfully, reset status to Connecting
    ResourceManager.getInstance().GetVdsManager(getVds().getId()).resetStatusToConnecting(getVds(), true);
    getReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Kdump detection will not be executed on host {0}({1}) since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    kdumpDetectionResult = detectHostKdumping();
    getReturnValue().setSucceeded(kdumpDetectionResult == KdumpDetectionResult.KDUMP_FINISHED);
}
#end_block

#method_before
@Test
public void getExistingVariable() {
    ExternalVariable expected = new ExternalVariable();
    expected.setName("fence-kdump-listener");
    Calendar cal = Calendar.getInstance();
    cal.setTimeZone(TimeZone.getTimeZone("UTC"));
    cal.set(2014, 3, 22, 15, 0, 5);
    cal.set(Calendar.MILLISECOND, 0);
    expected.setUpdated(cal.getTime());
    ExternalVariable found = dbFacade.getExternalVariableDao().get(expected.getName());
    assertNotNull(found);
    assertEquals(expected, found);
}
#method_after
@Test
public void getExistingVariable() {
    ExternalVariable expected = new ExternalVariable();
    expected.setName("fence-kdump-listener");
    ExternalVariable found = dbFacade.getExternalVariableDao().get(expected.getName());
    assertNotNull(found);
    assertEquals(expected, found);
    assertNotNull(found.getUpdateDate());
}
#end_block

#method_before
@Test
public void createNewVariableWithEmptyUpdated() {
    ExternalVariable newVar = new ExternalVariable();
    newVar.setName("new-var");
    newVar.setValue("123456");
    dbFacade.getExternalVariableDao().upsert(newVar);
    ExternalVariable found = dbFacade.getExternalVariableDao().get(newVar.getName());
    assertNotNull(found);
    assertEquals(newVar.getName(), found.getName());
    assertEquals(newVar.getValue(), found.getValue());
    assertNotNull(found.getUpdated());
}
#method_after
@Test
public void createNewVariableWithEmptyUpdated() {
    ExternalVariable newVar = new ExternalVariable();
    newVar.setName("new-var");
    newVar.setValue("123456");
    dbFacade.getExternalVariableDao().save(newVar);
    ExternalVariable found = dbFacade.getExternalVariableDao().get(newVar.getName());
    assertNotNull(found);
    assertEquals(newVar.getName(), found.getName());
    assertEquals(newVar.getValue(), found.getValue());
    assertNotNull(found.getUpdateDate());
}
#end_block

#method_before
@Test
public void updateExistingVariable() {
    String name = "fence-kdump-listener";
    ExternalVariable existing = dbFacade.getExternalVariableDao().get(name);
    existing.setValue("123456");
    existing.setUpdated(new Date());
    dbFacade.getExternalVariableDao().upsert(existing);
    ExternalVariable found = dbFacade.getExternalVariableDao().get(name);
    assertNotNull(found);
    assertEquals(existing, found);
}
#method_after
@Test
public void updateExistingVariable() {
    String name = "fence-kdump-listener";
    ExternalVariable existing = dbFacade.getExternalVariableDao().get(name);
    existing.setValue("123456");
    existing.setUpdateDate(new Date());
    dbFacade.getExternalVariableDao().update(existing);
    ExternalVariable found = dbFacade.getExternalVariableDao().get(name);
    assertNotNull(found);
    assertEquals(existing, found);
}
#end_block

#method_before
@Test
public void removeExistingVariable() {
    ExternalVariable var = new ExternalVariable();
    var.setName("new-var");
    var.setValue("123456");
    var.setUpdated(new Date());
    dbFacade.getExternalVariableDao().upsert(var);
    ExternalVariable found = dbFacade.getExternalVariableDao().get(var.getName());
    assertNotNull(found);
    assertEquals(var, found);
    dbFacade.getExternalVariableDao().remove(var.getName());
    dbFacade.getExternalVariableDao().get(var.getName());
    ExternalVariable removed = dbFacade.getExternalVariableDao().get(var.getName());
    assertNull(removed);
}
#method_after
@Test
public void removeExistingVariable() {
    ExternalVariable var = new ExternalVariable();
    var.setName("new-var");
    var.setValue("123456");
    var.setUpdateDate(new Date());
    dbFacade.getExternalVariableDao().save(var);
    ExternalVariable found = dbFacade.getExternalVariableDao().get(var.getName());
    assertNotNull(found);
    assertEquals(var, found);
    dbFacade.getExternalVariableDao().remove(var.getName());
    dbFacade.getExternalVariableDao().get(var.getName());
    ExternalVariable removed = dbFacade.getExternalVariableDao().get(var.getName());
    assertNull(removed);
}
#end_block

#method_before
@Override
public ExternalVariable mapRow(ResultSet rs, int rowNum) throws SQLException {
    ExternalVariable entity = new ExternalVariable();
    entity.setName(rs.getString("var_name"));
    entity.setValue(rs.getString("var_value"));
    entity.setUpdated(DbFacadeUtils.fromDate(rs.getTimestamp("updated")));
    return entity;
}
#method_after
@Override
public ExternalVariable mapRow(ResultSet rs, int rowNum) throws SQLException {
    ExternalVariable entity = new ExternalVariable();
    entity.setName(rs.getString("var_name"));
    entity.setValue(rs.getString("var_value"));
    entity.setUpdateDate(DbFacadeUtils.fromDate(rs.getTimestamp("_update_date")));
    return entity;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof ExternalVariable)) {
        return false;
    }
    ExternalVariable other = (ExternalVariable) obj;
    return ObjectUtils.objectsEqual(name, other.getName()) && ObjectUtils.objectsEqual(value, other.getValue()) && ObjectUtils.objectsEqual(updated, other.getUpdated());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof ExternalVariable)) {
        return false;
    }
    ExternalVariable other = (ExternalVariable) obj;
    return ObjectUtils.objectsEqual(name, other.getName()) && ObjectUtils.objectsEqual(value, other.getValue());
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + (name != null ? name.hashCode() : 0);
    result = 31 * result + (value != null ? value.hashCode() : 0);
    result = 31 * result + (updated != null ? updated.hashCode() : 0);
    return result;
}
#method_after
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + (name != null ? name.hashCode() : 0);
    result = 31 * result + (value != null ? value.hashCode() : 0);
    return result;
}
#end_block

#method_before
private void hostName_SelectedItemChanged() {
    VDS host = (VDS) getExternalHostName().getSelectedItem();
    getExternalDiscoveredHosts().setSelectedItem(null);
    getExternalHostGroups().setIsAvailable(false);
    getExternalHostGroups().setIsChangable(false);
    if (host == null) {
        host = new VDS();
    }
    updateModelFromVds(host, null, false, null);
    getHost().setEntity(host.getName());
    getHost().setIsChangable(false);
}
#method_after
// Define events:
private void hostName_SelectedItemChanged() {
    VDS vds = (VDS) getExternalHostName().getSelectedItem();
    if (vds == null) {
        vds = new VDS();
    }
    updateModelFromVds(vds, null, false, null);
    getHost().setIsChangable(false);
}
#end_block

#method_before
private void discoverHostName_SelectedItemChanged() {
    ExternalDiscoveredHost dhost = (ExternalDiscoveredHost) getExternalDiscoveredHosts().getSelectedItem();
    getExternalHostName().setSelectedItem(null);
    getExternalHostGroups().setIsAvailable(true);
    getExternalHostGroups().setIsChangable(true);
    VDS vds = new VDS();
    if (dhost != null) {
        vds.setVdsName(dhost.getName());
        vds.setHostName(dhost.getIp());
    }
    updateModelFromVds(vds, null, false, null);
    getName().setIsChangable(true);
}
#method_after
private void discoverHostName_SelectedItemChanged() {
    ExternalDiscoveredHost dhost = (ExternalDiscoveredHost) getExternalDiscoveredHosts().getSelectedItem();
    VDS vds = new VDS();
    if (dhost != null) {
        vds.setVdsName(dhost.getName());
        vds.setHostName(dhost.getIp());
    }
    updateModelFromVds(vds, null, false, null);
    getName().setIsChangable(true);
}
#end_block

#method_before
private void providers_SelectedItemChanged() {
    Provider provider = getProviders().getSelectedItem();
    setEnableSearchHost(provider != null);
    getExternalHostName().setItems(null);
    getExternalHostName().setIsChangable(false);
    getExternalDiscoveredHosts().setIsChangable(false);
    getExternalDiscoveredHosts().setItems(null);
    getExternalHostGroups().setIsChangable(false);
    getExternalHostGroups().setItems(null);
}
#method_after
private void providers_SelectedItemChanged() {
    Provider provider = getProviders().getSelectedItem();
    setEnableSearchHost(provider != null);
}
#end_block

#method_before
private void updateHostList(String searchFilter) {
    Provider provider = getProviders().getSelectedItem();
    if (provider != null) {
        AsyncQuery getHostsQuery = new AsyncQuery();
        getHostsQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ArrayList<VDS> hosts = (ArrayList<VDS>) result;
                ListModel<VDS> hostNameListModel = getExternalHostName();
                hosts.add(0, null);
                hostNameListModel.setItems(hosts);
                hostNameListModel.setIsChangable(true);
                setEnableSearchHost(true);
            }
        };
        AsyncDataProvider.getExternalProviderHostList(getHostsQuery, provider.getId(), true, searchFilter);
        AsyncQuery getDiscoveredHostsQuery = new AsyncQuery();
        getDiscoveredHostsQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ArrayList<ExternalDiscoveredHost> hosts = (ArrayList<ExternalDiscoveredHost>) result;
                ListModel externalDiscoveredHostsListModel = getExternalDiscoveredHosts();
                hosts.add(0, null);
                externalDiscoveredHostsListModel.setItems(hosts);
                externalDiscoveredHostsListModel.setIsChangable(true);
            }
        };
        AsyncDataProvider.GetExternalProviderDiscoveredHostList(getDiscoveredHostsQuery, provider);
        AsyncQuery getHostGroupsQuery = new AsyncQuery();
        getHostGroupsQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ArrayList<ExternalHostGroup> hostGroups = (ArrayList<ExternalHostGroup>) result;
                ListModel externalHostGroupsListModel = getExternalHostGroups();
                hostGroups.add(0, null);
                externalHostGroupsListModel.setItems(hostGroups);
                externalHostGroupsListModel.setIsChangable(true);
            }
        };
        AsyncDataProvider.GetExternalProviderHostGroupList(getHostGroupsQuery, provider);
    } else {
        getExternalHostName().setItems(null);
        getExternalHostName().setIsChangable(false);
        getExternalDiscoveredHosts().setItems(null);
        getExternalDiscoveredHosts().setIsChangable(false);
        getExternalDiscoveredHosts().setSelectedItem(null);
        getExternalHostGroups().setItems(null);
        getExternalHostGroups().setIsChangable(false);
        getExternalHostGroups().setSelectedItem(null);
        setEnableSearchHost(false);
    }
}
#method_after
private void updateHostList(boolean isDiscovered) {
    Provider provider = getProviders().getSelectedItem();
    if (provider == null) {
        return;
    }
    if (!isDiscovered) {
        AsyncQuery getHostsQuery = new AsyncQuery();
        getHostsQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ArrayList<VDS> hosts = (ArrayList<VDS>) result;
                ListModel<VDS> hostNameListModel = getExternalHostName();
                hostNameListModel.setItems(hosts);
                hostNameListModel.setIsChangable(true);
                setEnableSearchHost(true);
            }
        };
        AsyncDataProvider.getExternalProviderHostList(getHostsQuery, provider.getId(), true, getProviderSearchFilter().getEntity());
    } else {
        AsyncQuery getDiscoveredHostsQuery = new AsyncQuery();
        getDiscoveredHostsQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ArrayList<ExternalDiscoveredHost> hosts = (ArrayList<ExternalDiscoveredHost>) result;
                ListModel externalDiscoveredHostsListModel = getExternalDiscoveredHosts();
                externalDiscoveredHostsListModel.setItems(hosts);
                externalDiscoveredHostsListModel.setIsChangable(true);
            }
        };
        AsyncDataProvider.getExternalProviderDiscoveredHostList(getDiscoveredHostsQuery, provider);
        AsyncQuery getHostGroupsQuery = new AsyncQuery();
        getHostGroupsQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ArrayList<ExternalHostGroup> hostGroups = (ArrayList<ExternalHostGroup>) result;
                ListModel externalHostGroupsListModel = getExternalHostGroups();
                externalHostGroupsListModel.setItems(hostGroups);
                externalHostGroupsListModel.setIsChangable(true);
            }
        };
        AsyncDataProvider.getExternalProviderHostGroupList(getHostGroupsQuery, provider);
        AsyncQuery getComputeResourceQuery = new AsyncQuery();
        getComputeResourceQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ArrayList<ExternalComputeResource> computeResources = (ArrayList<ExternalComputeResource>) result;
                ListModel externalComputeResourceListModel = getExternalComputeResource();
                externalComputeResourceListModel.setItems(computeResources);
                externalComputeResourceListModel.setIsChangable(true);
            }
        };
        AsyncDataProvider.getExternalProviderComputeResourceList(getComputeResourceQuery, provider);
    }
}
#end_block

#method_before
@Override
protected void updateHosts() {
    updateHostList(getProviderSearchFilter().getEntity());
}
#method_after
@Override
public void updateHosts() {
    updateExternalHostModels();
}
#end_block

#method_before
private boolean isTypeRequiresAuthentication() {
    // return type == ProviderType.FOREMAN;
    return false;
}
#method_after
private boolean isTypeRequiresAuthentication() {
    return false;
}
#end_block

#method_before
private static void initCustomPropertiesList() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            customPropertiesList = (Map<Version, List<String>>) returnValue;
        }
    };
    callback.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            Map<Version, String> map = source != null ? (HashMap<Version, String>) source : new HashMap<Version, String>();
            Map<Version, ArrayList<String>> retMap = new HashMap<Version, ArrayList<String>>();
            for (Map.Entry<Version, String> keyValuePair : map.entrySet()) {
                // $NON-NLS-1$
                String[] split = keyValuePair.getValue().split("[;]", -1);
                if (split.length == 1 && (split[0] == null || split[0].isEmpty())) {
                    retMap.put(keyValuePair.getKey(), null);
                } else {
                    retMap.put(keyValuePair.getKey(), new ArrayList<String>());
                    for (String s : split) {
                        retMap.get(keyValuePair.getKey()).add(s);
                    }
                }
            }
            return retMap;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase().withoutRefresh(), callback);
}
#method_after
private static void initCustomPropertiesList() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            customPropertiesList = (Map<Version, Map<String, String>>) returnValue;
        }
    };
    callback.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return (source != null) ? (Map<Version, Map<String, String>>) source : new HashMap<Version, Map<String, String>>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase().withoutRefresh(), callback);
}
#end_block

#method_before
public static Map<Version, List<String>> getCustomPropertiesList() {
    return customPropertiesList;
}
#method_after
public static Map<Version, Map<String, String>> getCustomPropertiesList() {
    return customPropertiesList;
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#method_after
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    getProtocol().setIsAvailable(showTransportProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp(model.getManagementIp().getEntity());
    host.setPmUser(model.getPmUserName().getEntity());
    host.setPmPassword(model.getPmPassword().getEntity());
    host.setPmType(model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp(model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser(model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword(model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType(model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled(model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent(model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = model.getCluster().getSelectedItem().supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getIsProvioning()) {
            Provider provider = (Provider) model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            parameters.setAddProvisioned(provider.getId(), hostGroup, ((ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem()).getMac(), ((ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem()).getName());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(VdsProtocol.fromValue(model.getProtocol().getEntity() ? VdsProtocol.STOMP.toString() : VdsProtocol.XML.toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp(model.getManagementIp().getEntity());
    host.setPmUser(model.getPmUserName().getEntity());
    host.setPmPassword(model.getPmPassword().getEntity());
    host.setPmType(model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp(model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser(model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword(model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType(model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled(model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent(model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = model.getCluster().getSelectedItem().supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getIsProvisioning()) {
            Provider provider = (Provider) model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    setHostBricksListModel(new HostBricksListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(getHostBricksListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    setHostBricksListModel(new HostBricksListModel());
    setHostVmListModel(new HostVmListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(getHostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(getHostBricksListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
    getHostBricksListModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService());
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
    getHostBricksListModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService());
    getHostVmListModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsVirtService());
}
#end_block

#method_before
private void initInfoIcon(ApplicationConstants constants) {
    consoleAddressInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.enableConsoleAddressOverrideHelpMessage()), resources);
    providerSearchInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.providerSearchInfo()), resources);
}
#method_after
private void initInfoIcon(ApplicationConstants constants) {
    consoleAddressInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.enableConsoleAddressOverrideHelpMessage()), resources);
    providerSearchInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.providerSearchInfo()), resources);
    provisionedHostInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.provisionedHostInfo()), resources);
    discoveredHostInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.discoveredHostInfoIcon()), resources);
}
#end_block

#method_before
private void addStyles() {
    overrideIpTablesEditor.addContentWidgetStyleName(style.overrideIpStyle());
    externalHostProviderEnabledEditor.addContentWidgetStyleName(style.checkBox());
    providerSearchFilterEditor.addContentWidgetStyleName(style.searchFilter());
    providerSearchFilterEditor.setStyleName(style.searchFilterLabel());
    providerSearchFilterEditor.setLabelStyleName(style.emptyEditor());
    providerSearchFilterLabel.addContentWidgetStyleName(style.emptyEditor());
    providerSearchFilterLabel.setStyleName(style.searchFilterLabel());
    fetchSshFingerprint.addContentWidgetStyleName(style.fingerprintEditor());
    expanderContent.setStyleName(style.expanderContent());
    publicKeyEditor.setCustomStyle(style.pkStyle());
}
#method_after
private void addStyles() {
    overrideIpTablesEditor.addContentWidgetStyleName(style.overrideIpStyle());
    protocolEditor.addContentWidgetStyleName(style.protocolStyle());
    externalHostProviderEnabledEditor.addContentWidgetStyleName(style.checkBox());
    providerSearchFilterEditor.addContentWidgetStyleName(style.searchFilter());
    providerSearchFilterEditor.setStyleName(style.searchFilterLabel());
    providerSearchFilterEditor.setLabelStyleName(style.emptyEditor());
    providerSearchFilterLabel.addContentWidgetStyleName(style.emptyEditor());
    providerSearchFilterLabel.setStyleName(style.searchFilterLabel());
    fetchSshFingerprint.addContentWidgetStyleName(style.fingerprintEditor());
    expanderContent.setStyleName(style.expanderContent());
    publicKeyEditor.setCustomStyle(style.pkStyle());
}
#end_block

#method_before
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    // List boxes
    dataCenterEditor = new ListModelListBoxEditor<StoragePool>(new NullSafeRenderer<StoragePool>() {

        @Override
        public String renderNullSafe(StoragePool storagePool) {
            return storagePool.getName();
        }
    });
    clusterEditor = new ListModelListBoxEditor<VDSGroup>(new NullSafeRenderer<VDSGroup>() {

        @Override
        public String renderNullSafe(VDSGroup vdsGroup) {
            return vdsGroup.getName();
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS vds) {
            return vds.getName();
        }
    });
    providersEditor = new ListModelListBoxEditor<Provider>(new NullSafeRenderer<Provider>() {

        @Override
        public String renderNullSafe(Provider provider) {
            return provider.getName();
        }
    });
    pmVariantsEditor = new ListModelListBoxOnlyEditor<String>(new StringRenderer<String>());
    pmTypeEditor = new ListModelListBoxEditor<String>(new StringRenderer<String>());
    pmSecondaryTypeEditor = new ListModelListBoxEditor<String>(new StringRenderer<String>());
    externalDiscoveredHostsEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((ExternalDiscoveredHost) object).getName();
        }
    });
    externalHostGroupsEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return ((ExternalHostGroup) object).getName();
        }
    });
    externalHostsTypeEditor = new ListModelListBoxOnlyEditor<String>(new StringRenderer<String>());
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
}
#method_after
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    // List boxes
    dataCenterEditor = new ListModelListBoxEditor<StoragePool>(new NullSafeRenderer<StoragePool>() {

        @Override
        public String renderNullSafe(StoragePool storagePool) {
            return storagePool.getName();
        }
    });
    clusterEditor = new ListModelListBoxEditor<VDSGroup>(new NullSafeRenderer<VDSGroup>() {

        @Override
        public String renderNullSafe(VDSGroup vdsGroup) {
            return vdsGroup.getName();
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS vds) {
            return vds.getName();
        }
    });
    providersEditor = new ListModelListBoxEditor<Provider>(new NullSafeRenderer<Provider>() {

        @Override
        public String renderNullSafe(Provider provider) {
            return provider.getName();
        }
    });
    pmVariantsEditor = new ListModelListBoxOnlyEditor<String>(new StringRenderer<String>());
    pmTypeEditor = new ListModelListBoxEditor<String>(new StringRenderer<String>());
    pmSecondaryTypeEditor = new ListModelListBoxEditor<String>(new StringRenderer<String>());
    externalDiscoveredHostsEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((ExternalDiscoveredHost) object).getName();
        }
    });
    externalHostGroupsEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return ((ExternalHostGroup) object).getName();
        }
    });
    externalComputeResourceEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return ((ExternalComputeResource) object).getName();
        }
    });
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
    // $NON-NLS-1$
    rbDiscoveredHost = new RadioButton("2");
    // $NON-NLS-1$
    rbProvisionedHost = new RadioButton("2");
}
#end_block

#method_before
void localize(ApplicationConstants constants) {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.hostPopupDataCenterLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    hostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    authSshPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    rbPassword.setText(constants.hostPopupPasswordLabel());
    rbPublicKey.setText(constants.hostPopupPublicKeyLable());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    providerSearchFilterLabel.setLabel(constants.hostPopupProviderSearchFilter());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    pmSecondaryConcurrentEditor.setLabel(constants.hostPopupPmConcurrent());
    testButton.setLabel(constants.hostPopupTestButtonLabel());
    upButton.setLabel(constants.hostPopupUpButtonLabel());
    downButton.setLabel(constants.hostPopupDownButtonLabel());
    sourceLabel.setText(constants.hostPopupSourceText());
    // Primary
    pmAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    // Secondary
    pmSecondaryAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmSecondaryUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmSecondaryPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmSecondaryTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmSecondaryPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSecondarySlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmSecondaryOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmSecondaryOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecondarySecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    consoleAddress.setLabel(constants.consoleAddress());
    consoleAddressLabel.setText(constants.enableConsoleAddressOverride());
    // Auto PM
    disableAutomaticPowerManagementEditor.setLabel(constants.hostPopupPmDisableAutoPM());
    pmKdumpDetectionEditor.setLabel(constants.hostPopupPmKdumpDetection());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
    externalDiscoveredHostsEditor.setLabel(constants.discoveredHostsLabel());
    externalHostGroupsEditor.setLabel(constants.hostGroupsLabel());
}
#method_after
void localize(ApplicationConstants constants) {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.hostPopupDataCenterLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    hostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    authSshPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    rbPassword.setText(constants.hostPopupPasswordLabel());
    rbPublicKey.setText(constants.hostPopupPublicKeyLable());
    rbProvisionedHost.setText(constants.provisionedHostsLabel());
    rbDiscoveredHost.setText(constants.discoveredHostsLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    protocolEditor.setLabel(constants.hostPopupProtocolLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    providerSearchFilterLabel.setLabel(constants.hostPopupProviderSearchFilter());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    pmSecondaryConcurrentEditor.setLabel(constants.hostPopupPmConcurrent());
    testButton.setLabel(constants.hostPopupTestButtonLabel());
    upButton.setLabel(constants.hostPopupUpButtonLabel());
    downButton.setLabel(constants.hostPopupDownButtonLabel());
    sourceLabel.setText(constants.hostPopupSourceText());
    // Primary
    pmAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    // Secondary
    pmSecondaryAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmSecondaryUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmSecondaryPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmSecondaryTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmSecondaryPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSecondarySlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmSecondaryOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmSecondaryOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecondarySecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    consoleAddress.setLabel(constants.consoleAddress());
    consoleAddressLabel.setText(constants.enableConsoleAddressOverride());
    // Auto PM
    disableAutomaticPowerManagementEditor.setLabel(constants.hostPopupPmDisableAutoPM());
    pmKdumpDetectionEditor.setLabel(constants.hostPopupPmKdumpDetection());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
    externalDiscoveredHostsEditor.setLabel(constants.discoveredHostsLabel());
    externalHostGroupsEditor.setLabel(constants.hostGroupsLabel());
    externalComputeResourceEditor.setLabel(constants.computeResourceLabel());
}
#end_block

#method_before
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    object.getExternalHostsType().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                boolean isDiscoverVisible = externalDiscoveredHostsEditor.isVisible();
                showExternalDiscoveredHost(!isDiscoverVisible);
                showExternalProvisionedHosts(isDiscoverVisible);
                usualFormToDiscover(isDiscoverVisible);
            }
        }
    });
    object.getExternalHostProviderEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            usualFormToDiscover(!object.getExternalHostProviderEnabled().getEntity());
        }
    });
    rbPassword.setValue(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List<String> items = (List<String>) object.getPmProxyPreferencesList().getItems();
            String selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    object.getExternalHostsType().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#method_after
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    object.getProviders().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            object.updateHosts();
        }
    });
    object.getExternalHostProviderEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean showForemanProviders = object.getExternalHostProviderEnabled().getEntity();
            providersEditor.setVisible(showForemanProviders);
            provisionedHostSection.setVisible(showForemanProviders);
            discoveredHostSection.setVisible(showForemanProviders);
            if (showForemanProviders) {
                object.updateHosts();
            } else {
                object.cleanHostParametersFields();
                hideProviderWidgets(object);
            }
        }
    });
    object.getIsDiscorveredHosts().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getIsDiscorveredHosts().getEntity() == true) {
                rbDiscoveredHost.setValue(true);
                showDiscoveredHostsWidgets(true);
            } else {
                rbProvisionedHost.setValue(true);
                showProvisionedHostsWidgets(true);
            }
        }
    });
    rbPassword.setValue(true);
    rbPassword.setFocus(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List<String> items = (List<String>) object.getPmProxyPreferencesList().getItems();
            String selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#end_block

#method_before
private void initExternalHostProviderWidgets(boolean isAvailable) {
    // When the widgets should be enabled, only the "enable/disable" one should appear.
    // All the rest shouldn't be visible
    externalHostProviderEnabledEditor.setVisible(isAvailable);
    externalHostNameEditor.setVisible(false);
    externalHostsTypeEditor.setVisible(false);
    providersEditor.setVisible(false);
    externalDiscoveredHostsEditor.setVisible(false);
    externalHostGroupsEditor.setVisible(false);
    searchProviderPanel.setVisible(false);
}
#method_after
private void initExternalHostProviderWidgets(boolean isAvailable) {
    // When the widgets should be enabled, only the "enable/disable" one should appear.
    // All the rest shouldn't be visible
    externalHostProviderEnabledEditor.setVisible(isAvailable);
    provisionedHostSection.setVisible(false);
    discoveredHostSection.setVisible(false);
    providersEditor.setVisible(false);
    discoveredHostsPanel.setVisible(false);
    searchProviderPanel.setVisible(false);
}
#end_block

#method_before
private void showExternalDiscoveredHost(boolean enabled) {
    externalDiscoveredHostsEditor.setVisible(enabled);
    externalHostGroupsEditor.setVisible(enabled);
}
#method_after
private void showExternalDiscoveredHost(boolean enabled) {
    discoveredHostsPanel.setVisible(enabled);
}
#end_block

#method_before
private void showExternalProvisionedHosts(boolean enabled) {
    externalHostNameEditor.setVisible(enabled);
    searchProviderPanel.setVisible(enabled);
    providerSearchFilterLabel.setVisible(enabled);
    providerSearchFilterEditor.setVisible(enabled);
}
#method_after
private void showExternalProvisionedHosts(boolean enabled) {
    searchProviderPanel.setVisible(enabled);
}
#end_block

#method_before
private void usualFormToDiscover(boolean isUsual) {
    if (!isUsual) {
        authLabel.setText(constants.hostPopupAuthLabelForExternalHost());
        rbPublicKey.setVisible(false);
        expanderContent.setVisible(false);
        publicKeyEditor.getElement().getStyle().setVisibility(Visibility.HIDDEN);
        authSshPortEditor.getElement().getStyle().setVisibility(Visibility.HIDDEN);
        hostAddressEditor.setEnabled(true);
    } else {
        // Return to usual form
        authLabel.setText(constants.hostPopupAuthLabel());
        rbPublicKey.setVisible(true);
        expanderContent.setVisible(true);
        publicKeyEditor.getElement().getStyle().setVisibility(Visibility.VISIBLE);
        authSshPortEditor.getElement().getStyle().setVisibility(Visibility.VISIBLE);
        // maybe we can avoid the latter somehow
        rbPassword.setEnabled(true);
        displayPassPkWindow(true);
    }
}
#method_after
private void usualFormToDiscover(boolean isDiscovered) {
    if (isDiscovered) {
        authLabel.setText(constants.hostPopupAuthLabelForExternalHost());
        hostAddressEditor.setEnabled(true);
        hostAddressEditor.setVisible(true);
    } else {
        authLabel.setText(constants.hostPopupAuthLabel());
        displayPassPkWindow(true);
    }
    rbPublicKey.setVisible(!isDiscovered);
    rbPassword.setVisible(!isDiscovered);
    expanderContent.setVisible(!isDiscovered);
    publicKeyEditor.setVisible(!isDiscovered);
    authSshPortEditor.setVisible(!isDiscovered);
    userNameEditor.setVisible(!isDiscovered);
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    externalDiscoveredHostsEditor.setTabIndex(nextTabIndex++);
    externalHostGroupsEditor.setTabIndex(nextTabIndex++);
    providerSearchFilterLabel.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    rbProvisionedHost.setTabIndex(nextTabIndex++);
    rbDiscoveredHost.setTabIndex(nextTabIndex++);
    externalDiscoveredHostsEditor.setTabIndex(nextTabIndex++);
    externalHostGroupsEditor.setTabIndex(nextTabIndex++);
    externalComputeResourceEditor.setTabIndex(nextTabIndex++);
    providerSearchFilterLabel.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
protected RunVmValidator getRunVmValidator() {
    return new RunVmValidator(getVm(), getParameters(), isInternalExecution(), getActiveIsoDomainId(), osRepository);
}
#method_after
protected RunVmValidator getRunVmValidator() {
    return new RunVmValidator(getVm(), getParameters(), isInternalExecution(), getActiveIsoDomainId());
}
#end_block

#method_before
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setVdsName(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.setHostName(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setPort(model.getPort());
    } else {
        entity.setPort(DEFAULT_VDSM_PORT);
    }
    if (model.isSetSsh()) {
        map(model.getSsh(), entity);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetStorageManager()) {
        if (model.getStorageManager().getPriority() != null) {
            entity.setVdsSpmPriority(model.getStorageManager().getPriority());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplay().getAddress()) ? null : model.getDisplay().getAddress());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    return entity;
}
#method_after
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setVdsName(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.setHostName(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setPort(model.getPort());
    } else {
        entity.setPort(DEFAULT_VDSM_PORT);
    }
    if (model.isSetProtocol()) {
        entity.setProtocol(VdsProtocol.fromValue(model.getProtocol()));
    }
    if (model.isSetSsh()) {
        map(model.getSsh(), entity);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetStorageManager()) {
        if (model.getStorageManager().getPriority() != null) {
            entity.setVdsSpmPriority(model.getStorageManager().getPriority());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplay().getAddress()) ? null : model.getDisplay().getAddress());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    entity.setManagementIp(getManagementIp(model, entity));
    entity.setPmType(getManagementType(model, entity));
    entity.setPmUser(getManagementUser(model, entity));
    entity.setPmPassword(getManagementPassword(model, entity));
    entity.setPmOptions(getManagementOptions(model, entity));
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetAutomaticPmEnabled()) {
        entity.setDisablePowerManagementPolicy(!model.isAutomaticPmEnabled());
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    if (model.isSetAgents()) {
        // Currently only Primary/Secondary agents are supported
        int order = 1;
        for (Agent agent : model.getAgents().getAgents()) {
            if (agent.isSetOrder()) {
                order = agent.getOrder();
            }
            if (order == 1) {
                // Primary
                // in case that order is not defined, secondary will still be defined correctly.
                order++;
            } else if (order == 2) {
                // Secondary
                if (agent.isSetType()) {
                    entity.setPmSecondaryType(agent.getType());
                }
                if (agent.isSetAddress()) {
                    entity.setPmSecondaryIp(agent.getAddress());
                }
                if (agent.isSetUsername()) {
                    entity.setPmSecondaryUser(agent.getUsername());
                }
                if (agent.isSetPassword()) {
                    entity.setPmSecondaryPassword(agent.getPassword());
                }
                if (agent.isSetOptions()) {
                    entity.setPmSecondaryOptions(map(agent.getOptions(), null));
                }
                if (agent.isSetConcurrent()) {
                    entity.setPmSecondaryConcurrent(agent.isConcurrent());
                }
            }
        }
    }
    if (model.isSetKdumpDetection()) {
        entity.setPmKdumpDetection(model.isKdumpDetection());
    }
    return entity;
}
#method_after
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    boolean hasAgents = StringUtils.isNotEmpty(model.getAddress()) || (model.isSetAgents() && model.getAgents().getAgents().size() > 0);
    boolean removeSecondaryAgent = StringUtils.isNotEmpty(entity.getPmSecondaryIp()) && model.isSetAgents() && model.getAgents().getAgents().size() < 2;
    if (hasAgents) {
        entity.setManagementIp(getManagementIp(model, entity));
        entity.setPmType(getManagementType(model, entity));
        entity.setPmUser(getManagementUser(model, entity));
        entity.setPmPassword(getManagementPassword(model, entity));
        entity.setPmOptions(getManagementOptions(model, entity));
    } else {
        clearPmAgentsSettings(entity);
    }
    if (removeSecondaryAgent) {
        clearSecondaryPmAgentSettings(entity);
    }
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetAutomaticPmEnabled()) {
        entity.setDisablePowerManagementPolicy(!model.isAutomaticPmEnabled());
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    if (model.isSetAgents()) {
        // Currently only Primary/Secondary agents are supported
        int order = 1;
        for (Agent agent : model.getAgents().getAgents()) {
            if (agent.isSetOrder()) {
                order = agent.getOrder();
            }
            if (order == 1) {
                // Primary
                // in case that order is not defined, secondary will still be defined correctly.
                order++;
            } else if (order == 2) {
                // Secondary
                if (agent.isSetType()) {
                    entity.setPmSecondaryType(agent.getType());
                }
                if (agent.isSetAddress()) {
                    entity.setPmSecondaryIp(agent.getAddress());
                }
                if (agent.isSetUsername()) {
                    entity.setPmSecondaryUser(agent.getUsername());
                }
                if (agent.isSetPassword()) {
                    entity.setPmSecondaryPassword(agent.getPassword());
                }
                if (agent.isSetOptions()) {
                    entity.setPmSecondaryOptions(map(agent.getOptions(), null));
                }
                if (agent.isSetConcurrent()) {
                    entity.setPmSecondaryConcurrent(agent.isConcurrent());
                }
            }
        }
    }
    if (model.isSetKdumpDetection()) {
        entity.setPmKdumpDetection(model.isKdumpDetection());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getSpmStatus() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (SSH) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSelinux(map(entity, (SELinux) null));
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    model.setProtocol(map(entity.getProtocol(), (String) null));
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getSpmStatus() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (SSH) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSelinux(map(entity, (SELinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    return model;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = HardwareInformation.class)
public static HardwareInformation map(VDS entity, HardwareInformation template) {
    HardwareInformation model = template != null ? template : new HardwareInformation();
    model.setManufacturer(entity.getHardwareManufacturer());
    model.setFamily(entity.getHardwareFamily());
    model.setProductName(entity.getHardwareProductName());
    model.setSerialNumber(entity.getHardwareSerialNumber());
    model.setUuid(entity.getHardwareUUID());
    model.setVersion(entity.getHardwareVersion());
    return model;
}
#method_after
@Mapping(from = VDS.class, to = HardwareInformation.class)
public static HardwareInformation map(VDS entity, HardwareInformation template) {
    HardwareInformation model = template != null ? template : new HardwareInformation();
    model.setManufacturer(entity.getHardwareManufacturer());
    model.setFamily(entity.getHardwareFamily());
    model.setProductName(entity.getHardwareProductName());
    model.setSerialNumber(entity.getHardwareSerialNumber());
    model.setUuid(entity.getHardwareUUID());
    model.setVersion(entity.getHardwareVersion());
    model.setSupportedRngSources(RngDeviceMapper.mapRngSources(entity.getSupportedRngSources(), null));
    return model;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = SELinux.class)
public static SELinux map(VDS entity, SELinux template) {
    SELinux model = template != null ? template : new SELinux();
    if (entity.getSELinuxEnforceMode() == null) {
        return model;
    }
    model.setMode(entity.getSELinuxEnforceMode().toString());
    return model;
}
#method_after
@Mapping(from = VDS.class, to = SELinux.class)
public static SELinux map(VDS entity, SELinux template) {
    SELinux model = template != null ? template : new SELinux();
    if (entity.getSELinuxEnforceMode() == null) {
        return model;
    }
    String mode = null;
    switch(entity.getSELinuxEnforceMode()) {
        case DISABLED:
            mode = SELinuxMode.DISABLED.value();
            break;
        case PERMISSIVE:
            mode = SELinuxMode.PERMISSIVE.value();
            break;
        case ENFORCING:
            mode = SELinuxMode.ENFORCING.value();
    }
    model.setMode(mode);
    return model;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.KdumpStatus.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.KdumpStatus kdumpStatus, String template) {
    String result = null;
    if (kdumpStatus != null) {
        switch(kdumpStatus) {
            case UNKNOWN:
                result = KdumpStatus.UNKNOWN.value();
                break;
            case DISABLED:
                result = KdumpStatus.DISABLED.value();
                break;
            case ENABLED:
                result = KdumpStatus.ENABLED.value();
                break;
            default:
                break;
        }
    }
    return result;
}
#method_after
@Mapping(from = AutoNumaBalanceStatus.class, to = String.class)
public static String map(AutoNumaBalanceStatus autoNumaStatus, String template) {
    String result = null;
    if (autoNumaStatus != null) {
        switch(autoNumaStatus) {
            case DISABLE:
                result = AutoNumaStatus.DISABLE.value();
                break;
            case ENABLE:
                result = AutoNumaStatus.ENABLE.value();
                break;
            case UNKNOWN:
                result = AutoNumaStatus.UNKNOWN.value();
                break;
            default:
                break;
        }
    }
    return result;
}
#end_block

#method_before
private List<VDS> runHostListMethod(HttpMethod httpMethod) {
    try {
        runHttpMethod(httpClient, httpMethod);
        ForemanHostWrapper[] hosts = objectMapper.readValue(httpMethod.getResponseBody(), ForemanHostWrapper[].class);
        return mapHosts(Arrays.asList(hosts));
    } catch (JsonParseException e) {
        handleException(e);
    } catch (JsonMappingException e) {
        handleException(e);
    } catch (IOException e) {
        handleException(e);
    }
    return null;
}
#method_after
private List<VDS> runHostListMethod(HttpMethod httpMethod) {
    try {
        runHttpMethod(httpClient, httpMethod);
        ForemanHostWrapper fhw = objectMapper.readValue(httpMethod.getResponseBody(), ForemanHostWrapper.class);
        return mapHosts(Arrays.asList(fhw.getResults()));
    } catch (Exception e) {
        return null;
    }
}
#end_block

#method_before
private List<ExternalDiscoveredHost> runDiscoveredHostListMethod(HttpMethod httpMethod) {
    try {
        runHttpMethod(httpClient, httpMethod);
        ForemanDiscoveredHostWrapper[] hosts = objectMapper.readValue(httpMethod.getResponseBody(), ForemanDiscoveredHostWrapper[].class);
        return mapDiscoveredHosts(Arrays.asList(hosts));
    } catch (JsonParseException e) {
        handleException(e);
    } catch (JsonMappingException e) {
        handleException(e);
    } catch (IOException e) {
        handleException(e);
    }
    return null;
}
#method_after
private List<ExternalDiscoveredHost> runDiscoveredHostListMethod(HttpMethod httpMethod) {
    try {
        runHttpMethod(httpClient, httpMethod);
        ForemanDiscoveredHostWrapper fdw = objectMapper.readValue(httpMethod.getResponseBody(), ForemanDiscoveredHostWrapper.class);
        return mapDiscoveredHosts(Arrays.asList(fdw.getResults()));
    } catch (Exception e) {
        return null;
    }
}
#end_block

#method_before
private List<ExternalHostGroup> runHostGroupListMethod(HttpMethod httpMethod) {
    try {
        runHttpMethod(httpClient, httpMethod);
        ForemanHostGroupWrapper[] hostGroups = objectMapper.readValue(httpMethod.getResponseBody(), ForemanHostGroupWrapper[].class);
        return mapHostGroups(Arrays.asList(hostGroups));
    } catch (JsonParseException e) {
        handleException(e);
    } catch (JsonMappingException e) {
        handleException(e);
    } catch (IOException e) {
        handleException(e);
    }
    return null;
}
#method_after
private List<ExternalHostGroup> runHostGroupListMethod(HttpMethod httpMethod) {
    try {
        runHttpMethod(httpClient, httpMethod);
        ForemanHostGroupWrapper fhgw = objectMapper.readValue(httpMethod.getResponseBody(), ForemanHostGroupWrapper.class);
        return mapHostGroups(Arrays.asList(fhgw.getResults()));
    } catch (Exception e) {
        return null;
    }
}
#end_block

#method_before
private List<ExternalOperatingSystem> runOperationSystemMethod(HttpMethod httpMethod) {
    try {
        runHttpMethod(httpClient, httpMethod);
        ForemanOperatingSystemWrapper[] fos = objectMapper.readValue(httpMethod.getResponseBody(), ForemanOperatingSystemWrapper[].class);
        return mapOperationSystem(Arrays.asList(fos));
    } catch (JsonParseException e) {
        handleException(e);
    } catch (JsonMappingException e) {
        handleException(e);
    } catch (IOException e) {
        handleException(e);
    }
    return null;
}
#method_after
private List<ExternalOperatingSystem> runOperationSystemMethod(HttpMethod httpMethod) {
    try {
        runHttpMethod(httpClient, httpMethod);
        ForemanOperatingSystemWrapper fosw = objectMapper.readValue(httpMethod.getResponseBody(), ForemanOperatingSystemWrapper.class);
        return mapOperationSystem(Arrays.asList(fosw.getResults()));
    } catch (Exception e) {
        return null;
    }
}
#end_block

#method_before
private List<ExternalOperatingSystem> mapOperationSystem(List<ForemanOperatingSystemWrapper> foremanOss) {
    ArrayList<ExternalOperatingSystem> oss = new ArrayList<ExternalOperatingSystem>(foremanOss.size());
    for (ForemanOperatingSystemWrapper os : foremanOss) {
        ExternalOperatingSystem eos = new ExternalOperatingSystem();
        eos.setName(os.getOperatingsystem().getName());
        eos.setId(os.getOperatingsystem().getId());
        // TODO: maybe log it ?
        if (os.getOperatingsystem().getMedia().length > 0) {
            eos.setMedia_id(os.getOperatingsystem().getMedia()[0].getMedium().getId());
        }
        oss.add(eos);
    }
    return oss;
}
#method_after
private List<ExternalOperatingSystem> mapOperationSystem(List<ForemanOperatingSystem> foremanOss) {
    ArrayList<ExternalOperatingSystem> oss = new ArrayList<ExternalOperatingSystem>(foremanOss.size());
    for (ForemanOperatingSystem os : foremanOss) {
        ExternalOperatingSystem eos = new ExternalOperatingSystem();
        eos.setName(os.getName());
        eos.setId(os.getId());
        oss.add(eos);
    }
    return oss;
}
#end_block

#method_before
private List<ExternalDiscoveredHost> mapDiscoveredHosts(List<ForemanDiscoveredHostWrapper> foremanHosts) {
    ArrayList<ExternalDiscoveredHost> hosts = new ArrayList<ExternalDiscoveredHost>(foremanHosts.size());
    for (ForemanDiscoveredHostWrapper host : foremanHosts) {
        ExternalDiscoveredHost dhost = new ExternalDiscoveredHost();
        dhost.setName(host.getHost().getName());
        dhost.setIp(host.getHost().getIp());
        dhost.setMac(host.getHost().getMac());
        hosts.add(dhost);
    }
    return hosts;
}
#method_after
private List<ExternalDiscoveredHost> mapDiscoveredHosts(List<ForemanDiscoveredHost> foremanHosts) {
    ArrayList<ExternalDiscoveredHost> hosts = new ArrayList<ExternalDiscoveredHost>(foremanHosts.size());
    for (ForemanDiscoveredHost host : foremanHosts) {
        ExternalDiscoveredHost dhost = new ExternalDiscoveredHost();
        dhost.setName(host.getName());
        dhost.setIp(host.getIp());
        dhost.setMac(host.getMac());
        hosts.add(dhost);
    }
    return hosts;
}
#end_block

#method_before
private List<VDS> mapHosts(List<ForemanHostWrapper> foremanHosts) {
    ArrayList<VDS> hosts = new ArrayList<VDS>(foremanHosts.size());
    for (ForemanHostWrapper host : foremanHosts) {
        // retrieve all host info
        // currently we have only host name filled out. we can add much more if preferred
        /*
            HttpMethod method = new GetMethod(HOSTS_ENTRY_POINT + "/" + host.getHost().getName());
            runHttpMethod(httpClient, method);
            try {
                ForemanHostWrapper fhost = objectMapper.readValue(method.getResponseBody(), ForemanHostWrapper.class);
            } catch (JsonParseException e) {
                handleException(e);
            } catch (JsonMappingException e) {
                handleException(e);
            } catch (IOException e) {
                handleException(e);
            }
            */
        VDS vds = new VDS();
        vds.setVdsName(host.getHost().getName());
        hosts.add(vds);
    }
    return hosts;
}
#method_after
private List<VDS> mapHosts(List<ForemanHost> foremanHosts) {
    ArrayList<VDS> hosts = new ArrayList<VDS>(foremanHosts.size());
    for (ForemanHost host : foremanHosts) {
        VDS vds = new VDS();
        vds.setVdsName(host.getName());
        vds.setHostName(host.getIp());
        hosts.add(vds);
    }
    return hosts;
}
#end_block

#method_before
private List<ExternalHostGroup> mapHostGroups(List<ForemanHostGroupWrapper> foremanHostGroups) {
    ArrayList<ExternalHostGroup> hostGroups = new ArrayList<ExternalHostGroup>(foremanHostGroups.size());
    for (ForemanHostGroupWrapper hostGroup : foremanHostGroups) {
        ExternalHostGroup hostgroup = new ExternalHostGroup();
        hostgroup.setHostgroupId(hostGroup.getHostgroup().getId());
        hostgroup.setName(hostGroup.getHostgroup().getName());
        hostgroup.setOsId(hostGroup.getHostgroup().getOperatingsystem_id());
        hostgroup.setEnvironmentId(hostGroup.getHostgroup().getEnvironment_id());
        hostgroup.setDomainId(hostGroup.getHostgroup().getDomain_id());
        hostgroup.setSubnetId(hostGroup.getHostgroup().getSubnet_id());
        hostgroup.setParameters(hostGroup.getHostgroup().getParameters());
        // hostgroup.setPuppetclassIds(hostGroup.getHostgroup().getPuppetclass_ids());
        hostGroups.add(hostgroup);
    }
    return hostGroups;
}
#method_after
private List<ExternalHostGroup> mapHostGroups(List<ForemanHostGroup> foremanHostGroups) {
    ArrayList<ExternalHostGroup> hostGroups = new ArrayList<ExternalHostGroup>(foremanHostGroups.size());
    for (ForemanHostGroup hostGroup : foremanHostGroups) {
        ExternalHostGroup hostgroup = new ExternalHostGroup();
        hostgroup.setHostgroupId(hostGroup.getId());
        hostgroup.setName(hostGroup.getName());
        hostgroup.setOsId(hostGroup.getOperatingsystem_id());
        hostgroup.setEnvironmentId(hostGroup.getEnvironment_id());
        hostgroup.setDomainId(hostGroup.getDomain_id());
        hostgroup.setSubnetId(hostGroup.getSubnet_id());
        hostgroup.setParameters(hostGroup.getParameters());
        hostgroup.setMediumId(hostGroup.getMedium_id());
        hostgroup.setArchitectureId(hostGroup.getArchitecture_id());
        hostgroup.setPtableId(hostGroup.getPtable_id());
        hostGroups.add(hostgroup);
    }
    return hostGroups;
}
#end_block

#method_before
// Overriding HostProviderProxy functions
@Override
public List<VDS> getAll() {
    HttpMethod method = new GetMethod(ALL_HOSTS_QUERY);
    return runHostListMethod(method);
}
#method_after
@Override
public List<VDS> getAll() {
    HttpMethod method = new GetMethod(ALL_HOSTS_QUERY);
    return runHostListMethod(method);
}
#end_block

#method_before
private List<ExternalOperatingSystem> getOperationSystems() {
    HttpMethod method = new GetMethod(OS_QUERY);
    return runOperationSystemMethod(method);
}
#method_after
private List<ExternalOperatingSystem> getOperationSystems() {
    HttpMethod method = new GetMethod(OPERATION_SYSTEM_QUERY);
    return runOperationSystemMethod(method);
}
#end_block

#method_before
private void runHttpMethod(HttpClient httpClient, HttpMethod httpMethod) {
    try {
        int result = httpClient.executeMethod(httpMethod);
        // after post request the return value is HTTP_MOVED_TEMP on success
        if (result != HttpURLConnection.HTTP_OK && result != HttpURLConnection.HTTP_MOVED_TEMP) {
            throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE);
        }
    } catch (HttpException e) {
        handleException(e);
    } catch (SSLException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_SSL_FAILURE, e.getMessage());
    } catch (IOException e) {
        handleException(e);
    }
}
#method_after
private void runHttpMethod(HttpClient httpClient, HttpMethod httpMethod) {
    try {
        int result = httpClient.executeMethod(httpMethod);
        // after post request the return value is HTTP_MOVED_TEMP on success
        if (result != HttpURLConnection.HTTP_OK && result != HttpURLConnection.HTTP_MOVED_TEMP) {
            // 422: conflicts in data
            throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE);
        }
    } catch (HttpException e) {
        handleException(e);
    } catch (SSLException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_SSL_FAILURE, e.getMessage());
    } catch (IOException e) {
        handleException(e);
    }
}
#end_block

#method_before
private void initHttpClient() {
    try {
        URL hostUrl = getUrl();
        if (isSecured()) {
            int hostPort = hostUrl.getPort() == -1 ? HttpsURL.DEFAULT_PORT : hostUrl.getPort();
            Protocol httpsProtocol = new Protocol(String.valueOf(HttpsURL.DEFAULT_SCHEME), (ProtocolSocketFactory) new AuthSSLProtocolSocketFactory(ExternalTrustStoreInitializer.getTrustStore()), hostPort);
            httpClient.getHostConfiguration().setHost(hostUrl.getHost(), hostPort, httpsProtocol);
        } else {
            int hostPort = hostUrl.getPort() == -1 ? HttpURL.DEFAULT_PORT : hostUrl.getPort();
            httpClient.getHostConfiguration().setHost(hostUrl.getHost(), hostPort);
        }
        objectMapper.configure(Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        if (hostProvider.getUsername() != null && hostProvider.getPassword() != null) {
            Credentials hostProviderCredentials = new UsernamePasswordCredentials(hostProvider.getUsername(), hostProvider.getPassword());
            httpClient.getState().setCredentials(AuthScope.ANY, hostProviderCredentials);
            // Required when working with foreman's /api rather than accessing directly to /hosts
            httpClient.getState().setAuthenticationPreemptive(true);
        }
    } catch (RuntimeException e) {
        handleException(e);
    }
}
#method_after
private void initHttpClient() {
    try {
        URL hostUrl = getUrl();
        if (isSecured()) {
            int hostPort = hostUrl.getPort() == -1 ? HttpsURL.DEFAULT_PORT : hostUrl.getPort();
            Protocol httpsProtocol = new Protocol(String.valueOf(HttpsURL.DEFAULT_SCHEME), (ProtocolSocketFactory) new AuthSSLProtocolSocketFactory(ExternalTrustStoreInitializer.getTrustStore()), hostPort);
            httpClient.getHostConfiguration().setHost(hostUrl.getHost(), hostPort, httpsProtocol);
        } else {
            int hostPort = hostUrl.getPort() == -1 ? HttpURL.DEFAULT_PORT : hostUrl.getPort();
            httpClient.getHostConfiguration().setHost(hostUrl.getHost(), hostPort);
        }
        objectMapper.configure(Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        if (hostProvider.getUsername() != null && hostProvider.getPassword() != null) {
            Credentials hostProviderCredentials = new UsernamePasswordCredentials(hostProvider.getUsername(), hostProvider.getPassword());
            httpClient.getState().setCredentials(AuthScope.ANY, hostProviderCredentials);
            // Required when working with foreman's /api rather than accessing directly to /hosts
            httpClient.getParams().setAuthenticationPreemptive(true);
        }
    } catch (RuntimeException e) {
        handleException(e);
    }
}
#end_block

#method_before
private void InitVdsBroker() {
    log.infoFormat("Initialize vdsBroker ({0},{1})", _vds.getHostName(), _vds.getPort());
    // Get the values of the timeouts:
    int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
    int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
    int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
    Pair<VdsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(_vds.getHostName(), _vds.getPort(), clientTimeOut, connectionTimeOut, clientRetries, VdsServerConnector.class, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
    _vdsProxy = new VdsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
}
#method_after
private void InitVdsBroker() {
    log.infoFormat("Initialize vdsBroker ({0},{1})", _vds.getHostName(), _vds.getPort());
    // Get the values of the timeouts:
    int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
    int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
    int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
    _vdsProxy = TransportFactory.createVdsServer(_vds.getProtocol(), _vds.getHostName(), _vds.getPort(), clientTimeOut, connectionTimeOut, clientRetries);
}
#end_block

#method_before
public void refreshHost(VDS vds) {
    try {
        refreshCapabilities(new AtomicBoolean(), vds);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#method_after
public void refreshHost(VDS vds) {
    try {
        refreshCapabilities(new AtomicBoolean(), vds);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#end_block

#method_before
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getPreviousStatus() != vds.getStatus()) {
            vds.setPreviousStatus(vds.getStatus());
            if (_vds != null) {
                _vds.setPreviousStatus(vds.getStatus());
                if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                    calculateNextMaintenanceAttemptTime();
                }
            }
        }
        // update to new status
        vds.setStatus(status);
        if (_vds != null) {
            _vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (_vds != null) {
                    _vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (_vds != null) {
                    _vds.setCpuSys(Double.valueOf(0));
                    _vds.setCpuUser(Double.valueOf(0));
                    _vds.setCpuIdle(Double.valueOf(0));
                    _vds.setCpuLoad(Double.valueOf(0));
                    _vds.setUsageCpuPercent(0);
                    _vds.setUsageMemPercent(0);
                    _vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#method_after
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getStatus() != status) {
            if (status == VDSStatus.PreparingForMaintenance) {
                calculateNextMaintenanceAttemptTime();
            }
            vds.setPreviousStatus(vds.getStatus());
            if (_vds != null) {
                _vds.setPreviousStatus(vds.getStatus());
            }
        }
        // update to new status
        vds.setStatus(status);
        if (_vds != null) {
            _vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (_vds != null) {
                    _vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (_vds != null) {
                    _vds.setCpuSys(Double.valueOf(0));
                    _vds.setCpuUser(Double.valueOf(0));
                    _vds.setCpuIdle(Double.valueOf(0));
                    _vds.setCpuLoad(Double.valueOf(0));
                    _vds.setUsageCpuPercent(0);
                    _vds.setUsageMemPercent(0);
                    _vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#end_block

#method_before
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(vds.getVmCount(), vds.getSpmStatus());
        if (mUnrespondedAttempts.get() < Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount) || (lastUpdate + timeoutToFence) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getStatus() != VDSStatus.Connecting && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        log.infoFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, vm_count = {2}, " + "spm_status = {3}, non-responsive_timeout (seconds) = {4}, error = {5}", vds.getId(), vds.getName(), vds.getVmCount(), vds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        boolean executeSshSoftFencing = false;
        if (!sshSoftFencingExecuted.getAndSet(true)) {
            executeSshSoftFencing = true;
        }
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds, executeSshSoftFencing);
    }
    return true;
}
#method_after
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(vds.getVmCount(), vds.getSpmStatus());
        log.warnFormat("Host {0} is not responding. It will stay in Connecting state for a grace period of ${1} seconds and after that an attempt to fence the host will be issued.", vds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(vds.getId());
        logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
        AuditLogDirector.log(logable, AuditLogType.VDS_HOST_IN_CONNECTING_STATE);
        if (mUnrespondedAttempts.get() < Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount) || (lastUpdate + timeoutToFence) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getStatus() != VDSStatus.Connecting && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        moveVMsToUnknown();
        log.infoFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, vm_count = {2}, " + "spm_status = {3}, non-responsive_timeout (seconds) = {4}, error = {5}", vds.getId(), vds.getName(), vds.getVmCount(), vds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
        logable = new AuditLogableBase(vds.getId());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        boolean executeSshSoftFencing = false;
        if (!sshSoftFencingExecuted.getAndSet(true)) {
            executeSshSoftFencing = true;
        }
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds, executeSshSoftFencing);
    }
    return true;
}
#end_block

#method_before
public void dispose() {
    log.info("vdsManager::disposing");
    SchedulerUtilQuartzImpl.getInstance().deleteJob(onTimerJobId);
    XmlRpcUtils.shutDownConnection(((VdsServerWrapper) _vdsProxy).getHttpClient());
}
#method_after
public void dispose() {
    log.info("vdsManager::disposing");
    SchedulerUtilQuartzImpl.getInstance().deleteJob(onTimerJobId);
    if (VdsServerWrapper.class.isInstance(_vdsProxy)) {
        XmlRpcUtils.shutDownConnection(((VdsServerWrapper) _vdsProxy).getHttpClient());
    } else {
        ((JsonRpcVdsServer) _vdsProxy).close();
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().getAddProvisioned()) {
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        proxy.ProvisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword());
        AuditLogableBase logable = new AuditLogableBase();
        logable.addCustomValue("VdsName", getParameters().getvds().getName());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        AuditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().getAddPending() && !getParameters().getAddProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setProviderId(getParameters().getProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().getAddProvisioned()) {
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        AuditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().getAddPending() && !getParameters().getAddProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setProviderId(getParameters().getProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
public static void mockOsTypes() {
    IMocksControl control = EasyMock.createNiceControl();
    OsRepository osRepositoryMock = control.createMock(OsRepository.class);
    HashMap<Integer, String> osNames = new HashMap<>(1);
    osNames.put(0, "Unassigned");
    expect(osRepositoryMock.getUniqueOsNames()).andReturn(osNames).anyTimes();
    expect(osRepositoryMock.isBalloonDisabledByDefault(anyInt(), anyObject(Version.class))).andReturn(false).anyTimes();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepositoryMock);
    control.replay();
}
#method_after
public static void mockOsTypes() {
    IMocksControl control = EasyMock.createNiceControl();
    OsRepository osRepositoryMock = control.createMock(OsRepository.class);
    HashMap<Integer, String> osNames = new HashMap<>(1);
    osNames.put(0, "Unassigned");
    expect(osRepositoryMock.getUniqueOsNames()).andReturn(osNames).anyTimes();
    expect(osRepositoryMock.isBalloonEnabled(anyInt(), anyObject(Version.class))).andReturn(true).anyTimes();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepositoryMock);
    control.replay();
}
#end_block

#method_before
@BeforeClass
public static void setUp() throws Exception {
    preferences = new MapBackedPreferences(preferences, "");
    preferences.node("/os/rhel7/id").put("value", "777");
    preferences.node("/os/rhel7/name").put("value", "RHEL 7");
    preferences.node("/os/rhel7/family").put("value", "linux");
    preferences.node("/os/rhel7/bus").put("value", "64");
    preferences.node("/os/rhel7/devices/network").put("value", NETWORK_DEVICES);
    preferences.node("/os/rhel7/devices/disk/hotpluggableInterfaces").put("value", DISK_HOTPLUGGABLE_INTERFACES);
    preferences.node("/os/rhel7/resources/minimum/ram").put("value", "1024");
    preferences.node("/os/rhel7/resources/minimum/ram").put("value.3.1", "512");
    preferences.node("/os/rhel7/resources/maximum/ram").put("value", "2048");
    preferences.node("/os/rhel7/spiceSupport").put("value", "true");
    preferences.node("/os/rhel7/displayProtocols").put("value", "vnc/cirrus,qxl/qxl");
    preferences.node("/os/rhel7/devices/balloonDisabledByDefault").put("value", "false");
    preferences.node("/os/rhel7/sysprepPath").put("value", PATH_TO_SYSPREP);
    preferences.node("/os/rhel7/productKey").put("value", SOME_PRODUCT_KEY);
    preferences.node("/os/rhel7/devices/audio").put("value", SOUND_DEVICE);
    preferences.node("/os/rhel7/isTimezoneTypeInteger").put("value", "false");
    preferences.node("/os/bados/id").put("value", "666");
    preferences.node("/os/bados/derivedFrom").put("value", "nonExistingOs");
    preferences.node("/os/rhel8/id").put("value", "888");
    preferences.node("/os/rhel8/derivedFrom").put("value", "rhel7");
    preferences.node("/os/windows_8/id").put("value", "20");
    preferences.node("/backwardCompatibility").put("Windows8", "20");
    OsRepositoryImpl.INSTANCE.init(preferences);
}
#method_after
@BeforeClass
public static void setUp() throws Exception {
    preferences = new MapBackedPreferences(preferences, "");
    preferences.node("/os/rhel7/id").put("value", "777");
    preferences.node("/os/rhel7/name").put("value", "RHEL 7");
    preferences.node("/os/rhel7/family").put("value", "linux");
    preferences.node("/os/rhel7/bus").put("value", "64");
    preferences.node("/os/rhel7/devices/network").put("value", NETWORK_DEVICES);
    preferences.node("/os/rhel7/devices/disk/hotpluggableInterfaces").put("value", DISK_HOTPLUGGABLE_INTERFACES);
    preferences.node("/os/rhel7/watchDogModels").put("value", WATCH_DOG_MODELS);
    preferences.node("/os/rhel7/resources/minimum/ram").put("value", "1024");
    preferences.node("/os/rhel7/resources/minimum/ram").put("value.3.1", "512");
    preferences.node("/os/rhel7/resources/maximum/ram").put("value", "2048");
    preferences.node("/os/rhel7/spiceSupport").put("value", "true");
    preferences.node("/os/rhel7/displayProtocols").put("value", "vnc/cirrus,qxl/qxl");
    preferences.node("/os/rhel7/devices/balloon/enabled").put("value", "true");
    preferences.node("/os/rhel7/sysprepPath").put("value", PATH_TO_SYSPREP);
    preferences.node("/os/rhel7/productKey").put("value", SOME_PRODUCT_KEY);
    preferences.node("/os/rhel7/devices/audio").put("value", SOUND_DEVICE);
    preferences.node("/os/rhel7/devices/cdInterface").put("value", CD_INTERFACE);
    preferences.node("/os/rhel7/isTimezoneTypeInteger").put("value", "false");
    preferences.node("/os/bados/id").put("value", "666");
    preferences.node("/os/bados/derivedFrom").put("value", "nonExistingOs");
    preferences.node("/os/rhel8/id").put("value", "888");
    preferences.node("/os/rhel8/derivedFrom").put("value", "rhel7");
    preferences.node("/os/windows_8/id").put("value", "20");
    preferences.node("/backwardCompatibility").put("Windows8", "20");
    OsRepositoryImpl.INSTANCE.init(preferences);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    switch(getParameters().getOsRepositoryVerb()) {
        case GetOsNames:
            setReturnValue(osRepository.getOsNames());
            break;
        case GetUniqueOsNames:
            setReturnValue(osRepository.getUniqueOsNames());
            break;
        case GetOsIds:
            setReturnValue(osRepository.getOsIds());
            break;
        case GetLinuxOss:
            setReturnValue(osRepository.getLinuxOss());
            break;
        case GetWindowsOss:
            setReturnValue(osRepository.getWindowsOss());
            break;
        case GetNicHotplugSupportMap:
            setReturnValue(osRepository.getNicHotplugSupportMap());
            break;
        case GetDiskHotpluggableInterfacesMap:
            setReturnValue(osRepository.getDiskHotpluggableInterfacesMap());
            break;
        case GetOsArchitectures:
            setReturnValue(osRepository.getOsArchitectures());
            break;
        case GetMaxOsRam:
            setReturnValue(osRepository.getMaximumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetMinimumOsRam:
            setReturnValue(osRepository.getMinimumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetDisplayTypes:
            setReturnValue(osRepository.getDisplayTypes());
            break;
        case GetBalloonDisabledByDefaultMatrix:
            setReturnValue(osRepository.getBalloonDisabledByDefaultMatrix());
            break;
        case IsBalloonDisabledByDefault:
            setReturnValue(osRepository.isBalloonDisabledByDefault(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case HasNicHotplugSupport:
            setReturnValue(osRepository.hasNicHotplugSupport(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetDiskInterfaces:
            setReturnValue(osRepository.getDiskInterfaces(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetNetworkDevices:
            setReturnValue(osRepository.getNetworkDevices(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetDiskHotpluggableInterfaces:
            setReturnValue(osRepository.getDiskHotpluggableInterfaces(getParameters().getOsId(), getParameters().getVersion()));
            break;
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    switch(getParameters().getOsRepositoryVerb()) {
        case GetOsNames:
            setReturnValue(osRepository.getOsNames());
            break;
        case GetUniqueOsNames:
            setReturnValue(osRepository.getUniqueOsNames());
            break;
        case GetOsIds:
            setReturnValue(osRepository.getOsIds());
            break;
        case GetLinuxOss:
            setReturnValue(osRepository.getLinuxOss());
            break;
        case GetWindowsOss:
            setReturnValue(osRepository.getWindowsOss());
            break;
        case GetNicHotplugSupportMap:
            setReturnValue(osRepository.getNicHotplugSupportMap());
            break;
        case GetDiskHotpluggableInterfacesMap:
            setReturnValue(osRepository.getDiskHotpluggableInterfacesMap());
            break;
        case GetOsArchitectures:
            setReturnValue(osRepository.getOsArchitectures());
            break;
        case GetMaxOsRam:
            setReturnValue(osRepository.getMaximumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetMinimumOsRam:
            setReturnValue(osRepository.getMinimumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetDisplayTypes:
            setReturnValue(osRepository.getDisplayTypes());
            break;
        case GetBalloonSupportMap:
            setReturnValue(osRepository.getBalloonSupportMap());
            break;
        case IsBalloonEnabled:
            setReturnValue(osRepository.isBalloonEnabled(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case HasNicHotplugSupport:
            setReturnValue(osRepository.hasNicHotplugSupport(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetDiskInterfaces:
            setReturnValue(osRepository.getDiskInterfaces(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetNetworkDevices:
            setReturnValue(osRepository.getNetworkDevices(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetDiskHotpluggableInterfaces:
            setReturnValue(osRepository.getDiskHotpluggableInterfaces(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetVmWatchdogTypes:
            setReturnValue(osRepository.getVmWatchdogTypes(getParameters().getOsId(), getParameters().getVersion()));
            break;
    }
}
#end_block

#method_before
protected Response addVm(VmStatic staticVm, VM vm, Guid storageDomainId, Guid templateId, VDSGroup vdsGroup) {
    VmManagementParametersBase params = new VmManagementParametersBase(staticVm);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    } else {
        params.setBalloonEnabled(!isBalloonDisabledByDefault(staticVm.getOsId(), vdsGroup.getcompatibility_version()));
    }
    params.setStorageDomainId(storageDomainId);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), templateId));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    setupCloneTemplatePermissions(vm, params);
    params.setConsoleEnabled(vm.isSetConsole() && vm.getConsole().isSetEnabled() ? vm.getConsole().isEnabled() : !getConsoleDevicesForEntity(templateId).isEmpty());
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    return performCreate(VdcActionType.AddVm, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
protected Response addVm(VmStatic staticVm, VM vm, Guid storageDomainId, Guid templateId, VDSGroup vdsGroup) {
    VmManagementParametersBase params = new VmManagementParametersBase(staticVm);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    } else {
        params.setBalloonEnabled(isBalloonEnabled(staticVm.getOsId(), vdsGroup.getcompatibility_version()));
    }
    params.setStorageDomainId(storageDomainId);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), templateId));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    setupCloneTemplatePermissions(vm, params);
    params.setConsoleEnabled(vm.isSetConsole() && vm.getConsole().isSetEnabled() ? vm.getConsole().isEnabled() : !getConsoleDevicesForEntity(templateId).isEmpty());
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    return performCreate(VdcActionType.AddVm, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
protected Response addVmFromScratch(VmStatic staticVm, VM vm, Guid storageDomainId, VDSGroup vdsGroup) {
    AddVmFromScratchParameters params = new AddVmFromScratchParameters(staticVm, mapDisks(vm.getDisks()), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    } else {
        params.setBalloonEnabled(!isBalloonDisabledByDefault(staticVm.getOsId(), vdsGroup.getcompatibility_version()));
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    params.setStorageDomainId(storageDomainId);
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    if (vm.isSetConsole() && vm.getConsole().isSetEnabled()) {
        params.setConsoleEnabled(vm.getConsole().isEnabled());
    }
    return performCreate(VdcActionType.AddVmFromScratch, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
protected Response addVmFromScratch(VmStatic staticVm, VM vm, Guid storageDomainId, VDSGroup vdsGroup) {
    AddVmFromScratchParameters params = new AddVmFromScratchParameters(staticVm, mapDisks(vm.getDisks()), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    } else {
        params.setBalloonEnabled(isBalloonEnabled(staticVm.getOsId(), vdsGroup.getcompatibility_version()));
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    params.setStorageDomainId(storageDomainId);
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    if (vm.isSetConsole() && vm.getConsole().isSetEnabled()) {
        params.setConsoleEnabled(vm.getConsole().isEnabled());
    }
    return performCreate(VdcActionType.AddVmFromScratch, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
@ProxyEvent
public void onUiCommonInit(UiCommonInitEvent event) {
    // Notify view when the entity of the detail model changes
    modelProvider.getModel().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Object entity = modelProvider.getModel().getEntity();
            if (entity != null) {
                onDetailModelEntityChange(entity);
            }
        }
    });
    // Notify view when the detail model indicates progress
    modelProvider.getModel().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs pcArgs = (PropertyChangedEventArgs) args;
            if (PropertyChangedEventArgs.Args.PROGRESS.toString().equals(pcArgs.propertyName)) {
                if (modelProvider.getModel().getProgress() != null) {
                    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                        @Override
                        public void execute() {
                            if (getTable() != null) {
                                getTable().setLoadingState(LoadingState.LOADING);
                            }
                        }
                    });
                }
            }
        }
    });
}
#method_after
@ProxyEvent
public void onUiCommonInit(UiCommonInitEvent event) {
    // Notify view when the entity of the detail model changes
    modelProvider.getModel().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Object entity = modelProvider.getModel().getEntity();
            if (entity != null) {
                onDetailModelEntityChange(entity);
            }
        }
    });
    // Notify view when the detail model indicates progress
    modelProvider.getModel().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs pcArgs = (PropertyChangedEventArgs) args;
            if (PropertyChangedEventArgs.PROGRESS.equals(pcArgs.propertyName)) {
                if (modelProvider.getModel().getProgress() != null) {
                    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                        @Override
                        public void execute() {
                            if (getTable() != null) {
                                getTable().setLoadingState(LoadingState.LOADING);
                            }
                        }
                    });
                }
            }
        }
    });
}
#end_block

#method_before
@Override
protected void onCommonModelChange() {
    super.onCommonModelChange();
    // Add model items change handler
    getModel().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (hasModel() && handleItemsChangedEvent()) {
                updateData();
            }
        }
    });
    getModel().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (args instanceof PropertyChangedEventArgs) {
                PropertyChangedEventArgs pcArgs = (PropertyChangedEventArgs) args;
                if (PropertyChangedEventArgs.Args.PROGRESS.toString().equals(pcArgs.propertyName)) {
                    clearData();
                }
            }
        }
    });
}
#method_after
@Override
protected void onCommonModelChange() {
    super.onCommonModelChange();
    // Add model items change handler
    getModel().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (hasModel() && handleItemsChangedEvent()) {
                updateData();
            }
        }
    });
    getModel().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (args instanceof PropertyChangedEventArgs) {
                PropertyChangedEventArgs pcArgs = (PropertyChangedEventArgs) args;
                if (PropertyChangedEventArgs.PROGRESS.equals(pcArgs.propertyName)) {
                    clearData();
                }
            }
        }
    });
}
#end_block

#method_before
public String getComment() {
    return mVdsStatic.getComment();
}
#method_after
@Override
public String getComment() {
    return mVdsStatic.getComment();
}
#end_block

#method_before
public void setComment(String value) {
    mVdsStatic.setComment(value);
}
#method_after
@Override
public void setComment(String value) {
    mVdsStatic.setComment(value);
}
#end_block

#method_before
public int getProtocol() {
    return this.mVdsStatic.getProtocol();
}
#method_after
public VdsProtocol getProtocol() {
    return this.mVdsStatic.getProtocol();
}
#end_block

#method_before
public void setProtocol(int value) {
    this.mVdsStatic.setProtocol(value);
}
#method_after
public void setProtocol(VdsProtocol value) {
    this.mVdsStatic.setProtocol(value);
}
#end_block

#method_before
public String toString() {
    // is not enough, remove this once mVdsStatic can not be null
    return "Host[" + (mVdsStatic == null ? "null" : mVdsStatic.getName()) + "]";
}
#method_after
@Override
public String toString() {
    // is not enough, remove this once mVdsStatic can not be null
    return "Host[" + (mVdsStatic == null ? "null" : (mVdsStatic.getName() + "," + mVdsStatic.getId())) + "]";
}
#end_block

#method_before
@Override
public VdsStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsStatic entity = new VdsStatic();
    entity.setHostName(rs.getString("host_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueID(rs.getString("vds_unique_id"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(rs.getInt("protocol"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setVdsGroupId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_group_id")));
    entity.setId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_id")));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setPmEnabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    return entity;
}
#method_after
@Override
public VdsStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsStatic entity = new VdsStatic();
    entity.setHostName(rs.getString("host_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueID(rs.getString("vds_unique_id"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setVdsGroupId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_group_id")));
    entity.setId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_id")));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setPmEnabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    return entity;
}
#end_block

#method_before
public int getProtocol() {
    return this.protocol;
}
#method_after
public VdsProtocol getProtocol() {
    return this.protocol;
}
#end_block

#method_before
public void setProtocol(int value) {
    this.protocol = value;
}
#method_after
public void setProtocol(VdsProtocol value) {
    this.protocol = value;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((hostName == null) ? 0 : hostName.hashCode());
    result = prime * result + ((consoleAddress == null) ? 0 : consoleAddress.hashCode());
    result = prime * result + ((managementIp == null) ? 0 : managementIp.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + (int) (otpValidity ^ (otpValidity >>> 32));
    result = prime * result + (pmEnabled ? 1231 : 1237);
    result = prime * result + ((pmOptions == null) ? 0 : pmOptions.hashCode());
    result = prime * result + ((pmOptionsMap == null) ? 0 : pmOptionsMap.hashCode());
    result = prime * result + ((pmPassword == null) ? 0 : pmPassword.hashCode());
    result = prime * result + ((pmPort == null) ? 0 : pmPort.hashCode());
    result = prime * result + ((pmType == null) ? 0 : pmType.hashCode());
    result = prime * result + ((pmUser == null) ? 0 : pmUser.hashCode());
    result = prime * result + ((pmSecondaryIp == null) ? 0 : managementIp.hashCode());
    result = prime * result + (pmSecondaryConcurrent ? 1231 : 1237);
    result = prime * result + ((pmSecondaryOptions == null) ? 0 : pmOptions.hashCode());
    result = prime * result + ((pmSecondaryOptionsMap == null) ? 0 : pmSecondaryOptionsMap.hashCode());
    result = prime * result + ((pmSecondaryPassword == null) ? 0 : pmSecondaryPassword.hashCode());
    result = prime * result + ((pmSecondaryPort == null) ? 0 : pmSecondaryPort.hashCode());
    result = prime * result + ((pmSecondaryType == null) ? 0 : pmSecondaryType.hashCode());
    result = prime * result + ((pmSecondaryUser == null) ? 0 : pmSecondaryUser.hashCode());
    result = prime * result + (pmKdumpDetection ? 1 : 0);
    result = prime * result + port;
    result = prime * result + protocol;
    result = prime * result + sshPort;
    result = prime * result + ((sshUsername == null) ? 0 : sshUsername.hashCode());
    result = prime * result + ((serverSslEnabled == null) ? 0 : serverSslEnabled.hashCode());
    result = prime * result + ((uniqueId == null) ? 0 : uniqueId.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vdsStrength == null) ? 0 : vdsStrength.hashCode());
    result = prime * result + ((vdsType == null) ? 0 : vdsType.hashCode());
    result = prime * result + (disablePowerManagementPolicy ? 0 : 1);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((hostName == null) ? 0 : hostName.hashCode());
    result = prime * result + ((consoleAddress == null) ? 0 : consoleAddress.hashCode());
    result = prime * result + ((managementIp == null) ? 0 : managementIp.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + (int) (otpValidity ^ (otpValidity >>> 32));
    result = prime * result + (pmEnabled ? 1231 : 1237);
    result = prime * result + ((pmOptions == null) ? 0 : pmOptions.hashCode());
    result = prime * result + ((pmOptionsMap == null) ? 0 : pmOptionsMap.hashCode());
    result = prime * result + ((pmPassword == null) ? 0 : pmPassword.hashCode());
    result = prime * result + ((pmPort == null) ? 0 : pmPort.hashCode());
    result = prime * result + ((pmType == null) ? 0 : pmType.hashCode());
    result = prime * result + ((pmUser == null) ? 0 : pmUser.hashCode());
    result = prime * result + ((pmSecondaryIp == null) ? 0 : managementIp.hashCode());
    result = prime * result + (pmSecondaryConcurrent ? 1231 : 1237);
    result = prime * result + ((pmSecondaryOptions == null) ? 0 : pmOptions.hashCode());
    result = prime * result + ((pmSecondaryOptionsMap == null) ? 0 : pmSecondaryOptionsMap.hashCode());
    result = prime * result + ((pmSecondaryPassword == null) ? 0 : pmSecondaryPassword.hashCode());
    result = prime * result + ((pmSecondaryPort == null) ? 0 : pmSecondaryPort.hashCode());
    result = prime * result + ((pmSecondaryType == null) ? 0 : pmSecondaryType.hashCode());
    result = prime * result + ((pmSecondaryUser == null) ? 0 : pmSecondaryUser.hashCode());
    result = prime * result + (pmKdumpDetection ? 1 : 0);
    result = prime * result + port;
    result = prime * result + ((protocol == null) ? 0 : protocol.hashCode());
    result = prime * result + sshPort;
    result = prime * result + ((sshUsername == null) ? 0 : sshUsername.hashCode());
    result = prime * result + ((serverSslEnabled == null) ? 0 : serverSslEnabled.hashCode());
    result = prime * result + ((uniqueId == null) ? 0 : uniqueId.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vdsStrength == null) ? 0 : vdsStrength.hashCode());
    result = prime * result + ((vdsType == null) ? 0 : vdsType.hashCode());
    result = prime * result + (disablePowerManagementPolicy ? 0 : 1);
    return result;
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(rs.getInt("protocol"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    return entity;
}
#end_block

#method_before
@Override
protected void verify(Host model, Host transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getId(), transform.getId());
    assertNotNull(transform.getCluster());
    assertEquals(model.getCluster().getId(), transform.getCluster().getId());
    assertEquals(model.getAddress(), transform.getAddress());
    assertEquals(model.getPort(), transform.getPort());
    assertEquals(model.getProtocol(), transform.getProtocol());
    assertEquals(model.getStorageManager().getPriority(), transform.getStorageManager().getPriority());
    assertEquals(model.getDisplay().getAddress(), transform.getDisplay().getAddress());
}
#method_after
@Override
protected void verify(Host model, Host transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getId(), transform.getId());
    assertNotNull(transform.getCluster());
    assertEquals(model.getCluster().getId(), transform.getCluster().getId());
    assertEquals(model.getAddress(), transform.getAddress());
    assertEquals(model.getPort(), transform.getPort());
    assertEquals(model.getStorageManager().getPriority(), transform.getStorageManager().getPriority());
    assertEquals(model.getDisplay().getAddress(), transform.getDisplay().getAddress());
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            return new FutureMap(client, request);
        }
    });
    return ThreadPoolUtil.execute(future);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            return new FutureMap(client, request).withResponseKey("status");
        }
    });
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc connectStoragePool(String spUUID, int hostSpmId, String SCSIKey, String masterdomainId, int masterVersion) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.connect").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).withParameter("masterSdUUID", masterdomainId).withParameter("masterVersion", masterVersion).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc connectStoragePool(String spUUID, int hostSpmId, String SCSIKey, String masterdomainId, int masterVersion, Map<String, String> storageDomains) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.connect").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).withParameter("masterSdUUID", masterdomainId).withParameter("masterVersion", masterVersion).withOptionalParameterAsMap("domainDict", storageDomains).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public IQNListReturnForXmlRpc discoverSendTargets(Map<String, String> args) {
    JsonRpcRequest request = new RequestBuilder("ISCSIConnection.discoverSendTargets").withParameter("host", args.get("connection")).withParameter("port", args.get("port")).withOptionalParameter("user", args.get("user")).withOptionalParameter("password", args.get("password")).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    // TODO check response keys
    return new IQNListReturnForXmlRpc(response);
}
#method_after
@Override
public IQNListReturnForXmlRpc discoverSendTargets(Map<String, String> args) {
    JsonRpcRequest request = new RequestBuilder("ISCSIConnection.discoverSendTargets").withParameter("host", args.get("connection")).withParameter("port", args.get("port")).withOptionalParameter("user", args.get("user")).withOptionalParameter("password", args.get("password")).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("fullTargets");
    return new IQNListReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public FutureTask<Map<String, Object>> poll() {
    final JsonRpcRequest request = new RequestBuilder("Host.getCapabilities").build();
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            return new FutureMap(client, request);
        }
    });
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@Override
public FutureTask<Map<String, Object>> poll() {
    final JsonRpcRequest request = new RequestBuilder("Host.ping").build();
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            return new FutureMap(client, request);
        }
    });
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
@Override
public GlusterVolumeProfileInfoReturnForXmlRpc glusterVolumeProfileInfo(Guid clusterId, String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileInfo").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeProfileInfoReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumeProfileInfoReturnForXmlRpc glusterVolumeProfileInfo(Guid clusterId, String volumeName, boolean nfs) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileInfo").withParameter("volumeName", volumeName).withParameter("nfs", nfs).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeProfileInfoReturnForXmlRpc(clusterId, response);
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(model.getProtocol().getEntity() ? 1 : 0);
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp(model.getManagementIp().getEntity());
    host.setPmUser(model.getPmUserName().getEntity());
    host.setPmPassword(model.getPmPassword().getEntity());
    host.setPmType(model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp(model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser(model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword(model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType(model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled(model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent(model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = model.getCluster().getSelectedItem().supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(VdsProtocol.fromValue(model.getProtocol().getEntity() ? VdsProtocol.STOMP.toString() : VdsProtocol.XML.toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp(model.getManagementIp().getEntity());
    host.setPmUser(model.getPmUserName().getEntity());
    host.setPmPassword(model.getPmPassword().getEntity());
    host.setPmType(model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp(model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser(model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword(model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType(model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled(model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent(model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = model.getCluster().getSelectedItem().supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public void onInstall() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#method_after
public void onInstall() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    final boolean isOVirt = host.getVdsType() == VDSType.oVirtNode;
    if (!model.validate(isOVirt)) {
        model.setValidationFailed(new EntityModel<Boolean>(true));
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    setHostBricksListModel(new HostBricksListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(getHostBricksListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    setHostBricksListModel(new HostBricksListModel());
    setHostVmListModel(new HostVmListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(getHostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(getHostBricksListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
    getHostBricksListModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService());
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
    getHostBricksListModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService());
    getHostVmListModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsVirtService());
}
#end_block

#method_before
private IIrsServer getmIrsProxy() {
    return privatemIrsProxy;
}
#method_after
private IIrsServer getmIrsProxy() {
    return irsProxy;
}
#end_block

#method_before
private int getProtocol() {
    return this.privateProtocol;
}
#method_after
private VdsProtocol getProtocol() {
    return this.privateProtocol;
}
#end_block

#method_before
private void setProtocol(int value) {
    this.privateProtocol = value;
}
#method_after
private void setProtocol(VdsProtocol value) {
    this.privateProtocol = value;
}
#end_block

#method_before
private void proceedStorageDomain(StorageDomain data, int dataMasterVersion, StoragePool storagePool) {
    StorageDomain storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    StorageDomainStatic domainFromDb = null;
    StoragePoolIsoMap domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getStorageDomainType() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getStatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getStorageDomainType() == StorageDomainType.Master) || (data.getStorageDomainType() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getStorageName()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getmaster_domain_version()) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getStorageName(), storagePool.getmaster_domain_version(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setStoragePoolId(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getStatus() != StorageDomainStatus.Locked && domainPoolMap.getStatus() != data.getStatus()) {
            if (domainPoolMap.getStatus() != StorageDomainStatus.InActive && data.getStatus() != StorageDomainStatus.InActive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getStatus() != null && data.getStatus() == StorageDomainStatus.InActive && domainFromDb.getStorageDomainType() == StorageDomainType.Master) {
                StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintenance);
                    pool.setStatus(StoragePoolStatus.Maintenance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintenance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getStatus() != StorageDomainStatus.InActive && data.getStatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getAvailableDiskSize() != null && data.getUsedDiskSize() != null) {
                double freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                int freeDiskInGB = data.getStorageDynamicData().getfreeDiskInGB();
                AuditLogType type = AuditLogType.UNASSIGNED;
                boolean spaceThresholdMet = freeDiskInGB <= Config.<Integer>getValue(ConfigValues.FreeSpaceCriticalLowInGB);
                boolean percentThresholdMet = freePercent <= Config.<Integer>getValue(ConfigValues.FreeSpaceLow);
                if (spaceThresholdMet && percentThresholdMet) {
                    type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                } else {
                    if (spaceThresholdMet || percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.addCustomValue("DiskSpace", (data.getAvailableDiskSize()).toString());
                    data.setStorageName(domainFromDb.getStorageName());
                    AuditLogDirector.log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setStorageName(domainFromDb.getStorageName());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.errorFormat("Unrecognized alert for domain {0}(id = {1}): {2}", data.getStorageName(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debugFormat("The domain with id {0} was not found in DB", data.getId());
    }
}
#method_after
private void proceedStorageDomain(StorageDomain data, int dataMasterVersion, StoragePool storagePool) {
    StorageDomain storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    StorageDomainStatic domainFromDb = null;
    StoragePoolIsoMap domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getStorageDomainType() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getStatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getStorageDomainType() == StorageDomainType.Master) || (data.getStorageDomainType() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getStorageName()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getmaster_domain_version()) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getStorageName(), storagePool.getmaster_domain_version(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setStoragePoolId(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getStatus() != StorageDomainStatus.Locked && domainPoolMap.getStatus() != data.getStatus()) {
            if (domainPoolMap.getStatus() != StorageDomainStatus.Inactive && data.getStatus() != StorageDomainStatus.Inactive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getStatus() != null && data.getStatus() == StorageDomainStatus.Inactive && domainFromDb.getStorageDomainType() == StorageDomainType.Master) {
                StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintenance);
                    pool.setStatus(StoragePoolStatus.Maintenance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintenance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getStatus() != StorageDomainStatus.Inactive && data.getStatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getAvailableDiskSize() != null && data.getUsedDiskSize() != null) {
                double freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                int freeDiskInGB = data.getStorageDynamicData().getfreeDiskInGB();
                AuditLogType type = AuditLogType.UNASSIGNED;
                boolean spaceThresholdMet = freeDiskInGB <= Config.<Integer>getValue(ConfigValues.FreeSpaceCriticalLowInGB);
                boolean percentThresholdMet = freePercent <= Config.<Integer>getValue(ConfigValues.FreeSpaceLow);
                if (spaceThresholdMet && percentThresholdMet) {
                    type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                } else {
                    if (spaceThresholdMet || percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.addCustomValue("DiskSpace", (data.getAvailableDiskSize()).toString());
                    data.setStorageName(domainFromDb.getStorageName());
                    AuditLogDirector.log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setStorageName(domainFromDb.getStorageName());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.errorFormat("Unrecognized alert for domain {0}(id = {1}): {2}", data.getStorageName(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debugFormat("The domain with id {0} was not found in DB", data.getId());
    }
}
#end_block

#method_before
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
                if (getProtocol() == 1) {
                    privatemIrsProxy = new JsonRpcIIrsServer(JsonRpcUtils.createStompClient(host, getmIrsPort(), connectionTimeOut, clientTimeOut, clientRetries, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication)));
                } else if (getProtocol() == 0) {
                    Pair<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries, IrsServerConnector.class, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
                    privatemIrsProxy = new IrsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
                }
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#method_after
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
                irsProxy = TransportFactory.createIrsServer(getProtocol(), host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries);
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#end_block

#method_before
private String gethostFromVds() {
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    mCurrentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        mTriedVdssList.add(selectedVdsId);
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getVdsSpmId(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#method_after
private String gethostFromVds() {
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    mCurrentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        mTriedVdssList.add(selectedVdsId);
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterDomainId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                List<StoragePoolIsoMap> storagePoolIsoMap = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds, storagePool, masterDomainId, storagePoolIsoMap));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private void nullifyInternalProxies() {
    if (privatemIrsProxy != null) {
        if (IrsServerWrapper.class.isInstance(privatemIrsProxy)) {
            XmlRpcUtils.shutDownConnection(((IrsServerWrapper) privatemIrsProxy).getHttpClient());
        } else {
            ((JsonRpcIIrsServer) privatemIrsProxy).close();
        }
    }
    privatemCurrentIrsHost = null;
    privatemIrsProxy = null;
    mCurrentVdsId = null;
}
#method_after
private void nullifyInternalProxies() {
    if (irsProxy != null) {
        if (IrsServerWrapper.class.isInstance(irsProxy)) {
            XmlRpcUtils.shutDownConnection(((IrsServerWrapper) irsProxy).getHttpClient());
        } else {
            ((JsonRpcIIrsServer) irsProxy).close();
        }
    }
    privatemCurrentIrsHost = null;
    irsProxy = null;
    mCurrentVdsId = null;
}
#end_block

#method_before
public void updateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInProblems = null;
    Set<Guid> domainsInMaintenance = null;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive)) {
        try {
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.InActive));
            // build a list of all the domains in
            // pool (domainsInPool) that are not
            // visible by the host.
            List<Guid> domainsInPoolThatNonVisibleByVds = new ArrayList<Guid>();
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : domainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInPoolThatNonVisibleByVds.add(tempDomainId);
                }
            }
            // build a list of domains that the host
            // reports as in problem (code!=0) or (code==0
            // && lastChecl >
            // ConfigValues.MaxStorageVdsTimeoutCheckSec)
            // and are contained in the Active or
            // Unknown domains in pool
            List<Guid> domainsSeenByVdsInProblem = new ArrayList<Guid>();
            for (VDSDomainsData tempData : data) {
                if (domainsInPool.contains(tempData.getDomainId())) {
                    if (isDomainReportedAsProblematic(tempData, false)) {
                        domainsSeenByVdsInProblem.add(tempData.getDomainId());
                    } else if (tempData.getDelay() > Config.<Double>getValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && !isDomainReportedAsProblematic(tempData, false)) {
                    log.warnFormat("Storage Domain {0} was reported by Host {1} as Active in Pool {2}, moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setStatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                }
            }
            Set<Guid> maintInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Maintenance));
            maintInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.PreparingForMaintenance));
            domainsInMaintenance = new HashSet<Guid>();
            for (Guid tempDomainId : maintInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInMaintenance.add(tempDomainId);
                }
            }
            // build a list of all potential domains
            // in problem
            domainsInProblems = new HashSet<Guid>();
            domainsInProblems.addAll(domainsInPoolThatNonVisibleByVds);
            domainsInProblems.addAll(domainsSeenByVdsInProblem);
        } catch (RuntimeException ex) {
            log.error("error in updateVdsDomainsData", ex);
        }
    }
    updateDomainInProblem(vdsId, vdsName, domainsInProblems, domainsInMaintenance);
}
#method_after
public void updateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInProblems = null;
    Set<Guid> domainsInMaintenance = null;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive)) {
        try {
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Inactive));
            // build a list of all the domains in
            // pool (domainsInPool) that are not
            // visible by the host.
            List<Guid> domainsInPoolThatNonVisibleByVds = new ArrayList<Guid>();
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : domainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInPoolThatNonVisibleByVds.add(tempDomainId);
                }
            }
            // build a list of domains that the host
            // reports as in problem (code!=0) or (code==0
            // && lastChecl >
            // ConfigValues.MaxStorageVdsTimeoutCheckSec)
            // and are contained in the Active or
            // Unknown domains in pool
            List<Guid> domainsSeenByVdsInProblem = new ArrayList<Guid>();
            for (VDSDomainsData tempData : data) {
                if (domainsInPool.contains(tempData.getDomainId())) {
                    if (isDomainReportedAsProblematic(tempData, false)) {
                        domainsSeenByVdsInProblem.add(tempData.getDomainId());
                    } else if (tempData.getDelay() > Config.<Double>getValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && !isDomainReportedAsProblematic(tempData, false)) {
                    log.warnFormat("Storage Domain {0} was reported by Host {1} as Active in Pool {2}, moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setStatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                }
            }
            Set<Guid> maintInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Maintenance));
            maintInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.PreparingForMaintenance));
            domainsInMaintenance = new HashSet<Guid>();
            for (Guid tempDomainId : maintInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInMaintenance.add(tempDomainId);
                }
            }
            // build a list of all potential domains
            // in problem
            domainsInProblems = new HashSet<Guid>();
            domainsInProblems.addAll(domainsInPoolThatNonVisibleByVds);
            domainsInProblems.addAll(domainsSeenByVdsInProblem);
        } catch (RuntimeException ex) {
            log.error("error in updateVdsDomainsData", ex);
        }
    }
    updateDomainInProblem(vdsId, vdsName, domainsInProblems, domainsInMaintenance);
}
#end_block

#method_before
@Override
public Response approve(Action action) {
    if (action.isSetCluster() && (action.getCluster().isSetId() || action.getCluster().isSetName())) {
        update(setCluster(get(), action.getCluster()));
    }
    validateEnums(Action.class, action);
    ApproveVdsParameters params = new ApproveVdsParameters(guid);
    params = (ApproveVdsParameters) getMapper(Action.class, VdsOperationActionParameters.class).map(action, (VdsOperationActionParameters) params);
    return doAction(VdcActionType.ApproveVds, params, action);
}
#method_after
@Override
public Response approve(Action action) {
    if (action.isSetCluster() && (action.getCluster().isSetId() || action.getCluster().isSetName())) {
        update(setCluster(get(), action.getCluster()));
    }
    validateEnums(Action.class, action);
    ApproveVdsParameters params = new ApproveVdsParameters(guid);
    params = (ApproveVdsParameters) getMapper(Action.class, VdsOperationActionParameters.class).map(action, (VdsOperationActionParameters) params);
    // Set pk authentication as default
    params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.PublicKey);
    if (action.isSetRootPassword()) {
        params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.Password);
        params.setRootPassword(action.getRootPassword());
    } else if (action.isSetSsh() && action.getSsh().isSetAuthenticationMethod()) {
        if (action.getSsh().getAuthenticationMethod().equals(AuthenticationMethod.PASSWORD.value())) {
            params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.Password);
            if (action.getSsh().isSetUser() && action.getSsh().getUser().isSetPassword()) {
                params.setPassword(action.getSsh().getUser().getPassword());
            }
        }
    }
    return doAction(VdcActionType.ApproveVds, params, action);
}
#end_block

#method_before
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setVdsName(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.setHostName(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setPort(model.getPort());
    } else {
        entity.setPort(DEFAULT_VDSM_PORT);
    }
    if (model.isSetProtocol()) {
        entity.setProtocol(model.getProtocol());
    }
    if (model.isSetSsh()) {
        map(model.getSsh(), entity);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetStorageManager()) {
        if (model.getStorageManager().getPriority() != null) {
            entity.setVdsSpmPriority(model.getStorageManager().getPriority());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplay().getAddress()) ? null : model.getDisplay().getAddress());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    return entity;
}
#method_after
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setVdsName(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.setHostName(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setPort(model.getPort());
    } else {
        entity.setPort(DEFAULT_VDSM_PORT);
    }
    if (model.isSetProtocol()) {
        entity.setProtocol(VdsProtocol.fromValue(model.getProtocol()));
    }
    if (model.isSetSsh()) {
        map(model.getSsh(), entity);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetStorageManager()) {
        if (model.getStorageManager().getPriority() != null) {
            entity.setVdsSpmPriority(model.getStorageManager().getPriority());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplay().getAddress()) ? null : model.getDisplay().getAddress());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    entity.setManagementIp(getManagementIp(model, entity));
    entity.setPmType(getManagementType(model, entity));
    entity.setPmUser(getManagementUser(model, entity));
    entity.setPmPassword(getManagementPassword(model, entity));
    entity.setPmOptions(getManagementOptions(model, entity));
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetAutomaticPmEnabled()) {
        entity.setDisablePowerManagementPolicy(!model.isAutomaticPmEnabled());
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    if (model.isSetAgents()) {
        // Currently only Primary/Secondary agents are supported
        int order = 1;
        for (Agent agent : model.getAgents().getAgents()) {
            if (agent.isSetOrder()) {
                order = agent.getOrder();
            }
            if (order == 1) {
                // Primary
                // in case that order is not defined, secondary will still be defined correctly.
                order++;
            } else if (order == 2) {
                // Secondary
                if (agent.isSetType()) {
                    entity.setPmSecondaryType(agent.getType());
                }
                if (agent.isSetAddress()) {
                    entity.setPmSecondaryIp(agent.getAddress());
                }
                if (agent.isSetUsername()) {
                    entity.setPmSecondaryUser(agent.getUsername());
                }
                if (agent.isSetPassword()) {
                    entity.setPmSecondaryPassword(agent.getPassword());
                }
                if (agent.isSetOptions()) {
                    entity.setPmSecondaryOptions(map(agent.getOptions(), null));
                }
                if (agent.isSetConcurrent()) {
                    entity.setPmSecondaryConcurrent(agent.isConcurrent());
                }
            }
        }
    }
    if (model.isSetKdumpDetection()) {
        entity.setPmKdumpDetection(model.isKdumpDetection());
    }
    return entity;
}
#method_after
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    boolean hasAgents = StringUtils.isNotEmpty(model.getAddress()) || (model.isSetAgents() && model.getAgents().getAgents().size() > 0);
    boolean removeSecondaryAgent = StringUtils.isNotEmpty(entity.getPmSecondaryIp()) && model.isSetAgents() && model.getAgents().getAgents().size() < 2;
    if (hasAgents) {
        entity.setManagementIp(getManagementIp(model, entity));
        entity.setPmType(getManagementType(model, entity));
        entity.setPmUser(getManagementUser(model, entity));
        entity.setPmPassword(getManagementPassword(model, entity));
        entity.setPmOptions(getManagementOptions(model, entity));
    } else {
        clearPmAgentsSettings(entity);
    }
    if (removeSecondaryAgent) {
        clearSecondaryPmAgentSettings(entity);
    }
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetAutomaticPmEnabled()) {
        entity.setDisablePowerManagementPolicy(!model.isAutomaticPmEnabled());
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    if (model.isSetAgents()) {
        // Currently only Primary/Secondary agents are supported
        int order = 1;
        for (Agent agent : model.getAgents().getAgents()) {
            if (agent.isSetOrder()) {
                order = agent.getOrder();
            }
            if (order == 1) {
                // Primary
                // in case that order is not defined, secondary will still be defined correctly.
                order++;
            } else if (order == 2) {
                // Secondary
                if (agent.isSetType()) {
                    entity.setPmSecondaryType(agent.getType());
                }
                if (agent.isSetAddress()) {
                    entity.setPmSecondaryIp(agent.getAddress());
                }
                if (agent.isSetUsername()) {
                    entity.setPmSecondaryUser(agent.getUsername());
                }
                if (agent.isSetPassword()) {
                    entity.setPmSecondaryPassword(agent.getPassword());
                }
                if (agent.isSetOptions()) {
                    entity.setPmSecondaryOptions(map(agent.getOptions(), null));
                }
                if (agent.isSetConcurrent()) {
                    entity.setPmSecondaryConcurrent(agent.isConcurrent());
                }
            }
        }
    }
    if (model.isSetKdumpDetection()) {
        entity.setPmKdumpDetection(model.isKdumpDetection());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    model.setProtocol(entity.getProtocol());
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getSpmStatus() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (SSH) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    model.setProtocol(map(entity.getProtocol(), (String) null));
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getSpmStatus() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (SSH) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSelinux(map(entity, (SELinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    return model;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = HardwareInformation.class)
public static HardwareInformation map(VDS entity, HardwareInformation template) {
    HardwareInformation model = template != null ? template : new HardwareInformation();
    model.setManufacturer(entity.getHardwareManufacturer());
    model.setFamily(entity.getHardwareFamily());
    model.setProductName(entity.getHardwareProductName());
    model.setSerialNumber(entity.getHardwareSerialNumber());
    model.setUuid(entity.getHardwareUUID());
    model.setVersion(entity.getHardwareVersion());
    return model;
}
#method_after
@Mapping(from = VDS.class, to = HardwareInformation.class)
public static HardwareInformation map(VDS entity, HardwareInformation template) {
    HardwareInformation model = template != null ? template : new HardwareInformation();
    model.setManufacturer(entity.getHardwareManufacturer());
    model.setFamily(entity.getHardwareFamily());
    model.setProductName(entity.getHardwareProductName());
    model.setSerialNumber(entity.getHardwareSerialNumber());
    model.setUuid(entity.getHardwareUUID());
    model.setVersion(entity.getHardwareVersion());
    model.setSupportedRngSources(RngDeviceMapper.mapRngSources(entity.getSupportedRngSources(), null));
    return model;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.KdumpStatus.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.KdumpStatus kdumpStatus, String template) {
    String result = null;
    if (kdumpStatus != null) {
        switch(kdumpStatus) {
            case UNKNOWN:
                result = KdumpStatus.UNKNOWN.value();
                break;
            case DISABLED:
                result = KdumpStatus.DISABLED.value();
                break;
            case ENABLED:
                result = KdumpStatus.ENABLED.value();
                break;
            default:
                break;
        }
    }
    return result;
}
#method_after
@Mapping(from = VDS.class, to = SELinux.class)
public static SELinux map(VDS entity, SELinux template) {
    SELinux model = template != null ? template : new SELinux();
    if (entity.getSELinuxEnforceMode() == null) {
        return model;
    }
    String mode = null;
    switch(entity.getSELinuxEnforceMode()) {
        case DISABLED:
            mode = SELinuxMode.DISABLED.value();
            break;
        case PERMISSIVE:
            mode = SELinuxMode.PERMISSIVE.value();
            break;
        case ENFORCING:
            mode = SELinuxMode.ENFORCING.value();
    }
    model.setMode(mode);
    return model;
}
#end_block

#method_before
private void InitVdsBroker() {
    log.infoFormat("Initialize vdsBroker ({0},{1})", _vds.getHostName(), _vds.getPort());
    // Get the values of the timeouts:
    int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
    int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
    int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
    if (_vds.getProtocol() == 1) {
        _vdsProxy = new JsonRpcVdsServer(JsonRpcUtils.createStompClient(_vds.getHostName(), _vds.getPort(), connectionTimeOut, clientTimeOut, clientRetries, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication)));
    } else if (_vds.getProtocol() == 0) {
        Pair<VdsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(_vds.getHostName(), _vds.getPort(), clientTimeOut, connectionTimeOut, clientRetries, VdsServerConnector.class, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
        _vdsProxy = new VdsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
    }
}
#method_after
private void InitVdsBroker() {
    log.infoFormat("Initialize vdsBroker ({0},{1})", _vds.getHostName(), _vds.getPort());
    // Get the values of the timeouts:
    int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
    int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
    int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
    _vdsProxy = TransportFactory.createVdsServer(_vds.getProtocol(), _vds.getHostName(), _vds.getPort(), clientTimeOut, connectionTimeOut, clientRetries);
}
#end_block

#method_before
public void refreshHost(VDS vds) {
    try {
        /**
         * refresh capabilities
         */
        VDSStatus newStatus = refreshCapabilities(new AtomicBoolean(), vds);
        if (log.isDebugEnabled()) {
            log.debugFormat("Succeeded to refreshCapabilities for host {0} , new status will be {1} ", getVdsId(), newStatus);
        }
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#method_after
public void refreshHost(VDS vds) {
    try {
        refreshCapabilities(new AtomicBoolean(), vds);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#end_block

#method_before
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getPreviousStatus() != vds.getStatus()) {
            vds.setPreviousStatus(vds.getStatus());
            if (_vds != null) {
                _vds.setPreviousStatus(vds.getStatus());
                if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                    calculateNextMaintenanceAttemptTime();
                }
            }
        }
        // update to new status
        vds.setStatus(status);
        if (_vds != null) {
            _vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (_vds != null) {
                    _vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (_vds != null) {
                    _vds.setCpuSys(Double.valueOf(0));
                    _vds.setCpuUser(Double.valueOf(0));
                    _vds.setCpuIdle(Double.valueOf(0));
                    _vds.setCpuLoad(Double.valueOf(0));
                    _vds.setUsageCpuPercent(0);
                    _vds.setUsageMemPercent(0);
                    _vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#method_after
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getStatus() != status) {
            if (status == VDSStatus.PreparingForMaintenance) {
                calculateNextMaintenanceAttemptTime();
            }
            vds.setPreviousStatus(vds.getStatus());
            if (_vds != null) {
                _vds.setPreviousStatus(vds.getStatus());
            }
        }
        // update to new status
        vds.setStatus(status);
        if (_vds != null) {
            _vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (_vds != null) {
                    _vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (_vds != null) {
                    _vds.setCpuSys(Double.valueOf(0));
                    _vds.setCpuUser(Double.valueOf(0));
                    _vds.setCpuIdle(Double.valueOf(0));
                    _vds.setCpuLoad(Double.valueOf(0));
                    _vds.setUsageCpuPercent(0);
                    _vds.setUsageMemPercent(0);
                    _vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("GetCapabilitiesVDSCommand started method");
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                if (log.isDebugEnabled()) {
                    log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
                }
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
                returnStatus = vds.getStatus();
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            updateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debugFormat("monitoring: refresh {0} capabilities", vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED)) {
            AuditLogDirector.log(new AuditLogableBase(vds.getId()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warnFormat("Host {0} is running with disabled SELinux.", vds.getName());
            } else {
                log.warnFormat("Host {0} does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debugFormat("monitoring: vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            DbFacade.getInstance().getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            updateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(vds.getVmCount(), vds.getSpmStatus());
        if (mUnrespondedAttempts.get() < Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount) || (lastUpdate + timeoutToFence) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getStatus() != VDSStatus.Connecting && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        log.infoFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, vm_count = {2}, " + "spm_status = {3}, non-responsive_timeout (seconds) = {4}, error = {5}", vds.getId(), vds.getName(), vds.getVmCount(), vds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        boolean executeSshSoftFencing = false;
        if (!sshSoftFencingExecuted.getAndSet(true)) {
            executeSshSoftFencing = true;
        }
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds, executeSshSoftFencing);
    }
    return true;
}
#method_after
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(vds.getVmCount(), vds.getSpmStatus());
        log.warnFormat("Host {0} is not responding. It will stay in Connecting state for a grace period of ${1} seconds and after that an attempt to fence the host will be issued.", vds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(vds.getId());
        logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
        AuditLogDirector.log(logable, AuditLogType.VDS_HOST_IN_CONNECTING_STATE);
        if (mUnrespondedAttempts.get() < Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount) || (lastUpdate + timeoutToFence) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getStatus() != VDSStatus.Connecting && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        moveVMsToUnknown();
        log.infoFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, vm_count = {2}, " + "spm_status = {3}, non-responsive_timeout (seconds) = {4}, error = {5}", vds.getId(), vds.getName(), vds.getVmCount(), vds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
        logable = new AuditLogableBase(vds.getId());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        boolean executeSshSoftFencing = false;
        if (!sshSoftFencingExecuted.getAndSet(true)) {
            executeSshSoftFencing = true;
        }
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds, executeSshSoftFencing);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    IscsiBondValidator validator = new IscsiBondValidator();
    return validate(validator.iscsiBondWithTheSameNameExistInDataCenter(getIscsiBond()));
}
#method_after
@Override
protected boolean canDoAction() {
    if (!FeatureSupported.isIscsiMultipathingSupported(getStoragePool().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.ISCSI_BOND_NOT_SUPPORTED);
    }
    IscsiBondValidator validator = new IscsiBondValidator();
    return validate(validator.iscsiBondWithTheSameNameExistInDataCenter(getIscsiBond())) && validate(validator.validateAddedLogicalNetworks(getIscsiBond())) && validate(validator.validateAddedStorageConnections(getIscsiBond()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final IscsiBond iscsiBond = getIscsiBond();
    iscsiBond.setId(Guid.newGuid());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getDbFacade().getIscsiBondDao().save(iscsiBond);
            for (Guid networkId : iscsiBond.getNetworkIds()) {
                getDbFacade().getIscsiBondDao().addNetworkToIscsiBond(iscsiBond.getId(), networkId);
            }
            for (String connectionId : iscsiBond.getStorageConnectionIds()) {
                getDbFacade().getIscsiBondDao().addStorageConnectionToIscsiBond(iscsiBond.getId(), connectionId);
            }
            getReturnValue().setActionReturnValue(iscsiBond.getId());
            return null;
        }
    });
    connectAllHostsToStorage(iscsiBond.getStorageConnectionIds());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final IscsiBond iscsiBond = getIscsiBond();
    iscsiBond.setId(Guid.newGuid());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getDbFacade().getIscsiBondDao().save(iscsiBond);
            for (Guid networkId : iscsiBond.getNetworkIds()) {
                getDbFacade().getIscsiBondDao().addNetworkToIscsiBond(iscsiBond.getId(), networkId);
            }
            for (String connectionId : iscsiBond.getStorageConnectionIds()) {
                getDbFacade().getIscsiBondDao().addStorageConnectionToIscsiBond(iscsiBond.getId(), connectionId);
            }
            return null;
        }
    });
    connectAllHostsToStorage(iscsiBond.getStorageConnectionIds());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    IscsiBondValidator validator = new IscsiBondValidator();
    if (!validate(validator.isIscsiBondExist(getExistingIscsiBond()))) {
        return false;
    }
    if (isNameChanged() && !validate(validator.iscsiBondWithTheSameNameExistInDataCenter(getIscsiBond()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    IscsiBondValidator validator = new IscsiBondValidator();
    if (!validate(validator.isIscsiBondExist(getExistingIscsiBond()))) {
        return false;
    }
    if (isNameChanged() && !validate(validator.iscsiBondWithTheSameNameExistInDataCenter(getIscsiBond()))) {
        return false;
    }
    return validate(validator.validateAddedLogicalNetworks(getIscsiBond(), getExistingIscsiBond())) && validate(validator.validateAddedStorageConnections(getIscsiBond(), getExistingIscsiBond()));
}
#end_block

#method_before
@Override
protected Cluster postPopulate(Cluster model) {
    ErrorHandling errorHandling = new ErrorHandling();
    errorHandling.setOnError(MappingTestHelper.shuffle(MigrateOnError.class).value());
    model.setErrorHandling(errorHandling);
    model.getSerialNumber().setPolicy(SerialNumberPolicy.CUSTOM.value());
    model.getSchedulingPolicy().setPolicy(NONE);
    model.getSchedulingPolicy().setName(NONE);
    return model;
}
#method_after
@Override
protected Cluster postPopulate(Cluster model) {
    ErrorHandling errorHandling = new ErrorHandling();
    errorHandling.setOnError(MappingTestHelper.shuffle(MigrateOnError.class).value());
    model.setErrorHandling(errorHandling);
    SchedulingPolicy policy = new SchedulingPolicy();
    policy.setPolicy(NONE);
    model.setSchedulingPolicy(policy);
    model.getSerialNumber().setPolicy(SerialNumberPolicy.CUSTOM.value());
    model.getRequiredRngSources().getRngSources().clear();
    model.getRequiredRngSources().getRngSources().add(RngSource.RANDOM.name());
    model.getSchedulingPolicy().setPolicy(NONE);
    model.getSchedulingPolicy().setName(NONE);
    return model;
}
#end_block

#method_before
@Override
protected void verify(Cluster model, Cluster transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertNotNull(transform.getCpu());
    assertEquals(model.getCpu().getId(), transform.getCpu().getId());
    assertNotNull(transform.getDataCenter());
    assertEquals(model.getDataCenter().getId(), transform.getDataCenter().getId());
    assertNotNull(transform.getSchedulingPolicy());
    assertEquals(model.getSchedulingPolicy().getId(), transform.getSchedulingPolicy().getId());
    assertEquals(model.getSchedulingPolicy().getPolicy(), transform.getSchedulingPolicy().getPolicy());
    assertEquals(model.getSchedulingPolicy().getName(), transform.getSchedulingPolicy().getName());
    assertNotNull(model.getSchedulingPolicyProperties());
    assertEquals(CustomPropertiesParser.toMap(model.getSchedulingPolicyProperties()), CustomPropertiesParser.toMap(transform.getSchedulingPolicyProperties()));
    assertEquals(model.getErrorHandling().getOnError(), transform.getErrorHandling().getOnError());
    assertNotNull(transform.getMemoryPolicy());
    assertNotNull(transform.getMemoryPolicy().getTransparentHugepages());
    assertEquals(transform.getMemoryPolicy().getTransparentHugepages().isEnabled(), transform.getMemoryPolicy().getTransparentHugepages().isEnabled());
    assertEquals(model.isVirtService(), transform.isVirtService());
    assertEquals(model.isGlusterService(), transform.isGlusterService());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.isTrustedService(), transform.isTrustedService());
    assertEquals(model.isBallooningEnabled(), transform.isBallooningEnabled());
    assertEquals(model.getKsm().isEnabled(), transform.getKsm().isEnabled());
    assertEquals(model.getDisplay().getProxy(), transform.getDisplay().getProxy());
    assertEquals(model.getSerialNumber().getPolicy(), transform.getSerialNumber().getPolicy());
    assertEquals(model.getSerialNumber().getValue(), transform.getSerialNumber().getValue());
}
#method_after
@Override
protected void verify(Cluster model, Cluster transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertNotNull(transform.getCpu());
    assertEquals(model.getCpu().getId(), transform.getCpu().getId());
    assertNotNull(transform.getDataCenter());
    assertEquals(model.getDataCenter().getId(), transform.getDataCenter().getId());
    assertNotNull(transform.getSchedulingPolicy());
    assertEquals(model.getSchedulingPolicy().getId(), transform.getSchedulingPolicy().getId());
    assertEquals(model.getErrorHandling().getOnError(), transform.getErrorHandling().getOnError());
    assertNotNull(transform.getMemoryPolicy());
    assertNotNull(transform.getMemoryPolicy().getTransparentHugepages());
    assertEquals(transform.getMemoryPolicy().getTransparentHugepages().isEnabled(), transform.getMemoryPolicy().getTransparentHugepages().isEnabled());
    assertEquals(model.isVirtService(), transform.isVirtService());
    assertEquals(model.isGlusterService(), transform.isGlusterService());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.isTrustedService(), transform.isTrustedService());
    assertEquals(model.isBallooningEnabled(), transform.isBallooningEnabled());
    assertEquals(model.getKsm().isEnabled(), transform.getKsm().isEnabled());
    assertEquals(model.getDisplay().getProxy(), transform.getDisplay().getProxy());
    assertEquals(model.getSerialNumber().getPolicy(), transform.getSerialNumber().getPolicy());
    assertEquals(model.getSerialNumber().getValue(), transform.getSerialNumber().getValue());
}
#end_block

#method_before
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setcpu_name(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setcompatibility_version(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model, model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetOptionalReason()) {
        entity.setOptionalReasonRequired(model.isOptionalReason());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm() && model.getKsm().isSetEnabled()) {
        entity.setEnableKsm(model.getKsm().isEnabled());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    return entity;
}
#method_after
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setcpu_name(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setcompatibility_version(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetOptionalReason()) {
        entity.setOptionalReasonRequired(model.isOptionalReason());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm() && model.getKsm().isSetEnabled()) {
        entity.setEnableKsm(model.getKsm().isEnabled());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetRequiredRngSources()) {
        entity.getRequiredRngSources().clear();
        entity.getRequiredRngSources().addAll(RngDeviceMapper.mapRngSources(model.getRequiredRngSources(), null));
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getdescription());
    model.setComment(entity.getComment());
    if (entity.getcpu_name() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getcpu_name());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getcompatibility_version() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getcompatibility_version().getMajor());
        model.getVersion().setMinor(entity.getcompatibility_version().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    if (entity.getClusterPolicyProperties() != null && !entity.getClusterPolicyProperties().isEmpty()) {
        model.setSchedulingPolicyProperties(CustomPropertiesParser.fromMap(entity.getClusterPolicyProperties()));
    }
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setOptionalReason(entity.isOptionalReasonRequired());
    model.setBallooningEnabled(entity.isEnableBallooning());
    model.setKsm(new KSM());
    model.getKsm().setEnabled(entity.isEnableKsm());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    return model;
}
#method_after
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getdescription());
    model.setComment(entity.getComment());
    if (entity.getcpu_name() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getcpu_name());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getcompatibility_version() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getcompatibility_version().getMajor());
        model.getVersion().setMinor(entity.getcompatibility_version().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setOptionalReason(entity.isOptionalReasonRequired());
    model.setBallooningEnabled(entity.isEnableBallooning());
    model.setKsm(new KSM());
    model.getKsm().setEnabled(entity.isEnableKsm());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    if (entity.getRequiredRngSources() != null) {
        model.setRequiredRngSources(RngDeviceMapper.mapRngSources(entity.getRequiredRngSources(), null));
    }
    return model;
}
#end_block

#method_before
@Mapping(from = MigrateOnErrorOptions.class, to = ErrorHandling.class)
private static ErrorHandling map(MigrateOnErrorOptions migrateOnError, ErrorHandling template) {
    MigrateOnError value = map(migrateOnError, (MigrateOnError) null);
    if (value == null) {
        return null;
    } else {
        template = template == null ? new ErrorHandling() : template;
        template.setOnError(value.value());
        return template;
    }
}
#method_after
@Mapping(from = SchedulingPolicy.class, to = VDSGroup.class)
public static VDSGroup map(SchedulingPolicy model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setClusterPolicyId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetPolicy() || model.isSetName()) {
        entity.setClusterPolicyName(model.isSetName() ? model.getName() : model.getPolicy());
    }
    if (model.isSetThresholds()) {
        SchedulingPolicyThresholds thresholds = model.getThresholds();
        if (entity.getClusterPolicyProperties() == null) {
            entity.setClusterPolicyProperties(new LinkedHashMap<String, String>());
        }
        if (thresholds.getLow() != null) {
            entity.getClusterPolicyProperties().put(LOW_UTILIZATION, thresholds.getLow().toString());
        }
        if (thresholds.getHigh() != null) {
            entity.getClusterPolicyProperties().put(HIGH_UTILIZATION, thresholds.getHigh().toString());
        }
        if (thresholds.getDuration() != null) {
            int round = Math.round(thresholds.getDuration() / 60.0f);
            entity.getClusterPolicyProperties().put(CPU_OVER_COMMIT_DURATION_MINUTES, Integer.toString(round));
        }
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDSGroup.class, to = SchedulingPolicy.class)
public static SchedulingPolicy map(VDSGroup entity, SchedulingPolicy template) {
    SchedulingPolicy model = template != null ? template : new SchedulingPolicy();
    if (entity.getClusterPolicyName() != null) {
        model.setId(entity.getClusterPolicyId().toString());
        model.setPolicy(entity.getClusterPolicyName().toLowerCase());
        model.setName(entity.getClusterPolicyName().toLowerCase());
        if (entity.getClusterPolicyProperties() != null && !entity.getClusterPolicyProperties().isEmpty()) {
            model.setThresholds(new SchedulingPolicyThresholds());
            String lowUtilization = entity.getClusterPolicyProperties().get(LOW_UTILIZATION);
            String highUtilization = entity.getClusterPolicyProperties().get(HIGH_UTILIZATION);
            String cpuOverCommitDurationMinutes = entity.getClusterPolicyProperties().get(CPU_OVER_COMMIT_DURATION_MINUTES);
            if (lowUtilization != null) {
                model.getThresholds().setLow(Integer.parseInt(lowUtilization));
            }
            if (highUtilization != null) {
                model.getThresholds().setHigh(Integer.parseInt(highUtilization));
            }
            if (cpuOverCommitDurationMinutes != null) {
                int duration = Integer.parseInt(cpuOverCommitDurationMinutes) * 60;
                model.getThresholds().setDuration(duration);
            }
        }
    }
    return model;
}
#method_after
@Mapping(from = VDSGroup.class, to = SchedulingPolicy.class)
public static SchedulingPolicy map(VDSGroup entity, SchedulingPolicy template) {
    SchedulingPolicy model = template != null ? template : new SchedulingPolicy();
    if (entity.getClusterPolicyName() != null) {
        model.setId(entity.getClusterPolicyId() != null ? entity.getClusterPolicyId().toString() : null);
        model.setPolicy(entity.getClusterPolicyName().toLowerCase());
        model.setName(entity.getClusterPolicyName().toLowerCase());
        if (entity.getClusterPolicyProperties() != null && !entity.getClusterPolicyProperties().isEmpty()) {
            model.setThresholds(new SchedulingPolicyThresholds());
            String lowUtilization = entity.getClusterPolicyProperties().get(LOW_UTILIZATION);
            String highUtilization = entity.getClusterPolicyProperties().get(HIGH_UTILIZATION);
            String cpuOverCommitDurationMinutes = entity.getClusterPolicyProperties().get(CPU_OVER_COMMIT_DURATION_MINUTES);
            if (lowUtilization != null) {
                model.getThresholds().setLow(Integer.parseInt(lowUtilization));
            }
            if (highUtilization != null) {
                model.getThresholds().setHigh(Integer.parseInt(highUtilization));
            }
            if (cpuOverCommitDurationMinutes != null) {
                int duration = Integer.parseInt(cpuOverCommitDurationMinutes) * 60;
                model.getThresholds().setDuration(duration);
            }
        }
    }
    if (entity.getClusterPolicyProperties() != null && !entity.getClusterPolicyProperties().isEmpty()) {
        model.setProperties(CustomPropertiesParser.fromMap(entity.getClusterPolicyProperties()));
    }
    return model;
}
#end_block

#method_before
@Mapping(from = ClusterPolicy.class, to = SchedulingPolicy.class)
public static SchedulingPolicy map(ClusterPolicy entity, SchedulingPolicy template) {
    SchedulingPolicy model = template != null ? template : new SchedulingPolicy();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setLocked(entity.isLocked());
    model.setDefaultPolicy(entity.isDefaultPolicy());
    if (entity.getFilters() != null) {
        model.setFilters(new Filters());
        for (Guid filterId : entity.getFilters()) {
            Filter filter = new Filter();
            SchedulingPolicyUnit schedulingPolicyUnit = new SchedulingPolicyUnit();
            schedulingPolicyUnit.setId(filterId.toString());
            filter.setSchedulingPolicyUnit(schedulingPolicyUnit);
            Integer position = entity.getFilterPositionMap().get(filterId);
            filter.setPosition(position == null ? 0 : position);
            model.getFilters().getFilters().add(filter);
        }
    }
    if (entity.getFunctions() != null) {
        model.setWeights(new Weights());
        for (Pair<Guid, Integer> pair : entity.getFunctions()) {
            Weight weight = new Weight();
            SchedulingPolicyUnit schedulingPolicyUnit = new SchedulingPolicyUnit();
            schedulingPolicyUnit.setId(pair.getFirst().toString());
            weight.setSchedulingPolicyUnit(schedulingPolicyUnit);
            weight.setFactor(pair.getSecond());
            model.getWeights().getWeights().add(weight);
        }
    }
    if (entity.getBalance() != null) {
        model.setBalances(new Balances());
        Balance balance = new Balance();
        SchedulingPolicyUnit schedulingPolicyUnit = new SchedulingPolicyUnit();
        schedulingPolicyUnit.setId(entity.getBalance().toString());
        balance.setSchedulingPolicyUnit(schedulingPolicyUnit);
        model.getBalances().setBalances(balance);
    }
    if (entity.getParameterMap() != null && !entity.getParameterMap().isEmpty()) {
        model.setProperties(CustomPropertiesParser.fromMap(entity.getParameterMap()));
    }
    return model;
}
#method_after
@Mapping(from = ClusterPolicy.class, to = SchedulingPolicy.class)
public static SchedulingPolicy map(ClusterPolicy entity, SchedulingPolicy template) {
    SchedulingPolicy model = template != null ? template : new SchedulingPolicy();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setLocked(entity.isLocked());
    model.setDefaultPolicy(entity.isDefaultPolicy());
    if (entity.getParameterMap() != null && !entity.getParameterMap().isEmpty()) {
        model.setProperties(CustomPropertiesParser.fromMap(entity.getParameterMap()));
    }
    return model;
}
#end_block

#method_before
@Mapping(from = SchedulingPolicy.class, to = ClusterPolicy.class)
public static ClusterPolicy map(SchedulingPolicy model, ClusterPolicy template) {
    ClusterPolicy entity = template != null ? template : new ClusterPolicy();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetLocked()) {
        entity.setLocked(model.isLocked());
    }
    if (model.isSetDefaultPolicy()) {
        entity.setDefaultPolicy(model.isDefaultPolicy());
    }
    if (model.isSetFilters() && model.getFilters().isSetFilters()) {
        entity.setFilters(new ArrayList<Guid>());
        entity.setFilterPositionMap(new HashMap<Guid, Integer>());
        for (Filter filter : model.getFilters().getFilters()) {
            if (filter.isSetSchedulingPolicyUnit() && filter.getSchedulingPolicyUnit().isSetId()) {
                Guid filterGuid = GuidUtils.asGuid(filter.getSchedulingPolicyUnit().getId());
                entity.getFilters().add(filterGuid);
                entity.getFilterPositionMap().put(filterGuid, filter.isSetPosition() ? filter.getPosition() : 0);
            }
        }
    }
    if (model.isSetWeights() && model.getWeights().isSetWeights()) {
        entity.setFunctions(new ArrayList<Pair<Guid, Integer>>());
        for (Weight Weight : model.getWeights().getWeights()) {
            if (Weight.isSetSchedulingPolicyUnit() && Weight.getSchedulingPolicyUnit().isSetId()) {
                Guid WeightGuid = GuidUtils.asGuid(Weight.getSchedulingPolicyUnit().getId());
                entity.getFunctions().add(new Pair<Guid, Integer>(WeightGuid, Weight.isSetFactor() ? Weight.getFactor() : 1));
            }
        }
    }
    if (model.isSetBalances() && model.getBalances().isSetBalances() && model.getBalances().getBalances().isSetSchedulingPolicyUnit() && model.getBalances().getBalances().getSchedulingPolicyUnit().isSetId()) {
        entity.setBalance(GuidUtils.asGuid(model.getBalances().getBalances().getSchedulingPolicyUnit().getId()));
    }
    if (model.isSetProperties()) {
        entity.setParameterMap(CustomPropertiesParser.toMap(model.getProperties()));
    }
    return entity;
}
#method_after
@Mapping(from = SchedulingPolicy.class, to = ClusterPolicy.class)
public static ClusterPolicy map(SchedulingPolicy model, ClusterPolicy template) {
    ClusterPolicy entity = template != null ? template : new ClusterPolicy();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetLocked()) {
        entity.setLocked(model.isLocked());
    }
    if (model.isSetDefaultPolicy()) {
        entity.setDefaultPolicy(model.isDefaultPolicy());
    }
    if (model.isSetProperties()) {
        entity.setParameterMap(CustomPropertiesParser.toMap(model.getProperties()));
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = SchedulingPolicy.class, to = ClusterPolicy.class)
public static ClusterPolicy map(SchedulingPolicy model, ClusterPolicy template) {
    ClusterPolicy entity = template != null ? template : new ClusterPolicy();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetLocked()) {
        entity.setLocked(model.isLocked());
    }
    if (model.isSetDefaultPolicy()) {
        entity.setDefaultPolicy(model.isDefaultPolicy());
    }
    if (model.isSetFilters() && model.getFilters().isSetFilters()) {
        entity.setFilters(new ArrayList<Guid>());
        entity.setFilterPositionMap(new HashMap<Guid, Integer>());
        for (Filter filter : model.getFilters().getFilters()) {
            if (filter.isSetSchedulingPolicyUnit() && filter.getSchedulingPolicyUnit().isSetId()) {
                Guid filterGuid = GuidUtils.asGuid(filter.getSchedulingPolicyUnit().getId());
                entity.getFilters().add(filterGuid);
                entity.getFilterPositionMap().put(filterGuid, filter.isSetPosition() ? filter.getPosition() : 0);
            }
        }
    }
    if (model.isSetWeights() && model.getWeights().isSetWeights()) {
        entity.setFunctions(new ArrayList<Pair<Guid, Integer>>());
        for (Weight Weight : model.getWeights().getWeights()) {
            if (Weight.isSetSchedulingPolicyUnit() && Weight.getSchedulingPolicyUnit().isSetId()) {
                Guid WeightGuid = GuidUtils.asGuid(Weight.getSchedulingPolicyUnit().getId());
                entity.getFunctions().add(new Pair<Guid, Integer>(WeightGuid, Weight.isSetFactor() ? Weight.getFactor() : 1));
            }
        }
    }
    if (model.isSetBalances() && model.getBalances().isSetBalances() && model.getBalances().getBalances().isSetSchedulingPolicyUnit() && model.getBalances().getBalances().getSchedulingPolicyUnit().isSetId()) {
        entity.setBalance(GuidUtils.asGuid(model.getBalances().getBalances().getSchedulingPolicyUnit().getId()));
    }
    if (model.isSetProperties()) {
        entity.setParameterMap(CustomPropertiesParser.toMap(model.getProperties()));
    }
    return entity;
}
#method_after
@Mapping(from = ClusterPolicy.class, to = Filter.class)
public static Filter map(ClusterPolicy entity, Filter template) {
    if (template == null) {
        assert (false) : "scheduling filter cannot be null";
        return null;
    }
    Filter model = template;
    SchedulingPolicyUnit schedulingPolicyUnit = new SchedulingPolicyUnit();
    schedulingPolicyUnit.setId(model.getId());
    model.setSchedulingPolicyUnit(schedulingPolicyUnit);
    Integer position = null;
    if (entity.getFilterPositionMap() != null) {
        position = entity.getFilterPositionMap().get(GuidUtils.asGuid(model.getId()));
    }
    model.setPosition(position != null ? position : 0);
    return model;
}
#end_block

#method_before
public Features getFeatures(Version version) {
    Features features = new Features();
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_0)) {
        addFeatureTransparentHugePages(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_1)) {
        addFeatureGluster(features);
        addFeaturePosixDevice(features);
        addFeaturePortMirroring(features);
        addFeatureServerTime(features);
        addFeatureHostMemory(features);
        addFeatureHostSockets(features, version);
        addFeatureIgnoreCase(features);
        addFeatureMaxResults(features);
        addFeatureJSONContentType(features);
        addFeatureCorrelationId(features);
        addFeatureDiskActivation(features);
        addFeatureNicActivation(features);
        addFeatureSnapshotsRefactoring(features);
        addFeatureRemoveTemplateFromSD(features);
        addFeatureFloatingDisks(features);
        addFeatureAsyncDelete(features);
        addFeatureSessionBasedAuthentication(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_3)) {
        addFeatureVmApplications(features);
        addFeatureVirtioScsi(features);
        addFeatureComment(features);
        addFeatureRefreshHostCapabilities(features);
        addFeatureMemorySnapshot(features);
        addWatchdogFeature(features);
        addSshAuthenticationFeature(features);
        addForceSelectSpmFeature(features);
        addConsoleFeature(features);
        addFeatureStorageServerConnections(features);
        addFeatureStorageServerConnectionsForDomain(features);
        addFeatureAttachDetachStorageServerConnectionsForDomain(features);
        addSingleQxlPciFeature(features);
        addFeatureAddVmFromOvf(features);
        addVnicProfilesFeature(features);
        addStorageDomainImageFeature(features);
        addGlusterHooksFeature(features);
        addFeatureReportVmFQDN(features);
        addFeatureAttachDiskSnapshot(features);
        addFeatureCloudInit(features);
        addFeatureSchedulingPolicy(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_4)) {
        addGlusterBricksFeature(features);
        addFeatureCopyMoveDiskInAdditionalContext(features);
        addNetworkLabelsFeature(features);
        addRebootFeature(features);
        addMaintenanceFeature(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_5)) {
        addBookmarksFeature(features);
        addNetworkCustomPropertiesFeature(features);
        addFeatureRemoveDiskFromVmSnapshot(features);
        addFeatureDiskSnapshotsResourceInStorageDomainContext(features);
    }
    return features;
}
#method_after
public Features getFeatures(Version version) {
    Features features = new Features();
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_0)) {
        addFeatureTransparentHugePages(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_1)) {
        addFeatureGluster(features);
        addFeaturePosixDevice(features);
        addFeaturePortMirroring(features);
        addFeatureServerTime(features);
        addFeatureHostMemory(features);
        addFeatureHostSockets(features, version);
        addFeatureIgnoreCase(features);
        addFeatureMaxResults(features);
        addFeatureJSONContentType(features);
        addFeatureCorrelationId(features);
        addFeatureDiskActivation(features);
        addFeatureNicActivation(features);
        addFeatureSnapshotsRefactoring(features);
        addFeatureRemoveTemplateFromSD(features);
        addFeatureFloatingDisks(features);
        addFeatureAsyncDelete(features);
        addFeatureSessionBasedAuthentication(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_3)) {
        addFeatureVmApplications(features);
        addFeatureVirtioScsi(features);
        addFeatureComment(features);
        addFeatureRefreshHostCapabilities(features);
        addFeatureMemorySnapshot(features);
        addWatchdogFeature(features);
        addSshAuthenticationFeature(features);
        addForceSelectSpmFeature(features);
        addConsoleFeature(features);
        addFeatureStorageServerConnections(features);
        addFeatureStorageServerConnectionsForDomain(features);
        addFeatureAttachDetachStorageServerConnectionsForDomain(features);
        addSingleQxlPciFeature(features);
        addFeatureAddVmFromOvf(features);
        addVnicProfilesFeature(features);
        addStorageDomainImageFeature(features);
        addGlusterHooksFeature(features);
        addFeatureReportVmFQDN(features);
        addFeatureAttachDiskSnapshot(features);
        addFeatureCloudInit(features);
        addFeatureSchedulingPolicy(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_4)) {
        addGlusterBricksFeature(features);
        addFeatureCopyMoveDiskInAdditionalContext(features);
        addNetworkLabelsFeature(features);
        addRebootFeature(features);
        addMaintenanceFeature(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_5)) {
        addBookmarksFeature(features);
        addNetworkCustomPropertiesFeature(features);
        addFeatureRemoveDiskFromVmSnapshot(features);
        addFeatureDiskSnapshotsResourceInStorageDomainContext(features);
        addInstanceTypesFeature(features);
        addNumaNodesFeature(features);
    }
    return features;
}
#end_block

#method_before
@Mapping(from = PolicyUnit.class, to = SchedulingPolicyUnit.class)
public static SchedulingPolicyUnit map(PolicyUnit entity, SchedulingPolicyUnit template) {
    SchedulingPolicyUnit model = template != null ? template : new SchedulingPolicyUnit();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setType(entity.getPolicyUnitType().name().toLowerCase());
    model.setEnabled(entity.isEnabled());
    model.setInternal(entity.isInternal());
    if (entity.getParameterRegExMap() != null && !entity.getParameterRegExMap().isEmpty()) {
        model.setRegexValidationMap(CustomPropertiesParser.fromMap(entity.getParameterRegExMap()));
    }
    return model;
}
#method_after
@Mapping(from = PolicyUnit.class, to = SchedulingPolicyUnit.class)
public static SchedulingPolicyUnit map(PolicyUnit entity, SchedulingPolicyUnit template) {
    SchedulingPolicyUnit model = template != null ? template : new SchedulingPolicyUnit();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setType(map(entity.getPolicyUnitType(), null).name().toLowerCase());
    model.setEnabled(entity.isEnabled());
    model.setInternal(entity.isInternal());
    if (entity.getParameterRegExMap() != null && !entity.getParameterRegExMap().isEmpty()) {
        model.setPropertiesMetaData(CustomPropertiesParser.fromMap(entity.getParameterRegExMap()));
    }
    return model;
}
#end_block

#method_before
@Mapping(from = SchedulingPolicyUnit.class, to = PolicyUnit.class)
public static PolicyUnit map(SchedulingPolicyUnit model, PolicyUnit template) {
    PolicyUnit entity = template != null ? template : new PolicyUnit();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetType()) {
        entity.setPolicyUnitType(PolicyUnitType.valueOf(model.getType().toUpperCase()));
    }
    if (model.isSetEnabled()) {
        entity.setEnabled(model.isEnabled());
    }
    if (model.isSetInternal()) {
        entity.setInternal(model.isInternal());
    }
    if (model.isSetRegexValidationMap()) {
        entity.setParameterRegExMap(CustomPropertiesParser.toMap(model.getRegexValidationMap()));
    }
    return entity;
}
#method_after
@Mapping(from = SchedulingPolicyUnit.class, to = PolicyUnit.class)
public static PolicyUnit map(SchedulingPolicyUnit model, PolicyUnit template) {
    PolicyUnit entity = template != null ? template : new PolicyUnit();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetType()) {
        entity.setPolicyUnitType(map(org.ovirt.engine.api.model.PolicyUnitType.valueOf(model.getType().toUpperCase()), null));
    }
    if (model.isSetEnabled()) {
        entity.setEnabled(model.isEnabled());
    }
    if (model.isSetInternal()) {
        entity.setInternal(model.isInternal());
    }
    if (model.isSetPropertiesMetaData()) {
        entity.setParameterRegExMap(CustomPropertiesParser.toMap(model.getPropertiesMetaData()));
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = SchedulingPolicyUnit.class, to = PolicyUnit.class)
public static PolicyUnit map(SchedulingPolicyUnit model, PolicyUnit template) {
    PolicyUnit entity = template != null ? template : new PolicyUnit();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetType()) {
        entity.setPolicyUnitType(PolicyUnitType.valueOf(model.getType().toUpperCase()));
    }
    if (model.isSetEnabled()) {
        entity.setEnabled(model.isEnabled());
    }
    if (model.isSetInternal()) {
        entity.setInternal(model.isInternal());
    }
    if (model.isSetRegexValidationMap()) {
        entity.setParameterRegExMap(CustomPropertiesParser.toMap(model.getRegexValidationMap()));
    }
    return entity;
}
#method_after
@Mapping(from = org.ovirt.engine.api.model.PolicyUnitType.class, to = PolicyUnitType.class)
public static PolicyUnitType map(org.ovirt.engine.api.model.PolicyUnitType model, PolicyUnitType template) {
    if (model == null) {
        return null;
    }
    switch(model) {
        case FILTER:
            return PolicyUnitType.FILTER;
        case WEIGHT:
            return PolicyUnitType.WEIGHT;
        case LOAD_BALANCING:
            return PolicyUnitType.LOAD_BALANCING;
        default:
            assert (false) : "unknown Policy Unit Type value: " + model.toString();
            return null;
    }
}
#end_block

#method_before
public static Collection<DetailedLink> getLinks(String baseUri) {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities", baseUri));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("datacenters", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams(), baseUri));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("networks", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("roles", baseUri));
    links.add(createLink("storagedomains", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("tags", baseUri));
    links.add(createLink("bookmarks", baseUri));
    links.add(createLink("templates", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("users", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("groups", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("domains", baseUri));
    links.add(createLink("vmpools", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("vms", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("disks", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("jobs", baseUri));
    links.add(createLink("storageconnections", baseUri));
    links.add(createLink("vnicprofiles", baseUri));
    links.add(createLink("schedulingpolicyunits", baseUri));
    links.add(createLink("schedulingpolicies", baseUri));
    links.add(createLink("permissions", baseUri));
    return links;
}
#method_after
public static Collection<DetailedLink> getLinks(String baseUri) {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities", baseUri));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("datacenters", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams(), baseUri));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("networks", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("roles", baseUri));
    links.add(createLink("storagedomains", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("tags", baseUri));
    links.add(createLink("bookmarks", baseUri));
    links.add(createLink("templates", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("instancetypes", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("users", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("groups", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("domains", baseUri));
    links.add(createLink("vmpools", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("vms", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("disks", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("jobs", baseUri));
    links.add(createLink("storageconnections", baseUri));
    links.add(createLink("vnicprofiles", baseUri));
    links.add(createLink("schedulingpolicyunits", baseUri));
    links.add(createLink("schedulingpolicies", baseUri));
    links.add(createLink("permissions", baseUri));
    return links;
}
#end_block

#method_before
@Override
public Capabilities list() {
    Capabilities caps = new Capabilities();
    for (Version v : getSupportedClusterLevels()) {
        caps.getVersions().add(generateVersionCaps(v));
    }
    caps.setPermits(getPermits());
    // caps.setSchedulingPolicies(getSchedulingPolicies());
    return caps;
}
#method_after
@Override
public Capabilities list() {
    Capabilities caps = new Capabilities();
    for (Version v : getSupportedClusterLevels()) {
        caps.getVersions().add(generateVersionCaps(v));
    }
    caps.setPermits(getPermits());
    caps.setSchedulingPolicies(getSchedulingPolicies());
    return caps;
}
#end_block

#method_before
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addKdumpStates(version, KdumpStatus.values());
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    // addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addArchitectureCapabilities(version);
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    addSELinuxModes(version, SELinuxMode.values());
    addPolicyUnitTypes(version, PolicyUnitType.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#method_after
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addKdumpStates(version, KdumpStatus.values());
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addArchitectureCapabilities(version);
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    addSELinuxModes(version, SELinuxMode.values());
    addRngSources(version, RngSource.values());
    addPolicyUnitTypes(version, PolicyUnitType.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#end_block

#method_before
// private void addSchedulingPolicies(VersionCaps version, SchedulingPolicyType[] values) {
// version.setSchedulingPolicies(new SchedulingPolicies());
// for (SchedulingPolicyType policy : values) {
// version.getSchedulingPolicies().getPolicy().add(policy.value());
// }
// }
private void addPermits(VersionCaps version, PermitType[] values) {
    version.setPermits(new Permits());
    for (PermitType permit : values) {
        version.getPermits().getPermits().add(map(permit));
    }
}
#method_after
private void addPermits(VersionCaps version, PermitType[] values) {
    version.setPermits(new Permits());
    for (PermitType permit : values) {
        version.getPermits().getPermits().add(map(permit));
    }
}
#end_block

#method_before
// private SchedulingPolicies getSchedulingPolicies() {
// SchedulingPolicies policies = new SchedulingPolicies();
// for (SchedulingPolicyType policy : SchedulingPolicyType.values()) {
// policies.getPolicy().add(policy.value());
// }
// return policies;
// }
private void addMigrateOnErrorOptions(VersionCaps version, MigrateOnError[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_0)) {
        version.setErrorHandling(new org.ovirt.engine.api.model.ErrorHandlingOptions());
        for (MigrateOnError option : values) {
            version.getErrorHandling().getErrorHandling().add(option.value());
        }
    }
}
#method_after
private void addMigrateOnErrorOptions(VersionCaps version, MigrateOnError[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_0)) {
        version.setErrorHandling(new org.ovirt.engine.api.model.ErrorHandlingOptions());
        for (MigrateOnError option : values) {
            version.getErrorHandling().getErrorHandling().add(option.value());
        }
    }
}
#end_block

#method_before
protected SchedulingPolicies mapCollection(List<ClusterPolicy> entities) {
    SchedulingPolicies collection = new SchedulingPolicies();
    for (ClusterPolicy entity : entities) {
        collection.getSchedulingPolicies().add(addLinks(populate(map(entity), entity)));
    }
    return collection;
}
#method_after
protected SchedulingPolicies mapCollection(List<ClusterPolicy> entities) {
    SchedulingPolicies collection = new SchedulingPolicies();
    for (ClusterPolicy entity : entities) {
        collection.getSchedulingPolicy().add(addLinks(populate(map(entity), entity)));
    }
    return collection;
}
#end_block

#method_before
@Override
protected void verify(SchedulingPolicyUnit model, SchedulingPolicyUnit transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.isEnabled(), transform.isEnabled());
    assertNotNull(model.getRegexValidationMap());
    assertEquals(CustomPropertiesParser.toMap(model.getRegexValidationMap()), CustomPropertiesParser.toMap(transform.getRegexValidationMap()));
}
#method_after
@Override
protected void verify(SchedulingPolicyUnit model, SchedulingPolicyUnit transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.isEnabled(), transform.isEnabled());
    assertNotNull(model.getPropertiesMetaData());
    assertEquals(CustomPropertiesParser.toMap(model.getPropertiesMetaData()), CustomPropertiesParser.toMap(transform.getPropertiesMetaData()));
}
#end_block

#method_before
@Override
protected void verify(SchedulingPolicy model, SchedulingPolicy transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.isLocked(), transform.isLocked());
    assertEquals(model.isDefaultPolicy(), transform.isDefaultPolicy());
    for (int i = 0; i < model.getFilters().getFilters().size(); i++) {
        assertEquals(model.getFilters().getFilters().get(i).getSchedulingPolicyUnit().getId(), transform.getFilters().getFilters().get(i).getSchedulingPolicyUnit().getId());
        assertEquals(model.getFilters().getFilters().get(i).getPosition(), transform.getFilters().getFilters().get(i).getPosition());
    }
    for (int i = 0; i < model.getWeights().getWeights().size(); i++) {
        assertEquals(model.getWeights().getWeights().get(i).getSchedulingPolicyUnit().getId(), transform.getWeights().getWeights().get(i).getSchedulingPolicyUnit().getId());
        assertEquals(model.getWeights().getWeights().get(i).getFactor(), transform.getWeights().getWeights().get(i).getFactor());
    }
    assertEquals(model.getBalances().getBalances().getSchedulingPolicyUnit().getId(), transform.getBalances().getBalances().getSchedulingPolicyUnit().getId());
    assertNotNull(model.getProperties());
    assertEquals(CustomPropertiesParser.toMap(model.getProperties()), CustomPropertiesParser.toMap(transform.getProperties()));
}
#method_after
@Override
protected void verify(SchedulingPolicy model, SchedulingPolicy transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.isLocked(), transform.isLocked());
    assertEquals(model.isDefaultPolicy(), transform.isDefaultPolicy());
    assertNotNull(model.getProperties());
    assertEquals(CustomPropertiesParser.toMap(model.getProperties()), CustomPropertiesParser.toMap(transform.getProperties()));
}
#end_block

#method_before
protected boolean checkAddEditValidations() {
    List<ClusterPolicy> clusterPolicies = SchedulingManager.getInstance().getClusterPolicies();
    if (getClusterPolicy() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_PARAMETERS_INVALID);
    }
    for (ClusterPolicy clusterPolicy : clusterPolicies) {
        if (!clusterPolicy.getId().equals(getClusterPolicy().getId()) && clusterPolicy.getName().equals(getClusterPolicy().getName())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_NAME_INUSE);
        }
    }
    Map<Guid, PolicyUnitImpl> map = SchedulingManager.getInstance().getPolicyUnitsMap();
    Set<Guid> existingPolicyUnits = new HashSet<>();
    // check filter policy units
    if (getClusterPolicy().getFilters() != null) {
        for (Guid filterId : getClusterPolicy().getFilters()) {
            if (isPolicyUnitExist(filterId, existingPolicyUnits)) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_DUPLICATE_POLICY_UNIT);
            }
            PolicyUnitImpl policyUnitImpl = map.get(filterId);
            if (policyUnitImpl == null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_UNKNOWN_POLICY_UNIT);
            }
            if (policyUnitImpl.getPolicyUnit().getPolicyUnitType() != PolicyUnitType.FILTER) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_FILTER_NOT_IMPLEMENTED);
            }
        }
    }
    // check filters positions (there could be only one filter attached to first (-1) and last (-1)
    if (getClusterPolicy().getFilterPositionMap() != null) {
        boolean hasFirst = false;
        boolean hasLast = false;
        for (Integer position : getClusterPolicy().getFilterPositionMap().values()) {
            if (position == -1) {
                if (!hasFirst) {
                    hasFirst = true;
                } else {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_ONLY_ONE_FILTER_CAN_BE_FIRST);
                }
            } else if (position == 1) {
                if (!hasLast) {
                    hasLast = true;
                } else {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_ONLY_ONE_FILTER_CAN_BE_LAST);
                }
            }
        }
    }
    // check function policy units
    if (getClusterPolicy().getFunctions() != null) {
        for (Pair<Guid, Integer> functionPair : getClusterPolicy().getFunctions()) {
            if (isPolicyUnitExist(functionPair.getFirst(), existingPolicyUnits)) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_DUPLICATE_POLICY_UNIT);
            }
            PolicyUnitImpl policyUnitImpl = map.get(functionPair.getFirst());
            if (policyUnitImpl == null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_UNKNOWN_POLICY_UNIT);
            }
            if (policyUnitImpl.getPolicyUnit().getPolicyUnitType() != PolicyUnitType.WEIGHT) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_FUNCTION_NOT_IMPLEMENTED);
            }
            if (functionPair.getSecond() < 0) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_FUNCTION_FACTOR_NEGATIVE);
            }
        }
    }
    // check balance policy unit
    if (getClusterPolicy().getBalance() != null) {
        PolicyUnitImpl policyUnitImpl = map.get(getClusterPolicy().getBalance());
        if (policyUnitImpl == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_UNKNOWN_POLICY_UNIT);
        }
        if (policyUnitImpl.getPolicyUnit().getPolicyUnitType() != PolicyUnitType.LOAD_BALANCING) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_BALANCE_NOT_IMPLEMENTED);
        }
    }
    List<ValidationError> validationErrors = SimpleCustomPropertiesUtil.getInstance().validateProperties(SchedulingManager.getInstance().getCustomPropertiesRegexMap(getClusterPolicy()), getClusterPolicy().getParameterMap());
    if (!validationErrors.isEmpty()) {
        SimpleCustomPropertiesUtil.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    return true;
}
#method_after
protected boolean checkAddEditValidations() {
    List<ClusterPolicy> clusterPolicies = SchedulingManager.getInstance().getClusterPolicies();
    if (getClusterPolicy() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_PARAMETERS_INVALID);
    }
    for (ClusterPolicy clusterPolicy : clusterPolicies) {
        if (!clusterPolicy.getId().equals(getClusterPolicy().getId()) && clusterPolicy.getName().equals(getClusterPolicy().getName())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_NAME_INUSE);
        }
    }
    Map<Guid, PolicyUnitImpl> map = SchedulingManager.getInstance().getPolicyUnitsMap();
    Set<Guid> existingPolicyUnits = new HashSet<>();
    // check filter policy units
    if (getClusterPolicy().getFilters() != null) {
        for (Guid filterId : getClusterPolicy().getFilters()) {
            if (isPolicyUnitExists(filterId, existingPolicyUnits)) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_DUPLICATE_POLICY_UNIT);
            }
            PolicyUnitImpl policyUnitImpl = map.get(filterId);
            if (policyUnitImpl == null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_UNKNOWN_POLICY_UNIT);
            }
            if (policyUnitImpl.getPolicyUnit().getPolicyUnitType() != PolicyUnitType.FILTER) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_FILTER_NOT_IMPLEMENTED);
            }
        }
    }
    // check filters positions (there could be only one filter attached to first (-1) and last (-1)
    if (getClusterPolicy().getFilterPositionMap() != null) {
        boolean hasFirst = false;
        boolean hasLast = false;
        for (Integer position : getClusterPolicy().getFilterPositionMap().values()) {
            if (position == -1) {
                if (!hasFirst) {
                    hasFirst = true;
                } else {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_ONLY_ONE_FILTER_CAN_BE_FIRST);
                }
            } else if (position == 1) {
                if (!hasLast) {
                    hasLast = true;
                } else {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_ONLY_ONE_FILTER_CAN_BE_LAST);
                }
            }
        }
    }
    // check function policy units
    if (getClusterPolicy().getFunctions() != null) {
        for (Pair<Guid, Integer> functionPair : getClusterPolicy().getFunctions()) {
            if (isPolicyUnitExists(functionPair.getFirst(), existingPolicyUnits)) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_DUPLICATE_POLICY_UNIT);
            }
            PolicyUnitImpl policyUnitImpl = map.get(functionPair.getFirst());
            if (policyUnitImpl == null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_UNKNOWN_POLICY_UNIT);
            }
            if (policyUnitImpl.getPolicyUnit().getPolicyUnitType() != PolicyUnitType.WEIGHT) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_FUNCTION_NOT_IMPLEMENTED);
            }
            if (functionPair.getSecond() < 0) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_FUNCTION_FACTOR_NEGATIVE);
            }
        }
    }
    // check balance policy unit
    if (getClusterPolicy().getBalance() != null) {
        PolicyUnitImpl policyUnitImpl = map.get(getClusterPolicy().getBalance());
        if (policyUnitImpl == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_UNKNOWN_POLICY_UNIT);
        }
        if (policyUnitImpl.getPolicyUnit().getPolicyUnitType() != PolicyUnitType.LOAD_BALANCING) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_POLICY_BALANCE_NOT_IMPLEMENTED);
        }
    }
    List<ValidationError> validationErrors = SimpleCustomPropertiesUtil.getInstance().validateProperties(SchedulingManager.getInstance().getCustomPropertiesRegexMap(getClusterPolicy()), getClusterPolicy().getParameterMap());
    if (!validationErrors.isEmpty()) {
        SimpleCustomPropertiesUtil.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // add user session
    setActionReturnValue(getCurrentUser());
    getReturnValue().setLoginResult(LoginResult.Autheticated);
    // Permissions for this user might been changed since last login so
    // update his isAdmin flag accordingly
    updateUserData();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    setActionReturnValue(getCurrentUser());
    getReturnValue().setLoginResult(LoginResult.Autheticated);
    getReturnValue().setSessionId(engineSessionId);
    // Permissions for this user might been changed since last login so
    // update his isAdmin flag accordingly
    updateUserData();
    setSucceeded(true);
}
#end_block

#method_before
protected boolean attachUserToSession() {
    if (!StringUtils.isEmpty(getParameters().getSessionId())) {
        SessionDataContainer.getInstance().setUser(getParameters().getSessionId(), getCurrentUser());
    } else {
        if (!SessionDataContainer.getInstance().setUser(getCurrentUser())) {
            return failCanDoAction(VdcBllMessages.USER_CANNOT_LOGIN_SESSION_MISSING);
        }
        SessionDataContainer.getInstance().refresh();
        int userSessionHardLimit = Config.<Integer>getValue(ConfigValues.UserSessionHardLimit);
        Date validTo = userSessionHardLimit != 0 ? DateUtils.addMinutes(new Date(), userSessionHardLimit) : null;
        if (authRecord.<String>get(AuthRecord.VALID_TO) != null) {
            try {
                Date fromExtension = new SimpleDateFormat("yyyy-MM-dd HH:mm:ssZ").parse(authRecord.<String>get(AuthRecord.VALID_TO));
                if (validTo != null) {
                    validTo = validTo.compareTo(fromExtension) < 0 ? validTo : fromExtension;
                } else {
                    validTo = fromExtension;
                }
            } catch (ParseException e) {
                log.warn("Error parsing AuthRecord.VALID_TO . Default VALID_TO value will be set on session");
                log.debug("Exception is ", e);
            }
        }
        SessionDataContainer.getInstance().setAuthRecord(authRecord);
        SessionDataContainer.getInstance().setHardLimit(validTo);
    }
    return true;
}
#method_after
protected boolean attachUserToSession() {
    engineSessionId = UUID.randomUUID().toString();
    SessionDataContainer.getInstance().setUser(engineSessionId, getCurrentUser());
    SessionDataContainer.getInstance().refresh(engineSessionId);
    SessionDataContainer.getInstance().setAuthn(engineSessionId, authnExtension);
    if (principal != null) {
        SessionDataContainer.getInstance().setPrincipal(engineSessionId, principal);
    }
    // when trying to log on to virtual machines:
    if (getParameters().getPassword() != null) {
        SessionDataContainer.getInstance().setPassword(engineSessionId, getParameters().getPassword());
    }
    int userSessionHardLimit = Config.<Integer>getValue(ConfigValues.UserSessionHardLimit);
    Date validTo = userSessionHardLimit != 0 ? DateUtils.addMinutes(new Date(), userSessionHardLimit) : null;
    if (authRecord.<String>get(AuthRecord.VALID_TO) != null) {
        try {
            Date fromExtension = new SimpleDateFormat("yyyyMMddHHmmssZ").parse(authRecord.<String>get(AuthRecord.VALID_TO));
            if (validTo != null) {
                validTo = validTo.compareTo(fromExtension) < 0 ? validTo : fromExtension;
            } else {
                validTo = fromExtension;
            }
        } catch (ParseException e) {
            log.warn("Error parsing AuthRecord.VALID_TO . Default VALID_TO value will be set on session");
            log.debug("Exception is ", e);
        }
    }
    SessionDataContainer.getInstance().setHardLimit(engineSessionId, validTo);
    return true;
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    profile = AuthenticationProfileRepository.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    authnExtension = profile.getAuthn();
    if (!isPasswordAuth()) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    DbUser curUser = null;
    String curPassword = null;
    SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        curUser = sessionDataContainer.getUser(false);
        curPassword = sessionDataContainer.getPassword();
    } else {
        curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
        curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
    }
    // verify that in auto login mode , user is not taken from session.
    if (curUser != null && !StringUtils.isEmpty(curPassword)) {
        loginName = curUser.getLoginName();
        password = curPassword;
    }
    // Perform the actual authentication:
    authRecord = authenticate(loginName, password);
    if (authRecord != null) {
        DirectoryUser directoryUser = AuthzUtils.fetchPrincipalRecord(profile.getAuthz(), authRecord);
        if (directoryUser == null) {
            log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
        AcctUtils.reportAuthRecord(Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS, authRecord);
        // Check that the user exists in the database, if it doesn't exist then we need to add it now:
        dbUser = getDbUserDAO().getByExternalId(AuthzUtils.getName(profile.getAuthz()), directoryUser.getId());
        if (dbUser == null) {
            dbUser = new DbUser(directoryUser);
            String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
            dbUser.setGroupIds(groupIds);
            dbUser.setId(Guid.newGuid());
            getDbUserDAO().save(dbUser);
        }
        // except the login command
        if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
            AcctUtils.reportAuthRecord(Acct.ReportReason.PRINCIPAL_LOGIN_NO_PERMISSION, authRecord);
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Retrieve the MLA admin status of the user.
        // This may be redundant in some use-cases, but looking forward to Single Sign On,
        // we will want this info
        boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
        log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
        dbUser.setAdmin(isAdmin);
        setCurrentUser(dbUser);
        // Add the user password to the session, as it will be needed later
        // when trying to log on to virtual machines:
        SessionDataContainer.getInstance().setPassword(password);
        return true;
    }
    return false;
// Check that the user exists in the directory associated to the authentication profile:
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    profile = AuthenticationProfileRepository.getInstance().getProfile(getParameters().getProfileName());
    if (profile == null) {
        log.errorFormat("Can't login because authentication profile \"{1}\" doesn't exist.", profile);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    authnExtension = profile.getAuthn();
    authRecord = (ExtMap) getParameters().getAuthRecord();
    int reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
    if (getParameters().getAuthType() != null) {
        if (AuthType.NEGOTIATION == getParameters().getAuthType()) {
            reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_NEGOTIATE;
        }
    }
    String loginName = null;
    if (authRecord == null) {
        reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
        // Verify that the login name and password have been provided:
        loginName = getParameters().getLoginName();
        if (loginName == null) {
            log.errorFormat("Can't login user because no login name has been provided.");
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        String password = getParameters().getPassword();
        if (password == null) {
            log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
            return false;
        }
        if (!isPasswordAuth()) {
            log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profile.getName());
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        DbUser curUser = null;
        String curPassword = null;
        SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
        if (StringUtils.isEmpty(getParameters().getSessionId())) {
            curUser = sessionDataContainer.getUser(engineSessionId, false);
            curPassword = sessionDataContainer.getPassword(engineSessionId);
        } else {
            curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
            curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
        }
        // verify that in auto login mode , user is not taken from session.
        if (curUser != null && !StringUtils.isEmpty(curPassword)) {
            loginName = curUser.getLoginName();
            password = curPassword;
        }
        authenticate(loginName, password);
    }
    // Perform the actual authentication:
    if (authRecord != null) {
        ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord(profile.getAuthz(), authRecord);
        if (principalRecord == null) {
            log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", authRecord.<String>get(Authn.AuthRecord.PRINCIPAL), profile.getName());
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_WAS_NOT_FOUND, loginName, authRecord, null, "Principal record was not found. User name is %1$s", loginName);
            return false;
        }
        DirectoryUser directoryUser = AuthzUtils.mapPrincipalRecord(profile.getAuthz(), principalRecord);
        // Check that the user exists in the database, if it doesn't exist then we need to add it now:
        DbUser dbUser = getDbUserDAO().getByExternalId(AuthzUtils.getName(profile.getAuthz()), directoryUser.getId());
        if (dbUser == null) {
            dbUser = new DbUser(directoryUser);
            dbUser.setId(Guid.newGuid());
        }
        dbUser.setGroupIds(DirectoryUtils.getGroupIdsFromUser(directoryUser));
        getDbUserDAO().saveOrUpdate(dbUser);
        // except the login command
        if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
            AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_LOGIN_NO_PERMISSION, dbUser.getLoginName(), authRecord, principalRecord, "The user %1$s is not authorized to perform login", dbUser.getLoginName());
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Retrieve the MLA admin status of the user.
        // This may be redundant in some use-cases, but looking forward to Single Sign On,
        // we will want this info
        boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
        log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
        dbUser.setAdmin(isAdmin);
        setCurrentUser(dbUser);
        AcctUtils.reportRecords(reportReason, dbUser.getLoginName(), authRecord, principalRecord, "User %1$s which has princnipal name %2$s logged in ", dbUser.getLoginName(), principalRecord.<String>get(Authz.PrincipalRecord.NAME));
        return true;
    }
    return false;
// Check that the user exists in the directory associated to the authentication profile:
}
#end_block

#method_before
private ExtMap authenticate(String user, String password) {
    ExtensionProxy mapper = profile.getMapper();
    if (mapper != null) {
        user = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_USER).mput(Mapping.InvokeKeys.USER, user), true).<String>get(Mapping.InvokeKeys.USER, user);
    }
    ExtMap outputMap = authnExtension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, password));
    ExtMap result = outputMap.<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD);
    int authResult = outputMap.<Integer>get(Authn.InvokeKeys.RESULT);
    Integer reportReason = authResultToReportReasonMap.get(authResult);
    if (reportReason == null) {
        reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_FAILED;
    }
    AcctUtils.reportAuthRecord(reportReason, result);
    if (authResult != Authn.AuthResult.SUCCESS) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", user, getParameters().getProfileName());
        AuditLogType auditLogType = auditLogMap.get(authResult);
        // anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            logEventForUser(user, auditLogType);
        }
        if (authResult == Authn.AuthResult.CREDENTIALS_EXPIRED) {
            boolean addedUserPasswordExpiredCDA = false;
            if (outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                addCanDoActionMessage(String.format("$URL %1$s", outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL)));
                addedUserPasswordExpiredCDA = true;
            }
            if (outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                addCanDoActionMessage(String.format("$MSG %1$s", outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE)));
                addedUserPasswordExpiredCDA = true;
            }
            if (!addedUserPasswordExpiredCDA) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED);
            }
        } else {
            addCanDoActionMessage(vdcBllMessagesMap.get(authResult));
        }
        result = null;
    } else {
        result = outputMap.<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD);
        if (mapper != null) {
            result = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, result), true).<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD, result);
        }
    }
    return result;
}
#method_after
private void authenticate(String user, String password) {
    ExtensionProxy mapper = profile.getMapper();
    if (mapper != null) {
        user = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_USER).mput(Mapping.InvokeKeys.USER, user), true).<String>get(Mapping.InvokeKeys.USER, user);
    }
    ExtMap outputMap = authnExtension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, password));
    principal = outputMap.<String>get(Authn.InvokeKeys.PRINCIPAL);
    int authResult = outputMap.<Integer>get(Authn.InvokeKeys.RESULT);
    if (authResult != Authn.AuthResult.SUCCESS) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", user, getParameters().getProfileName());
        AuditLogType auditLogType = auditLogMap.get(authResult);
        // anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            logEventForUser(user, auditLogType);
        }
        if (authResult == Authn.AuthResult.CREDENTIALS_EXPIRED) {
            boolean addedUserPasswordExpiredCDA = false;
            if (outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                addCanDoActionMessage(String.format("$URL %1$s", outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL)));
                addedUserPasswordExpiredCDA = true;
            }
            if (outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                addCanDoActionMessage(String.format("$MSG %1$s", outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE)));
                addedUserPasswordExpiredCDA = true;
            }
            if (!addedUserPasswordExpiredCDA) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED);
            }
        } else {
            VdcBllMessages msg = vdcBllMessagesMap.get(authResult);
            if (msg == null) {
                msg = VdcBllMessages.USER_FAILED_TO_AUTHENTICATE;
            }
            addCanDoActionMessage(msg);
        }
    } else {
        authRecord = outputMap.<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD);
        if (mapper != null) {
            authRecord = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
        }
    }
}
#end_block

#method_before
@Override
public void initialize() {
    log.info("Start initializing " + getClass().getSimpleName());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    log.info("Running ovirt-engine " + Config.<String>getValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.InitDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initOsRepository();
    initSearchDependencies();
    initHandlers();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark incomplete jobs as {0}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>getValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    poolMonitoringJobId = SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    int autoStartVmsRunnerIntervalInSeconds = Config.<Integer>getValue(ConfigValues.AutoStartVmsRunnerIntervalInSeconds);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(AutoStartVmsRunner.getInstance(), "startFailedAutoStartVms", new Class[] {}, new Object[] {}, autoStartVmsRunnerIntervalInSeconds, autoStartVmsRunnerIntervalInSeconds, TimeUnit.SECONDS);
    int quotaCacheIntervalInMinutes = Config.<Integer>getValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    // initializes attestation
    initAttestation();
    Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {

        @Override
        public void run() {
            AcctUtils.reportReason(Acct.ReportReason.SHUTDOWN);
        }
    }));
    AcctUtils.reportReason(Acct.ReportReason.STARTUP);
}
#method_after
@Override
public void initialize() {
    log.info("Start initializing " + getClass().getSimpleName());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    log.info("Running ovirt-engine " + Config.<String>getValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.InitDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initOsRepository();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark incomplete jobs as {0}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>getValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    poolMonitoringJobId = SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    int autoStartVmsRunnerIntervalInSeconds = Config.<Integer>getValue(ConfigValues.AutoStartVmsRunnerIntervalInSeconds);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(AutoStartVmsRunner.getInstance(), "startFailedAutoStartVms", new Class[] {}, new Object[] {}, autoStartVmsRunnerIntervalInSeconds, autoStartVmsRunnerIntervalInSeconds, TimeUnit.SECONDS);
    int quotaCacheIntervalInMinutes = Config.<Integer>getValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    // initializes attestation
    initAttestation();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringUtils.isEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            return getErrorQueryReturnValue(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        }
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = (DbFacade.getInstance().getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion)).getoption_value();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.execute();
    return command.getQueryReturnValue();
}
#method_after
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = parameters.getSessionId();
        if (StringUtils.isEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            return getErrorQueryReturnValue(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        }
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = (DbFacade.getInstance().getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion)).getoption_value();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.execute();
    return command.getQueryReturnValue();
}
#end_block

#method_before
public ArrayList<VdcReturnValueBase> runMultipleActionsImpl(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isInternal, boolean isRunOnlyIfAllCanDoPass, boolean isWaitForResult, ExecutionContext executionContext) {
    String sessionId = ThreadLocalParamsContainer.getHttpSessionId();
    if (!StringUtils.isEmpty(sessionId)) {
        for (VdcActionParametersBase parameter : parameters) {
            if (StringUtils.isEmpty(parameter.getSessionId())) {
                parameter.setSessionId(sessionId);
            }
        }
    }
    MultipleActionsRunner runner = MultipleActionsRunnersFactory.createMultipleActionsRunner(actionType, parameters, isInternal);
    runner.setExecutionContext(executionContext);
    runner.setIsRunOnlyIfAllCanDoPass(isRunOnlyIfAllCanDoPass);
    runner.setIsWaitForResult(isWaitForResult);
    return runner.execute();
}
#method_after
public ArrayList<VdcReturnValueBase> runMultipleActionsImpl(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isInternal, boolean isRunOnlyIfAllCanDoPass, boolean isWaitForResult, ExecutionContext executionContext) {
    MultipleActionsRunner runner = MultipleActionsRunnersFactory.createMultipleActionsRunner(actionType, parameters, isInternal);
    runner.setExecutionContext(executionContext);
    runner.setIsRunOnlyIfAllCanDoPass(isRunOnlyIfAllCanDoPass);
    runner.setIsWaitForResult(isWaitForResult);
    return runner.execute();
}
#end_block

#method_before
@Override
public VdcQueryReturnValue runPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetDomainList:
        case RegisterVds:
        case CheckDBConnection:
        case ValidateSession:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
            if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion || configParameters.getConfigValue() == ConfigurationValues.ApplicationMode || configParameters.getConfigValue() == ConfigurationValues.UserMessageOfTheDay || configParameters.getConfigValue() == ConfigurationValues.UserSessionTimeOutInterval) {
                return runQueryImpl(actionType, parameters, false);
            }
            return getErrorQueryReturnValue(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
        default:
            return getErrorQueryReturnValue(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
    }
}
#method_after
@Override
public VdcQueryReturnValue runPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetAAAProfileList:
        case RegisterVds:
        case CheckDBConnection:
        case GetValueBySession:
        case ValidateSession:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
            if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion || configParameters.getConfigValue() == ConfigurationValues.ApplicationMode || configParameters.getConfigValue() == ConfigurationValues.UserMessageOfTheDay || configParameters.getConfigValue() == ConfigurationValues.UserSessionTimeOutInterval) {
                return runQueryImpl(actionType, parameters, false);
            }
            return getErrorQueryReturnValue(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
        default:
            return getErrorQueryReturnValue(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
    }
}
#end_block

#method_before
public final Object getData(String sessionId, String key, boolean refresh) {
    SessionInfo sessionInfo = getSessionInfo(sessionId);
    Object value = null;
    if (sessionInfo != null) {
        if (refresh) {
            refresh(sessionInfo);
        }
        value = sessionInfo.contentOfSession.get(key);
    }
    return value;
}
#method_after
public final Object getData(String sessionId, String key, boolean refresh) {
    if (sessionId == null) {
        return null;
    }
    SessionInfo sessionInfo = getSessionInfo(sessionId);
    Object value = null;
    if (sessionInfo != null) {
        if (refresh) {
            refresh(sessionInfo);
        }
        value = sessionInfo.contentOfSession.get(key);
    }
    return value;
}
#end_block

#method_before
@OnTimerMethodAnnotation("cleanExpiredUsersSessions")
public final void cleanExpiredUsersSessions() {
    Date now = new Date();
    Iterator<Entry<String, SessionInfo>> iterator = sessionInfoMap.entrySet().iterator();
    while (iterator.hasNext()) {
        Entry<String, SessionInfo> entryMap = iterator.next();
        ConcurrentMap<String, Object> sessionMap = entryMap.getValue().contentOfSession;
        Date hardLimit = (Date) sessionMap.get(HARD_LIMIT_PARAMETER_NAME);
        Date softLimit = (Date) sessionMap.get(SOFT_LIMIT_PARAMETER_NAME);
        if (hardLimit != null) {
            if (hardLimit.before(now)) {
                reportSessionRemoval(entryMap.getKey(), Acct.ReportReason.PRINCIPAL_SESSION_EXPIRED);
                iterator.remove();
            }
        }
        if (softLimit != null) {
            reportSessionRemoval(entryMap.getKey(), Acct.ReportReason.PRINCIPAL_SESSION_EXPIRED);
            if (softLimit.before(now)) {
                iterator.remove();
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("cleanExpiredUsersSessions")
public final void cleanExpiredUsersSessions() {
    Date now = new Date();
    Iterator<Entry<String, SessionInfo>> iter = sessionInfoMap.entrySet().iterator();
    while (iter.hasNext()) {
        Entry<String, SessionInfo> entry = iter.next();
        ConcurrentMap<String, Object> sessionMap = entry.getValue().contentOfSession;
        Date hardLimit = (Date) sessionMap.get(HARD_LIMIT_PARAMETER_NAME);
        Date softLimit = (Date) sessionMap.get(SOFT_LIMIT_PARAMETER_NAME);
        if ((hardLimit != null && hardLimit.before(now)) || (softLimit != null && softLimit.before(now))) {
            removeSessionImpl(entry.getKey(), Acct.ReportReason.PRINCIPAL_SESSION_EXPIRED, "Session has expired for principal %1$s", getPrincipal(entry.getKey()));
        }
    }
}
#end_block

#method_before
public final void setHardLimit(Date hardLimit) {
    setData(HARD_LIMIT_PARAMETER_NAME, hardLimit);
}
#method_after
public final void setHardLimit(String sessionId, Date hardLimit) {
    setData(sessionId, HARD_LIMIT_PARAMETER_NAME, hardLimit);
}
#end_block

#method_before
public final void setSoftLimit(Date softLimit) {
    setData(SOFT_LIMIT_PARAMETER_NAME, softLimit);
}
#method_after
public final void setSoftLimit(String sessionId, Date softLimit) {
    setData(sessionId, SOFT_LIMIT_PARAMETER_NAME, softLimit);
}
#end_block

#method_before
public void setPassword(String password) {
    setData(PASSWORD_PARAMETER_NAME, password);
}
#method_after
public void setPassword(String sessionId, String password) {
    setData(sessionId, PASSWORD_PARAMETER_NAME, password);
}
#end_block

#method_before
private void refresh(SessionInfo sessionInfo) {
    int softLimitValue = Config.<Integer>getValue(ConfigValues.UserSessionTimeOutInterval);
    if (softLimitValue > 0) {
        sessionInfo.contentOfSession.put(SOFT_LIMIT_PARAMETER_NAME, DateUtils.addMinutes(new Date(), softLimitValue));
    }
}
#method_after
public void refresh(String sessionId) {
    refresh(getSessionInfo(sessionId));
}
#end_block

#method_before
public static void report(ExtMap input) {
    List<ExtensionProxy> acctExtensions = ExtensionsManager.getInstance().getProvidedExtensions(Acct.class.getName());
    input.putIfAbsent(Base.InvokeKeys.COMMAND, Acct.InvokeCommands.REPORT);
    if (acctExtensions != null) {
        for (ExtensionProxy proxy : acctExtensions) {
            proxy.invoke(input);
        }
    }
}
#method_after
public static void report(ExtMap input) {
    List<ExtensionProxy> acctExtensions = EngineExtensionsManager.getInstance().getExtensionsByService(Acct.class.getName());
    input.putIfAbsent(Base.InvokeKeys.COMMAND, Acct.InvokeCommands.REPORT);
    if (acctExtensions != null) {
        for (ExtensionProxy proxy : acctExtensions) {
            proxy.invoke(input);
        }
    }
}
#end_block

#method_before
public static void reportReason(int reportReason) {
    ExtMap input = new ExtMap().mput(Acct.InvokeKeys.REASON, reportReason);
    report(input);
}
#method_after
public static void reportReason(int reportReason, String message, Object... msgArgs) {
    ExtMap input = new ExtMap().mput(Acct.InvokeKeys.REASON, reportReason).mput(Acct.InvokeKeys.MESSAGE, String.format(message, msgArgs));
    report(input);
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
        } else {
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            setCommandStatus(CommandStatus.SUCCEEDED);
            internalEndSuccessfully();
        } else {
            setCommandStatus(CommandStatus.FAILED);
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#method_after
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#end_block

#method_before
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (isInternalExecution() || !isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#method_after
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (!isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#end_block

#method_before
private boolean isQuotaDependant() {
    return getActionType().getQuotaDependency() != VdcActionType.QuotaDependency.NONE;
}
#method_after
protected boolean isQuotaDependant() {
    boolean result;
    if (getActionType().getQuotaDependency() == VdcActionType.QuotaDependency.NONE)
        result = false;
    else if (!isInternalExecution())
        result = true;
    else if (getActionType().isQuotaDependentAsInternalCommand())
        result = true;
    else
        result = false;
    return result;
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, String groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, groupIds, actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, HashSet<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#end_block

#method_before
protected final void execute() {
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
protected AsyncTaskType getTaskType() {
    throw new UnsupportedOperationException();
}
#method_after
protected AsyncTaskType getTaskType() {
    return AsyncTaskType.notSupported;
}
#end_block

#method_before
public AsyncTaskType getAsyncTaskType() {
    return getTaskType();
}
#method_after
public AsyncTaskType getAsyncTaskType() {
    if (getTaskType() == AsyncTaskType.notSupported) {
        throw new UnsupportedOperationException();
    }
    return getTaskType();
}
#end_block

#method_before
protected void persistCommand() {
    TaskManagerUtil.persistCommand(getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), getActionType(), getParameters());
}
#method_after
protected void persistCommand(VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    TaskManagerUtil.persistCommand(getCommandId(), parentParameters.getCommandId(), getActionType(), getParameters(), commandStatus);
}
#end_block

#method_before
public <P extends VdcActionParametersBase> CommandBase<P> createCommand(VdcActionType action, P parameters) {
    return CommandsFactory.getInstance().createCommand(action, parameters);
}
#method_after
public <P extends VdcActionParametersBase> CommandBase<P> createCommand(VdcActionType action, P parameters) {
    return CommandsFactory.createCommand(action, parameters);
}
#end_block

#method_before
public Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Step taskStep = ExecutionHandler.addTaskStep(command.getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
    if (taskStep != null) {
        asyncTaskCreationInfo.setStepId(taskStep.getId());
    }
    SPMAsyncTask task = concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
    task.setEntitiesMap(entitiesMap);
    AsyncTaskUtils.addOrUpdateTaskInDB(task);
    persistCommand(command.getCommandId(), command.getParameters().getParentParameters() == null ? Guid.Empty : command.getParameters().getParentParameters().getCommandId(), task.getParameters().getDbAsyncTask().getActionParameters().getCommandType(), task.getParameters().getDbAsyncTask().getActionParameters());
    getAsyncTaskManager().lockAndAddTaskToManager(task);
    Guid vdsmTaskId = task.getVdsmTaskId();
    ExecutionHandler.updateStepExternalId(taskStep, vdsmTaskId, ExternalSystemType.VDSM);
    return vdsmTaskId;
}
#method_after
public Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Step taskStep = ExecutionHandler.addTaskStep(command.getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
    if (taskStep != null) {
        asyncTaskCreationInfo.setStepId(taskStep.getId());
    }
    SPMAsyncTask task = concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
    task.setEntitiesMap(entitiesMap);
    AsyncTaskUtils.addOrUpdateTaskInDB(task);
    persistCommand(command.getCommandId(), task.getParameters().getDbAsyncTask().getRootCommandId(), task.getParameters().getDbAsyncTask().getActionParameters().getCommandType(), task.getParameters().getDbAsyncTask().getActionParameters(), command.getCommandStatus());
    getAsyncTaskManager().lockAndAddTaskToManager(task);
    Guid vdsmTaskId = task.getVdsmTaskId();
    ExecutionHandler.updateStepExternalId(taskStep, vdsmTaskId, ExternalSystemType.VDSM);
    return vdsmTaskId;
}
#end_block

#method_before
public void persistCommand(Guid commandId, Guid parentCommandId, VdcActionType actionType, VdcActionParametersBase params) {
    commandsCache.put(commandId, parentCommandId, actionType, params);
}
#method_after
@Override
public void persistCommand(Guid commandId, Guid rootCommandId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status) {
    commandsCache.put(commandId, rootCommandId, actionType, params, status);
}
#end_block

#method_before
public CommandBase<?> retrieveCommand(Guid commandId) {
    CommandBase<?> command = null;
    CommandEntity cmdEntity = commandsCache.get(commandId);
    if (cmdEntity != null) {
        command = CommandsFactory.getInstance().createCommand(cmdEntity.getCommandType(), CommandEntityUtils.getParameters(cmdEntity));
        // if the parentCommand Id is not null but parent parameters is null we rebuild the command hierarchy
        if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && command.getParameters().getParentParameters() == null) {
            CommandBase<?> parentCommand = retrieveCommand(cmdEntity.getParentCommandId());
            if (parentCommand != null) {
                command.getParameters().setParentParameters(parentCommand.getParameters());
            }
        }
    }
    return command;
}
#method_after
@Override
public CommandBase<?> retrieveCommand(Guid commandId) {
    CommandBase<?> command = null;
    CommandEntity cmdEntity = commandsCache.get(commandId);
    if (cmdEntity != null) {
        command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getActionParameters());
    }
    return command;
}
#end_block

#method_before
protected void revertTasks(CommandBase command) {
    if (command.getParameters().getVdsmTaskIds() != null) {
        // list to send to the pollTasks method
        ArrayList<Guid> taskIdAsList = new ArrayList<Guid>();
        for (Guid taskId : command.getParameters().getVdsmTaskIds()) {
            taskIdAsList.add(taskId);
            ArrayList<AsyncTaskStatus> tasksStatuses = getAsyncTaskManager().pollTasks(taskIdAsList);
            // call revert task only if ended successfully
            if (tasksStatuses.get(0).getTaskEndedSuccessfully()) {
                getBackend().getResourceManager().RunVdsCommand(VDSCommandType.SPMRevertTask, new SPMTaskGuidBaseVDSCommandParameters(command.getStoragePool().getId(), taskId));
            }
            taskIdAsList.clear();
        }
    }
}
#method_after
public void revertTasks(CommandBase command) {
    if (command.getParameters().getVdsmTaskIds() != null) {
        // list to send to the pollTasks method
        ArrayList<Guid> taskIdAsList = new ArrayList<Guid>();
        for (Guid taskId : command.getParameters().getVdsmTaskIds()) {
            taskIdAsList.add(taskId);
            ArrayList<AsyncTaskStatus> tasksStatuses = getAsyncTaskManager().pollTasks(taskIdAsList);
            // call revert task only if ended successfully
            if (tasksStatuses.get(0).getTaskEndedSuccessfully()) {
                getBackend().getResourceManager().RunVdsCommand(VDSCommandType.SPMRevertTask, new SPMTaskGuidBaseVDSCommandParameters(command.getStoragePool().getId(), taskId));
            }
            taskIdAsList.clear();
        }
    }
}
#end_block

#method_before
public VdcReturnValueBase endAction(SPMTask task) {
    AsyncTasks dbAsyncTask = task.getParameters().getDbAsyncTask();
    Guid stepId = dbAsyncTask.getStepId();
    VdcActionType actionType = getEndActionType(dbAsyncTask);
    Guid commandId = dbAsyncTask.getActionParameters().getCommandId();
    VdcActionParametersBase parameters = dbAsyncTask.getActionParameters();
    try {
        ExecutionContext context = null;
        if (stepId != null) {
            context = createFinalizingContext(stepId);
            executionContextMap.put(stepId, context);
            CommandEntity commandEntity = commandsCache.get(commandId);
            if (!actionType.equals(commandEntity.getCommandType())) {
                throw new RuntimeException("action types don't match");
            } else {
                log.info("in CommandManager.endAction action types match " + actionType.toString());
            }
            if (!parameters.equals(CommandEntityUtils.getParameters(commandEntity))) {
                throw new RuntimeException("parameters dont match");
            } else {
                log.info("in CommandManager.endAction parameters match " + parameters.toString());
            }
        }
        CommandBase<?> command = retrieveCommand(commandId);
        command.setContext(new CommandContext(context));
        return new DecoratedCommand(this, command, (CommandAsyncTask) task).endAction();
    } finally {
        commandsCache.remove(commandId);
    }
}
#method_after
public VdcReturnValueBase endAction(SPMTask task, ExecutionContext context) {
    AsyncTasks dbAsyncTask = task.getParameters().getDbAsyncTask();
    VdcActionType actionType = getEndActionType(dbAsyncTask);
    VdcActionParametersBase parameters = dbAsyncTask.getActionParameters();
    CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters);
    command.setContext(new CommandContext(context));
    return new DecoratedCommand(command).endAction();
}
#end_block

#method_before
public void initializeCache() {
    List<CommandEntity> cmdEntities = cmdEntityDao.getAll();
    for (CommandEntity cmdEntity : cmdEntities) {
        commandMap.put(cmdEntity.getId(), cmdEntity);
    }
}
#method_after
private void initializeCache() {
    if (!cacheInitialized) {
        synchronized (LOCK) {
            List<CommandEntity> cmdEntities = cmdEntityDao.getAll();
            for (CommandEntity cmdEntity : cmdEntities) {
                commandMap.put(cmdEntity.getId(), cmdEntity);
            }
            cacheInitialized = true;
        }
    }
}
#end_block

#method_before
@Override
public synchronized CommandEntity get(Guid commandId) {
    if (!cacheInitialized) {
        initializeCache();
        cacheInitialized = true;
    }
    return commandMap.get(commandId);
}
#method_after
@Override
public CommandEntity get(Guid commandId) {
    initializeCache();
    return commandMap.get(commandId);
}
#end_block

#method_before
@Override
public synchronized void remove(Guid commandId) {
    commandMap.remove(commandId);
    cmdEntityDao.remove(commandId);
}
#method_after
@Override
public void remove(Guid commandId) {
    commandMap.remove(commandId);
    cmdEntityDao.remove(commandId);
}
#end_block

#method_before
@Override
public synchronized void put(Guid commandId, Guid parentCommandId, VdcActionType actionType, VdcActionParametersBase params) {
    CommandEntity cmdEntity = buildGetCommandEntity(commandId, parentCommandId, actionType, params);
    commandMap.put(commandId, cmdEntity);
    cmdEntityDao.save(cmdEntity);
}
#method_after
@Override
public void put(Guid commandId, Guid rootCommandId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status) {
    CommandEntity cmdEntity = buildCommandEntity(commandId, rootCommandId, actionType, params, status);
    commandMap.put(commandId, cmdEntity);
    cmdEntityDao.saveOrUpdate(cmdEntity);
}
#end_block

#method_before
public static Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return CommandCoordinatorImpl.getInstance().createTask(taskId, command, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#method_after
public static Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return coco.createTask(taskId, command, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#end_block

#method_before
public static SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return CommandCoordinatorImpl.getInstance().concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public static SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public static void cancelTasks(final CommandBase command) {
    CommandCoordinatorImpl.getInstance().cancelTasks(command);
}
#method_after
public static void cancelTasks(final CommandBase command) {
    coco.cancelTasks(command);
}
#end_block

#method_before
public static void revertTasks(final CommandBase command) {
    CommandCoordinatorImpl.getInstance().revertTasks(command);
}
#method_after
public static void revertTasks(final CommandBase command) {
    coco.revertTasks(command);
}
#end_block

#method_before
public static AsyncTasks getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return CommandCoordinatorImpl.getInstance().getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public static AsyncTasks getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public static AsyncTasks createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return CommandCoordinatorImpl.getInstance().createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public static AsyncTasks createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public static void persistCommand(Guid commandId, Guid parentCommandId, VdcActionType actionType, VdcActionParametersBase params) {
    CommandCoordinatorImpl.getInstance().persistCommand(commandId, parentCommandId, actionType, params);
}
#method_after
public static void persistCommand(Guid commandId, Guid rootCommandId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status) {
    coco.persistCommand(commandId, rootCommandId, actionType, params, status);
}
#end_block

#method_before
private static AsyncTaskManager getAsyncTaskManager() {
    return AsyncTaskManager.getInstance(CommandCoordinatorImpl.getInstance());
}
#method_after
private static AsyncTaskManager getAsyncTaskManager() {
    return AsyncTaskManager.getInstance(coco);
}
#end_block

#method_before
@Override
protected CommandEntity generateNewEntity() {
    CommandEntity commandEntity = new CommandEntity();
    commandEntity.setCommandType(VdcActionType.AddVm);
    commandEntity.setCreatedAt(new Date(System.currentTimeMillis()));
    commandEntity.setId(Guid.newGuid());
    commandEntity.setParentCommandId(null);
    Map<String, Object> data = new HashMap<String, Object>();
    data.put("name", "oVirt");
    commandEntity.setData(data);
    return commandEntity;
}
#method_after
@Override
protected CommandEntity generateNewEntity() {
    CommandEntity commandEntity = new CommandEntity();
    commandEntity.setCommandType(VdcActionType.AddBond);
    commandEntity.setCreatedAt(new Date(System.currentTimeMillis()));
    commandEntity.setId(Guid.newGuid());
    commandEntity.setCommandStatus(CommandStatus.ACTIVE);
    VdcActionParametersBase params = new VdcActionParametersBase();
    commandEntity.setActionParameters(params);
    return commandEntity;
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(CommandEntity entity) {
    return getCustomMapSqlParameterSource().addValue("command_id", entity.getId()).addValue("command_type", entity.getCommandType()).addValue("parent_command_id", entity.getParentCommandId()).addValue("data", serializeData(entity.getData())).addValue("created_at", entity.getCreatedAt());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(CommandEntity entity) {
    return getCustomMapSqlParameterSource().addValue("command_id", entity.getId()).addValue("command_type", entity.getCommandType().getValue()).addValue("root_command_id", entity.getRootCommandId()).addValue("action_parameters", serializeParameters(entity.getActionParameters())).addValue("action_parameters_class", entity.getActionParameters() == null ? null : entity.getActionParameters().getClass().getName()).addValue("status", entity.getCommandStatus().toString());
}
#end_block

#method_before
private void localize(ApplicationConstants constants) {
    bricks.setLabel(constants.selectBrickToViewFopStats());
    nfsServers.setLabel(constants.selectServerToViewFopStats());
    bricksTab.setLabel(constants.volumeProfileBricksTab());
    nfsTab.setLabel(constants.volumeProfileNfsTab());
}
#method_after
private void localize(ApplicationConstants constants, ApplicationMessages messages) {
    bricks.setLabel(constants.selectBrickToViewFopStats());
    nfsServers.setLabel(constants.selectServerToViewFopStats());
    bricksTab.setLabel(constants.volumeProfileBricksTab());
    nfsTab.setLabel(constants.volumeProfileNfsTab());
    bricksErrorLabel.setText(constants.brickProfileErrorMessage());
    nfsErrorLabel.setText(constants.nfsProfileErrorMessage());
}
#end_block

#method_before
private void initEditors(ApplicationConstants constants, ApplicationResources resources) {
    nfsRefreshIcon = new RefreshActionIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    brickRefreshIcon = new RefreshActionIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    bricks = new ListModelListBoxEditor<BrickProfileDetails>(new NullSafeRenderer<BrickProfileDetails>() {

        @Override
        protected String renderNullSafe(BrickProfileDetails object) {
            return object.getBrickName();
        }
    });
    nfsServers = new ListModelListBoxEditor<NfsProfileDetails>(new NullSafeRenderer<NfsProfileDetails>() {

        @Override
        protected String renderNullSafe(NfsProfileDetails object) {
            return object.getNfsServerIp();
        }
    });
    volumeProfileStats = new EntityModelCellTable<ListModel>(false, true);
    volumeProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            return entity.getName();
        }
    }, constants.fileOperation());
    volumeProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            return entity.getHits() + "";
        }
    }, constants.fOpInvocationCount());
    /*
         * volumeProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {
         *
         * @Override protected String getText(FopStats entity) { return ""; } }, constants.fOpLatency());
         */
    volumeProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            // $NON-NLS-1$
            return entity.getMaxLatencyFormatted().getFirst() + " " + entity.getMaxLatencyFormatted().getSecond();
        }
    }, constants.fOpMaxLatency());
    volumeProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            // $NON-NLS-1$
            return entity.getMinLatencyFormatted().getFirst() + " " + entity.getMinLatencyFormatted().getSecond();
        }
    }, constants.fOpMinLatency());
    volumeProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            // $NON-NLS-1$
            return entity.getAvgLatencyFormatted().getFirst() + " " + entity.getAvgLatencyFormatted().getSecond();
        }
    }, constants.fOpAvgLatency());
    nfsServerProfileStats = new EntityModelCellTable<ListModel>(false, true);
    nfsServerProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            return entity.getName();
        }
    }, constants.fileOperation());
    nfsServerProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            return entity.getHits() + "";
        }
    }, constants.fOpInvocationCount());
    /*
         * nfsServerProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {
         *
         * @Override protected String getText(FopStats entity) { return ""; } }, constants.fOpLatency());
         */
    nfsServerProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            // $NON-NLS-1$
            return entity.getMaxLatencyFormatted().getFirst() + " " + entity.getMaxLatencyFormatted().getSecond();
        }
    }, constants.fOpMaxLatency());
    nfsServerProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            // $NON-NLS-1$
            return entity.getMinLatencyFormatted().getFirst() + " " + entity.getMinLatencyFormatted().getSecond();
        }
    }, constants.fOpMinLatency());
    nfsServerProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            // $NON-NLS-1$
            return entity.getAvgLatencyFormatted().getFirst() + " " + entity.getAvgLatencyFormatted().getSecond();
        }
    }, constants.fOpAvgLatency());
}
#method_after
private void initEditors(ApplicationConstants constants, ApplicationResources resources) {
    nfsRefreshIcon = new RefreshActionIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    brickRefreshIcon = new RefreshActionIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    bricks = new ListModelListBoxEditor<BrickProfileDetails>(new NullSafeRenderer<BrickProfileDetails>() {

        @Override
        protected String renderNullSafe(BrickProfileDetails object) {
            return object.getName();
        }
    });
    nfsServers = new ListModelListBoxEditor<GlusterVolumeProfileStats>(new NullSafeRenderer<GlusterVolumeProfileStats>() {

        @Override
        protected String renderNullSafe(GlusterVolumeProfileStats object) {
            return object.getName();
        }
    });
    volumeProfileStats = new EntityModelCellTable<ListModel>(false, true);
    volumeProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            return entity.getName();
        }
    }, constants.fileOperation());
    volumeProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            return entity.getHits() + "";
        }
    }, constants.fOpInvocationCount());
    volumeProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            // $NON-NLS-1$
            return entity.getMaxLatencyFormatted().getFirst() + " " + entity.getMaxLatencyFormatted().getSecond();
        }
    }, constants.fOpMaxLatency());
    volumeProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            // $NON-NLS-1$
            return entity.getMinLatencyFormatted().getFirst() + " " + entity.getMinLatencyFormatted().getSecond();
        }
    }, constants.fOpMinLatency());
    volumeProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            // $NON-NLS-1$
            return entity.getAvgLatencyFormatted().getFirst() + " " + entity.getAvgLatencyFormatted().getSecond();
        }
    }, constants.fOpAvgLatency());
    nfsServerProfileStats = new EntityModelCellTable<ListModel>(false, true);
    nfsServerProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            return entity.getName();
        }
    }, constants.fileOperation());
    nfsServerProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            return entity.getHits() + "";
        }
    }, constants.fOpInvocationCount());
    nfsServerProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            // $NON-NLS-1$
            return entity.getMaxLatencyFormatted().getFirst() + " " + entity.getMaxLatencyFormatted().getSecond();
        }
    }, constants.fOpMaxLatency());
    nfsServerProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            // $NON-NLS-1$
            return entity.getMinLatencyFormatted().getFirst() + " " + entity.getMinLatencyFormatted().getSecond();
        }
    }, constants.fOpMinLatency());
    nfsServerProfileStats.addEntityModelColumn(new EntityModelTextColumn<FopStats>() {

        @Override
        protected String getText(FopStats entity) {
            // $NON-NLS-1$
            return entity.getAvgLatencyFormatted().getFirst() + " " + entity.getAvgLatencyFormatted().getSecond();
        }
    }, constants.fOpAvgLatency());
}
#end_block

#method_before
@Override
public void edit(final VolumeProfileStatisticsModel object) {
    driver.edit(object);
    volumeProfileStats.asEditor().edit(object.getCumulativeStatistics());
    nfsServerProfileStats.asEditor().edit(object.getNfsServerProfileStats());
    profileRunTime.setText(object.getProfileRunTime());
    nfsProfileRunTime.setText(object.getNfsProfileRunTime());
    bytesRead.setText(object.getBytesRead());
    nfsBytesRead.setText(object.getNfsBytesRead());
    bytesWritten.setText(object.getBytesWritten());
    nfsBytesWritten.setText(object.getNfsBytesWritten());
    ClickHandler brickTabClickHandler = new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            VolumeProfileStatisticsModel.setCurrentTab(VolumeProfileStatisticsModel.ProfileTabSelected.BRICKS);
            object.queryBackend();
        }
    };
    brickRefreshIcon.setRefreshIconClickListener(brickTabClickHandler);
    ClickHandler nfsTabClickHandler = new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            VolumeProfileStatisticsModel.setCurrentTab(VolumeProfileStatisticsModel.ProfileTabSelected.NFS);
            object.queryBackend();
        }
    };
    nfsRefreshIcon.setRefreshIconClickListener(nfsTabClickHandler);
    bricksTab.addClickHandler(brickTabClickHandler);
    nfsTab.addClickHandler(nfsTabClickHandler);
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName.equals("brickProfileRunTimeChanged")) {
                // $NON-NLS-1$
                profileRunTime.setText(object.getProfileRunTime());
                profileRunTime.setVisible(true);
            }
            if (e.propertyName.equals("brickProfileDataRead")) {
                // $NON-NLS-1$
                bytesRead.setText(object.getBytesRead());
                bytesRead.setVisible(true);
            }
            if (e.propertyName.equals("brickProfileDataWritten")) {
                // $NON-NLS-1$
                bytesWritten.setText(object.getBytesWritten());
                bytesWritten.setVisible(true);
            }
            if (e.propertyName.equals("nfsProfileRunTimeChanged")) {
                // $NON-NLS-1$
                nfsProfileRunTime.setText(object.getNfsProfileRunTime());
                nfsProfileRunTime.setVisible(true);
            }
            if (e.propertyName.equals("nfsProfileDataRead")) {
                // $NON-NLS-1$
                nfsBytesRead.setText(object.getNfsBytesRead());
                nfsBytesRead.setVisible(true);
            }
            if (e.propertyName.equals("nfsProfileDataWritten")) {
                // $NON-NLS-1$
                nfsBytesWritten.setText(object.getNfsBytesWritten());
                nfsBytesWritten.setVisible(true);
            }
        }
    });
}
#method_after
@Override
public void edit(final VolumeProfileStatisticsModel object) {
    driver.edit(object);
    volumeProfileStats.asEditor().edit(object.getCumulativeStatistics());
    nfsServerProfileStats.asEditor().edit(object.getNfsServerProfileStats());
    profileRunTime.setText(object.getProfileRunTime());
    nfsProfileRunTime.setText(object.getNfsProfileRunTime());
    bytesRead.setText(object.getBytesRead());
    nfsBytesRead.setText(object.getNfsBytesRead());
    bytesWritten.setText(object.getBytesWritten());
    nfsBytesWritten.setText(object.getNfsBytesWritten());
    ClickHandler brickTabClickHandler = new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.queryBackend(true);
        }
    };
    brickRefreshIcon.setRefreshIconClickListener(brickTabClickHandler);
    ClickHandler nfsTabClickHandler = new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.queryBackend(false);
        }
    };
    nfsRefreshIcon.setRefreshIconClickListener(nfsTabClickHandler);
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName.equals("brickProfileRunTimeChanged")) {
                // $NON-NLS-1$
                profileRunTime.setText(object.getProfileRunTime());
            }
            if (e.propertyName.equals("brickProfileDataRead")) {
                // $NON-NLS-1$
                bytesRead.setText(object.getBytesRead());
            }
            if (e.propertyName.equals("brickProfileDataWritten")) {
                // $NON-NLS-1$
                bytesWritten.setText(object.getBytesWritten());
            }
            if (e.propertyName.equals("nfsProfileRunTimeChanged")) {
                // $NON-NLS-1$
                nfsProfileRunTime.setText(object.getNfsProfileRunTime());
            }
            if (e.propertyName.equals("nfsProfileDataRead")) {
                // $NON-NLS-1$
                nfsBytesRead.setText(object.getNfsBytesRead());
            }
            if (e.propertyName.equals("nfsProfileDataWritten")) {
                // $NON-NLS-1$
                nfsBytesWritten.setText(object.getNfsBytesWritten());
            }
            if (e.propertyName.equals("statusOfFetchingProfileStats")) {
                // $NON-NLS-1$
                boolean disableErrorLabels = !(object.isSuccessfulProfileStatsFetch());
                bricksErrorLabel.setVisible(disableErrorLabels);
                nfsErrorLabel.setVisible(disableErrorLabels);
            }
        }
    });
}
#end_block

#method_before
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    boolean allowStartProfiling = false;
    boolean allowStopProfiling = false;
    boolean allowProfileStatisticsDetails = false;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        List<GlusterVolumeEntity> list = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
        for (GlusterVolumeEntity volume : list) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
                allowStartProfiling = true;
                allowStopProfiling = true;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            GlusterAsyncTask asyncTask = volume.getAsyncTask();
            if (asyncTask != null) {
                allowStartRebalance = allowStartRebalance && asyncTask.getStatus() == null ? asyncTask.getJobStatus() != JobExecutionStatus.STARTED : asyncTask.getStatus() != JobExecutionStatus.STARTED;
            }
        }
        if (list.size() == 1) {
            GlusterVolumeEntity volumeEntity = list.get(0);
            GlusterAsyncTask asyncTask = volumeEntity.getAsyncTask();
            allowStopRebalance = volumeEntity.getStatus() == GlusterStatus.UP && asyncTask != null && asyncTask.getType() == GlusterTaskType.REBALANCE && asyncTask.getStatus() == JobExecutionStatus.STARTED;
        } else {
            allowStopRebalance = false;
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
        allowProfileStatisticsDetails = getProfileStatisticsAvailability(getSelectedItems());
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
    getStartVolumeProfilingCommand().setIsExecutionAllowed(allowStartProfiling);
    getStopVolumeProfilingCommand().setIsExecutionAllowed(allowStopProfiling);
    getShowVolumeProfileDetailsCommand().setIsExecutionAllowed(allowProfileStatisticsDetails);
}
#method_after
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    boolean allowStartProfiling = false;
    boolean allowStopProfiling = false;
    boolean allowProfileStatisticsDetails = false;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        List<GlusterVolumeEntity> list = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
        allowStartProfiling = isStartProfileAvailable(list);
        allowStopProfiling = isStopProfileAvailable(list);
        for (GlusterVolumeEntity volume : list) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            GlusterAsyncTask asyncTask = volume.getAsyncTask();
            if (asyncTask != null) {
                allowStartRebalance = allowStartRebalance && asyncTask.getStatus() == null ? asyncTask.getJobStatus() != JobExecutionStatus.STARTED : asyncTask.getStatus() != JobExecutionStatus.STARTED;
            }
        }
        if (list.size() == 1) {
            GlusterVolumeEntity volumeEntity = list.get(0);
            GlusterAsyncTask asyncTask = volumeEntity.getAsyncTask();
            allowStopRebalance = volumeEntity.getStatus() == GlusterStatus.UP && asyncTask != null && asyncTask.getType() == GlusterTaskType.REBALANCE && asyncTask.getStatus() == JobExecutionStatus.STARTED;
        } else {
            allowStopRebalance = false;
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
        allowProfileStatisticsDetails = getProfileStatisticsAvailability(list);
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
    getStartVolumeProfilingCommand().setIsExecutionAllowed(allowStartProfiling);
    getStopVolumeProfilingCommand().setIsExecutionAllowed(allowStopProfiling);
    getShowVolumeProfileDetailsCommand().setIsExecutionAllowed(allowProfileStatisticsDetails);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("rebalanceNotStarted")) {
        // $NON-NLS-1$
        closeConfirmationWindow();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    } else if (command.getName().equals("stop_rebalance_from_status")) {
        // $NON-NLS-1$
        stopRebalance();
    } else if (command.equals(getStartVolumeProfilingCommand()) || command.getName().equals("Start Profiling")) {
        // $NON-NLS-1$
        startVolumeProfiling();
    } else if (command.equals(getStopVolumeProfilingCommand()) || command.getName().equals("Stop Profiling")) {
        // $NON-NLS-1$
        stopVolumeProfiling();
    } else if (command.equals(getShowVolumeProfileDetailsCommand()) || command.getName().equals("Show Profile Details")) {
        // $NON-NLS-1$
        showVolumeProfiling();
    } else if (command.getName().equalsIgnoreCase("close_profile_stats")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.getName().equalsIgnoreCase("profilingNotStarted")) {
        // $NON-NLS-1$
        if (getConfirmWindow() == null) {
            return;
        }
        getConfirmWindow().stopProgress();
        setConfirmWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("rebalanceNotStarted")) {
        // $NON-NLS-1$
        closeConfirmationWindow();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    } else if (command.getName().equals("stop_rebalance_from_status")) {
        // $NON-NLS-1$
        stopRebalance();
    } else if (command.equals(getStartVolumeProfilingCommand()) || command.getName().equals("startProfiling")) {
        // $NON-NLS-1$
        startVolumeProfiling();
    } else if (command.equals(getStopVolumeProfilingCommand()) || command.getName().equals("stopProfiling")) {
        // $NON-NLS-1$
        stopVolumeProfiling();
    } else if (command.equals(getShowVolumeProfileDetailsCommand()) || command.getName().equals("showProfileDetails")) {
        // $NON-NLS-1$
        showVolumeProfiling();
    } else if (command.getName().equalsIgnoreCase("closeProfileStats")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
private void startVolumeProfiling() {
    if (getSelectedItems() == null) {
        return;
    }
    GlusterVolumeParameters parameter = new GlusterVolumeParameters(((GlusterVolumeEntity) getSelectedItem()).getId());
    Frontend.getInstance().runAction(VdcActionType.StartGlusterVolumeProfile, parameter);
}
#method_after
private void startVolumeProfiling() {
    if (getSelectedItems() == null) {
        return;
    }
    List<GlusterVolumeEntity> selectedVolumesList = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    for (GlusterVolumeEntity currentSelectedVolume : selectedVolumesList) {
        GlusterVolumeParameters parameter = new GlusterVolumeParameters(currentSelectedVolume.getId());
        parameters.add(parameter);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.StartGlusterVolumeProfile, parameters);
}
#end_block

#method_before
private void stopVolumeProfiling() {
    if (getSelectedItems() == null) {
        return;
    }
    GlusterVolumeParameters parameter = new GlusterVolumeParameters(((GlusterVolumeEntity) getSelectedItem()).getId());
    Frontend.getInstance().runAction(VdcActionType.StopGlusterVolumeProfile, parameter);
}
#method_after
private void stopVolumeProfiling() {
    if (getSelectedItems() == null) {
        return;
    }
    List<GlusterVolumeEntity> selectedVolumesList = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    for (GlusterVolumeEntity currentSelectedVolume : selectedVolumesList) {
        GlusterVolumeParameters parameter = new GlusterVolumeParameters(currentSelectedVolume.getId());
        parameters.add(parameter);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.StopGlusterVolumeProfile, parameters);
}
#end_block

#method_before
private void showVolumeProfiling() {
    if (getSelectedItem() == null) {
        return;
    }
    VolumeProfileStatisticsModel profileStatsModel = new VolumeProfileStatisticsModel(((GlusterVolumeEntity) getSelectedItem()).getClusterId(), ((GlusterVolumeEntity) getSelectedItem()).getId(), ((GlusterVolumeEntity) getSelectedItem()).getName(), this);
    ConfirmationModel cModel = new ConfirmationModel();
    setConfirmWindow(cModel);
    cModel.setTitle(ConstantsManager.getInstance().getMessages().volumeProfilingStatsTitle(((GlusterVolumeEntity) getSelectedItem()).getName()));
    // $NON-NLS-1$
    cModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    cModel.setHelpTag(HelpTag.volume_profile_statistics);
    // $NON-NLS-1$
    cModel.setHashName("volume_profile_statistics");
    // $NON-NLS-1$
    final UICommand profileStatisticsOk = new UICommand("profilingNotStarted", VolumeListModel.this);
    profileStatisticsOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    profileStatisticsOk.setIsCancel(true);
    cModel.getCommands().add(profileStatisticsOk);
    VolumeProfileStatisticsModel.setCurrentTab(VolumeProfileStatisticsModel.ProfileTabSelected.BRICKS);
    profileStatsModel.queryBackend();
    // $NON-NLS-1$
    UICommand closeProfilingStats = new UICommand("close_profile_stats", VolumeListModel.this);
    closeProfilingStats.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeProfilingStats.setIsCancel(true);
    profileStatsModel.getCommands().add(closeProfilingStats);
}
#method_after
private void showVolumeProfiling() {
    if (getSelectedItem() == null || getWindow() != null) {
        return;
    }
    GlusterVolumeEntity selectedVolume = (GlusterVolumeEntity) getSelectedItem();
    VolumeProfileStatisticsModel profileStatsModel = new VolumeProfileStatisticsModel(selectedVolume.getClusterId(), selectedVolume.getId(), selectedVolume.getName());
    setWindow(profileStatsModel);
    setHelpTag(HelpTag.volume_profile_statistics);
    // $NON-NLS-1$
    setHashName("volume_profile_statistics");
    // $NON-NLS-1$
    profileStatsModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    // $NON-NLS-1$
    UICommand closeProfilingStats = new UICommand("closeProfileStats", VolumeListModel.this);
    closeProfilingStats.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeProfilingStats.setIsCancel(true);
    profileStatsModel.getCommands().add(closeProfilingStats);
    profileStatsModel.queryBackend(true);
    profileStatsModel.queryBackend(false);
}
#end_block

#method_before
public ListModel<NfsProfileDetails> getNfsServers() {
    return nfsServers;
}
#method_after
public ListModel<GlusterVolumeProfileStats> getNfsServers() {
    return nfsServers;
}
#end_block

#method_before
public void setNfsServers(ListModel<NfsProfileDetails> nfsServers) {
    this.nfsServers = nfsServers;
}
#method_after
public void setNfsServers(ListModel<GlusterVolumeProfileStats> nfsServers) {
    this.nfsServers = nfsServers;
}
#end_block

#method_before
public void queryBackend() {
    boolean nfs = false;
    if (currentTab == ProfileTabSelected.NFS) {
        nfs = true;
    }
    final VolumeProfileStatisticsModel profileStatsModel = this;
    profileStatsModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    AsyncDataProvider.getGlusterVolumeProfilingStatistics(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            profileStatsModel.stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeProfileInfo profileInfoEntity = vdcValue.getReturnValue();
            setProfileInfo(profileInfoEntity);
            if ((profileInfoEntity == null) || (!vdcValue.getSucceeded())) {
                volumeListModel.showProfileErrorWindow();
            } else {
                setConfirmWindow(null);
                if (getWindow() == null) {
                    setTitle(ConstantsManager.getInstance().getMessages().volumeProfilingStatsTitle(volumeName));
                    if (currentTab == ProfileTabSelected.NFS) {
                        showNfsProfileStats(profileInfoEntity);
                    } else {
                        showProfileStats(profileInfoEntity);
                    }
                    volumeListModel.setProfileWindow(profileStatsModel);
                }
            }
        }
    }), clusterId, volumeId, nfs);
}
#method_after
public void queryBackend(final boolean isBrickSelected) {
    startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    AsyncDataProvider.getGlusterVolumeProfilingStatistics(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeProfileInfo profileInfoEntity = vdcValue.getReturnValue();
            if ((profileInfoEntity == null) || (!vdcValue.getSucceeded())) {
                setSuccessfulProfileStatsFetch(false);
                if (!isBrickSelected) {
                    showNfsProfileStats(profileInfoEntity);
                } else {
                    showProfileStats(profileInfoEntity);
                }
            } else {
                GlusterVolumeProfileInfo aggregatedProfileInfo = new GlusterVolumeProfileInfo();
                aggregatedProfileInfo.setBrickProfileDetails((profileInfoEntity.getBrickProfileDetails() != null) ? profileInfoEntity.getBrickProfileDetails() : getProfileInfo().getBrickProfileDetails());
                aggregatedProfileInfo.setNfsProfileDetails((profileInfoEntity.getNfsProfileDetails() != null) ? profileInfoEntity.getNfsProfileDetails() : getProfileInfo().getNfsProfileDetails());
                setProfileInfo(aggregatedProfileInfo);
                setSuccessfulProfileStatsFetch(true);
                setTitle(ConstantsManager.getInstance().getMessages().volumeProfilingStatsTitle(volumeName));
                if (!isBrickSelected) {
                    showNfsProfileStats(profileInfoEntity);
                } else {
                    showProfileStats(profileInfoEntity);
                }
            }
        }
    }), clusterId, volumeId, !isBrickSelected);
}
#end_block

#method_before
public void showProfileStats(GlusterVolumeProfileInfo entity) {
    final List<BrickProfileDetails> brickProfileDetails = entity.getBrickProfileDetails();
    getBricks().setItems(brickProfileDetails);
    getBricks().setSelectedItem(brickProfileDetails.get(0));
}
#method_after
public void showProfileStats(GlusterVolumeProfileInfo entity) {
    if (entity != null) {
        final List<BrickProfileDetails> brickProfileDetails = entity.getBrickProfileDetails();
        getBricks().setItems(brickProfileDetails);
        if (brickProfileDetails.size() > 0) {
            getBricks().setSelectedItem(brickProfileDetails.get(0));
        }
    }
}
#end_block

#method_before
public void showNfsProfileStats(GlusterVolumeProfileInfo entity) {
    final List<NfsProfileDetails> nfsProfileDetails = entity.getNfsProfileDetails();
    getNfsServers().setItems(nfsProfileDetails);
    getNfsServers().setSelectedItem(nfsProfileDetails.get(0));
}
#method_after
public void showNfsProfileStats(GlusterVolumeProfileInfo entity) {
    if (entity != null) {
        List<GlusterVolumeProfileStats> nfsProfileDetails = entity.getNfsProfileDetails();
        getNfsServers().setItems(nfsProfileDetails);
        if (nfsProfileDetails.size() > 0) {
            getNfsServers().setSelectedItem(nfsProfileDetails.get(0));
        }
    }
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<GlusterVolumeEntity, VolumeListModel> getVolumeListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VolumePopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VolumeRebalanceStatusPopupPresenterWidget> rebalanceStatusPopupProvider, final Provider<VolumeProfileStatisticsPopupPresenterWidget> volumeProfileStatsPopupProvider) {
    return new MainTabModelProvider<GlusterVolumeEntity, VolumeListModel>(eventBus, defaultConfirmPopupProvider, VolumeListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewVolumeCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getStatusRebalanceCommand() || lastExecutedCommand.getName().equals("onStopRebalance")) {
                // $NON-NLS-1$
                return rebalanceStatusPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getShowVolumeProfileDetailsCommand() || lastExecutedCommand.getName().equals("Show Profile Details")) {
                // $NON-NLS-1$
                return volumeProfileStatsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VolumeListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getStopCommand() || lastExecutedCommand == getModel().getRemoveVolumeCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<GlusterVolumeEntity, VolumeListModel> getVolumeListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VolumePopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VolumeRebalanceStatusPopupPresenterWidget> rebalanceStatusPopupProvider, final Provider<VolumeProfileStatisticsPopupPresenterWidget> volumeProfileStatsPopupProvider) {
    return new MainTabModelProvider<GlusterVolumeEntity, VolumeListModel>(eventBus, defaultConfirmPopupProvider, VolumeListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewVolumeCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getStatusRebalanceCommand() || lastExecutedCommand.getName().equals("onStopRebalance")) {
                // $NON-NLS-1$
                return rebalanceStatusPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getShowVolumeProfileDetailsCommand() || lastExecutedCommand.getName().equals("showProfileDetails")) {
                // $NON-NLS-1$
                return volumeProfileStatsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VolumeListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getStopCommand() || lastExecutedCommand == getModel().getRemoveVolumeCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    super.equals(obj);
    BrickProfileDetails brickDetails = (BrickProfileDetails) obj;
    if (brickDetails.getBrickId() == null) {
        return false;
    }
    if (!(ObjectUtils.objectsEqual(getBrickId(), brickDetails.getBrickId()))) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    BrickProfileDetails brickDetails = (BrickProfileDetails) obj;
    if (brickDetails.getBrickId() == null) {
        return false;
    }
    if (!(ObjectUtils.objectsEqual(getBrickId(), brickDetails.getBrickId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private String generateOvfStoreDescription(Date updateDate, boolean isUpdated, Long size) {
    Map<String, Object> description = new HashMap<>();
    description.put(OvfInfoFileConstants.IsUpdated, isUpdated);
    description.put(OvfInfoFileConstants.DiskDescription, OvfInfoFileConstants.OvfStoreDescriptionLabel);
    description.put(OvfInfoFileConstants.LastUpdated, updateDate.toString());
    description.put(OvfInfoFileConstants.Domains, Arrays.asList(getParameters().getStorageDomainId()));
    if (size != null) {
        description.put(OvfInfoFileConstants.Size, size);
    }
    return buildJson(description);
}
#method_after
private String generateOvfStoreDescription(Date updateDate, boolean isUpdated, Long size) {
    Map<String, Object> description = new HashMap<>();
    description.put(OvfInfoFileConstants.DiskDescription, OvfInfoFileConstants.OvfStoreDescriptionLabel);
    description.put(OvfInfoFileConstants.Domains, Arrays.asList(getParameters().getStorageDomainId()));
    description.put(OvfInfoFileConstants.IsUpdated, isUpdated);
    description.put(OvfInfoFileConstants.LastUpdated, updateDate.toString());
    if (size != null) {
        description.put(OvfInfoFileConstants.Size, size);
    }
    return buildJson(description, false);
}
#end_block

#method_before
private String generateInfoFileData() {
    Map<String, Object> data = new HashMap<>();
    data.put(OvfInfoFileConstants.LastUpdated, updateDate.toString());
    data.put(OvfInfoFileConstants.Domains, Arrays.asList(getParameters().getStorageDomainId()));
    return buildJson(data);
}
#method_after
private String generateInfoFileData() {
    Map<String, Object> data = new HashMap<>();
    data.put(OvfInfoFileConstants.LastUpdated, updateDate.toString());
    data.put(OvfInfoFileConstants.Domains, Arrays.asList(getParameters().getStorageDomainId()));
    return buildJson(data, true);
}
#end_block

#method_before
private String buildJson(Map<String, Object> map) {
    try {
        return JsonHelper.mapToJson(map);
    } catch (IOException e) {
        throw new RuntimeException("Exception while generating json containing ovf store info", e);
    }
}
#method_after
private String buildJson(Map<String, Object> map, boolean prettyPrint) {
    try {
        return JsonHelper.mapToJson(map, prettyPrint);
    } catch (IOException e) {
        throw new RuntimeException("Exception while generating json containing ovf store info", e);
    }
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface);
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() == 0) {
            opts.put("mtu", NetworkUtils.getDefaultMTU().toString());
        } else {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        VDS host = getDbFacade().getVdsDao().get(getParameters().getVdsId());
        Version version = host.getVdsGroupCompatibilityVersion();
        if (qosConfiguredOnInterface(iface, network) && FeatureSupported.hostNetworkQos(version)) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        Set<Version> supportedClusterVersionsSet = host.getSupportedClusterVersionsSet();
        if (supportedClusterVersionsSet == null || supportedClusterVersionsSet.isEmpty()) {
            log.warnFormat("Host {0} ({1}) doesn't contain Supported Cluster Versions, therefore 'defaultRoute'" + " will not be sent via the SetupNetworks", host.getName(), host.getId());
        } else if (FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet)) && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (iface.hasCustomProperties()) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, iface.getCustomProperties());
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface);
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() == 0) {
            opts.put("mtu", NetworkUtils.getDefaultMtu().toString());
        } else {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        VDS host = getDbFacade().getVdsDao().get(getParameters().getVdsId());
        Version version = host.getVdsGroupCompatibilityVersion();
        if (qosConfiguredOnInterface(iface, network) && FeatureSupported.hostNetworkQos(version)) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        Set<Version> supportedClusterVersionsSet = host.getSupportedClusterVersionsSet();
        if (supportedClusterVersionsSet == null || supportedClusterVersionsSet.isEmpty()) {
            log.warnFormat("Host {0} ({1}) doesn't contain Supported Cluster Versions, therefore 'defaultRoute'" + " will not be sent via the SetupNetworks", host.getName(), host.getId());
        } else if (FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet)) && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (iface.hasCustomProperties()) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, iface.getCustomProperties());
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
public static boolean isNetworkInSync(VdsNetworkInterface iface, Network network, NetworkQoS qos) {
    return ((network.getMtu() == 0 && iface.getMtu() == getDefaultMTU()) || iface.getMtu() == network.getMtu()) && Objects.equals(iface.getVlanId(), network.getVlanId()) && iface.isBridged() == network.isVmNetwork() && (isQosInSync(iface, qos) || iface.isQosOverridden());
}
#method_after
public static boolean isNetworkInSync(VdsNetworkInterface iface, Network network, NetworkQoS qos) {
    return ((network.getMtu() == 0 && iface.getMtu() == getDefaultMtu()) || iface.getMtu() == network.getMtu()) && Objects.equals(iface.getVlanId(), network.getVlanId()) && iface.isBridged() == network.isVmNetwork() && (isQosInSync(iface, qos) || iface.isQosOverridden());
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    if (TransactionSupport.current() != null) {
        TransactionSupport.registerRollbackHandler(this);
    }
    String networkName = (getParameters().getNetworkName() == null) ? "" : getParameters().getNetworkName();
    String vlanId = (getParameters().getVlanId() != null) ? getParameters().getVlanId().toString() : "";
    String bond = (getParameters().getBondName() == null) ? "" : getParameters().getBondName();
    String[] nics = (getParameters().getNics() == null) ? new String[] {} : getParameters().getNics();
    Map<String, String> options = new HashMap<String, String>();
    switch(getParameters().getBootProtocol()) {
        case DHCP:
            options.put(VdsProperties.BOOT_PROTOCOL, VdsProperties.DHCP);
            break;
        case STATIC_IP:
            if (!StringUtils.isEmpty(getParameters().getInetAddr())) {
                options.put(VdsProperties.IP_ADDRESS, getParameters().getInetAddr());
            }
            if (!StringUtils.isEmpty(getParameters().getNetworkMask())) {
                options.put(VdsProperties.NETMASK, getParameters().getNetworkMask());
            }
            if (!StringUtils.isEmpty(getParameters().getGateway())) {
                options.put(VdsProperties.GATEWAY, getParameters().getGateway());
            }
            break;
        default:
            break;
    }
    options.put(VdsProperties.STP, (getParameters().getStp()) ? "yes" : "no");
    if (!StringUtils.isEmpty(getParameters().getBondingOptions())) {
        options.put(VdsProperties.BONDING_OPTIONS, getParameters().getBondingOptions());
    }
    options.put(VdsProperties.STP, (getParameters().getStp()) ? "yes" : "no");
    // options[VdsProperties.force] = "true";
    options.put("bridged", Boolean.toString(getParameters().isVmNetwork()));
    Network network = getParameters().getNetwork();
    if (network != null) {
        if (network.getMtu() == 0) {
            options.put("mtu", NetworkUtils.getDefaultMTU().toString());
        } else {
            options.put("mtu", String.valueOf(network.getMtu()));
        }
    }
    status = getBroker().addNetwork(networkName, vlanId, bond, nics, options);
    proceedProxyReturnValue();
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    if (TransactionSupport.current() != null) {
        TransactionSupport.registerRollbackHandler(this);
    }
    String networkName = (getParameters().getNetworkName() == null) ? "" : getParameters().getNetworkName();
    String vlanId = (getParameters().getVlanId() != null) ? getParameters().getVlanId().toString() : "";
    String bond = (getParameters().getBondName() == null) ? "" : getParameters().getBondName();
    String[] nics = (getParameters().getNics() == null) ? new String[] {} : getParameters().getNics();
    Map<String, String> options = new HashMap<String, String>();
    switch(getParameters().getBootProtocol()) {
        case DHCP:
            options.put(VdsProperties.BOOT_PROTOCOL, VdsProperties.DHCP);
            break;
        case STATIC_IP:
            if (!StringUtils.isEmpty(getParameters().getInetAddr())) {
                options.put(VdsProperties.IP_ADDRESS, getParameters().getInetAddr());
            }
            if (!StringUtils.isEmpty(getParameters().getNetworkMask())) {
                options.put(VdsProperties.NETMASK, getParameters().getNetworkMask());
            }
            if (!StringUtils.isEmpty(getParameters().getGateway())) {
                options.put(VdsProperties.GATEWAY, getParameters().getGateway());
            }
            break;
        default:
            break;
    }
    options.put(VdsProperties.STP, (getParameters().getStp()) ? "yes" : "no");
    if (!StringUtils.isEmpty(getParameters().getBondingOptions())) {
        options.put(VdsProperties.BONDING_OPTIONS, getParameters().getBondingOptions());
    }
    options.put(VdsProperties.STP, (getParameters().getStp()) ? "yes" : "no");
    // options[VdsProperties.force] = "true";
    options.put("bridged", Boolean.toString(getParameters().isVmNetwork()));
    Network network = getParameters().getNetwork();
    if (network != null) {
        if (network.getMtu() == 0) {
            options.put("mtu", NetworkUtils.getDefaultMtu().toString());
        } else {
            options.put("mtu", String.valueOf(network.getMtu()));
        }
    }
    status = getBroker().addNetwork(networkName, vlanId, bond, nics, options);
    proceedProxyReturnValue();
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    String networkName = (getParameters().getNetworkName() == null) ? "" : getParameters().getNetworkName();
    String oldNetwork = (getParameters().getOldNetworkName() == null) ? "" : getParameters().getOldNetworkName();
    String vlanId = (getParameters().getVlanId() != null) ? getParameters().getVlanId().toString() : "";
    String bond = (getParameters().getBondName() == null) ? "" : getParameters().getBondName();
    String[] nics = (getParameters().getNics() == null) ? new String[] {} : getParameters().getNics();
    Map<String, String> options = new HashMap<String, String>();
    switch(getParameters().getBootProtocol()) {
        case DHCP:
            options.put(VdsProperties.BOOT_PROTOCOL, VdsProperties.DHCP);
            break;
        case STATIC_IP:
            if (!StringUtils.isEmpty(getParameters().getInetAddr())) {
                options.put(VdsProperties.IP_ADDRESS, getParameters().getInetAddr());
            }
            if (!StringUtils.isEmpty(getParameters().getNetworkMask())) {
                options.put(VdsProperties.NETMASK, getParameters().getNetworkMask());
            }
            if (!StringUtils.isEmpty(getParameters().getGateway())) {
                options.put(VdsProperties.GATEWAY, getParameters().getGateway());
            }
            break;
        default:
            break;
    }
    if (!StringUtils.isEmpty(getParameters().getBondingOptions())) {
        options.put(VdsProperties.BONDING_OPTIONS, getParameters().getBondingOptions());
    }
    options.put(VdsProperties.STP, (getParameters().getStp()) ? "yes" : "no");
    options.put("bridged", Boolean.toString(getParameters().isVmNetwork()));
    Network network = getParameters().getNetwork();
    if (network != null) {
        if (network.getMtu() == 0) {
            options.put("mtu", NetworkUtils.getDefaultMTU().toString());
        } else {
            options.put("mtu", String.valueOf(network.getMtu()));
        }
    }
    // options[VdsProperties.force] = "true";
    if (getParameters().getCheckConnectivity()) {
        options.put(VdsProperties.CONNECTIVITY_CHECK, "true");
        options.put(VdsProperties.CONNECTIVITY_TIMEOUT, String.valueOf(getParameters().getConnectionTimeout()));
    }
    status = getBroker().editNetwork(oldNetwork, networkName, vlanId, bond, nics, options);
    proceedProxyReturnValue();
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    String networkName = (getParameters().getNetworkName() == null) ? "" : getParameters().getNetworkName();
    String oldNetwork = (getParameters().getOldNetworkName() == null) ? "" : getParameters().getOldNetworkName();
    String vlanId = (getParameters().getVlanId() != null) ? getParameters().getVlanId().toString() : "";
    String bond = (getParameters().getBondName() == null) ? "" : getParameters().getBondName();
    String[] nics = (getParameters().getNics() == null) ? new String[] {} : getParameters().getNics();
    Map<String, String> options = new HashMap<String, String>();
    switch(getParameters().getBootProtocol()) {
        case DHCP:
            options.put(VdsProperties.BOOT_PROTOCOL, VdsProperties.DHCP);
            break;
        case STATIC_IP:
            if (!StringUtils.isEmpty(getParameters().getInetAddr())) {
                options.put(VdsProperties.IP_ADDRESS, getParameters().getInetAddr());
            }
            if (!StringUtils.isEmpty(getParameters().getNetworkMask())) {
                options.put(VdsProperties.NETMASK, getParameters().getNetworkMask());
            }
            if (!StringUtils.isEmpty(getParameters().getGateway())) {
                options.put(VdsProperties.GATEWAY, getParameters().getGateway());
            }
            break;
        default:
            break;
    }
    if (!StringUtils.isEmpty(getParameters().getBondingOptions())) {
        options.put(VdsProperties.BONDING_OPTIONS, getParameters().getBondingOptions());
    }
    options.put(VdsProperties.STP, (getParameters().getStp()) ? "yes" : "no");
    options.put("bridged", Boolean.toString(getParameters().isVmNetwork()));
    Network network = getParameters().getNetwork();
    if (network != null) {
        if (network.getMtu() == 0) {
            options.put("mtu", NetworkUtils.getDefaultMtu().toString());
        } else {
            options.put("mtu", String.valueOf(network.getMtu()));
        }
    }
    // options[VdsProperties.force] = "true";
    if (getParameters().getCheckConnectivity()) {
        options.put(VdsProperties.CONNECTIVITY_CHECK, "true");
        options.put(VdsProperties.CONNECTIVITY_TIMEOUT, String.valueOf(getParameters().getConnectionTimeout()));
    }
    status = getBroker().editNetwork(oldNetwork, networkName, vlanId, bond, nics, options);
    proceedProxyReturnValue();
}
#end_block

#method_before
public Boolean getActivate() {
    return activate;
}
#method_after
public boolean getActivate() {
    return activate;
}
#end_block

#method_before
public void setActivate(Boolean activate) {
    this.activate = activate;
}
#method_after
public void setActivate(boolean activate) {
    this.activate = activate;
}
#end_block

#method_before
@Override
protected void setUpQueryExpectations(String query, Object failure) throws Exception {
    assert (query.equals(""));
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainsByStoragePoolId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[NAMES.length - 1] }, setUpStorageDomains(), failure);
    control.replay();
}
#method_after
@Override
protected void setUpQueryExpectations(String query, Object failure) throws Exception {
    assertEquals("", query);
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainsByStoragePoolId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[NAMES.length - 1] }, setUpStorageDomains(), failure);
    control.replay();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = getBackend().runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters, new CommandContext(getCompensationContext()));
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectAllHostsToPool();
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        return null;
                    }
                });
                if (!Boolean.FALSE.equals(getParameters().getActivate())) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = getBackend().runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters, new CommandContext(getCompensationContext()));
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectAllHostsToPool();
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#end_block

#method_before
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#method_after
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, String groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, groupIds, actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, HashSet<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#end_block

#method_before
public static void setParameters(CommandEntity commandEntity, VdcActionParametersBase params) {
    if (commandEntity.getData() == null) {
        commandEntity.setData(new HashMap<String, Object>());
    }
    commandEntity.getData().put(PARAMETERS_KEY, params);
}
#method_after
public static void setParameters(CommandEntity commandEntity, VdcActionParametersBase params) {
    commandEntity.getData().put(PARAMETERS_KEY, params);
}
#end_block

#method_before
public static VdcActionParametersBase getParameters(CommandEntity commandEntity) {
    return commandEntity.getData() != null ? (VdcActionParametersBase) commandEntity.getData().get(PARAMETERS_KEY) : null;
}
#method_after
public static VdcActionParametersBase getParameters(CommandEntity commandEntity) {
    return (VdcActionParametersBase) commandEntity.getData().get(PARAMETERS_KEY);
}
#end_block

#method_before
public Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Step taskStep = ExecutionHandler.addTaskStep(command.getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
    if (taskStep != null) {
        asyncTaskCreationInfo.setStepId(taskStep.getId());
    }
    SPMAsyncTask task = concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
    task.setEntitiesMap(entitiesMap);
    AsyncTaskUtils.addOrUpdateTaskInDB(task);
    commandsCache.put(task.getParameters().getDbAsyncTask().getStepId(), command.getCommandId(), command.getParameters().getParentParameters() == null ? Guid.Empty : command.getParameters().getParentParameters().getCommandId(), task);
    getAsyncTaskManager().lockAndAddTaskToManager(task);
    Guid vdsmTaskId = task.getVdsmTaskId();
    ExecutionHandler.updateStepExternalId(taskStep, vdsmTaskId, ExternalSystemType.VDSM);
    return vdsmTaskId;
}
#method_after
public Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Step taskStep = ExecutionHandler.addTaskStep(command.getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
    if (taskStep != null) {
        asyncTaskCreationInfo.setStepId(taskStep.getId());
    }
    SPMAsyncTask task = concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
    task.setEntitiesMap(entitiesMap);
    AsyncTaskUtils.addOrUpdateTaskInDB(task);
    commandsCache.put(command.getCommandId(), command.getParameters().getParentParameters() == null ? Guid.Empty : command.getParameters().getParentParameters().getCommandId(), task);
    getAsyncTaskManager().lockAndAddTaskToManager(task);
    Guid vdsmTaskId = task.getVdsmTaskId();
    ExecutionHandler.updateStepExternalId(taskStep, vdsmTaskId, ExternalSystemType.VDSM);
    return vdsmTaskId;
}
#end_block

#method_before
@Override
public void put(Guid stepId, Guid commandId, Guid parentCommandId, SPMAsyncTask task) {
    commandMap.put(stepId, buildGetCommandEntity(commandId, parentCommandId, task));
}
#method_after
@Override
public void put(Guid commandId, Guid parentCommandId, SPMAsyncTask task) {
    commandMap.put(commandId, buildCommandEntity(commandId, parentCommandId, task));
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#method_after
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#end_block

#method_before
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (isInternalExecution() || !isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#method_after
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (!isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#end_block

#method_before
protected boolean isQuotaDependant() {
    return getActionType().getQuotaDependency() != VdcActionType.QuotaDependency.NONE;
}
#method_after
protected boolean isQuotaDependant() {
    boolean result;
    if (getActionType().getQuotaDependency() == VdcActionType.QuotaDependency.NONE)
        result = false;
    else if (!isInternalExecution())
        result = true;
    else if (getActionType().isQuotaDependentAsInternalCommand())
        result = true;
    else
        result = false;
    return result;
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, String groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, groupIds, actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, HashSet<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#end_block

#method_before
public static AsyncTaskManager getInstance(CommandCoordinator coco) {
    if (taskManager == null) {
        synchronized (LOCK) {
            if (taskManager == null) {
                taskManager = new AsyncTaskManager(coco);
            }
        }
    }
    return taskManager;
}
#method_after
public static AsyncTaskManager getInstance() {
    return taskManager;
}
#end_block

#method_before
synchronized private void removeClearedAndOldTasks() {
    Set<Guid> poolsOfActiveTasks = new HashSet<Guid>();
    Set<Guid> poolsOfClearedAndOldTasks = new HashSet<Guid>();
    ConcurrentMap<Guid, SPMTask> activeTaskMap = new ConcurrentHashMap<Guid, SPMTask>();
    for (SPMTask task : _tasks.values()) {
        if (!cachingOver(task)) {
            activeTaskMap.put(task.getVdsmTaskId(), task);
            poolsOfActiveTasks.add(task.getStoragePoolID());
        } else {
            poolsOfClearedAndOldTasks.add(task.getStoragePoolID());
        }
    }
    // Check if _tasks need to be updated with less tasks (activated tasks).
    if (poolsOfClearedAndOldTasks.size() > 0) {
        setNewMap(activeTaskMap);
        poolsOfClearedAndOldTasks.removeAll(poolsOfActiveTasks);
    }
    for (Guid storagePoolID : poolsOfClearedAndOldTasks) {
        log.infoFormat("Cleared all tasks of pool {0}.", storagePoolID);
    }
}
#method_after
synchronized private void removeClearedAndOldTasks() {
    Set<Guid> poolsOfActiveTasks = new HashSet<Guid>();
    Set<Guid> poolsOfClearedAndOldTasks = new HashSet<Guid>();
    ConcurrentMap<Guid, SPMTask> activeTaskMap = new ConcurrentHashMap<>();
    for (SPMTask task : _tasks.values()) {
        if (!cachingOver(task)) {
            activeTaskMap.put(task.getVdsmTaskId(), task);
            poolsOfActiveTasks.add(task.getStoragePoolID());
        } else {
            poolsOfClearedAndOldTasks.add(task.getStoragePoolID());
        }
    }
    // Check if _tasks need to be updated with less tasks (activated tasks).
    if (poolsOfClearedAndOldTasks.size() > 0) {
        setNewMap(activeTaskMap);
        poolsOfClearedAndOldTasks.removeAll(poolsOfActiveTasks);
    }
    for (Guid storagePoolID : poolsOfClearedAndOldTasks) {
        log.infoFormat("Cleared all tasks of pool {0}.", storagePoolID);
    }
}
#end_block

#method_before
public static Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return CommandCoordinatorImpl.getInstance().createTask(taskId, command, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#method_after
public static Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return coco.createTask(taskId, command, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#end_block

#method_before
public static SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return CommandCoordinatorImpl.getInstance().concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public static SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public static void cancelTasks(final CommandBase command) {
    CommandCoordinatorImpl.getInstance().cancelTasks(command);
}
#method_after
public static void cancelTasks(final CommandBase command) {
    coco.cancelTasks(command);
}
#end_block

#method_before
public static void revertTasks(final CommandBase command) {
    CommandCoordinatorImpl.getInstance().revertTasks(command);
}
#method_after
public static void revertTasks(final CommandBase command) {
    coco.revertTasks(command);
}
#end_block

#method_before
public static AsyncTasks getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return CommandCoordinatorImpl.getInstance().getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public static AsyncTasks getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public static AsyncTasks createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return CommandCoordinatorImpl.getInstance().createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public static AsyncTasks createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
private static AsyncTaskManager getAsyncTaskManager() {
    return AsyncTaskManager.getInstance(CommandCoordinatorImpl.getInstance());
}
#method_after
private static AsyncTaskManager getAsyncTaskManager() {
    return AsyncTaskManager.getInstance(coco);
}
#end_block

#method_before
public VdcReturnValueBase endAction(Guid stepId, VdcActionType actionType, AsyncTasks dbAsyncTask, ExecutionContext context) {
    VdcActionParametersBase parameters = dbAsyncTask.getActionParameters();
    CommandBase<?> command = CommandsFactory.getInstance().createCommand(actionType, parameters);
    command.setContext(new CommandContext(context));
    return command.endAction();
}
#method_after
public VdcReturnValueBase endAction(Guid stepId, VdcActionType actionType, AsyncTasks dbAsyncTask, ExecutionContext context) {
    VdcActionParametersBase parameters = dbAsyncTask.getActionParameters();
    CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters);
    command.setContext(new CommandContext(context));
    return command.endAction();
}
#end_block

#method_before
public static AsyncTaskManager getInstance(CommandCoordinator coco) {
    if (taskManager == null) {
        synchronized (LOCK) {
            if (taskManager == null) {
                taskManager = new AsyncTaskManager(coco);
            }
        }
    }
    return taskManager;
}
#method_after
public static AsyncTaskManager getInstance() {
    return taskManager;
}
#end_block

#method_before
Grid createRow(final HostInterface hostInterface) {
    Grid row = new Grid(1, 2);
    // $NON-NLS-1$
    row.setHeight("100%");
    // $NON-NLS-1$
    row.setWidth("100%");
    Style gridStyle = row.getElement().getStyle();
    // $NON-NLS-1$
    gridStyle.setBorderColor("white");
    gridStyle.setBorderWidth(1, Unit.PX);
    gridStyle.setBorderStyle(BorderStyle.SOLID);
    // $NON-NLS-1$
    row.getColumnFormatter().setWidth(0, "30px");
    // $NON-NLS-1$
    row.getColumnFormatter().setWidth(1, "210px");
    // Check box and interface status icon
    row.setWidget(0, 0, new HorizontalPanel() {

        {
            if (isSelectionAvailable) {
                add(getCheckBox());
            }
            add(new InterfaceStatusImage(hostInterface.getStatus()));
        }
    });
    // Name
    row.setWidget(0, 1, HostInterfaceForm.createInterfaceLabel(hostInterface.getInterface()));
    return row;
}
#method_after
Grid createRow(final HostInterface hostInterface) {
    Grid row = new Grid(1, 2);
    // $NON-NLS-1$
    row.setHeight("100%");
    // $NON-NLS-1$
    row.setWidth("100%");
    Style gridStyle = row.getElement().getStyle();
    // $NON-NLS-1$
    gridStyle.setBorderColor("white");
    gridStyle.setBorderWidth(1, Unit.PX);
    gridStyle.setBorderStyle(BorderStyle.SOLID);
    // $NON-NLS-1$
    row.getColumnFormatter().setWidth(0, "30px");
    // $NON-NLS-1$
    row.getColumnFormatter().setWidth(1, "210px");
    // Check box and interface status icon
    row.setWidget(0, 0, new HorizontalPanel() {

        {
            if (isSelectionAvailable) {
                add(getCheckBox());
            }
            add(new InterfaceStatusImage(hostInterface.getStatus()));
        }
    });
    // Name
    row.setWidget(0, 1, new InterfaceLabelWithToolTip(hostInterface.getInterface()).getLabel());
    return row;
}
#end_block

#method_before
@Override
public void setTitle(String text) {
    this.title = SafeHtmlUtils.fromTrustedString(text);
}
#method_after
@Override
public void setTitle(String text) {
    tooltipPanel.setText(text);
}
#end_block

#method_before
public void setTitle(SafeHtml text) {
    this.title = text;
}
#method_after
public void setTitle(SafeHtml text) {
    tooltipPanel.setText(text);
}
#end_block

#method_before
@Override
public void setMainTabSelectedItem(VDS selectedItem) {
    // TODO(vszocs) possible performance optimization: don't create HostInterfaceForm upon each selection
    hostInterfaceForm = new HostInterfaceForm(getDetailModel());
    contentPanel.remove(contentPanel.getWidgetCount() - 1);
    contentPanel.add(hostInterfaceForm);
    contentPanel.getParent().getElement().getStyle().setOverflowX(Overflow.AUTO);
}
#method_after
@Override
public void setMainTabSelectedItem(VDS selectedItem) {
    // TODO(vszocs) possible performance optimization: don't create HostInterfaceForm upon each selection
    hostInterfaceForm = new HostInterfaceForm(getDetailModel());
    contentPanel.remove(contentPanel.getWidgetCount() - 1);
    contentPanel.add(hostInterfaceForm);
}
#end_block

#method_before
public static DirectoryUser fetchPrincipalRecord(final ExtensionProxy extension, ExtMap authRecord) {
    return mapPrincipalRecord(extension, extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord)).<ExtMap>get(Authz.InvokeKeys.PRINCIPAL_RECORD));
}
#method_after
public static DirectoryUser fetchPrincipalRecord(final ExtensionProxy extension, ExtMap authRecord) {
    return mapPrincipalRecord(extension, extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord).mput(Authz.InvokeKeys.QUERY_FLAGS, Authz.QueryFlags.RESOLVE_GROUPS | Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE)).<ExtMap>get(Authz.InvokeKeys.PRINCIPAL_RECORD));
}
#end_block

#method_before
public static List<DirectoryUser> findPrincipalsByQuery(final ExtensionProxy extension, final String namespace, final String query) {
    return queryPrincipals(extension, namespace, SearchQueryParsingUtils.generateQueryMap(query, Authz.QueryEntity.PRINCIPAL), false);
}
#method_after
public static List<DirectoryUser> findPrincipalsByQuery(final ExtensionProxy extension, final String namespace, final String query) {
    return queryPrincipals(extension, namespace, SearchQueryParsingUtils.generateQueryMap(query, Authz.QueryEntity.PRINCIPAL), false, false);
}
#end_block

#method_before
public static List<DirectoryUser> findPrincipalsByIds(final ExtensionProxy extension, final String namespace, final List<String> ids) {
    List<DirectoryUser> results = new ArrayList<>();
    for (List<String> batch : SearchQueryParsingUtils.getIdsBatches(extension.getContext(), ids)) {
        results.addAll(queryPrincipals(extension, namespace, SearchQueryParsingUtils.generateQueryMap(batch, Authz.QueryEntity.PRINCIPAL), true));
    }
    return results;
}
#method_after
public static List<DirectoryUser> findPrincipalsByIds(final ExtensionProxy extension, final String namespace, final List<String> ids, final boolean groupsResolving, final boolean groupsResolvingRecursive) {
    List<DirectoryUser> results = new ArrayList<>();
    for (List<String> batch : SearchQueryParsingUtils.getIdsBatches(extension.getContext(), ids)) {
        results.addAll(queryPrincipals(extension, namespace, SearchQueryParsingUtils.generateQueryMap(batch, Authz.QueryEntity.PRINCIPAL), groupsResolving, groupsResolvingRecursive));
    }
    return results;
}
#end_block

#method_before
public static DirectoryUser findPrincipalById(final ExtensionProxy extension, String namespace, final String id) {
    List<DirectoryUser> users = findPrincipalsByIds(extension, namespace, Arrays.asList(id));
    if (users.isEmpty()) {
        return null;
    }
    return users.get(0);
}
#method_after
public static DirectoryUser findPrincipalById(final ExtensionProxy extension, final String namespace, final String id, final boolean groupsResolving, final boolean groupsResolvingRecursive) {
    List<DirectoryUser> users = findPrincipalsByIds(extension, namespace, Arrays.asList(id), groupsResolving, groupsResolvingRecursive);
    if (users.isEmpty()) {
        return null;
    }
    return users.get(0);
}
#end_block

#method_before
public static List<DirectoryGroup> findGroupsByQuery(final ExtensionProxy extension, final String namespace, final String query) {
    return queryGroups(extension, namespace, SearchQueryParsingUtils.generateQueryMap(query, Authz.QueryEntity.GROUP));
}
#method_after
public static List<DirectoryGroup> findGroupsByQuery(final ExtensionProxy extension, final String namespace, final String query) {
    return queryGroups(extension, namespace, SearchQueryParsingUtils.generateQueryMap(query, Authz.QueryEntity.GROUP), false, false);
}
#end_block

#method_before
public static List<DirectoryGroup> findGroupsByIds(final ExtensionProxy extension, final String namespace, final List<String> ids) {
    List<DirectoryGroup> results = new ArrayList<>();
    for (List<String> batch : SearchQueryParsingUtils.getIdsBatches(extension.getContext(), ids)) {
        results.addAll(queryGroups(extension, namespace, SearchQueryParsingUtils.generateQueryMap(batch, QueryEntity.GROUP)));
    }
    return results;
}
#method_after
public static List<DirectoryGroup> findGroupsByIds(final ExtensionProxy extension, final String namespace, final List<String> ids, final boolean resolveGroups, final boolean resolveGroupsRecursive) {
    List<DirectoryGroup> results = new ArrayList<>();
    for (List<String> batch : SearchQueryParsingUtils.getIdsBatches(extension.getContext(), ids)) {
        results.addAll(queryGroups(extension, namespace, SearchQueryParsingUtils.generateQueryMap(batch, QueryEntity.GROUP), resolveGroups, resolveGroupsRecursive));
    }
    return results;
}
#end_block

#method_before
public static DirectoryGroup findGroupById(final ExtensionProxy extension, String namespace, final String id) {
    List<DirectoryGroup> groups = findGroupsByIds(extension, namespace, Arrays.asList(id));
    if (groups.isEmpty()) {
        return null;
    }
    return groups.get(0);
}
#method_after
public static DirectoryGroup findGroupById(final ExtensionProxy extension, String namespace, final String id, final boolean resolveGroups, final boolean resolveGroupsRecursive) {
    List<DirectoryGroup> groups = findGroupsByIds(extension, namespace, Arrays.asList(id), resolveGroups, resolveGroupsRecursive);
    if (groups.isEmpty()) {
        return null;
    }
    return groups.get(0);
}
#end_block

#method_before
private static List<DirectoryUser> queryPrincipals(final ExtensionProxy extension, final String namespace, final ExtMap filter, boolean recursiveGroupsResolving) {
    ExtMap inputMap = new ExtMap().mput(Authz.InvokeKeys.QUERY_ENTITY, Authz.QueryEntity.PRINCIPAL).mput(Authz.InvokeKeys.RESOLVE_GROUPS_RECURSIVE, recursiveGroupsResolving).mput(Authz.InvokeKeys.RESOLVE_GROUPS, recursiveGroupsResolving).mput(Authz.InvokeKeys.QUERY_FILTER, filter).mput(Authz.InvokeKeys.NAMESPACE, namespace);
    return populatePrincipals(extension, namespace, inputMap);
}
#method_after
private static List<DirectoryUser> queryPrincipals(final ExtensionProxy extension, final String namespace, final ExtMap filter, boolean groupsResolving, boolean groupsResolvingRecursive) {
    ExtMap inputMap = new ExtMap().mput(Authz.InvokeKeys.QUERY_ENTITY, Authz.QueryEntity.PRINCIPAL).mput(Authz.InvokeKeys.QUERY_FLAGS, queryFlagValue(groupsResolving, groupsResolvingRecursive)).mput(Authz.InvokeKeys.QUERY_FILTER, filter).mput(Authz.InvokeKeys.NAMESPACE, namespace);
    return populatePrincipals(extension, namespace, inputMap);
}
#end_block

#method_before
private static List<DirectoryGroup> queryGroups(final ExtensionProxy extension, final String namespace, final ExtMap filter) {
    return populateGroups(extension, namespace, new ExtMap().mput(Authz.InvokeKeys.QUERY_ENTITY, Authz.QueryEntity.GROUP).mput(Authz.InvokeKeys.QUERY_FILTER, filter));
}
#method_after
private static List<DirectoryGroup> queryGroups(final ExtensionProxy extension, final String namespace, final ExtMap filter, boolean resolveGroups, boolean recursiveGroupResolving) {
    return populateGroups(extension, namespace, new ExtMap().mput(Authz.InvokeKeys.QUERY_ENTITY, Authz.QueryEntity.GROUP).mput(Authz.InvokeKeys.QUERY_FILTER, filter).mput(Authz.InvokeKeys.QUERY_FLAGS, queryFlagValue(resolveGroups, recursiveGroupResolving)));
}
#end_block

#method_before
private static DirectoryGroup mapGroupRecord(final ExtensionProxy extension, final ExtMap group) {
    DirectoryGroup directoryGroup = null;
    if (group != null) {
        directoryGroup = new DirectoryGroup(extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME), group.<String>get(Authz.GroupRecord.NAMESPACE), group.<String>get(Authz.GroupRecord.ID), group.<String>get(Authz.GroupRecord.NAME));
    }
    return directoryGroup;
}
#method_after
private static DirectoryGroup mapGroupRecord(final ExtensionProxy extension, final ExtMap group) {
    DirectoryGroup directoryGroup = null;
    if (group != null) {
        directoryGroup = new DirectoryGroup(extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME), group.<String>get(Authz.GroupRecord.NAMESPACE), group.<String>get(Authz.GroupRecord.ID), group.<String>get(Authz.GroupRecord.NAME));
        for (ExtMap memberOf : group.<List<ExtMap>>get(Authz.GroupRecord.GROUPS, Collections.<ExtMap>emptyList())) {
            directoryGroup.getGroups().add(mapGroupRecord(extension, memberOf));
        }
    }
    return directoryGroup;
}
#end_block

#method_before
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled() == null ? getVm().isBootMenuEnabled() : getParameters().isBootMenuEnabled());
    getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled() == null ? getVm().isSpiceFileTransferEnabled() : getParameters().isSpiceFileTransferEnabled());
    getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled() == null ? getVm().isSpiceCopyPasteEnabled() : getParameters().isSpiceCopyPasteEnabled());
    // Clear the first user:
    getVm().setConsoleUserId(null);
    getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
    (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
    if (getParameters().getInitializationType() == null) {
        // if vm not initialized, use sysprep/cloud-init
        if (!getVm().isInitialized()) {
            VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                getVm().setInitializationType(InitializationType.Sysprep);
            } else if (getVm().getVmInit() != null) {
                getVm().setInitializationType(InitializationType.CloudInit);
            } else {
                getVm().setInitializationType(InitializationType.None);
            }
        }
    } else {
        getVm().setInitializationType(getParameters().getInitializationType());
    }
    // if we attach floppy we don't need the sysprep
    if (!getVm().isRunOnce() && !StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVmStaticDAO().update(getVm().getStaticData());
    }
    // get what cpu flags should be passed to vdsm according to cluster
    // cpu name
    getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
    VmHandler.updateVmGuestAgentVersion(getVm());
    getVm().setCpuName(getVdsGroup().getcpu_name());
    if (!getVm().getInterfaces().isEmpty()) {
        initParametersForExternalNetworks();
    }
    if (getFlow() != RunVmFlow.RESUME_HIBERNATE) {
        getVm().setHibernationVolHandle(getMemoryFromSnapshot());
    }
}
#method_after
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
    (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
    if (getParameters().getInitializationType() == null) {
        // if vm not initialized, use sysprep/cloud-init
        if (!getVm().isInitialized()) {
            VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                getVm().setInitializationType(InitializationType.Sysprep);
            } else if (getVm().getVmInit() != null) {
                getVm().setInitializationType(InitializationType.CloudInit);
            } else {
                getVm().setInitializationType(InitializationType.None);
            }
        }
    } else {
        getVm().setInitializationType(getParameters().getInitializationType());
    }
    // if we attach floppy we don't need the sysprep
    if (!getVm().isRunOnce() && !StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVmStaticDAO().update(getVm().getStaticData());
    }
    // get what cpu flags should be passed to vdsm according to cluster
    // cpu name
    getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
    VmHandler.updateVmGuestAgentVersion(getVm());
    getVm().setCpuName(getVdsGroup().getcpu_name());
    if (!getVm().getInterfaces().isEmpty()) {
        initParametersForExternalNetworks();
    }
    if (getFlow() != RunVmFlow.RESUME_HIBERNATE) {
        getVm().setHibernationVolHandle(getMemoryFromSnapshot());
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return null;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.emptyList();
}
#end_block

#method_before
private void removeVmHibernationVolumes() {
    RemoveVmHibernationVolumesParameters removeVmHibernationVolumesParameters = new RemoveVmHibernationVolumesParameters(getVmId());
    removeVmHibernationVolumesParameters.setParentCommand(getActionType());
    removeVmHibernationVolumesParameters.setEntityInfo(getParameters().getEntityInfo());
    removeVmHibernationVolumesParameters.setParentParameters(getParameters());
    VdcReturnValueBase vdcRetValue = getBackend().runInternalAction(VdcActionType.RemoveVmHibernationVolumes, removeVmHibernationVolumesParameters, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    for (Guid taskId : vdcRetValue.getInternalVdsmTaskIdList()) {
        AsyncTaskManager.getInstance().startPollingTask(taskId);
    }
}
#method_after
private void removeVmHibernationVolumes() {
    RemoveVmHibernationVolumesParameters removeVmHibernationVolumesParameters = new RemoveVmHibernationVolumesParameters(getVmId());
    removeVmHibernationVolumesParameters.setParentCommand(getActionType());
    removeVmHibernationVolumesParameters.setEntityInfo(getParameters().getEntityInfo());
    removeVmHibernationVolumesParameters.setParentParameters(getParameters());
    VdcReturnValueBase vdcRetValue = getBackend().runInternalAction(VdcActionType.RemoveVmHibernationVolumes, removeVmHibernationVolumesParameters, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    for (Guid taskId : vdcRetValue.getInternalVdsmTaskIdList()) {
        TaskManagerUtil.startPollingTask(taskId);
    }
}
#end_block

#method_before
@Override
public void processOnVmStop(Guid vmId) {
    Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId), ExecutionHandler.createInternalJobContext());
}
#method_after
@Override
public void processOnVmStop(Guid vmId) {
    Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId));
}
#end_block

#method_before
@Override
public void storagePoolUpEvent(StoragePool storagePool) {
    AsyncTaskManager.getInstance().addStoragePoolExistingTasks(storagePool);
}
#method_after
@Override
public void storagePoolUpEvent(StoragePool storagePool) {
    TaskManagerUtil.addStoragePoolExistingTasks(storagePool);
}
#end_block

#method_before
public static Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return CommandCoordinator.getInstance().createTask(taskId, command, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#method_after
public static Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return coco.createTask(taskId, command, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#end_block

#method_before
public static SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return CommandCoordinator.getInstance().concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public static SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public static void cancelTasks(final CommandBase command) {
    CommandCoordinator.getInstance().cancelTasks(command);
}
#method_after
public static void cancelTasks(final CommandBase command) {
    coco.cancelTasks(command);
}
#end_block

#method_before
public static void revertTasks(final CommandBase command) {
    CommandCoordinator.getInstance().revertTasks(command);
}
#method_after
public static void revertTasks(final CommandBase command) {
    coco.revertTasks(command);
}
#end_block

#method_before
public static AsyncTasks getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return CommandCoordinator.getInstance().getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public static AsyncTasks getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public static AsyncTasks createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return CommandCoordinator.getInstance().createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public static AsyncTasks createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#method_after
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#end_block

#method_before
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (isInternalExecution() || !isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#method_after
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (!isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#end_block

#method_before
private boolean isQuotaDependant() {
    return getActionType().getQuotaDependency() != VdcActionType.QuotaDependency.NONE;
}
#method_after
protected boolean isQuotaDependant() {
    boolean result;
    if (getActionType().getQuotaDependency() == VdcActionType.QuotaDependency.NONE)
        result = false;
    else if (!isInternalExecution())
        result = true;
    else if (getActionType().isQuotaDependentAsInternalCommand())
        result = true;
    else
        result = false;
    return result;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#end_block

#method_before
@Override
public void processOnClientIpChange(final VDS vds, final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(vmId);
    final AuditLogableBase event = new AuditLogableBase();
    event.setVmId(vmId);
    event.setUserName(vmDynamic.getConsoleCurrentUserName());
    // (this happened when user close the console to spice/vnc)
    if (StringUtils.isEmpty(vmDynamic.getClientIp())) {
        vmDynamic.setConsoleCurrentUserName(null);
        DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
        AuditLogDirector.log(event, AuditLogType.VM_CONSOLE_DISCONNECTED);
    } else {
        AuditLogDirector.log(event, AuditLogType.VM_CONSOLE_CONNECTED);
    }
}
#method_after
@Override
public void processOnClientIpChange(final VDS vds, final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(vmId);
    final AuditLogableBase event = new AuditLogableBase();
    event.setVmId(vmId);
    String username = vmDynamic.getConsoleCurrentUserName();
    if (username.contains("@")) {
        username = username.substring(0, username.indexOf("@"));
    }
    event.setUserName(username);
    // (this happened when user close the console to spice/vnc)
    if (StringUtils.isEmpty(vmDynamic.getClientIp())) {
        vmDynamic.setConsoleCurrentUserName(null);
        DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
        AuditLogDirector.log(event, AuditLogType.VM_CONSOLE_DISCONNECTED);
    } else {
        AuditLogDirector.log(event, AuditLogType.VM_CONSOLE_CONNECTED);
    }
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    // Create authentication profiles for all the domains that exist in the database:
    // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
    createInternalAAAConfigurations();
    createKerberosLdapAAAConfigurations();
    ExtensionsManager.getInstance().dump();
    AuthenticationProfileRepository.getInstance();
    DbUserCacheManager.getInstance().init();
    TaskManagerUtil.initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
}
#method_after
@Override
@PostConstruct
public void create() {
    try {
        // Create authentication profiles for all the domains that exist in the database:
        // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
        EngineExtensionsManager.getInstance().engineInitialize();
        AuthenticationProfileRepository.getInstance();
        DbUserCacheManager.getInstance().init();
        TaskManagerUtil.initAsyncTaskManager();
        ResourceManager.getInstance().init();
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolManager.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        ExternalTrustStoreInitializer.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        new DwhHeartBeat().init();
        // Initialize Power Management Health Check
        PmHealthCheckManager.getInstance().initialize();
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#end_block

#method_before
private boolean checkAndFetchQuota(QuotaConsumptionParametersWrapper parameters, QuotaConsumptionParameter param, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (param.getQuotaGuid() == null || Guid.Empty.equals(param.getQuotaGuid())) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        parameters.getCanDoActionMessages().add(String.format("$VmName %1$s", parameters.getAuditLogable().getVmName()));
        if (QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
            auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        }
        log.errorFormat("No Quota id passed from command: {0}", parameters.getAuditLogable().getClass().getName());
        corruptedParameters.add(param);
        return false;
    }
    Quota quota = fetchQuotaFromCache(param.getQuotaGuid(), parameters.getStoragePool().getId());
    if (quota == null) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
        parameters.getCanDoActionMessages().add(String.format("$VmName %1$s", parameters.getAuditLogable().getVmName()));
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("The quota id {0} is not found in backend and DB.", param.getQuotaGuid().toString());
        corruptedParameters.add(param);
        return false;
    } else {
        param.setQuota(quota);
    }
    if (!quota.getStoragePoolId().equals(parameters.getStoragePoolId())) {
        throw new InvalidQuotaParametersException("The Quota storage pool id does not match the passed storage pool");
    }
    return true;
}
#method_after
private boolean checkAndFetchQuota(QuotaConsumptionParametersWrapper parameters, QuotaConsumptionParameter param, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (param.getQuotaGuid() == null || Guid.Empty.equals(param.getQuotaGuid())) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        parameters.getCanDoActionMessages().add(String.format("$VmName %1$s", parameters.getAuditLogable().getVmName()));
        if (QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT == parameters.getStoragePool().getQuotaEnforcementType()) {
            auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        }
        log.errorFormat("No Quota id passed from command: {0}", parameters.getAuditLogable().getClass().getName());
        corruptedParameters.add(param);
        return false;
    }
    Quota quota = fetchQuotaFromCache(param.getQuotaGuid(), parameters.getStoragePool().getId());
    if (quota == null) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
        parameters.getCanDoActionMessages().add(String.format("$VmName %1$s", parameters.getAuditLogable().getVmName()));
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("The quota id {0} is not found in backend and DB.", param.getQuotaGuid().toString());
        corruptedParameters.add(param);
        return false;
    } else {
        param.setQuota(quota);
    }
    if (!quota.getStoragePoolId().equals(parameters.getStoragePoolId())) {
        throw new InvalidQuotaParametersException("The Quota storage pool id does not match the passed storage pool");
    }
    return true;
}
#end_block

#method_before
private boolean canDoSnapshot(VM vm) {
    // if live snapshot is enabled, there is no need to check if vm is up since in any case snapshot is possible
    if (!isLiveSnapshotEnabled() && !vm.isDown()) {
        // if there is no live snapshot and the vm is up - snapshot is not possible
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DATA_CENTER_VERSION_DOESNT_SUPPORT_LIVE_SNAPSHOT);
    }
    // it is possible, even if unlikely, that the QEMU on the host does not support live snapshotting
    if (!getVdsFromRunningVm(vm).getLiveSnapshotSupport()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_QEMU_UNSUPPORTED_OPERATION);
    }
    return true;
}
#method_after
private boolean canDoSnapshot(VM vm) {
    // if live snapshot is enabled, there is no need to check if vm is up since in any case snapshot is possible
    if (!isLiveSnapshotEnabled() && !vm.isDown()) {
        // if there is no live snapshot and the vm is up - snapshot is not possible
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DATA_CENTER_VERSION_DOESNT_SUPPORT_LIVE_SNAPSHOT);
    }
    VDS vds = getVds();
    // it is possible, even if unlikely, that the QEMU on the host does not support live snapshotting
    if (vds != null && !vds.getLiveSnapshotSupport()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_QEMU_UNSUPPORTED_OPERATION);
    }
    return true;
}
#end_block

#method_before
@Test
public void testSaveOrUpdateExisting() {
    int sizeBeforeSave = dao.getAll().size();
    existingUser.setFirstName("changedname");
    existingUser.setLastName("changedsurname");
    int sizeAfterSave = dao.getAll().size();
    dao.saveOrUpdate(existingUser);
    DbUser result = dao.get(existingUser.getId());
    assertEquals(existingUser, result);
    assertEquals(0, sizeAfterSave - sizeBeforeSave);
}
#method_after
@Test
public void testSaveOrUpdateExisting() {
    int sizeBeforeSave = dao.getAll().size();
    existingUser.setFirstName("changedname");
    existingUser.setLastName("changedsurname");
    dao.saveOrUpdate(existingUser);
    int sizeAfterSave = dao.getAll().size();
    DbUser result = dao.get(existingUser.getId());
    assertEquals(existingUser, result);
    assertEquals(0, sizeAfterSave - sizeBeforeSave);
}
#end_block

#method_before
private void initLocalizationEditor() {
    localeBox = new ListBox();
    // $NON-NLS-1$
    localeBox.getElement().setId("AbstractLoginFormView_localeBox");
    // Add the option to change the locale
    String currentLocale = LocaleInfo.getCurrentLocale().getLocaleName();
    String[] localeNames = LocaleInfo.getAvailableLocaleNames();
    // Populate the locale list box with available locales
    boolean foundDefaultLocale = false;
    for (String localeName : localeNames) {
        if (!DEFAULT_LOCALE.equals(localeName)) {
            String nativeName = LocaleInfo.getLocaleNativeDisplayName(localeName);
            localeBox.addItem(nativeName, localeName);
            if (localeName.equals(currentLocale)) {
                setSelectedLocale(localeBox.getItemCount() - 1);
                foundDefaultLocale = true;
            }
        }
    }
    // When no available locale matches the current locale, select the first available locale
    if (!foundDefaultLocale && localeNames.length > 0) {
        setSelectedLocale(0);
    }
    localeBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            String localeQueryParam = LocaleInfo.getLocaleQueryParam();
            // $NON-NLS-1$ //$NON-NLS-2$
            String localeString = "?" + localeQueryParam + "=" + localeBox.getValue(localeBox.getSelectedIndex());
            // $NON-NLS-1$ //$NON-NLS-2$
            Window.open(FrontendUrlUtils.getCurrentPageURL() + localeString, "_self", "");
        }
    });
}
#method_after
private void initLocalizationEditor() {
    localeBox = new ListBox();
    // Add the option to change the locale
    String currentLocale = LocaleInfo.getCurrentLocale().getLocaleName();
    String[] localeNames = LocaleInfo.getAvailableLocaleNames();
    // Populate the locale list box with available locales
    boolean foundDefaultLocale = false;
    for (String localeName : localeNames) {
        if (!DEFAULT_LOCALE.equals(localeName)) {
            String nativeName = LocaleInfo.getLocaleNativeDisplayName(localeName);
            localeBox.addItem(nativeName, localeName);
            if (localeName.equals(currentLocale)) {
                setSelectedLocale(localeBox.getItemCount() - 1);
                foundDefaultLocale = true;
            }
        }
    }
    // When no available locale matches the current locale, select the first available locale
    if (!foundDefaultLocale && localeNames.length > 0) {
        setSelectedLocale(0);
    }
    localeBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            String localeQueryParam = LocaleInfo.getLocaleQueryParam();
            // $NON-NLS-1$ //$NON-NLS-2$
            String localeString = "?" + localeQueryParam + "=" + localeBox.getValue(localeBox.getSelectedIndex());
            // $NON-NLS-1$ //$NON-NLS-2$
            Window.open(FrontendUrlUtils.getCurrentPageURL() + localeString, "_self", "");
        }
    });
}
#end_block

#method_before
@Override
public IAutoCompleter getFieldRelationshipAutoCompleter(String fieldName) {
    if (UPTIME.equals(fieldName) || CREATIONDATE.equals(fieldName)) {
        return BiggerOrSmallerRelationAutoCompleter.INSTANCE;
    } else if (CPU_USAGE.equals(fieldName) || MEM_USAGE.equals(fieldName) || MEM_USAGE.equals(fieldName) || NETWORK_USAGE.equals(fieldName) || MIGRATION_PROGRESS_PERCENT.equals(fieldName)) {
        return NumericConditionRelationAutoCompleter.INSTANCE;
    } else if (TAG.equals(fieldName)) {
        return StringOnlyEqualConditionRelationAutoCompleter.INSTANCE;
    } else {
        return StringConditionRelationAutoCompleter.INSTANCE;
    }
}
#method_after
@Override
public IAutoCompleter getFieldRelationshipAutoCompleter(String fieldName) {
    if (UPTIME.equals(fieldName) || CREATIONDATE.equals(fieldName)) {
        return BiggerOrSmallerRelationAutoCompleter.INSTANCE;
    } else if (CPU_USAGE.equals(fieldName) || MEM_USAGE.equals(fieldName) || MEMORY.equals(fieldName) || NETWORK_USAGE.equals(fieldName)) {
        return NumericConditionRelationAutoCompleter.INSTANCE;
    } else if (TAG.equals(fieldName)) {
        return StringOnlyEqualConditionRelationAutoCompleter.INSTANCE;
    } else {
        return StringConditionRelationAutoCompleter.INSTANCE;
    }
}
#end_block

#method_before
public void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    ArrayList<VdcActionType> actionsList = new ArrayList<VdcActionType>(items.size());
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>(items.size());
    for (DbUser item : items) {
        if (item.isGroup()) {
            actionsList.add(VdcActionType.AddGroup);
        } else {
            actionsList.add(VdcActionType.AddUser);
        }
        DirectoryIdParameters parameters = new DirectoryIdParameters();
        parameters.setDirectory(item.getDomain());
        parameters.setId(item.getExternalId());
        parametersList.add(parameters);
    }
    model.startProgress(null);
    IFrontendActionAsyncCallback nopCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
        // Nothing.
        }
    };
    IFrontendActionAsyncCallback lastCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    };
    ArrayList<IFrontendActionAsyncCallback> callbacksList = new ArrayList<IFrontendActionAsyncCallback>(items.size());
    for (int i = 1; i < items.size(); i++) {
        callbacksList.add(nopCallback);
    }
    callbacksList.add(lastCallback);
    Frontend.getInstance().runMultipleActions(actionsList, parametersList, callbacksList, lastCallback, model);
}
#method_after
public void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    ArrayList<VdcActionType> actionsList = new ArrayList<VdcActionType>(items.size());
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>(items.size());
    for (DbUser item : items) {
        if (item.isGroup()) {
            actionsList.add(VdcActionType.AddGroup);
        } else {
            actionsList.add(VdcActionType.AddUser);
        }
        DirectoryIdParameters parameters = new DirectoryIdParameters();
        parameters.setDirectory(item.getDomain());
        parameters.setId(item.getExternalId());
        parameters.setNamespace(item.getNamespace());
        parametersList.add(parameters);
    }
    model.startProgress(null);
    IFrontendActionAsyncCallback nopCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
        // Nothing.
        }
    };
    IFrontendActionAsyncCallback lastCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    };
    ArrayList<IFrontendActionAsyncCallback> callbacksList = new ArrayList<IFrontendActionAsyncCallback>(items.size());
    for (int i = 1; i < items.size(); i++) {
        callbacksList.add(nopCallback);
    }
    callbacksList.add(lastCallback);
    Frontend.getInstance().runMultipleActions(actionsList, parametersList, callbacksList, lastCallback, model);
}
#end_block

#method_before
@Override
protected void connect() {
    if (getEntity() != null) {
        // $NON-NLS-1$
        getLogger().debug("Connecting to Spice console...");
        if (!getspice().getIsInstalled()) {
            // $NON-NLS-1$
            getLogger().info("Spice client is not installed.");
            getspice().install();
            return;
        }
        // Check a spice version.
        if (getConfigurator().getIsAdmin() && getspice().getCurrentVersion().compareTo(getspice().getDesiredVersion()) < 0) {
            // $NON-NLS-1$ //$NON-NLS-2$
            getLogger().info("Spice client version is not as desired (" + getspice().getDesiredVersion() + ")");
            getspice().install();
            return;
        }
        // Don't connect if there VM is not running on any host.
        if (getEntity().getRunOnVds() == null) {
            return;
        }
        // If it is not windows or SPICE guest agent is not installed, make sure the WAN options are disabled.
        if (!AsyncDataProvider.isWindowsOsType(getEntity().getVmOsId()) || !getEntity().getHasSpiceDriver()) {
            getspice().setWanOptionsEnabled(false);
        }
        UICommand setVmTicketCommand = new UICommand("setVmCommand", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand uiCommand) {
                setVmTicket();
            }
        });
        executeCommandWithConsoleSafenessWarning(setVmTicketCommand);
    }
}
#method_after
@Override
protected void connect() {
    if (getEntity() != null) {
        // $NON-NLS-1$
        getLogger().debug("Connecting to Spice console...");
        // Check a spice version.
        if (getConfigurator().getIsAdmin() && getspice().getCurrentVersion().compareTo(getspice().getDesiredVersion()) < 0) {
            // $NON-NLS-1$ //$NON-NLS-2$
            Window.alert("Spice client version is not as desired (" + getspice().getDesiredVersion() + ")");
            return;
        }
        // Don't connect if there VM is not running on any host.
        if (getEntity().getRunOnVds() == null) {
            return;
        }
        // If it is not windows or SPICE guest agent is not installed, make sure the WAN options are disabled.
        if (!AsyncDataProvider.isWindowsOsType(getEntity().getVmOsId()) || !getEntity().getHasSpiceDriver()) {
            getspice().setWanOptionsEnabled(false);
        }
        UICommand setVmTicketCommand = new UICommand("setVmCommand", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand uiCommand) {
                setVmTicket();
            }
        });
        executeCommandWithConsoleSafenessWarning(setVmTicketCommand);
    }
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setArchitecture(new ListModel<ArchitectureType>());
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#end_block

#method_before
private void populateCPUList(ClusterModel clusterModel, List<ServerCpu> cpus, boolean canChangeArchitecture) {
    ServerCpu oldSelectedCpu = clusterModel.getCPU().getSelectedItem();
    clusterModel.getCPU().setItems(cpus);
    initSupportedArchitectures(clusterModel);
    clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.firstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
    if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
        initCPU();
    }
    if (clusterModel.getIsEdit()) {
        if (!canChangeArchitecture) {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(clusterModel.getEntity().getArchitecture())));
        }
        ArchitectureType oldSelectedArch = clusterModel.getArchitecture().getSelectedItem();
        if (oldSelectedArch != null) {
            getArchitecture().setSelectedItem(oldSelectedArch);
        } else {
            getArchitecture().setSelectedItem(getEntity().getArchitecture());
        }
    } else {
        getArchitecture().setSelectedItem(ArchitectureType.undefined);
    }
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
}
#method_after
private void populateCPUList(ClusterModel clusterModel, List<ServerCpu> cpus, boolean canChangeArchitecture) {
    ServerCpu oldSelectedCpu = clusterModel.getCPU().getSelectedItem();
    clusterModel.getCPU().setItems(cpus);
    initSupportedArchitectures(clusterModel);
    clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.firstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
    if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
        initCPU();
    }
    if (clusterModel.getIsEdit()) {
        if (!canChangeArchitecture) {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(clusterModel.getEntity().getArchitecture())));
        }
        ArchitectureType oldSelectedArch = clusterModel.getArchitecture().getSelectedItem();
        if (oldSelectedArch != null) {
            getArchitecture().setSelectedItem(oldSelectedArch);
        } else {
            getArchitecture().setSelectedItem(getEntity().getArchitecture());
        }
    } else {
        getArchitecture().setSelectedItem(ArchitectureType.undefined);
    }
}
#end_block

#method_before
private void populateCPUList(ClusterModel clusterModel, List<ServerCpu> cpus, boolean canChangeArchitecture) {
    ServerCpu oldSelectedCpu = clusterModel.getCPU().getSelectedItem();
    clusterModel.getCPU().setItems(cpus);
    initSupportedArchitectures(clusterModel);
    clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.firstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
    if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
        initCPU();
    }
    if (clusterModel.getIsEdit()) {
        if (!canChangeArchitecture) {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(clusterModel.getEntity().getArchitecture())));
        }
        ArchitectureType oldSelectedArch = clusterModel.getArchitecture().getSelectedItem();
        if (oldSelectedArch != null) {
            getArchitecture().setSelectedItem(oldSelectedArch);
        } else {
            getArchitecture().setSelectedItem(getEntity().getArchitecture());
        }
    } else {
        getArchitecture().setSelectedItem(ArchitectureType.undefined);
    }
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
}
#method_after
private void populateCPUList(ClusterModel clusterModel, List<ServerCpu> cpus, boolean canChangeArchitecture) {
    ServerCpu oldSelectedCpu = clusterModel.getCPU().getSelectedItem();
    clusterModel.getCPU().setItems(cpus);
    initSupportedArchitectures(clusterModel);
    clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.firstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
    if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
        initCPU();
    }
    if (clusterModel.getIsEdit()) {
        if (!canChangeArchitecture) {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(clusterModel.getEntity().getArchitecture())));
        }
        ArchitectureType oldSelectedArch = clusterModel.getArchitecture().getSelectedItem();
        if (oldSelectedArch != null) {
            getArchitecture().setSelectedItem(oldSelectedArch);
        } else {
            getArchitecture().setSelectedItem(getEntity().getArchitecture());
        }
    } else {
        getArchitecture().setSelectedItem(ArchitectureType.undefined);
    }
}
#end_block

#method_before
private static void mapProfileDetails(List<StatsInfo> statsInfoList, EntityProfileDetail entityprofileDetail) {
    for (StatsInfo statsInfo : statsInfoList) {
        ProfileDetail profileDetail = new ProfileDetail();
        profileDetail.setProfileType(statsInfo.getProfileStatsType().name());
        profileDetail.setDuration(statsInfo.getDuration());
        profileDetail.getStatistic().add(StatisticResourceUtils.setDatum(TOTAL_READ, statsInfo.getTotalRead()));
        profileDetail.getStatistic().add(StatisticResourceUtils.setDatum(TOTAL_WRITE, statsInfo.getTotalWrite()));
        mapBlockStats(profileDetail, statsInfo);
        mapFopStats(profileDetail, statsInfo);
        entityprofileDetail.getProfileDetail().add(profileDetail);
    }
}
#method_after
private static void mapProfileDetails(List<StatsInfo> statsInfoList, EntityProfileDetail entityprofileDetail) {
    for (StatsInfo statsInfo : statsInfoList) {
        ProfileDetail profileDetail = new ProfileDetail();
        profileDetail.setProfileType(statsInfo.getProfileStatsType().name());
        profileDetail.setDuration(statsInfo.getDuration());
        profileDetail.getStatistic().add(StatisticResourceUtils.setDatum(clone(TOTAL_READ), statsInfo.getTotalRead()));
        profileDetail.getStatistic().add(StatisticResourceUtils.setDatum(clone(TOTAL_WRITE), statsInfo.getTotalWrite()));
        mapBlockStats(profileDetail, statsInfo);
        mapFopStats(profileDetail, statsInfo);
        entityprofileDetail.getProfileDetail().add(profileDetail);
    }
}
#end_block

#method_before
private static void mapFopStats(ProfileDetail profileDetail, StatsInfo statsInfo) {
    for (FopStats fopStat : statsInfo.getFopStats()) {
        FopStatistic fStat = new FopStatistic();
        fStat.setName(fopStat.getName());
        fStat.getStatistic().add(StatisticResourceUtils.setDatum(MIN_LATENCY, fopStat.getMinLatency()));
        fStat.getStatistic().add(StatisticResourceUtils.setDatum(MAX_LATENCY, fopStat.getMaxLatency()));
        fStat.getStatistic().add(StatisticResourceUtils.setDatum(AVG_LATENCY, fopStat.getAvgLatency()));
        fStat.getStatistic().add(StatisticResourceUtils.setDatum(HITS, fopStat.getHits()));
        profileDetail.getFopStatistic().add(fStat);
    }
}
#method_after
private static void mapFopStats(ProfileDetail profileDetail, StatsInfo statsInfo) {
    for (FopStats fopStat : statsInfo.getFopStats()) {
        FopStatistic fStat = new FopStatistic();
        fStat.setName(fopStat.getName());
        fStat.getStatistic().add(StatisticResourceUtils.setDatum(clone(MIN_LATENCY), fopStat.getMinLatency()));
        fStat.getStatistic().add(StatisticResourceUtils.setDatum(clone(MAX_LATENCY), fopStat.getMaxLatency()));
        fStat.getStatistic().add(StatisticResourceUtils.setDatum(clone(AVG_LATENCY), fopStat.getAvgLatency()));
        fStat.getStatistic().add(StatisticResourceUtils.setDatum(clone(HITS), fopStat.getHits()));
        profileDetail.getFopStatistic().add(fStat);
    }
}
#end_block

#method_before
private static void mapBlockStats(ProfileDetail profileDetail, StatsInfo statsInfo) {
    for (BlockStats blockStat : statsInfo.getBlockStats()) {
        BlockStatistic bStat = new BlockStatistic();
        bStat.getStatistic().add(StatisticResourceUtils.setDatum(BLOCK_SIZE, blockStat.getSize()));
        bStat.getStatistic().add(StatisticResourceUtils.setDatum(BYTES_BLOCK_READ, blockStat.getBlockRead()));
        bStat.getStatistic().add(StatisticResourceUtils.setDatum(BYTES_BLOCK_WRITE, blockStat.getBlockWrite()));
        profileDetail.getBlockStatistic().add(bStat);
    }
}
#method_after
private static void mapBlockStats(ProfileDetail profileDetail, StatsInfo statsInfo) {
    for (BlockStats blockStat : statsInfo.getBlockStats()) {
        BlockStatistic bStat = new BlockStatistic();
        bStat.getStatistic().add(StatisticResourceUtils.setDatum(clone(BLOCK_SIZE), blockStat.getSize()));
        bStat.getStatistic().add(StatisticResourceUtils.setDatum(clone(BYTES_BLOCK_READ), blockStat.getBlockRead()));
        bStat.getStatistic().add(StatisticResourceUtils.setDatum(clone(BYTES_BLOCK_WRITE), blockStat.getBlockWrite()));
        profileDetail.getBlockStatistic().add(bStat);
    }
}
#end_block

#method_before
public static String asId(String name) {
    return UUID.nameUUIDFromBytes(name.getBytes()).toString();
}
#method_after
private static String asId(String name) {
    return UUID.nameUUIDFromBytes(name.getBytes()).toString();
}
#end_block

#method_before
@Override
public GlusterVolumeProfileDetails getProfileStatistics() {
    VdcQueryReturnValue result = runQuery(VdcQueryType.GetGlusterVolumeProfileInfo, new GlusterVolumeProfileParameters(Guid.createGuidFromString(parent.getParent().get().getId()), guid));
    if (result != null && result.getSucceeded() && result.getReturnValue() != null) {
        return LinkHelper.addLinks(uriInfo, getMapper(GlusterVolumeProfileInfo.class, GlusterVolumeProfileDetails.class).map((GlusterVolumeProfileInfo) result.getReturnValue(), null));
    } else {
        // throw exception
        throw new WebFaultException(null, localize(Messages.BACKEND_FAILED), Response.Status.INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
public GlusterVolumeProfileDetails getProfileStatistics() {
    boolean nfsStats = isNfsStatistics();
    VdcQueryReturnValue result = runQuery(VdcQueryType.GetGlusterVolumeProfileInfo, new GlusterVolumeProfileParameters(Guid.createGuidFromString(parent.getParent().get().getId()), guid, nfsStats));
    if (result != null && result.getSucceeded() && result.getReturnValue() != null) {
        return LinkHelper.addLinks(uriInfo, getMapper(GlusterVolumeProfileInfo.class, GlusterVolumeProfileDetails.class).map((GlusterVolumeProfileInfo) result.getReturnValue(), null));
    } else {
        // throw exception
        throw new WebFaultException(null, localize(Messages.BACKEND_FAILED), Response.Status.INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
public void registerProfile(AuthenticationProfile profile) {
    profiles.put(profile.getName(), profile);
}
#method_after
public void registerProfile(AuthenticationProfile profile) {
    registerProfile(profiles, profile);
}
#end_block

#method_before
private void createProfiles() throws ConfigurationException {
    for (ExtensionProxy authnExtension : EngineExtensionsManager.getInstance().getExtensionsByService(AUTHN_SERVICE)) {
        String mapperName = authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(AUTHN_MAPPING_PLUGIN);
        String authzName = authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(AUTHN_AUTHZ_PLUGIN);
        if (authzName == null) {
            throw new ConfigurationException(String.format("Authz plugin for %1$s does not exist", authnExtension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME)));
        }
        registerProfile(new AuthenticationProfile(authnExtension, EngineExtensionsManager.getInstance().getExtensionByName(authzName), mapperName != null ? EngineExtensionsManager.getInstance().getExtensionByName(mapperName) : null));
    }
}
#method_after
private Map<String, AuthenticationProfile> createProfiles() throws ConfigurationException {
    // Get the extensions that correspond to authn (authentication) service.
    // For each extension - get the relevant authn extension.
    Map<String, AuthenticationProfile> results = new HashMap<>();
    for (ExtensionProxy authnExtension : EngineExtensionsManager.getInstance().getExtensionsByService(AUTHN_SERVICE)) {
        String mapperName = authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(AUTHN_MAPPING_PLUGIN);
        String authzName = authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(AUTHN_AUTHZ_PLUGIN);
        if (authzName == null) {
            throw new ConfigurationException(String.format("Authz plugin for %1$s does not exist", authnExtension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME)));
        }
        AuthenticationProfile profile = new AuthenticationProfile(authnExtension, EngineExtensionsManager.getInstance().getExtensionByName(authzName), mapperName != null ? EngineExtensionsManager.getInstance().getExtensionByName(mapperName) : null);
        results.put(profile.getName(), profile);
    }
    return results;
}
#end_block

#method_before
public void registerProfile(AuthenticationProfile profile) {
    profiles.put(profile.getName(), profile);
}
#method_after
private void registerProfile(Map<String, AuthenticationProfile> map, AuthenticationProfile profile) {
    map.put(profile.getName(), profile);
}
#end_block

#method_before
@Override
public void update(Observable o, Object arg) {
    clear();
    createProfiles();
}
#method_after
@Override
public void update(Observable o, Object arg) {
    profiles = createProfiles();
}
#end_block

#method_before
@Before
public void setUp() {
    disk1 = createDisk();
    disk1.setDiskAlias("disk1");
    disk2 = createDisk();
    disk2.setDiskAlias("disk2");
    validator = spy(new DiskSnapshotsValidator(Arrays.asList(disk1, disk2)));
}
#method_after
@Before
public void setUp() {
    disk1 = createDisk();
    disk1.setDiskAlias("disk1");
    disk2 = createDisk();
    disk2.setDiskAlias("disk2");
    validator = spy(new DiskSnapshotsValidator(Arrays.asList(disk1, disk2)));
    doReturn(diskImageDao).when(validator).getDiskImageDao();
    doReturn(snapshotDao).when(validator).getSnapshotDao();
}
#end_block

#method_before
@Test
public void testRemoveImageFromSnapshotConfiguration() throws OvfReaderException {
    Guid vmId = Guid.newGuid();
    VM vm = new VM();
    vm.setId(vmId);
    vm.setStoragePoolId(Guid.newGuid());
    vm.setVmtName(RandomUtils.instance().nextString(10));
    vm.setOrigin(OriginType.OVIRT);
    vm.setDbGeneration(1L);
    Guid vmSnapshotId = Guid.newGuid();
    DiskImage disk1 = addTestDisk(vm, vmSnapshotId);
    DiskImage disk2 = addTestDisk(vm, vmSnapshotId);
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> disks = new ArrayList<DiskImage>(Arrays.asList(disk1, disk2));
    String ovf = ovfManager.ExportVm(vm, disks, Version.v3_1);
    Snapshot snap = new Snapshot();
    snap.setVmConfiguration(ovf);
    snap.setId(vmSnapshotId);
    when(snapshotDAO.get(vmSnapshotId)).thenReturn(snap);
    doReturn(disk2).when(cmd).getDiskImage();
    doReturn(disk2).when(cmd).getImage();
    doReturn(disk2.getId()).when(cmd).getImageId();
    Snapshot actual = cmd.prepareSnapshotConfigWithoutImageSingleImage(vmSnapshotId, disk2.getImageId());
    String actualOvf = actual.getVmConfiguration();
    ArrayList<DiskImage> actualImages = new ArrayList<DiskImage>();
    ovfManager.ImportVm(actualOvf, new VM(), actualImages, new ArrayList<VmNetworkInterface>());
    assertEquals("Wrong number of disks", 1, actualImages.size());
    assertEquals("Wrong disk", disk1, actualImages.get(0));
}
#method_after
@Test
public void testRemoveImageFromSnapshotConfiguration() throws OvfReaderException {
    Guid vmId = Guid.newGuid();
    VM vm = new VM();
    vm.setId(vmId);
    vm.setStoragePoolId(Guid.newGuid());
    vm.setVmtName(RandomUtils.instance().nextString(10));
    vm.setOrigin(OriginType.OVIRT);
    vm.setDbGeneration(1L);
    Guid vmSnapshotId = Guid.newGuid();
    DiskImage disk1 = addTestDisk(vm, vmSnapshotId);
    DiskImage disk2 = addTestDisk(vm, vmSnapshotId);
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> disks = new ArrayList<DiskImage>(Arrays.asList(disk1, disk2));
    String ovf = ovfManager.ExportVm(vm, disks, Version.v3_1);
    Snapshot snap = new Snapshot();
    snap.setVmConfiguration(ovf);
    snap.setId(vmSnapshotId);
    when(snapshotDAO.get(vmSnapshotId)).thenReturn(snap);
    doReturn(disk2).when(cmd).getDiskImage();
    doReturn(disk2).when(cmd).getImage();
    doReturn(disk2.getId()).when(cmd).getImageId();
    Snapshot actual = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snap, disk2.getImageId());
    String actualOvf = actual.getVmConfiguration();
    ArrayList<DiskImage> actualImages = new ArrayList<DiskImage>();
    ovfManager.ImportVm(actualOvf, new VM(), actualImages, new ArrayList<VmNetworkInterface>());
    assertEquals("Wrong number of disks", 1, actualImages.size());
    assertEquals("Wrong disk", disk1, actualImages.get(0));
}
#end_block

#method_before
@Test
public void testRemoveImageFromSnapshotConfigurationBackwardCompatibility() throws OvfReaderException {
    Guid vmId = Guid.newGuid();
    VM vm = new VM();
    vm.setId(vmId);
    vm.setStoragePoolId(Guid.newGuid());
    vm.setVmtName(RandomUtils.instance().nextString(10));
    vm.setOrigin(OriginType.OVIRT);
    vm.setDbGeneration(1L);
    Guid vmSnapshotId = Guid.newGuid();
    DiskImage disk1 = addTestDisk(vm, vmSnapshotId);
    DiskImage disk2 = addTestDisk(vm, vmSnapshotId);
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> disks = new ArrayList<DiskImage>(Arrays.asList(disk1, disk2));
    String ovf = ovfManager.ExportVm(vm, disks, Version.v3_0);
    Snapshot snap = new Snapshot();
    snap.setVmConfiguration(ovf);
    snap.setId(vmSnapshotId);
    when(snapshotDAO.get(vmSnapshotId)).thenReturn(snap);
    doReturn(disk2).when(cmd).getDiskImage();
    doReturn(disk2).when(cmd).getImage();
    doReturn(disk2.getId()).when(cmd).getImageId();
    Snapshot actual = cmd.prepareSnapshotConfigWithoutImageSingleImage(vmSnapshotId, disk2.getImageId());
    String actualOvf = actual.getVmConfiguration();
    ArrayList<DiskImage> actualImages = new ArrayList<DiskImage>();
    ovfManager.ImportVm(actualOvf, new VM(), actualImages, new ArrayList<VmNetworkInterface>());
    assertEquals("Wrong number of disks", 1, actualImages.size());
    assertEquals("Wrong disk", disk1, actualImages.get(0));
}
#method_after
@Test
public void testRemoveImageFromSnapshotConfigurationBackwardCompatibility() throws OvfReaderException {
    Guid vmId = Guid.newGuid();
    VM vm = new VM();
    vm.setId(vmId);
    vm.setStoragePoolId(Guid.newGuid());
    vm.setVmtName(RandomUtils.instance().nextString(10));
    vm.setOrigin(OriginType.OVIRT);
    vm.setDbGeneration(1L);
    Guid vmSnapshotId = Guid.newGuid();
    DiskImage disk1 = addTestDisk(vm, vmSnapshotId);
    DiskImage disk2 = addTestDisk(vm, vmSnapshotId);
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> disks = new ArrayList<DiskImage>(Arrays.asList(disk1, disk2));
    String ovf = ovfManager.ExportVm(vm, disks, Version.v3_0);
    Snapshot snap = new Snapshot();
    snap.setVmConfiguration(ovf);
    snap.setId(vmSnapshotId);
    when(snapshotDAO.get(vmSnapshotId)).thenReturn(snap);
    doReturn(disk2).when(cmd).getDiskImage();
    doReturn(disk2).when(cmd).getImage();
    doReturn(disk2.getId()).when(cmd).getImageId();
    Snapshot actual = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snap, disk2.getImageId());
    String actualOvf = actual.getVmConfiguration();
    ArrayList<DiskImage> actualImages = new ArrayList<DiskImage>();
    ovfManager.ImportVm(actualOvf, new VM(), actualImages, new ArrayList<VmNetworkInterface>());
    assertEquals("Wrong number of disks", 1, actualImages.size());
    assertEquals("Wrong disk", disk1, actualImages.get(0));
}
#end_block

#method_before
@Test
public void validateGenerateVmNameStartsWithMask() {
    assertEquals("017mypool", NameForVmInPoolGenerator.generateVmName("???mypool".replace('?', VmPool.MASK_CHARACTER), 17));
}
#method_after
@Test
public void validateGenerateVmNameStartsWithMask() {
    NameForVmInPoolGenerator generator = createNameForVmInPoolGenerator("???mypool");
    for (int i = 1; i < 17; ++i) {
        generator.generateVmName();
    }
    assertEquals("017mypool", generator.generateVmName());
}
#end_block

#method_before
@Test
public void validateGenerateVmNameMaskInside() {
    assertEquals("my001pool", NameForVmInPoolGenerator.generateVmName("my???pool".replace('?', VmPool.MASK_CHARACTER), 1));
}
#method_after
@Test
public void validateGenerateVmNameMaskInside() {
    NameForVmInPoolGenerator generator = createNameForVmInPoolGenerator("my???pool");
    assertEquals("my001pool", generator.generateVmName());
}
#end_block

#method_before
@Test
public void validateGenerateVmNameEndsWithMask() {
    assertEquals("mypool170", NameForVmInPoolGenerator.generateVmName("mypool???".replace('?', VmPool.MASK_CHARACTER), 170));
}
#method_after
@Test
public void validateGenerateVmNameEndsWithMask() {
    NameForVmInPoolGenerator generator = createNameForVmInPoolGenerator("mypool???");
    for (int i = 1; i < 101; ++i) {
        generator.generateVmName();
    }
    assertEquals("mypool101", generator.generateVmName());
}
#end_block

#method_before
@Test
public void validateGenerateVmNameWithoutMask1() {
    assertEquals("mypool-1", NameForVmInPoolGenerator.generateVmName("mypool", 1));
}
#method_after
@Test
public void validateGenerateVmNameWithoutMask1() {
    NameForVmInPoolGenerator generator = createNameForVmInPoolGenerator("mypool");
    assertEquals("mypool-1", generator.generateVmName());
}
#end_block

#method_before
@Test
public void validateGenerateVmNameWithoutMask2() {
    assertEquals("mypool-17", NameForVmInPoolGenerator.generateVmName("mypool", 17));
}
#method_after
@Test
public void validateGenerateVmNameWithoutMask2() {
    NameForVmInPoolGenerator generator = createNameForVmInPoolGenerator("mypool");
    for (int i = 1; i < 17; ++i) {
        generator.generateVmName();
    }
    assertEquals("mypool-17", generator.generateVmName());
}
#end_block

#method_before
@Test
public void validateGenerateVmNameWithoutMask3() {
    assertEquals("mypool-170", NameForVmInPoolGenerator.generateVmName("mypool", 170));
}
#method_after
@Test
public void validateGenerateVmNameWithoutMask3() {
    NameForVmInPoolGenerator generator = createNameForVmInPoolGenerator("mypool");
    for (int i = 1; i < 101; ++i) {
        generator.generateVmName();
    }
    assertEquals("mypool-101", generator.generateVmName());
}
#end_block

#method_before
@Test
public void logRenamedEntity() {
    abstract class RenameCommand extends CommandBaseDummy implements RenamedEntityInfoProvider {

        protected RenameCommand(VdcActionParametersBase params) {
            super(params);
        }
    }
    RenameCommand command = mock(RenameCommand.class);
    when(command.getEntityOldName()).thenReturn(null);
    when(command.getEntityNewName()).thenReturn(null);
    doCallRealMethod().when(command).logRenamedEntity();
    command.logRenamedEntity();
    when(command.getEntityOldName()).thenReturn("foo");
    when(command.getEntityNewName()).thenReturn("bar");
    command.logRenamedEntity();
    when(command.getEntityOldName()).thenReturn(null);
    when(command.getEntityNewName()).thenReturn("bar");
    command.logRenamedEntity();
    when(command.getEntityOldName()).thenReturn("foo");
    when(command.getEntityNewName()).thenReturn(null);
    command.logRenamedEntity();
}
#method_after
@Test
public void logRenamedEntity() {
    abstract class RenameCommand extends CommandBaseDummy implements RenamedEntityInfoProvider {

        protected RenameCommand(VdcActionParametersBase params) {
            super(params);
        }
    }
    RenameCommand command = mock(RenameCommand.class);
    when(command.getEntityOldName()).thenReturn(null);
    when(command.getEntityNewName()).thenReturn(null);
    doCallRealMethod().when(command).logRenamedEntity();
    command.logRenamedEntity();
    when(command.getEntityOldName()).thenReturn("foo");
    when(command.getEntityNewName()).thenReturn("bar");
    when(command.getCurrentUser()).thenReturn(mock(DbUser.class));
    command.logRenamedEntity();
    when(command.getEntityOldName()).thenReturn(null);
    when(command.getEntityNewName()).thenReturn("bar");
    command.logRenamedEntity();
    when(command.getEntityOldName()).thenReturn("foo");
    when(command.getEntityNewName()).thenReturn(null);
    command.logRenamedEntity();
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface);
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() == 0) {
            opts.put("mtu", Config.<Integer>getValue(ConfigValues.DefaultMTU).toString());
        } else {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        VDS host = getDbFacade().getVdsDao().get(getParameters().getVdsId());
        Version version = host.getVdsGroupCompatibilityVersion();
        if (qosConfiguredOnInterface(iface, network) && FeatureSupported.hostNetworkQos(version)) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        Set<Version> supportedClusterVersionsSet = host.getSupportedClusterVersionsSet();
        if (supportedClusterVersionsSet == null || supportedClusterVersionsSet.isEmpty()) {
            log.warnFormat("Host {0} ({1}) doesn't contain Supported Cluster Versions, therefore 'defaultRoute'" + " will not be sent via the SetupNetworks", host.getName(), host.getId());
        } else if (FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet)) && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (iface.hasCustomProperties()) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, iface.getCustomProperties());
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface);
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() == 0) {
            opts.put("mtu", Config.<Integer>getValue(ConfigValues.DefaultMtu).toString());
        } else {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        VDS host = getDbFacade().getVdsDao().get(getParameters().getVdsId());
        Version version = host.getVdsGroupCompatibilityVersion();
        if (qosConfiguredOnInterface(iface, network) && FeatureSupported.hostNetworkQos(version)) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        Set<Version> supportedClusterVersionsSet = host.getSupportedClusterVersionsSet();
        if (supportedClusterVersionsSet == null || supportedClusterVersionsSet.isEmpty()) {
            log.warnFormat("Host {0} ({1}) doesn't contain Supported Cluster Versions, therefore 'defaultRoute'" + " will not be sent via the SetupNetworks", host.getName(), host.getId());
        } else if (FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet)) && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (iface.hasCustomProperties()) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, iface.getCustomProperties());
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    String networkName = (getParameters().getNetworkName() == null) ? "" : getParameters().getNetworkName();
    String oldNetwork = (getParameters().getOldNetworkName() == null) ? "" : getParameters().getOldNetworkName();
    String vlanId = (getParameters().getVlanId() != null) ? getParameters().getVlanId().toString() : "";
    String bond = (getParameters().getBondName() == null) ? "" : getParameters().getBondName();
    String[] nics = (getParameters().getNics() == null) ? new String[] {} : getParameters().getNics();
    Map<String, String> options = new HashMap<String, String>();
    switch(getParameters().getBootProtocol()) {
        case DHCP:
            options.put(VdsProperties.BOOT_PROTOCOL, VdsProperties.DHCP);
            break;
        case STATIC_IP:
            if (!StringUtils.isEmpty(getParameters().getInetAddr())) {
                options.put(VdsProperties.IP_ADDRESS, getParameters().getInetAddr());
            }
            if (!StringUtils.isEmpty(getParameters().getNetworkMask())) {
                options.put(VdsProperties.NETMASK, getParameters().getNetworkMask());
            }
            if (!StringUtils.isEmpty(getParameters().getGateway())) {
                options.put(VdsProperties.GATEWAY, getParameters().getGateway());
            }
            break;
        default:
            break;
    }
    if (!StringUtils.isEmpty(getParameters().getBondingOptions())) {
        options.put(VdsProperties.BONDING_OPTIONS, getParameters().getBondingOptions());
    }
    options.put(VdsProperties.STP, (getParameters().getStp()) ? "yes" : "no");
    options.put("bridged", Boolean.toString(getParameters().isVmNetwork()));
    Network network = getParameters().getNetwork();
    if (network != null) {
        if (network.getMtu() == 0) {
            options.put("mtu", Config.<Integer>getValue(ConfigValues.DefaultMTU).toString());
        } else {
            options.put("mtu", String.valueOf(network.getMtu()));
        }
    }
    // options[VdsProperties.force] = "true";
    if (getParameters().getCheckConnectivity()) {
        options.put(VdsProperties.CONNECTIVITY_CHECK, "true");
        options.put(VdsProperties.CONNECTIVITY_TIMEOUT, String.valueOf(getParameters().getConnectionTimeout()));
    }
    status = getBroker().editNetwork(oldNetwork, networkName, vlanId, bond, nics, options);
    proceedProxyReturnValue();
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    String networkName = (getParameters().getNetworkName() == null) ? "" : getParameters().getNetworkName();
    String oldNetwork = (getParameters().getOldNetworkName() == null) ? "" : getParameters().getOldNetworkName();
    String vlanId = (getParameters().getVlanId() != null) ? getParameters().getVlanId().toString() : "";
    String bond = (getParameters().getBondName() == null) ? "" : getParameters().getBondName();
    String[] nics = (getParameters().getNics() == null) ? new String[] {} : getParameters().getNics();
    Map<String, String> options = new HashMap<String, String>();
    switch(getParameters().getBootProtocol()) {
        case DHCP:
            options.put(VdsProperties.BOOT_PROTOCOL, VdsProperties.DHCP);
            break;
        case STATIC_IP:
            if (!StringUtils.isEmpty(getParameters().getInetAddr())) {
                options.put(VdsProperties.IP_ADDRESS, getParameters().getInetAddr());
            }
            if (!StringUtils.isEmpty(getParameters().getNetworkMask())) {
                options.put(VdsProperties.NETMASK, getParameters().getNetworkMask());
            }
            if (!StringUtils.isEmpty(getParameters().getGateway())) {
                options.put(VdsProperties.GATEWAY, getParameters().getGateway());
            }
            break;
        default:
            break;
    }
    if (!StringUtils.isEmpty(getParameters().getBondingOptions())) {
        options.put(VdsProperties.BONDING_OPTIONS, getParameters().getBondingOptions());
    }
    options.put(VdsProperties.STP, (getParameters().getStp()) ? "yes" : "no");
    options.put("bridged", Boolean.toString(getParameters().isVmNetwork()));
    Network network = getParameters().getNetwork();
    if (network != null) {
        if (network.getMtu() == 0) {
            options.put("mtu", Config.<Integer>getValue(ConfigValues.DefaultMtu).toString());
        } else {
            options.put("mtu", String.valueOf(network.getMtu()));
        }
    }
    // options[VdsProperties.force] = "true";
    if (getParameters().getCheckConnectivity()) {
        options.put(VdsProperties.CONNECTIVITY_CHECK, "true");
        options.put(VdsProperties.CONNECTIVITY_TIMEOUT, String.valueOf(getParameters().getConnectionTimeout()));
    }
    status = getBroker().editNetwork(oldNetwork, networkName, vlanId, bond, nics, options);
    proceedProxyReturnValue();
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    if (TransactionSupport.current() != null) {
        TransactionSupport.registerRollbackHandler(this);
    }
    String networkName = (getParameters().getNetworkName() == null) ? "" : getParameters().getNetworkName();
    String vlanId = (getParameters().getVlanId() != null) ? getParameters().getVlanId().toString() : "";
    String bond = (getParameters().getBondName() == null) ? "" : getParameters().getBondName();
    String[] nics = (getParameters().getNics() == null) ? new String[] {} : getParameters().getNics();
    Map<String, String> options = new HashMap<String, String>();
    switch(getParameters().getBootProtocol()) {
        case DHCP:
            options.put(VdsProperties.BOOT_PROTOCOL, VdsProperties.DHCP);
            break;
        case STATIC_IP:
            if (!StringUtils.isEmpty(getParameters().getInetAddr())) {
                options.put(VdsProperties.IP_ADDRESS, getParameters().getInetAddr());
            }
            if (!StringUtils.isEmpty(getParameters().getNetworkMask())) {
                options.put(VdsProperties.NETMASK, getParameters().getNetworkMask());
            }
            if (!StringUtils.isEmpty(getParameters().getGateway())) {
                options.put(VdsProperties.GATEWAY, getParameters().getGateway());
            }
            break;
        default:
            break;
    }
    options.put(VdsProperties.STP, (getParameters().getStp()) ? "yes" : "no");
    if (!StringUtils.isEmpty(getParameters().getBondingOptions())) {
        options.put(VdsProperties.BONDING_OPTIONS, getParameters().getBondingOptions());
    }
    options.put(VdsProperties.STP, (getParameters().getStp()) ? "yes" : "no");
    // options[VdsProperties.force] = "true";
    options.put("bridged", Boolean.toString(getParameters().isVmNetwork()));
    Network network = getParameters().getNetwork();
    if (network != null) {
        if (network.getMtu() == 0) {
            options.put("mtu", Config.<Integer>getValue(ConfigValues.DefaultMTU).toString());
        } else {
            options.put("mtu", String.valueOf(network.getMtu()));
        }
    }
    status = getBroker().addNetwork(networkName, vlanId, bond, nics, options);
    proceedProxyReturnValue();
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    if (TransactionSupport.current() != null) {
        TransactionSupport.registerRollbackHandler(this);
    }
    String networkName = (getParameters().getNetworkName() == null) ? "" : getParameters().getNetworkName();
    String vlanId = (getParameters().getVlanId() != null) ? getParameters().getVlanId().toString() : "";
    String bond = (getParameters().getBondName() == null) ? "" : getParameters().getBondName();
    String[] nics = (getParameters().getNics() == null) ? new String[] {} : getParameters().getNics();
    Map<String, String> options = new HashMap<String, String>();
    switch(getParameters().getBootProtocol()) {
        case DHCP:
            options.put(VdsProperties.BOOT_PROTOCOL, VdsProperties.DHCP);
            break;
        case STATIC_IP:
            if (!StringUtils.isEmpty(getParameters().getInetAddr())) {
                options.put(VdsProperties.IP_ADDRESS, getParameters().getInetAddr());
            }
            if (!StringUtils.isEmpty(getParameters().getNetworkMask())) {
                options.put(VdsProperties.NETMASK, getParameters().getNetworkMask());
            }
            if (!StringUtils.isEmpty(getParameters().getGateway())) {
                options.put(VdsProperties.GATEWAY, getParameters().getGateway());
            }
            break;
        default:
            break;
    }
    options.put(VdsProperties.STP, (getParameters().getStp()) ? "yes" : "no");
    if (!StringUtils.isEmpty(getParameters().getBondingOptions())) {
        options.put(VdsProperties.BONDING_OPTIONS, getParameters().getBondingOptions());
    }
    options.put(VdsProperties.STP, (getParameters().getStp()) ? "yes" : "no");
    // options[VdsProperties.force] = "true";
    options.put("bridged", Boolean.toString(getParameters().isVmNetwork()));
    Network network = getParameters().getNetwork();
    if (network != null) {
        if (network.getMtu() == 0) {
            options.put("mtu", Config.<Integer>getValue(ConfigValues.DefaultMtu).toString());
        } else {
            options.put("mtu", String.valueOf(network.getMtu()));
        }
    }
    status = getBroker().addNetwork(networkName, vlanId, bond, nics, options);
    proceedProxyReturnValue();
}
#end_block

#method_before
@Before
public void mockConfig() {
    HashSet<Version> supportedClusters = new HashSet<>();
    supportedClusters.add(version);
    when(host.getSupportedClusterVersionsSet()).thenReturn(supportedClusters);
    when(host.getVdsGroupCompatibilityVersion()).thenReturn(version);
    configRule.mockConfigValue(ConfigValues.DefaultRouteSupported, version, Boolean.FALSE);
    configRule.mockConfigValue(ConfigValues.DefaultMTU, 1500);
}
#method_after
@Before
public void mockConfig() {
    HashSet<Version> supportedClusters = new HashSet<>();
    supportedClusters.add(version);
    when(host.getSupportedClusterVersionsSet()).thenReturn(supportedClusters);
    when(host.getVdsGroupCompatibilityVersion()).thenReturn(version);
    configRule.mockConfigValue(ConfigValues.DefaultRouteSupported, version, Boolean.FALSE);
    configRule.mockConfigValue(ConfigValues.DefaultMtu, 1500);
}
#end_block

#method_before
@Override
public Response approve(Action action) {
    if (action.isSetCluster() && (action.getCluster().isSetId() || action.getCluster().isSetName())) {
        update(setCluster(get(), action.getCluster()));
    }
    validateEnums(Action.class, action);
    ApproveVdsParameters params = new ApproveVdsParameters(guid);
    params = (ApproveVdsParameters) getMapper(Action.class, VdsOperationActionParameters.class).map(action, (VdsOperationActionParameters) params);
    if (action.isSetSsh() && action.getSsh().isSetAuthenticationMethod()) {
        if (action.getSsh().getAuthenticationMethod() == VdsOperationActionParameters.AuthenticationMethod.Password.toString()) {
            params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.Password);
            if (action.isSetRootPassword()) {
                params.setRootPassword(action.getRootPassword());
            } else if (action.getSsh().isSetUser()) {
                params.setPassword(action.getSsh().getUser().getPassword());
            }
        } else {
            params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.PublicKey);
        }
    } else {
        params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.PublicKey);
    }
    return doAction(VdcActionType.ApproveVds, params, action);
}
#method_after
@Override
public Response approve(Action action) {
    if (action.isSetCluster() && (action.getCluster().isSetId() || action.getCluster().isSetName())) {
        update(setCluster(get(), action.getCluster()));
    }
    validateEnums(Action.class, action);
    ApproveVdsParameters params = new ApproveVdsParameters(guid);
    params = (ApproveVdsParameters) getMapper(Action.class, VdsOperationActionParameters.class).map(action, (VdsOperationActionParameters) params);
    // Set pk authentication as default
    params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.PublicKey);
    if (action.isSetRootPassword()) {
        params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.Password);
        params.setRootPassword(action.getRootPassword());
    } else if (action.isSetSsh() && action.getSsh().isSetAuthenticationMethod()) {
        if (action.getSsh().getAuthenticationMethod().equals(AuthenticationMethod.PASSWORD.value())) {
            params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.Password);
            if (action.getSsh().isSetUser() && action.getSsh().getUser().isSetPassword()) {
                params.setPassword(action.getSsh().getUser().getPassword());
            }
        }
    }
    return doAction(VdcActionType.ApproveVds, params, action);
}
#end_block

#method_before
private void getService(final ServiceCallback callback) {
    ((ServiceDefTarget) this.xsrfService).setServiceEntryPoint(getXsrfServiceEndPoint());
    if (xsrfRequestBuilder.getXsrfToken() != null) {
        callback.serviceFound(service);
    } else {
        xsrfService.getNewXsrfToken(new AsyncCallback<XsrfToken>() {

            @Override
            public void onSuccess(XsrfToken token) {
                xsrfRequestBuilder.setXsrfToken(token);
                callback.serviceFound(service);
            }

            @Override
            public void onFailure(Throwable caught) {
                callback.onFailure(caught);
            }
        });
    }
}
#method_after
private void getService(final ServiceCallback callback) {
    if (xsrfRequestBuilder.getXsrfToken() != null) {
        callback.serviceFound(service);
    } else {
        xsrfService.getNewXsrfToken(new AsyncCallback<XsrfToken>() {

            @Override
            public void onSuccess(XsrfToken token) {
                xsrfRequestBuilder.setXsrfToken(token);
                callback.serviceFound(service);
            }

            @Override
            public void onFailure(Throwable caught) {
                callback.onFailure(caught);
            }
        });
    }
}
#end_block

#method_before
@Override
public void login(final VdcOperation<VdcActionType, LoginUserParameters> loginOperation) {
    getService(new ServiceCallback() {

        @Override
        public void serviceFound(GenericApiGWTServiceAsync service) {
            service.Login(loginOperation.getParameter().getLoginName(), loginOperation.getParameter().getPassword(), loginOperation.getParameter().getProfileName(), loginOperation.getOperation(), new AsyncCallback<VdcReturnValueBase>() {

                @Override
                public void onSuccess(final VdcReturnValueBase result) {
                    // Remove the rpc token when logging in. Due to session fixation protection we need a new
                    // token based on the new session.
                    getXsrfRequestBuilder().setXsrfToken(null);
                    loginOperation.getCallback().onSuccess(loginOperation, result);
                }

                @Override
                public void onFailure(final Throwable caught) {
                    loginOperation.getCallback().onFailure(loginOperation, caught);
                }
            });
        }

        @Override
        public void onFailure(Throwable exception) {
            loginOperation.getCallback().onFailure(loginOperation, exception);
        }
    });
}
#method_after
@Override
public void login(final VdcOperation<VdcActionType, LoginUserParameters> loginOperation) {
    getService(new ServiceCallback() {

        @Override
        public void serviceFound(GenericApiGWTServiceAsync service) {
            service.Login(loginOperation.getParameter().getLoginName(), loginOperation.getParameter().getPassword(), loginOperation.getParameter().getProfileName(), loginOperation.getOperation(), new AsyncCallback<VdcReturnValueBase>() {

                @Override
                public void onSuccess(final VdcReturnValueBase result) {
                    // Remove the rpc token when logging in. Due to session fixation protection we need a new
                    // token based on the new session.
                    xsrfRequestBuilder.setXsrfToken(null);
                    loginOperation.getCallback().onSuccess(loginOperation, result);
                }

                @Override
                public void onFailure(final Throwable caught) {
                    loginOperation.getCallback().onFailure(loginOperation, caught);
                }
            });
        }

        @Override
        public void onFailure(Throwable exception) {
            loginOperation.getCallback().onFailure(loginOperation, exception);
        }
    });
}
#end_block

#method_before
@Override
public void logout(final Object userObject, final UserCallback callback) {
    getService(new ServiceCallback() {

        @Override
        public void serviceFound(GenericApiGWTServiceAsync foundService) {
            foundService.logOff((DbUser) userObject, new AsyncCallback<VdcReturnValueBase>() {

                @Override
                public void onSuccess(final VdcReturnValueBase result) {
                    // Remove the rpc token when logging out.
                    getXsrfRequestBuilder().setXsrfToken(null);
                    callback.onSuccess(result);
                }

                @Override
                public void onFailure(final Throwable caught) {
                    getXsrfRequestBuilder().setXsrfToken(null);
                    callback.onFailure(caught);
                }
            });
        }

        @Override
        public void onFailure(Throwable exception) {
            callback.onFailure(exception);
        }
    });
}
#method_after
@Override
public void logout(final Object userObject, final UserCallback callback) {
    getService(new ServiceCallback() {

        @Override
        public void serviceFound(GenericApiGWTServiceAsync foundService) {
            foundService.logOff((DbUser) userObject, new AsyncCallback<VdcReturnValueBase>() {

                @Override
                public void onSuccess(final VdcReturnValueBase result) {
                    // Remove the rpc token when logging out.
                    xsrfRequestBuilder.setXsrfToken(null);
                    callback.onSuccess(result);
                }

                @Override
                public void onFailure(final Throwable caught) {
                    xsrfRequestBuilder.setXsrfToken(null);
                    callback.onFailure(caught);
                }
            });
        }

        @Override
        public void onFailure(Throwable exception) {
            callback.onFailure(exception);
        }
    });
}
#end_block

#method_before
@Override
public void storeInHttpSession(final String key, final String value, final StorageCallback callback) {
    getService(new ServiceCallback() {

        @Override
        public void serviceFound(GenericApiGWTServiceAsync service) {
            service.storeInHttpSession(key, value, new AsyncCallback<Void>() {

                @Override
                public void onSuccess(final Void result) {
                    callback.onSuccess(null);
                }

                @Override
                public void onFailure(final Throwable caught) {
                    callback.onFailure(caught);
                }
            });
        }

        @Override
        public void onFailure(Throwable caught) {
            getXsrfRequestBuilder().setXsrfToken(null);
            callback.onFailure(caught);
        }
    });
}
#method_after
@Override
public void storeInHttpSession(final String key, final String value, final StorageCallback callback) {
    getService(new ServiceCallback() {

        @Override
        public void serviceFound(GenericApiGWTServiceAsync service) {
            service.storeInHttpSession(key, value, new AsyncCallback<Void>() {

                @Override
                public void onSuccess(final Void result) {
                    callback.onSuccess(null);
                }

                @Override
                public void onFailure(final Throwable caught) {
                    callback.onFailure(caught);
                }
            });
        }

        @Override
        public void onFailure(Throwable caught) {
            xsrfRequestBuilder.setXsrfToken(null);
            callback.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
public void retrieveFromHttpSession(final String key, final StorageCallback callback) {
    getService(new ServiceCallback() {

        @Override
        public void serviceFound(GenericApiGWTServiceAsync service) {
            service.retrieveFromHttpSession(key, new AsyncCallback<String>() {

                @Override
                public void onSuccess(final String result) {
                    callback.onSuccess(result);
                }

                @Override
                public void onFailure(final Throwable caught) {
                    callback.onFailure(caught);
                }
            });
        }

        @Override
        public void onFailure(Throwable exception) {
            getXsrfRequestBuilder().setXsrfToken(null);
            callback.onFailure(exception);
        }
    });
}
#method_after
@Override
public void retrieveFromHttpSession(final String key, final StorageCallback callback) {
    getService(new ServiceCallback() {

        @Override
        public void serviceFound(GenericApiGWTServiceAsync service) {
            service.retrieveFromHttpSession(key, new AsyncCallback<String>() {

                @Override
                public void onSuccess(final String result) {
                    callback.onSuccess(result);
                }

                @Override
                public void onFailure(final Throwable caught) {
                    callback.onFailure(caught);
                }
            });
        }

        @Override
        public void onFailure(Throwable exception) {
            xsrfRequestBuilder.setXsrfToken(null);
            callback.onFailure(exception);
        }
    });
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    fakeScheduler = new FakeGWTScheduler();
    mockService = mock(GenericApiGWTServiceAsync.class, withSettings().extraInterfaces(ServiceDefTarget.class));
    mockXsrfService = mock(XsrfTokenServiceAsync.class, withSettings().extraInterfaces(ServiceDefTarget.class));
    CommunicationProvider communicationsProvider = new GWTRPCCommunicationProvider(mockService, mockXsrfService);
    ((GWTRPCCommunicationProvider) communicationsProvider).getXsrfRequestBuilder().setXsrfToken(// $NON-NLS-1$
    new XsrfToken("Something"));
    // $NON-NLS-1$
    ((GWTRPCCommunicationProvider) communicationsProvider).setBaseURL("/baseurl");
    OperationProcessor operationProcessor = new OperationProcessor(communicationsProvider);
    operationProcessor.setScheduler(fakeScheduler);
    VdcOperationManager operationsManager = new VdcOperationManager(operationProcessor);
    operationsManager.setLoggedIn(true);
    frontend = new Frontend(operationsManager, mockCanDoActionErrorsTranslator, mockVdsmErrorsTranslator, mockEventBus);
    frontend.queryCompleteEvent = queryCompleteEvent;
    frontend.queryStartedEvent = queryStartEvent;
    frontend.frontendFailureEvent = mockFrontendFailureEvent;
    frontend.frontendNotLoggedInEvent = mockFrontendNotLoggedInEvent;
    frontend.subscribe(new VdcQueryType[] { VdcQueryType.Search });
    frontend.setEventsHandler(mockEventsHandler);
    frontend.setConstants(mockConstants);
    // $NON-NLS-1$
    when(mockAsyncQuery.getContext()).thenReturn("test");
    when(mockAsyncQuery.getDel()).thenReturn(mockAsyncCallback);
}
#method_after
@Before
public void setUp() throws Exception {
    mockService = mock(GenericApiGWTServiceAsync.class, withSettings().extraInterfaces(ServiceDefTarget.class));
    fakeScheduler = new FakeGWTScheduler();
    XsrfRpcRequestBuilder mockXsrfRpcRequestBuilder = new XsrfRpcRequestBuilder();
    CommunicationProvider communicationsProvider = new GWTRPCCommunicationProvider(mockService, mockXsrfService, mockXsrfRpcRequestBuilder);
    // $NON-NLS-1$
    mockXsrfRpcRequestBuilder.setXsrfToken(new XsrfToken("Something"));
    OperationProcessor operationProcessor = new OperationProcessor(communicationsProvider);
    operationProcessor.setScheduler(fakeScheduler);
    VdcOperationManager operationsManager = new VdcOperationManager(operationProcessor);
    operationsManager.setLoggedIn(true);
    frontend = new Frontend(operationsManager, mockCanDoActionErrorsTranslator, mockVdsmErrorsTranslator, mockEventBus);
    frontend.queryCompleteEvent = queryCompleteEvent;
    frontend.queryStartedEvent = queryStartEvent;
    frontend.frontendFailureEvent = mockFrontendFailureEvent;
    frontend.frontendNotLoggedInEvent = mockFrontendNotLoggedInEvent;
    frontend.subscribe(new VdcQueryType[] { VdcQueryType.Search });
    frontend.setEventsHandler(mockEventsHandler);
    frontend.setConstants(mockConstants);
    // $NON-NLS-1$
    when(mockAsyncQuery.getContext()).thenReturn("test");
    when(mockAsyncQuery.getDel()).thenReturn(mockAsyncCallback);
}
#end_block

#method_before
@Test
public void testRunMultipleQueries_404_failure() {
    // Don't immediately call process until both queries are in the queue.
    fakeScheduler.setThreshold(2);
    when(mockConstants.requestToServerFailedWithCode()).thenReturn(// $NON-NLS-1$
    "A Request to the Server failed with the following Status Code");
    ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
    queryTypeList.add(VdcQueryType.Search);
    queryTypeList.add(VdcQueryType.Search);
    ArrayList<VdcQueryParametersBase> queryParamsList = new ArrayList<VdcQueryParametersBase>();
    // $NON-NLS-1$
    queryParamsList.add(new SearchParameters("*win*", SearchType.VM));
    // $NON-NLS-1$
    queryParamsList.add(new SearchParameters("*lin*", SearchType.VM));
    // $NON-NLS-1$
    frontend.runMultipleQueries(queryTypeList, queryParamsList, mockMultipleQueryCallback, "test");
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, // $NON-NLS-1$
    "404 status code");
    // Repeat 4 times, because of retries.
    for (int i = 1; i < RETRY_COUNT; i++) {
        // Reset the count so we can re-add both entries again.
        fakeScheduler.resetCount();
        verify(mockService, times(i)).RunMultipleQueries(eq(queryTypeList), eq(queryParamsList), callbackMultipleQueries.capture());
        // Call the failure handler.
        callbackMultipleQueries.getValue().onFailure(exception);
    }
    ArgumentCaptor<FrontendFailureEventArgs> eventArgs = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), eventArgs.capture());
    assertEquals(// $NON-NLS-1$
    "Message text didn't match", // $NON-NLS-1$
    "A Request to the Server failed with the following Status Code: 404", eventArgs.getValue().getMessage().getText());
}
#method_after
@Test
public void testRunMultipleQueries_404_failure() {
    // Don't immediately call process until both queries are in the queue.
    fakeScheduler.setThreshold(2);
    when(mockConstants.requestToServerFailedWithCode()).thenReturn(// $NON-NLS-1$
    "A Request to the Server failed with the following Status Code");
    ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
    queryTypeList.add(VdcQueryType.Search);
    queryTypeList.add(VdcQueryType.Search);
    ArrayList<VdcQueryParametersBase> queryParamsList = new ArrayList<VdcQueryParametersBase>();
    // $NON-NLS-1$
    queryParamsList.add(new SearchParameters("*win*", SearchType.VM));
    // $NON-NLS-1$
    queryParamsList.add(new SearchParameters("*lin*", SearchType.VM));
    // $NON-NLS-1$
    frontend.runMultipleQueries(queryTypeList, queryParamsList, mockMultipleQueryCallback, "test");
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, // $NON-NLS-1$
    "404 status code");
    // Repeat 4 times, because of retries.
    for (int i = 1; i < RETRY_COUNT; i++) {
        // Reset the count so we can re-add both entries again.
        fakeScheduler.resetCount();
        verify(mockService, times(i)).RunMultipleQueries(eq(queryTypeList), eq(queryParamsList), callbackMultipleQueries.capture());
        // Call the failure handler.
        callbackMultipleQueries.getValue().onFailure(exception);
    }
    ArgumentCaptor<FrontendFailureEventArgs> eventArgs = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), eventArgs.capture());
    assertEquals(// $NON-NLS-1$
    "Message text didn't match", // $NON-NLS-1$
    "A Request to the Server failed with the following Status Code: 404", eventArgs.getValue().getMessages().get(0).getText());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    mockService = mock(GenericApiGWTServiceAsync.class, withSettings().extraInterfaces(ServiceDefTarget.class));
    mockXsrfService = mock(XsrfTokenServiceAsync.class, withSettings().extraInterfaces(ServiceDefTarget.class));
    testProvider = new GWTRPCCommunicationProvider(mockService, mockXsrfService);
    // $NON-NLS-1$
    testProvider.xsrfRequestBuilder.setXsrfToken(new XsrfToken("Something"));
    // $NON-NLS-1$
    testProvider.setBaseURL("/baseurl");
}
#method_after
@Before
public void setUp() throws Exception {
    mockXsrfRpcRequestBuilder = new XsrfRpcRequestBuilder();
    testProvider = new GWTRPCCommunicationProvider(mockService, mockXsrfService, mockXsrfRpcRequestBuilder);
    // $NON-NLS-1$
    mockXsrfRpcRequestBuilder.setXsrfToken(new XsrfToken("Something"));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testMissingXsrfToken() {
    // Remove token so there should be a request for it.
    testProvider.xsrfRequestBuilder.setXsrfToken(null);
    VdcQueryParametersBase testParameters = new VdcQueryParametersBase();
    final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList = new ArrayList<VdcOperation<VdcQueryType, VdcQueryParametersBase>>();
    final VdcOperation<VdcQueryType, VdcQueryParametersBase> testOperation = new VdcOperation<VdcQueryType, VdcQueryParametersBase>(VdcQueryType.Search, testParameters, null);
    operationList.add(testOperation);
    testProvider.transmitOperation(testOperation);
    verify(mockXsrfService).getNewXsrfToken((AsyncCallback<XsrfToken>) any());
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testMissingXsrfToken() {
    // Remove token so there should be a request for it.
    mockXsrfRpcRequestBuilder.setXsrfToken(null);
    VdcQueryParametersBase testParameters = new VdcQueryParametersBase();
    final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList = new ArrayList<VdcOperation<VdcQueryType, VdcQueryParametersBase>>();
    final VdcOperation<VdcQueryType, VdcQueryParametersBase> testOperation = new VdcOperation<VdcQueryType, VdcQueryParametersBase>(VdcQueryType.Search, testParameters, null);
    operationList.add(testOperation);
    testProvider.transmitOperation(testOperation);
    verify(mockXsrfService).getNewXsrfToken((AsyncCallback<XsrfToken>) any());
}
#end_block

#method_before
@Override
public VdcReturnValueBase Login(String userName, String password, String profileName, VdcActionType loginType) {
    LoginUserParameters params = new LoginUserParameters(profileName, userName, password);
    HttpSession originalSession = getSession();
    // Prevent session fixation.
    getSession().invalidate();
    // Calling getSession again after invalidating it should create a new session.
    HttpSession newSession = getSession();
    // $NON-NLS-1$
    assert !newSession.equals(originalSession) : "new session the same as old session";
    params.setSessionId(getSession().getId());
    params.setActionType(loginType);
    VdcReturnValueBase returnValue = getBackend().login(params);
    return returnValue;
}
#method_after
@Override
public VdcReturnValueBase Login(String userName, String password, String profileName, VdcActionType loginType) {
    LoginUserParameters params = new LoginUserParameters(profileName, userName, password);
    HttpSession originalSession = getSession();
    // Prevent session fixation.
    getSession().invalidate();
    // Calling getSession again after invalidating it should create a new session.
    HttpSession newSession = getSession();
    // $NON-NLS-1$
    assert !newSession.equals(originalSession) : "new session the same as old session";
    params.setSessionId(getSession().getId());
    params.setActionType(loginType);
    VdcReturnValueBase returnValue = getBackend().login(params);
    if (returnValue.getSucceeded()) {
        // $NON-NLS-1$
        this.getThreadLocalResponse().addHeader("OVIRT-SSO-TOKEN", getSession().getId());
    }
    return returnValue;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    fakeScheduler = new FakeGWTScheduler();
    mockService = mock(GenericApiGWTServiceAsync.class, withSettings().extraInterfaces(ServiceDefTarget.class));
    mockXsrfService = mock(XsrfTokenServiceAsync.class, withSettings().extraInterfaces(ServiceDefTarget.class));
    CommunicationProvider communicationsProvider = new GWTRPCCommunicationProvider(mockService, mockXsrfService);
    ((GWTRPCCommunicationProvider) communicationsProvider).getXsrfRequestBuilder().setXsrfToken(// $NON-NLS-1$
    new XsrfToken("Something"));
    // $NON-NLS-1$
    ((GWTRPCCommunicationProvider) communicationsProvider).setBaseURL("/baseurl");
    OperationProcessor operationProcessor = new OperationProcessor(communicationsProvider);
    operationProcessor.setScheduler(fakeScheduler);
    VdcOperationManager operationsManager = new VdcOperationManager(operationProcessor);
    operationsManager.setLoggedIn(true);
    frontend = new Frontend(operationsManager, mockCanDoActionErrorsTranslator, mockVdsmErrorsTranslator, mockEventBus);
    frontend.setEventsHandler(mockEventsHandler);
    frontend.setConstants(mockConstants);
    frontend.frontendFailureEvent = mockFrontendFailureEvent;
    frontend.setLoginHandler(mockLoginHandler);
    when(mockAsyncQuery.getDel()).thenReturn(mockAsyncCallback);
}
#method_after
@Before
public void setUp() throws Exception {
    mockService = mock(GenericApiGWTServiceAsync.class, withSettings().extraInterfaces(ServiceDefTarget.class));
    fakeScheduler = new FakeGWTScheduler();
    XsrfRpcRequestBuilder mockXsrfRpcRequestBuilder = new XsrfRpcRequestBuilder();
    CommunicationProvider communicationsProvider = new GWTRPCCommunicationProvider(mockService, mockXsrfService, mockXsrfRpcRequestBuilder);
    // $NON-NLS-1$
    mockXsrfRpcRequestBuilder.setXsrfToken(new XsrfToken("Something"));
    OperationProcessor operationProcessor = new OperationProcessor(communicationsProvider);
    operationProcessor.setScheduler(fakeScheduler);
    VdcOperationManager operationsManager = new VdcOperationManager(operationProcessor);
    operationsManager.setLoggedIn(true);
    frontend = new Frontend(operationsManager, mockCanDoActionErrorsTranslator, mockVdsmErrorsTranslator, mockEventBus);
    frontend.setEventsHandler(mockEventsHandler);
    frontend.setConstants(mockConstants);
    frontend.frontendFailureEvent = mockFrontendFailureEvent;
    frontend.setLoginHandler(mockLoginHandler);
    when(mockAsyncQuery.getDel()).thenReturn(mockAsyncCallback);
    when(mockConstants.noCanDoActionMessage()).thenReturn(NO_MESSAGE);
}
#end_block

#method_before
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_actionMessageSize_1_or_less() {
    VdcFault testFault = new VdcFault();
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    Object testState = new Object();
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, false);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Descriptions should match", // $NON-NLS-1$ //$NON-NLS-2$
    "This is a description", failureCaptor.getValue().getMessage().getDescription());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    "No Message", failureCaptor.getValue().getMessage().getText());
}
#method_after
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_actionMessageSize_1_or_less() {
    VdcFault testFault = new VdcFault();
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    Object testState = new Object();
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, true);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Descriptions should match", // $NON-NLS-1$ //$NON-NLS-2$
    "This is a description", failureCaptor.getValue().getMessages().get(0).getDescription());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    NO_MESSAGE, failureCaptor.getValue().getMessages().get(0).getText());
}
#end_block

#method_before
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_withActionMessageSize1() {
    VdcFault testFault = new VdcFault();
    // $NON-NLS-1$
    ArrayList<String> translatedErrors = new ArrayList<String>(Arrays.asList("Translated Message 1"));
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    when(mockCanDoActionErrorsTranslator.translateErrorText(any(ArrayList.class))).thenReturn(translatedErrors);
    Object testState = new Object();
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 1");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, false);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Descriptions should match", // $NON-NLS-1$ //$NON-NLS-2$
    "This is a description", failureCaptor.getValue().getMessage().getDescription());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match translation", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 1", failureCaptor.getValue().getMessage().getText());
}
#method_after
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_withActionMessageSize1() {
    VdcFault testFault = new VdcFault();
    // $NON-NLS-1$
    ArrayList<String> translatedErrors = new ArrayList<String>(Arrays.asList("Translated Message 1"));
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    when(mockCanDoActionErrorsTranslator.translateErrorText(any(ArrayList.class))).thenReturn(translatedErrors);
    Object testState = new Object();
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 1");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, true);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Descriptions should match", // $NON-NLS-1$ //$NON-NLS-2$
    "This is a description", failureCaptor.getValue().getMessages().get(0).getDescription());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match translation", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 1", failureCaptor.getValue().getMessages().get(0).getText());
}
#end_block

#method_before
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_withActionMessageSizeGreaterThan1() {
    VdcFault testFault = new VdcFault();
    ArrayList<String> translatedErrors = new ArrayList<String>(Arrays.asList("Translated Message 1", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 2"));
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    when(mockCanDoActionErrorsTranslator.translateErrorText(any(ArrayList.class))).thenReturn(translatedErrors);
    Object testState = new Object();
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 1");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 2");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, false);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    // $NON-NLS-1$
    assertNull("Message should be null", failureCaptor.getValue().getMessage());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 1", failureCaptor.getValue().getMessages().get(0).getText());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 2", failureCaptor.getValue().getMessages().get(1).getText());
}
#method_after
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_withActionMessageSizeGreaterThan1() {
    VdcFault testFault = new VdcFault();
    ArrayList<String> translatedErrors = new ArrayList<String>(Arrays.asList("Translated Message 1", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 2"));
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    when(mockCanDoActionErrorsTranslator.translateErrorText(any(ArrayList.class))).thenReturn(translatedErrors);
    Object testState = new Object();
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 1");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 2");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, true);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 1", failureCaptor.getValue().getMessages().get(0).getText());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 2", failureCaptor.getValue().getMessages().get(1).getText());
}
#end_block

#method_before
private void bindFrontendInfrastructure() {
    bind(Frontend.class).in(Singleton.class);
    requestStaticInjection(Frontend.InstanceHolder.class);
    bind(VdcOperationManager.class).in(Singleton.class);
    bind(OperationProcessor.class).in(Singleton.class);
    bind(CommunicationProvider.class).to(GWTRPCCommunicationProvider.class).in(Singleton.class);
    bind(GenericApiGWTServiceAsync.class).in(Singleton.class);
    bind(XsrfTokenServiceAsync.class).in(Singleton.class);
}
#method_after
private void bindFrontendInfrastructure() {
    bind(Frontend.class).in(Singleton.class);
    requestStaticInjection(Frontend.InstanceHolder.class);
    bind(VdcOperationManager.class).in(Singleton.class);
    bind(OperationProcessor.class).in(Singleton.class);
    bind(CommunicationProvider.class).to(GWTRPCCommunicationProvider.class).in(Singleton.class);
}
#end_block

#method_before
private <T> void bindTypeAndImplAsSingleton(Class<T> type, Class<? extends T> impl) {
    bind(type).to(impl);
    bind(impl).in(Singleton.class);
}
#method_after
protected <T> void bindTypeAndImplAsSingleton(Class<T> type, Class<? extends T> impl) {
    bind(type).to(impl);
    bind(impl).in(Singleton.class);
}
#end_block

#method_before
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDAO().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDAO().getStorageDomainByTypeAndPool(storagePoolId, StorageDomainType.Master);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.InActive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSError error = null;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), storagePoolId, vds.getVdsSpmId(), masterDomain.getId(), storagePool.getmaster_domain_version()));
        if (!vdsReturnValue.getSucceeded()) {
            error = vdsReturnValue.getVdsError();
        }
    } catch (VdcBLLException e) {
        error = e.getVdsError();
    }
    if (error != null) {
        if (error.getCode() != VdcBllErrors.CannotConnectMultiplePools && masterDomainInactiveOrUnknown) {
            log.infoFormat("Could not connect host {0} to pool {1}, as the master domain is in inactive/unknown status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.errorFormat("Could not connect host {0} to pool {1} with the message: {2}", vds.getName(), storagePool.getName(), error.getMessage());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        result.setSuccess(proceedVdsStats(!masterDomainInactiveOrUnknown));
        if (!result.isSuccess()) {
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#method_after
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDAO().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDAO().getStorageDomainByTypeAndPool(storagePoolId, StorageDomainType.Master);
    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(storagePoolId);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.Inactive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSError error = null;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, storagePool, masterDomain.getId(), storagePoolIsoMap));
        if (!vdsReturnValue.getSucceeded()) {
            error = vdsReturnValue.getVdsError();
        }
    } catch (VdcBLLException e) {
        error = e.getVdsError();
    }
    if (error != null) {
        if (error.getCode() != VdcBllErrors.CannotConnectMultiplePools && masterDomainInactiveOrUnknown) {
            log.infoFormat("Could not connect host {0} to pool {1}, as the master domain is in inactive/unknown status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.errorFormat("Could not connect host {0} to pool {1} with the message: {2}", vds.getName(), storagePool.getName(), error.getMessage());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        result.setSuccess(proceedVdsStats(!masterDomainInactiveOrUnknown));
        if (!result.isSuccess()) {
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#end_block

#method_before
protected void initConnectionList(boolean includeInactiveDomains) {
    Set<StorageDomainStatus> statuses;
    if (includeInactiveDomains) {
        statuses = EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.InActive, StorageDomainStatus.Unknown);
    } else {
        statuses = EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.Unknown);
    }
    _connections = DbFacade.getInstance().getStorageServerConnectionDao().getConnectableStorageConnectionsByStorageTypeAndStatus(getStoragePool().getId(), null, statuses);
    updateConnectionsTypeMap();
}
#method_after
protected void initConnectionList(boolean includeInactiveDomains) {
    Set<StorageDomainStatus> statuses;
    statuses = includeInactiveDomains ? EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.Unknown, StorageDomainStatus.Inactive) : EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.Unknown);
    _connections = DbFacade.getInstance().getStorageServerConnectionDao().getStorageConnectionsByStorageTypeAndStatus(getStoragePool().getId(), null, statuses);
    updateConnectionsTypeMap();
}
#end_block

#method_before
@Override
public List<StorageServerConnections> getConnectableStorageConnectionsByStorageType(Guid pool, StorageType storageType) {
    return getConnectableStorageConnectionsByStorageTypeAndStatus(pool, storageType, EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.InActive, StorageDomainStatus.Unknown));
}
#method_after
@Override
public List<StorageServerConnections> getConnectableStorageConnectionsByStorageType(Guid pool, StorageType storageType) {
    return getStorageConnectionsByStorageTypeAndStatus(pool, storageType, EnumSet.of(StorageDomainStatus.Active, StorageDomainStatus.Inactive, StorageDomainStatus.Unknown));
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#method_after
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParameters(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#end_block

#method_before
public static Object invokeMethodWithNoArgs(Object o, String name) {
    try {
        Method m = o.getClass().getMethod(name);
        return m.invoke(o);
    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
        return null;
    }
}
#method_after
public static Object invokeMethodWithNoArgs(Object o, Method method) {
    try {
        return method.invoke(o);
    } catch (InvocationTargetException | IllegalAccessException e) {
        return null;
    }
}
#end_block

#method_before
protected void markImagesIllegalIfNotInDb(VM vm, Guid snapshotId) {
    List<DiskImage> imagesInDb = getDiskImageDao().getAllSnapshotsForVmSnapshot(snapshotId);
    // Converts to a map of Id to DiskImage in order to check existence only by Image ID (in case not all
    // image data is written to OVF
    Map<Guid, DiskImage> imagesInDbMap = ImagesHandler.getDiskImagesByIdMap(imagesInDb);
    for (DiskImage fromConfigImg : vm.getImages()) {
        if (fromConfigImg.getDiskStorageType() == Disk.DiskStorageType.IMAGE && imagesInDbMap != null && !imagesInDbMap.containsKey(fromConfigImg.getImageId())) {
            log.debugFormat("Image {0} of Disk {1} cannot be found in database. This image will be returned as ILLEGAL from the query", fromConfigImg.getImageId(), fromConfigImg.getId());
            fromConfigImg.setImageStatus(ImageStatus.ILLEGAL);
        } else {
            // Return image status as appears in DB (needed in case status is ILLEGAL in DB)
            DiskImage imageInDb = imagesInDbMap.get(fromConfigImg.getImageId());
            fromConfigImg.setImageStatus(imageInDb.getImageStatus());
        }
    }
}
#method_after
protected void markImagesIllegalIfNotInDb(VM vm, Guid snapshotId) {
    List<DiskImage> imagesInDb = getDiskImageDao().getAllSnapshotsForVmSnapshot(snapshotId);
    // Converts to a map of Id to DiskImage in order to check existence only by Image ID (in case not all
    // image data is written to OVF
    Map<Guid, DiskImage> imagesInDbMap = ImagesHandler.getDiskImagesByIdMap(imagesInDb);
    for (DiskImage fromConfigImg : vm.getImages()) {
        if (fromConfigImg.getDiskStorageType() == Disk.DiskStorageType.IMAGE && !imagesInDbMap.containsKey(fromConfigImg.getImageId())) {
            log.debugFormat("Image {0} of Disk {1} cannot be found in database. This image will be returned as ILLEGAL from the query", fromConfigImg.getImageId(), fromConfigImg.getId());
            fromConfigImg.setImageStatus(ImageStatus.ILLEGAL);
        } else {
            // Return image status as appears in DB (needed in case status is ILLEGAL in DB)
            DiskImage imageInDb = imagesInDbMap.get(fromConfigImg.getImageId());
            fromConfigImg.setImageStatus(imageInDb.getImageStatus());
        }
    }
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    initializeObjectState();
    if (getParameters().getTaskGroupSuccess()) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
    } else {
        List<String> failedToRemoveDisks = new ArrayList<>();
        // Remove successfully deleted images from the snapshot
        for (VdcActionParametersBase parametersBase : getParameters().getImagesParameters()) {
            ImagesContainterParametersBase imagesParams = (ImagesContainterParametersBase) parametersBase;
            if (imagesParams.getTaskGroupSuccess()) {
                Snapshot snapshotWithoutImage = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(getParameters().getSnapshotId(), imagesParams.getImageId());
                getSnapshotDao().update(snapshotWithoutImage);
            } else {
                log.errorFormat("Could not delete image {1} from snapshot {2}", getParameters().getSnapshotId(), imagesParams.getImageId());
                DiskImage diskImage = getDiskImageDao().getSnapshotById(imagesParams.getImageId());
                failedToRemoveDisks.add(diskImage.getDiskAlias());
            }
        }
        if (!failedToRemoveDisks.isEmpty()) {
            addCustomValue("DiskAlias", StringUtils.join(failedToRemoveDisks, ", "));
            AuditLogDirector.log(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_PARTIAL_SNAPSHOT);
        }
        getSnapshotDao().updateStatus(getParameters().getSnapshotId(), SnapshotStatus.OK);
    }
    super.endVmCommand();
}
#method_after
@Override
protected void endVmCommand() {
    initializeObjectState();
    if (getParameters().getTaskGroupSuccess()) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
    } else {
        List<String> failedToRemoveDisks = new ArrayList<>();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
        for (VdcActionParametersBase parameters : getParameters().getImagesParameters()) {
            ImagesContainterParametersBase imagesParams = (parameters instanceof ImagesContainterParametersBase ? (ImagesContainterParametersBase) parameters : null);
            if (imagesParams == null) {
                // instances of ImagesContainterParametersBase objects.
                continue;
            }
            if (imagesParams.getTaskGroupSuccess()) {
                snapshot = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snapshot, imagesParams.getImageId());
            } else {
                log.errorFormat("Could not delete image {0} from snapshot {1}", imagesParams.getImageId(), getParameters().getSnapshotId());
                DiskImage diskImage = getDiskImageDao().getSnapshotById(imagesParams.getImageId());
                failedToRemoveDisks.add(diskImage.getDiskAlias());
            }
        }
        // Remove memory volume and update the dao.
        // Note: on failure, we can treat memory volume deletion as deleting an image
        // and remove it from the snapshot entity (rollback isn't applicable).
        snapshot.setMemoryVolume("");
        getSnapshotDao().update(snapshot);
        if (!failedToRemoveDisks.isEmpty()) {
            addCustomValue("DiskAliases", StringUtils.join(failedToRemoveDisks, ", "));
            AuditLogDirector.log(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_PARTIAL_SNAPSHOT);
        }
        getSnapshotDao().updateStatus(getParameters().getSnapshotId(), SnapshotStatus.OK);
    }
    super.endVmCommand();
}
#end_block

#method_before
public static List<DirectoryUser> findPrincipalsByQuery(final ExtensionProxy extension, final String query) {
    return queryPrincipals(extension, SearchQueryParsingUtils.generateQueryMap(query, Authz.QueryEntity.PRINCIPAL), false);
}
#method_after
public static List<DirectoryUser> findPrincipalsByQuery(final ExtensionProxy extension, final String namespace, final String query) {
    return queryPrincipals(extension, namespace, SearchQueryParsingUtils.generateQueryMap(query, Authz.QueryEntity.PRINCIPAL), false);
}
#end_block

#method_before
public static List<DirectoryUser> findPrincipalsByIds(final ExtensionProxy extension, final List<String> ids) {
    List<DirectoryUser> results = new ArrayList<>();
    for (List<String> batch : SearchQueryParsingUtils.getIdsBatches(extension.getContext(), ids)) {
        results.addAll(queryPrincipals(extension, SearchQueryParsingUtils.generateQueryMap(batch, Authz.QueryEntity.PRINCIPAL), true));
    }
    return results;
}
#method_after
public static List<DirectoryUser> findPrincipalsByIds(final ExtensionProxy extension, final String namespace, final List<String> ids) {
    List<DirectoryUser> results = new ArrayList<>();
    for (List<String> batch : SearchQueryParsingUtils.getIdsBatches(extension.getContext(), ids)) {
        results.addAll(queryPrincipals(extension, namespace, SearchQueryParsingUtils.generateQueryMap(batch, Authz.QueryEntity.PRINCIPAL), true));
    }
    return results;
}
#end_block

#method_before
public static DirectoryUser findPrincipalById(final ExtensionProxy extension, final String id) {
    List<DirectoryUser> users = findPrincipalsByIds(extension, Arrays.asList(id));
    if (users.isEmpty()) {
        return null;
    }
    return users.get(0);
}
#method_after
public static DirectoryUser findPrincipalById(final ExtensionProxy extension, String namespace, final String id) {
    List<DirectoryUser> users = findPrincipalsByIds(extension, namespace, Arrays.asList(id));
    if (users.isEmpty()) {
        return null;
    }
    return users.get(0);
}
#end_block

#method_before
public static List<DirectoryGroup> findGroupsByQuery(final ExtensionProxy extension, final String query) {
    return queryGroups(extension, SearchQueryParsingUtils.generateQueryMap(query, Authz.QueryEntity.GROUP));
}
#method_after
public static List<DirectoryGroup> findGroupsByQuery(final ExtensionProxy extension, final String namespace, final String query) {
    return queryGroups(extension, namespace, SearchQueryParsingUtils.generateQueryMap(query, Authz.QueryEntity.GROUP));
}
#end_block

#method_before
public static List<DirectoryGroup> findGroupsByIds(final ExtensionProxy extension, final List<String> ids) {
    List<DirectoryGroup> results = new ArrayList<>();
    for (List<String> batch : SearchQueryParsingUtils.getIdsBatches(extension.getContext(), ids)) {
        results.addAll(queryGroups(extension, SearchQueryParsingUtils.generateQueryMap(batch, QueryEntity.GROUP)));
    }
    return results;
}
#method_after
public static List<DirectoryGroup> findGroupsByIds(final ExtensionProxy extension, final String namespace, final List<String> ids) {
    List<DirectoryGroup> results = new ArrayList<>();
    for (List<String> batch : SearchQueryParsingUtils.getIdsBatches(extension.getContext(), ids)) {
        results.addAll(queryGroups(extension, namespace, SearchQueryParsingUtils.generateQueryMap(batch, QueryEntity.GROUP)));
    }
    return results;
}
#end_block

#method_before
public static DirectoryGroup findGroupById(final ExtensionProxy extension, final String id) {
    List<DirectoryGroup> groups = findGroupsByIds(extension, Arrays.asList(id));
    if (groups.isEmpty()) {
        return null;
    }
    return groups.get(0);
}
#method_after
public static DirectoryGroup findGroupById(final ExtensionProxy extension, String namespace, final String id) {
    List<DirectoryGroup> groups = findGroupsByIds(extension, namespace, Arrays.asList(id));
    if (groups.isEmpty()) {
        return null;
    }
    return groups.get(0);
}
#end_block

#method_before
private static List<DirectoryUser> queryPrincipals(final ExtensionProxy extension, final ExtMap filter, boolean recursiveGroupsResolving) {
    return populatePrincipals(extension, new ExtMap().mput(Authz.InvokeKeys.QUERY_ENTITY, Authz.QueryEntity.PRINCIPAL).mput(Authz.InvokeKeys.RESOLVE_GROUPS_RECURSIVE, recursiveGroupsResolving).mput(Authz.InvokeKeys.QUERY_FILTER, filter));
}
#method_after
private static List<DirectoryUser> queryPrincipals(final ExtensionProxy extension, final String namespace, final ExtMap filter, boolean recursiveGroupsResolving) {
    ExtMap inputMap = new ExtMap().mput(Authz.InvokeKeys.QUERY_ENTITY, Authz.QueryEntity.PRINCIPAL).mput(Authz.InvokeKeys.RESOLVE_GROUPS_RECURSIVE, recursiveGroupsResolving).mput(Authz.InvokeKeys.QUERY_FILTER, filter).mput(Authz.InvokeKeys.NAMESPACE, namespace);
    return populatePrincipals(extension, namespace, inputMap);
}
#end_block

#method_before
private static List<DirectoryGroup> queryGroups(ExtensionProxy extension, final ExtMap filter) {
    return populateGroups(extension, new ExtMap().mput(Authz.InvokeKeys.QUERY_ENTITY, Authz.QueryEntity.GROUP).mput(Authz.InvokeKeys.QUERY_FILTER, filter));
}
#method_after
private static List<DirectoryGroup> queryGroups(final ExtensionProxy extension, final String namespace, final ExtMap filter) {
    return populateGroups(extension, namespace, new ExtMap().mput(Authz.InvokeKeys.QUERY_ENTITY, Authz.QueryEntity.GROUP).mput(Authz.InvokeKeys.QUERY_FILTER, filter));
}
#end_block

#method_before
private static List<DirectoryUser> populatePrincipals(final ExtensionProxy extension, final ExtMap input) {
    final List<DirectoryUser> directoryUsers = new ArrayList<>();
    queryImpl(extension, input, new QueryResultHandler() {

        @Override
        public boolean handle(List<ExtMap> queryResults) {
            boolean result = true;
            for (ExtMap queryResult : queryResults) {
                if (directoryUsers.size() < QUERIES_RESULTS_LIMIT) {
                    directoryUsers.add(mapPrincipalRecord(extension, queryResult));
                } else {
                    result = false;
                    break;
                }
            }
            return result;
        }
    });
    return directoryUsers;
}
#method_after
private static List<DirectoryUser> populatePrincipals(final ExtensionProxy extension, final String namespace, final ExtMap input) {
    final List<DirectoryUser> directoryUsers = new ArrayList<>();
    queryImpl(extension, namespace, input, new QueryResultHandler() {

        @Override
        public boolean handle(List<ExtMap> queryResults) {
            boolean result = true;
            for (ExtMap queryResult : queryResults) {
                if (directoryUsers.size() < QUERIES_RESULTS_LIMIT) {
                    directoryUsers.add(mapPrincipalRecord(extension, queryResult));
                } else {
                    result = false;
                    break;
                }
            }
            return result;
        }
    });
    return directoryUsers;
}
#end_block

#method_before
private static List<DirectoryGroup> populateGroups(final ExtensionProxy extension, final ExtMap input) {
    final List<DirectoryGroup> directoryGroups = new ArrayList<>();
    queryImpl(extension, input, new QueryResultHandler() {

        @Override
        public boolean handle(List<ExtMap> queryResults) {
            boolean result = true;
            for (ExtMap queryResult : queryResults) {
                if (directoryGroups.size() < QUERIES_RESULTS_LIMIT) {
                    directoryGroups.add(mapGroupRecord(extension, queryResult));
                } else {
                    result = false;
                }
            }
            return result;
        }
    });
    return directoryGroups;
}
#method_after
private static List<DirectoryGroup> populateGroups(final ExtensionProxy extension, final String namespace, final ExtMap input) {
    final List<DirectoryGroup> directoryGroups = new ArrayList<>();
    queryImpl(extension, namespace, input, new QueryResultHandler() {

        @Override
        public boolean handle(List<ExtMap> queryResults) {
            boolean result = true;
            for (ExtMap queryResult : queryResults) {
                if (directoryGroups.size() < QUERIES_RESULTS_LIMIT) {
                    directoryGroups.add(mapGroupRecord(extension, queryResult));
                } else {
                    result = false;
                }
            }
            return result;
        }
    });
    return directoryGroups;
}
#end_block

#method_before
private static void queryImpl(final ExtensionProxy extension, final ExtMap input, final QueryResultHandler handler) {
    for (String namespace : extension.getContext().<List<String>>get(Authz.ContextKeys.AVAILABLE_NAMESPACES)) {
        Object opaque = extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.QUERY_OPEN).mput(Authz.InvokeKeys.NAMESPACE, namespace).mput(input)).get(Authz.InvokeKeys.QUERY_OPAQUE);
        List<ExtMap> result = null;
        try {
            do {
                result = extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.QUERY_EXECUTE).mput(Authz.InvokeKeys.QUERY_OPAQUE, opaque).mput(Authz.InvokeKeys.PAGE_SIZE, PAGE_SIZE)).get(Authz.InvokeKeys.QUERY_RESULT);
            } while (result != null && handler.handle(result));
        } finally {
            extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.QUERY_CLOSE).mput(Authz.InvokeKeys.QUERY_OPAQUE, opaque));
        }
        // no conditional in for-in
        if (result != null) {
            break;
        }
    }
}
#method_after
private static void queryImpl(final ExtensionProxy extension, final String namespace, final ExtMap input, final QueryResultHandler handler) {
    Object opaque = extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.QUERY_OPEN).mput(Authz.InvokeKeys.NAMESPACE, namespace).mput(input)).get(Authz.InvokeKeys.QUERY_OPAQUE);
    List<ExtMap> result = null;
    try {
        do {
            result = extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.QUERY_EXECUTE).mput(Authz.InvokeKeys.QUERY_OPAQUE, opaque).mput(Authz.InvokeKeys.PAGE_SIZE, PAGE_SIZE)).get(Authz.InvokeKeys.QUERY_RESULT);
        } while (result != null && handler.handle(result));
    } finally {
        extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.QUERY_CLOSE).mput(Authz.InvokeKeys.QUERY_OPAQUE, opaque));
    }
}
#end_block

#method_before
protected void updateReadOnlyChangeability() {
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    if (DiskInterface.IDE.equals(diskInterface)) {
        getIsReadOnly().setChangeProhibitionReason(CONSTANTS.cannotEnableIdeInterfaceForReadOnlyDisk());
        getIsReadOnly().setIsChangable(false);
    } else {
        getIsReadOnly().setIsChangable(isEditEnabled());
    }
}
#method_after
protected void updateReadOnlyChangeability() {
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    if (diskInterface == DiskInterface.IDE) {
        getIsReadOnly().setChangeProhibitionReason(CONSTANTS.cannotEnableIdeInterfaceForReadOnlyDisk());
        getIsReadOnly().setIsChangable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    boolean isDirectLUN = Boolean.FALSE.equals(getIsInternal().getEntity());
    if (diskInterface == DiskInterface.VirtIO_SCSI && isDirectLUN) {
        getIsReadOnly().setChangeProhibitionReason(CONSTANTS.cannotEnableVirtIoScsiInterfaceForLunReadOnlyDisk());
        getIsReadOnly().setIsChangable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    getIsReadOnly().setIsChangable(isEditEnabled());
}
#end_block

#method_before
private void updatePlugChangeability() {
    if (getVm() == null) {
        // No point in updating plug to VM if there's no VM
        return;
    }
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    boolean isVmRunning = getVm() != null && getVm().getStatus() != VMStatus.Down;
    if (DiskInterface.IDE.equals(diskInterface) && isVmRunning) {
        getIsPlugged().setChangeProhibitionReason(CONSTANTS.cannotHotPlugDiskWithIdeInterface());
        getIsPlugged().setIsChangable(false);
        getIsPlugged().setEntity(false);
    } else {
        if (!canDiskBePlugged(getVm())) {
            getIsPlugged().setEntity(false);
            getIsPlugged().setChangeProhibitionReason(CONSTANTS.cannotPlugDiskIncorrectVmStatus());
            getIsPlugged().setIsChangable(false);
        } else {
            getIsPlugged().setIsChangable(isEditEnabled());
            getIsPlugged().setEntity(true);
        }
    }
}
#method_after
private void updatePlugChangeability() {
    if (getVm() == null) {
        // No point in updating plug to VM if there's no VM
        return;
    }
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    boolean isVmRunning = getVm() != null && getVm().getStatus() != VMStatus.Down;
    if (DiskInterface.IDE.equals(diskInterface) && isVmRunning) {
        getIsPlugged().setChangeProhibitionReason(CONSTANTS.cannotHotPlugDiskWithIdeInterface());
        getIsPlugged().setIsChangable(false);
        getIsPlugged().setEntity(false);
    } else {
        if (!canDiskBePlugged(getVm())) {
            getIsPlugged().setChangeProhibitionReason(CONSTANTS.cannotPlugDiskIncorrectVmStatus());
            getIsPlugged().setIsChangable(false);
            getIsPlugged().setEntity(false);
        } else {
            getIsPlugged().setIsChangable(isEditEnabled());
            getIsPlugged().setEntity(true);
        }
    }
}
#end_block

#method_before
public boolean validate() {
    getDescription().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    if (getVm() == null) {
        getAlias().validateEntity(new IValidation[] { new NotEmptyValidation(), new I18NNameValidation() });
    } else {
        getAlias().validateEntity(new IValidation[] { new I18NNameValidation() });
    }
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getDiskInterface().validateEntity(new IValidation[] { new IValidation() {

        @Override
        public ValidationResult validate(Object value) {
            ValidationResult result = new ValidationResult();
            if (getDiskInterface().getSelectedItem() == DiskInterface.IDE && getIsReadOnly().getEntity()) {
                result.setSuccess(false);
                result.getReasons().add(ConstantsManager.getInstance().getConstants().cannotEnableIdeInterfaceForReadOnlyDisk());
            }
            return result;
        }
    } });
    return getAlias().getIsValid() && getDescription().getIsValid() && getQuota().getIsValid() && getDiskInterface().getIsValid();
}
#method_after
public boolean validate() {
    getDescription().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    if (getVm() == null) {
        getAlias().validateEntity(new IValidation[] { new NotEmptyValidation(), new I18NNameValidation() });
    } else {
        getAlias().validateEntity(new IValidation[] { new I18NNameValidation() });
    }
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    return getAlias().getIsValid() && getDescription().getIsValid() && getQuota().getIsValid() && getDiskInterface().getIsValid();
}
#end_block

#method_before
@Override
protected void initFrontend() {
    super.initFrontend();
    // Configure REST API integration for UI plugin infrastructure
    frontend.setLoginHandler(new FrontendLoginHandler() {

        @Override
        public void onLoginSuccess(final String userName, final String password, final String domain) {
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    // $NON-NLS-1$
                    final String domainToken = "@";
                    restApiSessionManager.acquireSession(userName.contains(domainToken) ? userName : userName + domainToken + domain, password);
                }
            });
        }

        @Override
        public void onLogout() {
            restApiSessionManager.releaseSession();
        }
    });
}
#method_after
@Override
protected void initFrontend() {
    super.initFrontend();
    ReportInit.getInstance().initHandlers(eventBus);
    // Configure REST API integration for UI plugin infrastructure
    frontend.setLoginHandler(new FrontendLoginHandler() {

        @Override
        public void onLoginSuccess(final String userName, final String password, final String domain) {
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    // $NON-NLS-1$
                    final String domainToken = "@";
                    restApiSessionManager.acquireSession(userName.contains(domainToken) ? userName : userName + domainToken + domain, password);
                }
            });
        }

        @Override
        public void onLogout() {
            restApiSessionManager.releaseSession();
        }
    });
}
#end_block

#method_before
public void dataCenterWithClusterSelectedItemChanged() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    StoragePool dataCenter = dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    if (dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        getModel().getQuota().setIsAvailable(true);
    } else {
        getModel().getQuota().setIsAvailable(false);
    }
    postDataCenterWithClusterSelectedItemChanged();
}
#method_after
public void dataCenterWithClusterSelectedItemChanged() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    StoragePool dataCenter = dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    if (dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        getModel().getQuota().setIsAvailable(true);
    } else {
        getModel().getQuota().setIsAvailable(false);
    }
    getModel().getIsRngEnabled().setIsChangable(isRngDeviceSupported(getModel()));
    getModel().getIsRngEnabled().setMessage(constants.rngNotSupportedByCluster());
    setRngAvailability();
    postDataCenterWithClusterSelectedItemChanged();
}
#end_block

#method_before
protected void updateCustomPropertySheet(Version clusterVersion) {
    getModel().getCustomPropertySheet().setKeyValueString(getModel().getCustomPropertiesKeysList().get(clusterVersion));
}
#method_after
protected void updateCustomPropertySheet(Version clusterVersion) {
    getModel().getCustomPropertySheet().setKeyValueMap(getModel().getCustomPropertiesKeysList().get(clusterVersion));
}
#end_block

#method_before
protected void updateQuotaByCluster(final Guid defaultQuota, final String quotaName) {
    if (getModel().getQuota().getIsAvailable()) {
        VDSGroup cluster = getModel().getSelectedCluster();
        if (cluster == null) {
            return;
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForVdsGroup, new IdQueryParameters(cluster.getId()), new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                UnitVmModel vmModel = (UnitVmModel) model;
                ArrayList<Quota> quotaList = ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (quotaList != null && !quotaList.isEmpty()) {
                    vmModel.getQuota().setItems(quotaList);
                }
                if (defaultQuota != null && !Guid.Empty.equals(defaultQuota)) {
                    boolean hasQuotaInList = false;
                    for (Quota quota : quotaList) {
                        if (quota.getId().equals(defaultQuota)) {
                            vmModel.getQuota().setSelectedItem(quota);
                            hasQuotaInList = true;
                            break;
                        }
                    }
                    // Add the quota to the list only in edit mode
                    if (!hasQuotaInList && !getModel().getIsNew()) {
                        Quota quota = new Quota();
                        quota.setId(defaultQuota);
                        quota.setQuotaName(quotaName);
                        quotaList.add(quota);
                        vmModel.getQuota().setItems(quotaList);
                        vmModel.getQuota().setSelectedItem(quota);
                    }
                }
            }
        }));
    }
}
#method_after
protected void updateQuotaByCluster(final Guid defaultQuota, final String quotaName) {
    if (getModel().getQuota().getIsAvailable()) {
        VDSGroup cluster = getModel().getSelectedCluster();
        if (cluster == null) {
            return;
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForVdsGroup, new IdQueryParameters(cluster.getId()), new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                UnitVmModel vmModel = (UnitVmModel) model;
                ArrayList<Quota> quotaList = ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (quotaList != null && !quotaList.isEmpty()) {
                    vmModel.getQuota().setItems(quotaList);
                }
                if (quotaList != null && defaultQuota != null && !Guid.Empty.equals(defaultQuota)) {
                    boolean hasQuotaInList = false;
                    for (Quota quota : quotaList) {
                        if (quota.getId().equals(defaultQuota)) {
                            vmModel.getQuota().setSelectedItem(quota);
                            hasQuotaInList = true;
                            break;
                        }
                    }
                    // Add the quota to the list only in edit mode
                    if (!hasQuotaInList && !getModel().getIsNew()) {
                        Quota quota = new Quota();
                        quota.setId(defaultQuota);
                        quota.setQuotaName(quotaName);
                        quotaList.add(quota);
                        vmModel.getQuota().setItems(quotaList);
                        vmModel.getQuota().setSelectedItem(quota);
                    }
                }
            }
        }));
    }
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    instanceTypesEditor.setLabel(constants.instanceType());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    detachableMemSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditorWithDetachable.setLabel(constants.coresPerSocket());
    numOfSocketsEditorWithDetachable.setLabel(constants.numOfSockets());
}
#method_after
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    instanceTypesEditor.setLabel(constants.instanceType());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Rng device tab
    rngDeviceTab.setLabel(constants.rngDeviceTab());
    isRngEnabledEditor.setLabel(constants.rngDevEnabled());
    rngPeriodEditor.setLabel(constants.rngPeriod());
    rngBytesEditor.setLabel(constants.rngBytes());
    rngSourceRandom.setLabel(constants.rngSourceRandom());
    rngSourceHwrng.setLabel(constants.rngSourceHwrng());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    spiceFileTransferEnabledEditor.setLabel(constants.spiceFileTransferEnabled());
    spiceCopyPasteEnabledEditor.setLabel(constants.spiceCopyPasteEnabled());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    detachableMemSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditorWithDetachable.setLabel(constants.coresPerSocket());
    numOfSocketsEditorWithDetachable.setLabel(constants.numOfSockets());
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getcompatibility_version() != null) {
                boolean enabled = AsyncDataProvider.isSerialNumberPolicySupported(vdsGroup.getcompatibility_version().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getcompatibility_version() != null) {
                boolean enabled = AsyncDataProvider.isSerialNumberPolicySupported(vdsGroup.getcompatibility_version().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            rngPanel.setVisible((Boolean) object.getIsRngEnabled().getEntity());
        }
    });
}
#end_block

#method_before
protected void updateUsbNativeMessageVisibility(final UnitVmModel object) {
    VDSGroup vdsGroup = object.getSelectedCluster();
    changeApplicationLevelVisibility(nativeUsbWarningMessage, object.getUsbPolicy().getSelectedItem() == UsbPolicy.ENABLED_NATIVE && vdsGroup != null && vdsGroup.getcompatibility_version() != null && !(Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MigrationSupportForNativeUsb, vdsGroup.getcompatibility_version().getValue()));
}
#method_after
protected void updateUsbNativeMessageVisibility(final UnitVmModel object) {
    Version vdsGroupVersion = clusterVersionOrNull(object);
    changeApplicationLevelVisibility(nativeUsbWarningMessage, object.getUsbPolicy().getSelectedItem() == UsbPolicy.ENABLED_NATIVE && vdsGroupVersion != null && !(Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MigrationSupportForNativeUsb, vdsGroupVersion.getValue()));
}
#end_block

#method_before
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsSystemTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsSystemTabValid()) {
                    systemTab.markAsValid();
                } else {
                    systemTab.markAsInvalid(null);
                }
            } else if ("IsDisplayTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsDisplayTabValid()) {
                    consoleTab.markAsValid();
                } else {
                    consoleTab.markAsInvalid(null);
                }
            } else if ("IsAllocationTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsAllocationTabValid()) {
                    resourceAllocationTab.markAsValid();
                } else {
                    resourceAllocationTab.markAsInvalid(null);
                }
            } else if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(highAvailabilityTab, vm.getIsHighlyAvailable().getEntity());
            } else if ("IsBootSequenceTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsHighlyAvailable().getEntity()) {
                    bootOptionsTab.markAsValid();
                } else {
                    bootOptionsTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsCustomPropertiesTabValid()) {
                    customPropertiesTab.markAsValid();
                } else {
                    customPropertiesTab.markAsInvalid(null);
                }
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || vm.getIsVirtioScsiEnabled().getIsAvailable());
                if (isDisksAvailable) {
                    // Update warning message by disks status
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.ILLEGAL);
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.LOCKED);
                } else {
                    // Clear warning message
                    // $NON-NLS-1$
                    generalWarningMessage.setText("");
                }
            }
        }
    });
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsLinuxOS".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(linuxBootOptionsPanel, vm.getIsLinuxOS());
            }
        }
    });
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    ssoMethodGuestAgent.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodNone.asRadioButton(), false);
            }
        }
    });
    ssoMethodNone.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodGuestAgent.asRadioButton(), false);
            }
        }
    });
}
#method_after
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsSystemTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsSystemTabValid()) {
                    systemTab.markAsValid();
                } else {
                    systemTab.markAsInvalid(null);
                }
            } else if ("IsDisplayTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsDisplayTabValid()) {
                    consoleTab.markAsValid();
                } else {
                    consoleTab.markAsInvalid(null);
                }
            } else if ("IsAllocationTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsAllocationTabValid()) {
                    resourceAllocationTab.markAsValid();
                } else {
                    resourceAllocationTab.markAsInvalid(null);
                }
            } else if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(highAvailabilityTab, vm.getIsHighlyAvailable().getEntity());
            } else if ("IsBootSequenceTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsHighlyAvailable().getEntity()) {
                    bootOptionsTab.markAsValid();
                } else {
                    bootOptionsTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsCustomPropertiesTabValid()) {
                    customPropertiesTab.markAsValid();
                } else {
                    customPropertiesTab.markAsInvalid(null);
                }
            } else if ("IsRngTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.isRngTabValid()) {
                    rngDeviceTab.markAsValid();
                } else {
                    rngDeviceTab.markAsInvalid(null);
                }
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                changeApplicationLevelVisibility(disksPanel, isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
                changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || vm.getIsVirtioScsiEnabled().getIsAvailable());
                if (isDisksAvailable) {
                    // Update warning message by disks status
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.ILLEGAL);
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.LOCKED);
                } else {
                    // Clear warning message
                    // $NON-NLS-1$
                    generalWarningMessage.setText("");
                }
            }
        }
    });
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsLinuxOS".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(linuxBootOptionsPanel, vm.getIsLinuxOS());
            }
        }
    });
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    rngSourceRandom.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            vm.getRngSourceRandom().setEntity(true);
            vm.getRngSourceHwrng().setEntity(false);
        }
    });
    rngSourceHwrng.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            vm.getRngSourceHwrng().setEntity(true);
            vm.getRngSourceRandom().setEntity(false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    ssoMethodGuestAgent.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodNone.asRadioButton(), false);
            }
        }
    });
    ssoMethodNone.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodGuestAgent.asRadioButton(), false);
            }
        }
    });
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceRandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(allTabs(), simpleField().visibleInAdvancedModeOnly()).putAll(adancedFieldsFromGeneralTab(), simpleField().visibleInAdvancedModeOnly()).putAll(consoleTabWidgets(), simpleField().visibleInAdvancedModeOnly()).update(consoleTab, simpleField()).update(numOfMonitorsEditor, simpleField()).update(isSingleQxlEnabledEditor, simpleField()).putOne(isSoundcardEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isConsoleDeviceEnabledEditor, simpleField().visibleInAdvancedModeOnly());
}
#method_after
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(allTabs(), simpleField().visibleInAdvancedModeOnly()).putAll(adancedFieldsFromGeneralTab(), simpleField().visibleInAdvancedModeOnly()).putAll(consoleTabWidgets(), simpleField().visibleInAdvancedModeOnly()).update(consoleTab, simpleField()).update(numOfMonitorsEditor, simpleField()).update(isSingleQxlEnabledEditor, simpleField()).putOne(isSoundcardEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isConsoleDeviceEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(spiceFileTransferEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(spiceCopyPasteEnabledEditor, simpleField().visibleInAdvancedModeOnly());
}
#end_block

#method_before
protected List<Widget> allTabs() {
    return Arrays.<Widget>asList(initialRunTab, consoleTab, hostTab, resourceAllocationTab, bootOptionsTab, customPropertiesTab, highAvailabilityTab, poolTab, systemTab);
}
#method_after
protected List<Widget> allTabs() {
    return Arrays.<Widget>asList(initialRunTab, consoleTab, hostTab, resourceAllocationTab, bootOptionsTab, customPropertiesTab, rngDeviceTab, highAvailabilityTab, poolTab, systemTab);
}
#end_block

#method_before
protected void disableAllTabs() {
    generalTab.disableContent();
    poolTab.disableContent();
    initialRunTab.disableContent();
    consoleTab.disableContent();
    hostTab.disableContent();
    highAvailabilityTab.disableContent();
    resourceAllocationTab.disableContent();
    bootOptionsTab.disableContent();
    customPropertiesTab.disableContent();
    systemTab.disableContent();
    oSTypeEditor.setEnabled(false);
    quotaEditor.setEnabled(false);
    dataCenterWithClusterEditor.setEnabled(false);
    templateEditor.setEnabled(false);
    baseTemplateEditor.setEnabled(false);
    vmTypeEditor.setEnabled(false);
    instanceTypesEditor.setEnabled(false);
}
#method_after
protected void disableAllTabs() {
    generalTab.disableContent();
    poolTab.disableContent();
    initialRunTab.disableContent();
    consoleTab.disableContent();
    hostTab.disableContent();
    highAvailabilityTab.disableContent();
    resourceAllocationTab.disableContent();
    bootOptionsTab.disableContent();
    customPropertiesTab.disableContent();
    systemTab.disableContent();
    rngDeviceTab.disableContent();
    oSTypeEditor.setEnabled(false);
    quotaEditor.setEnabled(false);
    dataCenterWithClusterEditor.setEnabled(false);
    templateEditor.setEnabled(false);
    baseTemplateEditor.setEnabled(false);
    vmTypeEditor.setEnabled(false);
    instanceTypesEditor.setEnabled(false);
}
#end_block

#method_before
void bindInfrastructure() {
    bindCommonInfrastructure(WebAdminPlaceManager.class);
    bind(ApplicationInit.class).asEagerSingleton();
    bind(InternalConfiguration.class).asEagerSingleton();
    bind(PostMessageDispatcher.class).asEagerSingleton();
    bind(CurrentUserRole.class).to(CommonCurrentUserRole.class).in(Singleton.class);
}
#method_after
void bindInfrastructure() {
    bindCommonInfrastructure(WebAdminPlaceManager.class);
    bind(InternalConfiguration.class).asEagerSingleton();
    bind(PostMessageDispatcher.class).asEagerSingleton();
    bindTypeAndImplAsSingleton(CurrentUserRole.class, CommonCurrentUserRole.class);
}
#end_block

#method_before
protected void performLogin(T loginModel) {
    DbUser loggedUser = loginModel.getLoggedUser();
    String loginPassword = (String) loginModel.getPassword().getEntity();
    // UiCommon login preparation
    frontend.initLoggedInUser(loggedUser, loginPassword);
    beforeUiCommonInitEvent(loginModel);
    UiCommonInitEvent.fire(eventBus);
    // UI login actions
    user.onUserLogin(loggedUser);
    // Post-login actions
    loginModel.getPassword().setEntity(null);
}
#method_after
protected void performLogin(T loginModel) {
    DbUser loggedUser = loginModel.getLoggedUser();
    String loginPassword = loginModel.getPassword().getEntity();
    // UiCommon login preparation
    frontend.initLoggedInUser(loggedUser, loginPassword);
    beforeUiCommonInitEvent(loginModel);
    UiCommonInitEvent.fire(eventBus);
    // UI login actions
    user.onUserLogin(loggedUser);
    // Post-login actions
    loginModel.getPassword().setEntity(null);
}
#end_block

#method_before
protected void handleAutoLogin(AutoLoginData autoLoginData) {
    final DbUser loggedUser = autoLoginData.getDbUser();
    // Use deferred command because CommonModel change needs to happen
    // after all model providers have been properly initialized
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            lockInteractionManager.showLoadingIndicator();
            getLoginModel().autoLogin(loggedUser);
        }
    });
    // Indicate that the user should be logged in automatically
    user.setAutoLogin(true);
}
#method_after
protected void handleAutoLogin(AutoLoginData autoLoginData) {
    final DbUser loggedUser = autoLoginData.getDbUser();
    // Use deferred command because CommonModel change needs to happen
    // after all model providers have been properly initialized
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            lockInteractionManager.showLoadingIndicator();
            getLoginModel().autoLogin(loggedUser);
        }
    });
    SSOTokenChangeEvent.fire(eventBus, SSOTokenData.instance().getToken());
    // Indicate that the user should be logged in automatically
    user.setAutoLogin(true);
}
#end_block

#method_before
void bindInfrastructure() {
    bindCommonInfrastructure(UserPortalPlaceManager.class);
    bind(LoggedInExtendedPlaceGatekeeper.class).in(Singleton.class);
    bind(ApplicationInit.class).asEagerSingleton();
    bind(CurrentUserRole.class).to(UserPortalCurrentUserRole.class).in(Singleton.class);
}
#method_after
void bindInfrastructure() {
    bindCommonInfrastructure(UserPortalPlaceManager.class);
    bind(LoggedInExtendedPlaceGatekeeper.class).in(Singleton.class);
    bind(CurrentUserRole.class).in(Singleton.class);
    bind(ApplicationInit.class).asEagerSingleton();
    bindTypeAndImplAsSingleton(CurrentUserRole.class, UserPortalCurrentUserRole.class);
}
#end_block

#method_before
public Map<Version, List<String>> getCustomPropertiesKeysList() {
    return privateCustomPropertiesKeysList;
}
#method_after
public Map<Version, Map<String, String>> getCustomPropertiesKeysList() {
    return privateCustomPropertiesKeysList;
}
#end_block

#method_before
public void setCustomPropertiesKeysList(Map<Version, List<String>> value) {
    privateCustomPropertiesKeysList = value;
}
#method_after
public void setCustomPropertiesKeysList(Map<Version, Map<String, String>> value) {
    privateCustomPropertiesKeysList = value;
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    isRngEnabled.setEntity(false);
    rngSourceRandom.setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            vmTypeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            vmTypeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#end_block

#method_before
private void handleQxlClusterLevel() {
    // Enable Single PCI only on cluster 3.3 and high and on Linux OS
    boolean isLinux = getIsLinuxOS();
    boolean isQxl = getDisplayType() == DisplayType.qxl;
    boolean clusterSupportsSinglePci = getSelectedCluster() != null && Version.v3_3.compareTo(getSelectedCluster().getcompatibility_version()) <= 0;
    getBehavior().enableSinglePCI(isLinux && isQxl && clusterSupportsSinglePci);
}
#method_after
private void handleQxlClusterLevel() {
    // Enable Single PCI only on cluster 3.3 and high and on Linux OS
    boolean isLinux = getIsLinuxOS();
    boolean isQxl = getDisplayType() == DisplayType.qxl;
    boolean clusterSupportsSinglePci = getSelectedCluster() != null && Version.v3_3.compareTo(getSelectedCluster().getcompatibility_version()) <= 0;
    getBehavior().enableSinglePCI(isLinux && isQxl && clusterSupportsSinglePci);
    if (getSelectedCluster() != null) {
        boolean spiceFileTransferToggle = isQxl && AsyncDataProvider.isSpiceFileTransferToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceFileTransferToggle) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceFileTransferEnabled().setIsChangable(spiceFileTransferToggle);
        boolean spiceCopyPasteToggle = isQxl && AsyncDataProvider.isSpiceCopyPasteToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangable(spiceCopyPasteToggle);
    }
}
#end_block

#method_before
public boolean validateHwPart() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getMinAllocatedMemory().getIsValid());
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    return behaviorValid && customPropertySheetValid && getName().getIsValid() && getDescription().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getUsbPolicy().getIsValid() && getMigrationDowntime().getIsValid();
}
#method_after
public boolean validateHwPart() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getMinAllocatedMemory().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setRngTabValid(getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    return behaviorValid && customPropertySheetValid && getName().getIsValid() && getDescription().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getUsbPolicy().getIsValid() && getMigrationDowntime().getIsValid() && getRngBytes().getIsValid() && getRngPeriod().getIsValid();
}
#end_block

#method_before
public Map<String, String> getVMProperties(Version version, VmStatic vmStatic) {
    separeteCustomPropertiesToUserAndPredefined(version, vmStatic);
    Map<String, String> map = new HashMap<String, String>();
    getPredefinedProperties(version, vmStatic, map);
    getUserDefinedProperties(version, vmStatic, map);
    return map;
}
#method_after
public Map<String, String> getVMProperties(Version version, VmStatic vmStatic) {
    separateCustomPropertiesToUserAndPredefined(version, vmStatic);
    Map<String, String> map = new HashMap<String, String>();
    getPredefinedProperties(version, vmStatic, map);
    getUserDefinedProperties(version, vmStatic, map);
    return map;
}
#end_block

#method_before
public void dataCenterWithClusterSelectedItemChanged() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    StoragePool dataCenter = dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    if (dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        getModel().getQuota().setIsAvailable(true);
    } else {
        getModel().getQuota().setIsAvailable(false);
    }
    postDataCenterWithClusterSelectedItemChanged();
}
#method_after
public void dataCenterWithClusterSelectedItemChanged() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    StoragePool dataCenter = dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    if (dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        getModel().getQuota().setIsAvailable(true);
    } else {
        getModel().getQuota().setIsAvailable(false);
    }
    getModel().getIsRngEnabled().setIsChangable(isRngDeviceSupported(getModel()));
    getModel().getIsRngEnabled().setMessage(constants.rngNotSupportedByCluster());
    setRngAvailability();
    postDataCenterWithClusterSelectedItemChanged();
}
#end_block

#method_before
protected void updateQuotaByCluster(final Guid defaultQuota, final String quotaName) {
    if (getModel().getQuota().getIsAvailable()) {
        VDSGroup cluster = getModel().getSelectedCluster();
        if (cluster == null) {
            return;
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForVdsGroup, new IdQueryParameters(cluster.getId()), new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                UnitVmModel vmModel = (UnitVmModel) model;
                ArrayList<Quota> quotaList = ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (quotaList != null && !quotaList.isEmpty()) {
                    vmModel.getQuota().setItems(quotaList);
                }
                if (defaultQuota != null && !Guid.Empty.equals(defaultQuota)) {
                    boolean hasQuotaInList = false;
                    for (Quota quota : quotaList) {
                        if (quota.getId().equals(defaultQuota)) {
                            vmModel.getQuota().setSelectedItem(quota);
                            hasQuotaInList = true;
                            break;
                        }
                    }
                    // Add the quota to the list only in edit mode
                    if (!hasQuotaInList && !getModel().getIsNew()) {
                        Quota quota = new Quota();
                        quota.setId(defaultQuota);
                        quota.setQuotaName(quotaName);
                        quotaList.add(quota);
                        vmModel.getQuota().setItems(quotaList);
                        vmModel.getQuota().setSelectedItem(quota);
                    }
                }
            }
        }));
    }
}
#method_after
protected void updateQuotaByCluster(final Guid defaultQuota, final String quotaName) {
    if (getModel().getQuota().getIsAvailable()) {
        VDSGroup cluster = getModel().getSelectedCluster();
        if (cluster == null) {
            return;
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForVdsGroup, new IdQueryParameters(cluster.getId()), new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                UnitVmModel vmModel = (UnitVmModel) model;
                ArrayList<Quota> quotaList = ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (quotaList != null && !quotaList.isEmpty()) {
                    vmModel.getQuota().setItems(quotaList);
                }
                if (quotaList != null && defaultQuota != null && !Guid.Empty.equals(defaultQuota)) {
                    boolean hasQuotaInList = false;
                    for (Quota quota : quotaList) {
                        if (quota.getId().equals(defaultQuota)) {
                            vmModel.getQuota().setSelectedItem(quota);
                            hasQuotaInList = true;
                            break;
                        }
                    }
                    // Add the quota to the list only in edit mode
                    if (!hasQuotaInList && !getModel().getIsNew()) {
                        Quota quota = new Quota();
                        quota.setId(defaultQuota);
                        quota.setQuotaName(quotaName);
                        quotaList.add(quota);
                        vmModel.getQuota().setItems(quotaList);
                        vmModel.getQuota().setSelectedItem(quota);
                    }
                }
            }
        }));
    }
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setArchitecture(new ListModel<ArchitectureType>());
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setArchitecture(new ListModel<ArchitectureType>());
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    setRngSourcesCheckboxes(version);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
}
#end_block

#method_before
private void populateCPUList(ClusterModel clusterModel, List<ServerCpu> cpus, boolean canChangeArchitecture) {
    ServerCpu oldSelectedCpu = clusterModel.getCPU().getSelectedItem();
    clusterModel.getCPU().setItems(cpus);
    initSupportedArchitectures(clusterModel);
    clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.firstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
    if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
        initCPU();
    }
    if (clusterModel.getIsEdit()) {
        if (!canChangeArchitecture) {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(clusterModel.getEntity().getArchitecture())));
        }
        ArchitectureType oldSelectedArch = clusterModel.getArchitecture().getSelectedItem();
        if (oldSelectedArch != null) {
            getArchitecture().setSelectedItem(oldSelectedArch);
        } else {
            getArchitecture().setSelectedItem(getEntity().getArchitecture());
        }
    } else {
        getArchitecture().setSelectedItem(ArchitectureType.undefined);
    }
}
#method_after
private void populateCPUList(ClusterModel clusterModel, List<ServerCpu> cpus, boolean canChangeArchitecture) {
    ServerCpu oldSelectedCpu = clusterModel.getCPU().getSelectedItem();
    clusterModel.getCPU().setItems(cpus);
    initSupportedArchitectures(clusterModel);
    clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.firstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
    if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
        initCPU();
    }
    if (clusterModel.getIsEdit()) {
        if (!canChangeArchitecture) {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(clusterModel.getEntity().getArchitecture())));
        }
        ArchitectureType oldSelectedArch = clusterModel.getArchitecture().getSelectedItem();
        if (oldSelectedArch != null) {
            getArchitecture().setSelectedItem(oldSelectedArch);
        } else {
            getArchitecture().setSelectedItem(getEntity().getArchitecture());
        }
    } else {
        getArchitecture().setSelectedItem(ArchitectureType.undefined);
    }
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
}
#end_block

#method_before
private void storagePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    final StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        return;
    }
    if (selectedDataCenter.isLocal()) {
        setIsResiliencePolicyTabAvailable(false);
    } else {
        setIsResiliencePolicyTabAvailable(true);
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            Version selectedVersion = clusterModel.getVersion().getSelectedItem();
            clusterModel.getVersion().setItems(versions);
            if (selectedVersion == null || !versions.contains(selectedVersion) || selectedVersion.compareTo(selectedDataCenter.getcompatibility_version()) > 0) {
                clusterModel.getVersion().setSelectedItem(selectedDataCenter.getcompatibility_version());
            } else if (clusterModel.getIsEdit()) {
                clusterModel.getVersion().setSelectedItem(Linq.firstOrDefault(versions, new Linq.VersionPredicate(clusterModel.getEntity().getcompatibility_version())));
            } else {
                clusterModel.getVersion().setSelectedItem(selectedVersion);
            }
        }
    };
    AsyncDataProvider.getDataCenterVersions(_asyncQuery, selectedDataCenter.getId());
}
#method_after
private void storagePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    final StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        return;
    }
    if (selectedDataCenter.isLocal()) {
        setIsResiliencePolicyTabAvailable(false);
    } else {
        setIsResiliencePolicyTabAvailable(true);
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            Version selectedVersion = clusterModel.getVersion().getSelectedItem();
            clusterModel.getVersion().setItems(versions);
            if (selectedVersion == null || !versions.contains(selectedVersion) || selectedVersion.compareTo(selectedDataCenter.getcompatibility_version()) > 0) {
                if (ApplicationModeHelper.getUiMode().equals(ApplicationMode.GlusterOnly)) {
                    clusterModel.getVersion().setSelectedItem(Linq.selectHighestVersion(versions));
                } else {
                    clusterModel.getVersion().setSelectedItem(selectedDataCenter.getcompatibility_version());
                }
            } else if (clusterModel.getIsEdit()) {
                clusterModel.getVersion().setSelectedItem(Linq.firstOrDefault(versions, new Linq.VersionPredicate(clusterModel.getEntity().getcompatibility_version())));
            } else {
                clusterModel.getVersion().setSelectedItem(selectedVersion);
            }
        }
    };
    AsyncDataProvider.getDataCenterVersions(_asyncQuery, selectedDataCenter.getId());
}
#end_block

#method_before
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsGeneralTabValid(getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true));
    return getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getSpiceProxy().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true) && getCustomPropertySheet().getIsValid();
}
#method_after
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validateRngRequiredSource();
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    boolean generalTabValid = getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getRngRandomSourceRequired().getIsValid() && getRngHwrngSourceRequired().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && isFingerprintVerified()) : true);
    setIsGeneralTabValid(generalTabValid);
    return generalTabValid && getCustomPropertySheet().getIsValid();
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    isRngEnabled.setEntity(false);
    rngSourceRandom.setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            vmTypeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            vmTypeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#end_block

#method_before
private void handleQxlClusterLevel() {
    // Enable Single PCI only on cluster 3.3 and high and on Linux OS
    boolean isLinux = getIsLinuxOS();
    boolean isQxl = getDisplayType() == DisplayType.qxl;
    boolean clusterSupportsSinglePci = getSelectedCluster() != null && Version.v3_3.compareTo(getSelectedCluster().getcompatibility_version()) <= 0;
    getBehavior().enableSinglePCI(isLinux && isQxl && clusterSupportsSinglePci);
}
#method_after
private void handleQxlClusterLevel() {
    // Enable Single PCI only on cluster 3.3 and high and on Linux OS
    boolean isLinux = getIsLinuxOS();
    boolean isQxl = getDisplayType() == DisplayType.qxl;
    boolean clusterSupportsSinglePci = getSelectedCluster() != null && Version.v3_3.compareTo(getSelectedCluster().getcompatibility_version()) <= 0;
    getBehavior().enableSinglePCI(isLinux && isQxl && clusterSupportsSinglePci);
    boolean spiceFileTransferToggle = isQxl && getSelectedCluster() != null && AsyncDataProvider.isSpiceFileTransferToggleSupported(getSelectedCluster().getcompatibility_version().toString());
    if (!spiceFileTransferToggle) {
        handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
    }
    getSpiceFileTransferEnabled().setIsChangable(spiceFileTransferToggle);
    boolean spiceCopyPasteToggle = isQxl && getSelectedCluster() != null && AsyncDataProvider.isSpiceCopyPasteToggleSupported(getSelectedCluster().getcompatibility_version().toString());
    if (!spiceCopyPasteToggle) {
        handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
    }
    getSpiceCopyPasteEnabled().setIsChangable(spiceCopyPasteToggle);
}
#end_block

#method_before
public boolean validateHwPart() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getMinAllocatedMemory().getIsValid());
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    return behaviorValid && customPropertySheetValid && getName().getIsValid() && getDescription().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getUsbPolicy().getIsValid() && getMigrationDowntime().getIsValid();
}
#method_after
public boolean validateHwPart() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getMinAllocatedMemory().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setRngTabValid(getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    return behaviorValid && customPropertySheetValid && getName().getIsValid() && getDescription().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getUsbPolicy().getIsValid() && getMigrationDowntime().getIsValid() && getRngBytes().getIsValid() && getRngPeriod().getIsValid();
}
#end_block

#method_before
private void addStyles() {
    importGlusterConfigurationEditor.addContentWidgetStyleName(style.editorContentWidget());
    migrateOnErrorOption_NOEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_YESEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_HA_ONLYEditor.addContentWidgetStyleName(style.label());
    countThreadsAsCoresEditor.setContentWidgetStyleName(style.fullWidth());
    enableTrustedServiceEditor.setContentWidgetStyleName(style.fullWidth());
    enableHaReservationEditor.setContentWidgetStyleName(style.fullWidth());
}
#method_after
private void addStyles() {
    importGlusterConfigurationEditor.addContentWidgetStyleName(style.editorContentWidget());
    migrateOnErrorOption_NOEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_YESEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_HA_ONLYEditor.addContentWidgetStyleName(style.label());
    countThreadsAsCoresEditor.setContentWidgetStyleName(style.fullWidth());
    enableTrustedServiceEditor.setContentWidgetStyleName(style.fullWidth());
    enableHaReservationEditor.setContentWidgetStyleName(style.fullWidth());
    enableOptionalReasonEditor.setContentWidgetStyleName(style.fullWidth());
}
#end_block

#method_before
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    cpuEditor.setLabel(constants.clusterPopupCPUTypeLabel());
    architectureEditor.setLabel(constants.clusterPopupArchitectureLabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    rngLabel.setText(constants.requiredRngSources());
    rngRandomSourceRequired.setLabel(constants.rngSourceRandom());
    rngHwrngSourceRequired.setLabel(constants.rngSourceHwrng());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.asRadioButton().setHTML(templates.radioButtonLabel(constants.clusterPopupOptimizationNoneLabel()));
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    enableHaReservationEditor.setLabel(constants.clusterPolicyEnableHaReservationLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
    enableKsm.setLabel(constants.enableKsmLabel());
    enableBallooning.setLabel(constants.enableBallooningLabel());
    schedulerOptimizationPanelTitle.setText(constants.schedulerOptimizationPanelLabel());
    optimizeForUtilizationEditor.setLabel(constants.optimizeForUtilizationLabel());
    optimizeForSpeedEditor.setLabel(constants.optimizeForSpeedLabel());
    guarantyResourcesEditor.setLabel(constants.guarantyResourcesLabel());
    allowOverbookingEditor.setLabel(constants.allowOverbookingLabel());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    consoleTab.setLabel(constants.consoleTabLabel());
}
#method_after
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    cpuEditor.setLabel(constants.clusterPopupCPUTypeLabel());
    architectureEditor.setLabel(constants.clusterPopupArchitectureLabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    rngLabel.setText(constants.requiredRngSources());
    rngRandomSourceRequired.setLabel(constants.rngSourceRandom());
    rngHwrngSourceRequired.setLabel(constants.rngSourceHwrng());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.asRadioButton().setHTML(templates.radioButtonLabel(constants.clusterPopupOptimizationNoneLabel()));
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    enableHaReservationEditor.setLabel(constants.clusterPolicyEnableHaReservationLabel());
    enableOptionalReasonEditor.setLabel(constants.clusterPolicyEnableReasonLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
    enableKsm.setLabel(constants.enableKsmLabel());
    enableBallooning.setLabel(constants.enableBallooningLabel());
    schedulerOptimizationPanelTitle.setText(constants.schedulerOptimizationPanelLabel());
    optimizeForUtilizationEditor.setLabel(constants.optimizeForUtilizationLabel());
    optimizeForSpeedEditor.setLabel(constants.optimizeForSpeedLabel());
    guarantyResourcesEditor.setLabel(constants.guarantyResourcesLabel());
    allowOverbookingEditor.setLabel(constants.allowOverbookingLabel());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    consoleTab.setLabel(constants.consoleTabLabel());
}
#end_block

#method_before
private void initRadioButtonEditors() {
    // $NON-NLS-1$
    enableOvirtServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    enableGlusterServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    optimizationNoneEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForServerEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForDesktopEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationCustomEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    migrateOnErrorOption_YESEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_HA_ONLYEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_NOEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    optimizeForUtilizationEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    optimizeForSpeedEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    guarantyResourcesEditor = new EntityModelRadioButtonEditor("4");
    // $NON-NLS-1$
    allowOverbookingEditor = new EntityModelRadioButtonEditor("4");
}
#method_after
private void initRadioButtonEditors() {
    // $NON-NLS-1$
    enableOvirtServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    enableGlusterServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    optimizationNoneEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForServerEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForDesktopEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationCustomEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    migrateOnErrorOption_YESEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_HA_ONLYEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_NOEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    optimizeForUtilizationEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    optimizeForSpeedEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    guarantyResourcesEditor = new EntityModelRadioButtonEditor("4");
    // $NON-NLS-1$
    allowOverbookingEditor = new EntityModelRadioButtonEditor("4");
    serialNumberPolicyEditor = new SerialNumberPolicyWidget(eventBus, templates, messages, resources, new VisibilityRenderer.SimpleVisibilityRenderer());
}
#end_block

#method_before
private void initCheckBoxEditors() {
    importGlusterConfigurationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableTrustedServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHaReservationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableKsm = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableKsm.getContentWidgetContainer().setWidth("350px");
    enableBallooning = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableBallooning.getContentWidgetContainer().setWidth("350px");
    rngRandomSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    rngHwrngSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
}
#method_after
private void initCheckBoxEditors() {
    importGlusterConfigurationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableTrustedServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHaReservationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableOptionalReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableKsm = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableKsm.getContentWidgetContainer().setWidth("350px");
    enableBallooning = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableBallooning.getContentWidgetContainer().setWidth("350px");
    rngRandomSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    rngHwrngSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
}
#end_block

#method_before
private void initInfoIcons(ApplicationResources resources, ApplicationConstants constants, ApplicationTemplates templates) {
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", constants.clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuThreadsInfo = new InfoIcon(templates.italicFixedWidth("600px", constants.clusterPopupCpuThreadsInfo()), resources);
    schedulerOptimizationInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    allowOverbookingInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    EntityModelLabel label = new EntityModelLabel();
    label.setText(constants.clusterSpiceProxyEnable());
    spiceProxyOverrideEnabled = new EntityModelCheckBoxOnlyEditor();
    spiceProxyEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo(label, spiceProxyOverrideEnabled);
}
#method_after
private void initInfoIcons(ApplicationResources resources, ApplicationConstants constants, ApplicationTemplates templates) {
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", constants.clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuThreadsInfo = new InfoIcon(templates.italicFixedWidth("600px", constants.clusterPopupCpuThreadsInfo()), resources);
    schedulerOptimizationInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    allowOverbookingInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.clusterSpiceProxyEnable());
    // $NON-NLS-1$
    label.setWidth("250px");
    spiceProxyOverrideEnabled = new EntityModelCheckBoxOnlyEditor();
    spiceProxyEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo<String>(label, spiceProxyOverrideEnabled);
}
#end_block

#method_before
private void applyModeCustomizations() {
    if (ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly) {
        optimizationTab.setVisible(false);
        resiliencePolicyTab.setVisible(false);
        clusterPolicyTab.setVisible(false);
        dataCenterPanel.addStyleName(style.generalTabTopDecoratorEmpty());
    }
}
#method_after
private void applyModeCustomizations() {
    if (ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly) {
        optimizationTab.setVisible(false);
        resiliencePolicyTab.setVisible(false);
        clusterPolicyTab.setVisible(false);
        consoleTab.setVisible(false);
        dataCenterPanel.addStyleName(style.generalTabTopDecoratorEmpty());
    }
}
#end_block

#method_before
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getCPU().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isCpuNameBlank = object.getCPU().getSelectedItem() == null;
            architectureEditor.setVisible(isCpuNameBlank);
        }
    });
    object.getVersion().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            rngLabel.setVisible(object.getRngRandomSourceRequired().getIsAvailable() && object.getRngHwrngSourceRequired().getIsAvailable());
        }
    });
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingPanel.setVisible(allowOverbookingEditor.isVisible());
}
#method_after
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getCPU().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isCpuNameBlank = object.getCPU().getSelectedItem() == null;
            architectureEditor.setVisible(isCpuNameBlank);
        }
    });
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingPanel.setVisible(allowOverbookingEditor.isVisible());
    object.getVersion().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getVersion().getSelectedItem() != null) {
                String clusterVersion = object.getVersion().getSelectedItem().getValue();
                serialNumberPolicyEditor.setVisible(AsyncDataProvider.isSerialNumberPolicySupported(clusterVersion));
            }
        }
    });
}
#end_block

#method_before
@Override
public ClusterModel flush() {
    return driver.flush();
}
#method_after
@Override
public ClusterModel flush() {
    serialNumberPolicyEditor.flush();
    return driver.flush();
}
#end_block

#method_before
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().startProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.setHandleFailure(true);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            getWindow().stopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            } else if (!returnValue.getSucceeded()) {
                clusterModel.setMessage(Frontend.getInstance().getAppErrorsTranslator().translateErrorTextSingle(returnValue.getExceptionString()));
                return;
            }
            Map<String, String> hostMap = returnValue.getReturnValue();
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel> list = new ArrayList<EntityModel>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel entityModel = new EntityModel(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.getGlusterHosts(aQuery, clusterModel.getGlusterHostAddress().getEntity(), clusterModel.getGlusterHostPassword().getEntity(), clusterModel.getGlusterHostFingerprint().getEntity());
}
#method_after
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().startProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.setHandleFailure(true);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            getWindow().stopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            } else if (!returnValue.getSucceeded()) {
                clusterModel.setMessage(Frontend.getInstance().getAppErrorsTranslator().translateErrorTextSingle(returnValue.getExceptionString()));
                return;
            }
            Map<String, String> hostMap = returnValue.getReturnValue();
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel<HostDetailModel>> list = new ArrayList<EntityModel<HostDetailModel>>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel<HostDetailModel> entityModel = new EntityModel<HostDetailModel>(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.getGlusterHosts(aQuery, clusterModel.getGlusterHostAddress().getEntity(), clusterModel.getGlusterHostPassword().getEntity(), clusterModel.getGlusterHostFingerprint().getEntity());
}
#end_block

#method_before
private void importClusterHosts(ClusterModel clusterModel, ArrayList<EntityModel> hostList) {
    setWindow(null);
    getAddMultipleHostsCommand().execute();
    final MultipleHostsModel hostsModel = new MultipleHostsModel();
    setWindow(hostsModel);
    hostsModel.setTitle(ConstantsManager.getInstance().getConstants().addMultipleHostsTitle());
    hostsModel.setHelpTag(HelpTag.add_hosts);
    // $NON-NLS-1$
    hostsModel.setHashName("add_hosts");
    hostsModel.setClusterModel(clusterModel);
    hostsModel.getHosts().setItems(hostList);
    // $NON-NLS-1$
    UICommand command = new UICommand("OnSaveHosts", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    hostsModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    hostsModel.getCommands().add(command);
}
#method_after
private void importClusterHosts(ClusterModel clusterModel, ArrayList<EntityModel<HostDetailModel>> hostList) {
    setWindow(null);
    getAddMultipleHostsCommand().execute();
    final MultipleHostsModel hostsModel = new MultipleHostsModel();
    setWindow(hostsModel);
    hostsModel.setTitle(ConstantsManager.getInstance().getConstants().addMultipleHostsTitle());
    hostsModel.setHelpTag(HelpTag.add_hosts);
    // $NON-NLS-1$
    hostsModel.setHashName("add_hosts");
    hostsModel.setClusterModel(clusterModel);
    hostsModel.getHosts().setItems(hostList);
    // $NON-NLS-1$
    UICommand command = new UICommand("OnSaveHosts", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    hostsModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    hostsModel.getCommands().add(command);
}
#end_block

#method_before
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress(null);
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till then using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setVdsGroupId(hostsModel.getClusterModel().getClusterId());
        host.setpm_enabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(false);
        parameters.setRebootAfterInstallation(hostsModel.getClusterModel().getEnableOvirtService().getIsSelected());
        parametersList.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllCanDoPassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllCanDoPassed = isAllCanDoPassed && returnValueBase.getCanDoAction();
                if (!isAllCanDoPassed) {
                    break;
                }
            }
            if (isAllCanDoPassed) {
                cancel();
            }
        }
    }, null);
}
#method_after
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress(null);
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till then using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setVdsGroupId(hostsModel.getClusterModel().getClusterId());
        host.setpm_enabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(hostsModel.isConfigureFirewall());
        parameters.setRebootAfterInstallation(hostsModel.getClusterModel().getEnableOvirtService().getIsSelected());
        parametersList.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllCanDoPassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllCanDoPassed = isAllCanDoPassed && returnValueBase.getCanDoAction();
                if (!isAllCanDoPassed) {
                    break;
                }
            }
            if (isAllCanDoPassed) {
                cancel();
            }
        }
    }, null);
}
#end_block

#method_before
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    this.setSystemTreeSelectedItem(systemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    this.setSystemTreeSelectedItem(systemTreeSelectedItem);
    commonInitialize();
}
#end_block

#method_before
private void setRngAvailability() {
    TModel model = getModel();
    Set<VmRngDevice.Source> requiredRngSources = model.getSelectedCluster().getRequiredRngSources();
    model.getIsRngEnabled().setIsChangable(!requiredRngSources.isEmpty());
    model.getIsRngEnabled().setMessage(constants.rngNotSupportedByCluster());
    model.getRngPeriod().setIsChangable(!requiredRngSources.isEmpty());
    model.getRngPeriod().setMessage(constants.rngNotSupportedByCluster());
    model.getRngBytes().setIsChangable(!requiredRngSources.isEmpty());
    model.getRngBytes().setMessage(constants.rngNotSupportedByCluster());
    model.getRngSourceRandom().setIsChangable(requiredRngSources.contains(VmRngDevice.Source.RANDOM));
    model.getRngSourceRandom().setMessage(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.RANDOM.toString()));
    model.getRngSourceHwrng().setIsChangable(requiredRngSources.contains(VmRngDevice.Source.HWRNG));
    model.getRngSourceHwrng().setMessage(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.HWRNG.toString()));
}
#method_after
private void setRngAvailability() {
    TModel model = getModel();
    Set<VmRngDevice.Source> requiredRngSources = model.getSelectedCluster().getRequiredRngSources();
    boolean requiredRngSourcesEmpty = requiredRngSources.isEmpty();
    boolean randomSourceAvailable = requiredRngSources.contains(VmRngDevice.Source.RANDOM);
    boolean hwrngSourceAvailable = requiredRngSources.contains(VmRngDevice.Source.HWRNG);
    model.getIsRngEnabled().setIsChangable(!requiredRngSourcesEmpty);
    model.getRngPeriod().setIsChangable(!requiredRngSourcesEmpty);
    model.getRngBytes().setIsChangable(!requiredRngSourcesEmpty);
    if (requiredRngSourcesEmpty) {
        model.getIsRngEnabled().setMessage(constants.rngNotSupportedByCluster());
        model.getRngPeriod().setMessage(constants.rngNotSupportedByCluster());
        model.getRngBytes().setMessage(constants.rngNotSupportedByCluster());
    }
    model.getRngSourceRandom().setIsChangable(randomSourceAvailable);
    if (randomSourceAvailable) {
        model.getRngSourceRandom().setMessage(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.RANDOM.toString()));
    }
    model.getRngSourceHwrng().setIsChangable(hwrngSourceAvailable);
    if (hwrngSourceAvailable) {
        model.getRngSourceHwrng().setMessage(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.HWRNG.toString()));
    }
}
#end_block

#method_before
protected List<VmTemplate> filterNotBaseTemplates(List<VmTemplate> templates) {
    List<VmTemplate> baseTemplates = new ArrayList<VmTemplate>();
    for (VmTemplate template : templates) {
        if (template.getId().equals(template.getBaseTemplateId())) {
            baseTemplates.add(template);
            baseTemplateToSubTemplates.put(template.getId(), new ArrayList<VmTemplate>());
        }
    }
    for (VmTemplate template : templates) {
        Guid baseTemplateId = template.getBaseTemplateId();
        if (baseTemplateToSubTemplates.containsKey(baseTemplateId)) {
            baseTemplateToSubTemplates.get(baseTemplateId).add(template);
        }
    }
    for (List<VmTemplate> subversions : (Collection<List<VmTemplate>>) baseTemplateToSubTemplates.values()) {
        Collections.sort(subversions, new Comparator<VmTemplate>() {

            @Override
            public int compare(VmTemplate o1, VmTemplate o2) {
                return o2.getTemplateVersionNumber() - o1.getTemplateVersionNumber();
            }
        });
    }
    for (List<VmTemplate> subversions : baseTemplateToSubTemplates.values()) {
        subversions.add(0, createLatestTemplate(subversions.get(0)));
    }
    return baseTemplates;
}
#method_after
protected List<VmTemplate> filterNotBaseTemplates(List<VmTemplate> templates) {
    List<VmTemplate> baseTemplates = new ArrayList<VmTemplate>();
    for (VmTemplate template : templates) {
        if (template.getId().equals(template.getBaseTemplateId())) {
            baseTemplates.add(template);
            baseTemplateToSubTemplates.put(template.getId(), new ArrayList<VmTemplate>());
        }
    }
    for (VmTemplate template : templates) {
        Guid baseTemplateId = template.getBaseTemplateId();
        if (baseTemplateToSubTemplates.containsKey(baseTemplateId)) {
            baseTemplateToSubTemplates.get(baseTemplateId).add(template);
        }
    }
    for (List<VmTemplate> subversions : baseTemplateToSubTemplates.values()) {
        Collections.sort(subversions, new Comparator<VmTemplate>() {

            @Override
            public int compare(VmTemplate o1, VmTemplate o2) {
                return o2.getTemplateVersionNumber() - o1.getTemplateVersionNumber();
            }
        });
    }
    for (List<VmTemplate> subversions : baseTemplateToSubTemplates.values()) {
        subversions.add(0, createLatestTemplate(subversions.get(0)));
    }
    return baseTemplates;
}
#end_block

#method_before
private void doUpdateTimeZone(final String selectedTimeZone) {
    final Collection<TimeZoneModel> timeZones = TimeZoneModel.getTimeZones(getTimeZoneType());
    getModel().getTimeZone().setItems(timeZones);
    getModel().getTimeZone().setSelectedItem(Linq.firstOrDefault(timeZones, new Linq.TimeZonePredicate(selectedTimeZone)));
    getModel().getTimeZone().setChangeProhibitionReason(constants.timeZoneNotChangeableForLinuxVms());
    getModel().getTimeZone().setIsChangable(!getModel().getIsLinuxOS());
}
#method_after
private void doUpdateTimeZone(final String selectedTimeZone) {
    final Collection<TimeZoneModel> timeZones = TimeZoneModel.getTimeZones(getTimeZoneType());
    getModel().getTimeZone().setItems(timeZones);
    getModel().getTimeZone().setSelectedItem(Linq.firstOrDefault(timeZones, new Linq.TimeZonePredicate(selectedTimeZone)));
}
#end_block

#method_before
protected void initPriority(int priority) {
    AsyncDataProvider.getMaxVmPriority(new AsyncQuery(new Object[] { getModel(), priority }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            UnitVmModel model = (UnitVmModel) array[0];
            int vmPriority = (Integer) array[1];
            cachedMaxPriority = (Integer) returnValue;
            int value = AsyncDataProvider.getRoundedPriority(vmPriority, cachedMaxPriority);
            EntityModel tempVar = new EntityModel();
            tempVar.setEntity(value);
            model.getPriority().setSelectedItem(tempVar);
            updatePriority();
        }
    }, getModel().getHash()));
}
#method_after
protected void initPriority(int priority) {
    priorityUtil.initPriority(priority);
}
#end_block

#method_before
protected void updateCustomPropertySheet() {
    if (getModel().getSelectedCluster() == null) {
        return;
    }
    VDSGroup cluster = getModel().getSelectedCluster();
    getModel().getCustomPropertySheet().setKeyValueString(getModel().getCustomPropertiesKeysList().get(cluster.getcompatibility_version()));
}
#method_after
protected void updateCustomPropertySheet() {
    if (getModel().getSelectedCluster() == null) {
        return;
    }
    VDSGroup cluster = getModel().getSelectedCluster();
    updateCustomPropertySheet(cluster.getcompatibility_version());
}
#end_block

#method_before
protected void updateCustomPropertySheet() {
    if (getModel().getSelectedCluster() == null) {
        return;
    }
    VDSGroup cluster = getModel().getSelectedCluster();
    getModel().getCustomPropertySheet().setKeyValueString(getModel().getCustomPropertiesKeysList().get(cluster.getcompatibility_version()));
}
#method_after
protected void updateCustomPropertySheet(Version clusterVersion) {
    getModel().getCustomPropertySheet().setKeyValueString(getModel().getCustomPropertiesKeysList().get(clusterVersion));
}
#end_block

#method_before
public void updateMaxNumOfVmCpus() {
    VDSGroup cluster = getModel().getSelectedCluster();
    String version = cluster.getcompatibility_version().toString();
    AsyncDataProvider.getMaxNumOfVmCpus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            behavior.maxCpus = (Integer) returnValue;
            behavior.postUpdateNumOfSockets2();
        }
    }, getModel().getHash()), version);
}
#method_after
public void updateMaxNumOfVmCpus() {
    String version = getClusterCompatibilityVersion().toString();
    AsyncDataProvider.getMaxNumOfVmCpus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            behavior.maxCpus = (Integer) returnValue;
            behavior.postUpdateNumOfSockets2();
        }
    }, getModel().getHash()), version);
}
#end_block

#method_before
public void postUpdateNumOfSockets2() {
    VDSGroup cluster = getModel().getSelectedCluster();
    String version = cluster.getcompatibility_version().toString();
    AsyncDataProvider.getMaxNumOfCPUsPerSocket(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            behavior.maxCpusPerSocket = (Integer) returnValue;
            behavior.totalCpuCoresChanged();
        }
    }, getModel().getHash()), version);
}
#method_after
public void postUpdateNumOfSockets2() {
    String version = getClusterCompatibilityVersion().toString();
    AsyncDataProvider.getMaxNumOfCPUsPerSocket(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            behavior.maxCpusPerSocket = (Integer) returnValue;
            behavior.totalCpuCoresChanged();
        }
    }, getModel().getHash()), version);
}
#end_block

#method_before
protected void updateQuotaByCluster(final Guid defaultQuota, final String quotaName) {
    if (getModel().getQuota().getIsAvailable()) {
        VDSGroup cluster = getModel().getSelectedCluster();
        if (cluster == null) {
            return;
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForVdsGroup, new IdQueryParameters(cluster.getId()), new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                UnitVmModel vmModel = (UnitVmModel) model;
                ArrayList<Quota> quotaList = ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (quotaList != null && !quotaList.isEmpty()) {
                    vmModel.getQuota().setItems(quotaList);
                }
                if (defaultQuota != null && !Guid.Empty.equals(defaultQuota)) {
                    boolean hasQuotaInList = false;
                    for (Quota quota : quotaList) {
                        if (quota.getId().equals(defaultQuota)) {
                            vmModel.getQuota().setSelectedItem(quota);
                            hasQuotaInList = true;
                            break;
                        }
                    }
                    // Add the quota to the list only in edit mode
                    if (!hasQuotaInList && !getModel().getIsNew()) {
                        Quota quota = new Quota();
                        quota.setId(defaultQuota);
                        quota.setQuotaName(quotaName);
                        quotaList.add(quota);
                        vmModel.getQuota().setItems(quotaList);
                        vmModel.getQuota().setSelectedItem(quota);
                    }
                }
            }
        }));
    }
}
#method_after
protected void updateQuotaByCluster(final Guid defaultQuota, final String quotaName) {
    if (getModel().getQuota().getIsAvailable()) {
        VDSGroup cluster = getModel().getSelectedCluster();
        if (cluster == null) {
            return;
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForVdsGroup, new IdQueryParameters(cluster.getId()), new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                UnitVmModel vmModel = (UnitVmModel) model;
                ArrayList<Quota> quotaList = ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (quotaList != null && !quotaList.isEmpty()) {
                    vmModel.getQuota().setItems(quotaList);
                }
                if (quotaList != null && defaultQuota != null && !Guid.Empty.equals(defaultQuota)) {
                    boolean hasQuotaInList = false;
                    for (Quota quota : quotaList) {
                        if (quota.getId().equals(defaultQuota)) {
                            vmModel.getQuota().setSelectedItem(quota);
                            hasQuotaInList = true;
                            break;
                        }
                    }
                    // Add the quota to the list only in edit mode
                    if (!hasQuotaInList && !getModel().getIsNew()) {
                        Quota quota = new Quota();
                        quota.setId(defaultQuota);
                        quota.setQuotaName(quotaName);
                        quotaList.add(quota);
                        vmModel.getQuota().setItems(quotaList);
                        vmModel.getQuota().setSelectedItem(quota);
                    }
                }
            }
        }));
    }
}
#end_block

#method_before
protected void updateMemoryBalloon() {
    if (getModel().getSelectedCluster() != null) {
        VDSGroup cluster = getModel().getSelectedCluster();
        boolean hasMemoryBalloon = cluster.getcompatibility_version().compareTo(VmListModel.BALLOON_DEVICE_MIN_VERSION) >= 0;
        getModel().getMemoryBalloonDeviceEnabled().setIsAvailable(hasMemoryBalloon);
    }
}
#method_after
protected void updateMemoryBalloon() {
    if (getModel().getSelectedCluster() != null) {
        updateMemoryBalloon(getModel().getSelectedCluster().getcompatibility_version());
    }
}
#end_block

#method_before
protected void updateMemoryBalloon() {
    if (getModel().getSelectedCluster() != null) {
        VDSGroup cluster = getModel().getSelectedCluster();
        boolean hasMemoryBalloon = cluster.getcompatibility_version().compareTo(VmListModel.BALLOON_DEVICE_MIN_VERSION) >= 0;
        getModel().getMemoryBalloonDeviceEnabled().setIsAvailable(hasMemoryBalloon);
    }
}
#method_after
protected void updateMemoryBalloon(Version clusterVersion) {
    boolean hasMemoryBalloon = clusterVersion.compareTo(VmListModel.BALLOON_DEVICE_MIN_VERSION) >= 0;
    getModel().getMemoryBalloonDeviceEnabled().setIsAvailable(hasMemoryBalloon);
}
#end_block

#method_before
public void updateUseHostCpuAvailability() {
    boolean clusterSupportsHostCpu = getModel().getSelectedCluster() != null && (getModel().getSelectedCluster()).getcompatibility_version().compareTo(Version.v3_2) >= 0;
    boolean nonMigratable = MigrationSupport.PINNED_TO_HOST == getModel().getMigrationMode().getSelectedItem();
    boolean manuallyMigratableAndAnyHostInCluster = MigrationSupport.IMPLICITLY_NON_MIGRATABLE == getModel().getMigrationMode().getSelectedItem() && Boolean.TRUE.equals(getModel().getIsAutoAssign().getEntity());
    if (clusterSupportsHostCpu && (nonMigratable || manuallyMigratableAndAnyHostInCluster)) {
        getModel().getHostCpu().setIsChangable(true);
    } else {
        getModel().getHostCpu().setEntity(false);
        getModel().getHostCpu().setChangeProhibitionReason(constants.hosCPUUnavailable());
        getModel().getHostCpu().setIsChangable(false);
    }
}
#method_after
public void updateUseHostCpuAvailability() {
    boolean clusterSupportsHostCpu = getClusterCompatibilityVersion() != null && (getClusterCompatibilityVersion().compareTo(Version.v3_2) >= 0);
    boolean nonMigratable = MigrationSupport.PINNED_TO_HOST == getModel().getMigrationMode().getSelectedItem();
    boolean manuallyMigratableAndAnyHostInCluster = MigrationSupport.IMPLICITLY_NON_MIGRATABLE == getModel().getMigrationMode().getSelectedItem() && Boolean.TRUE.equals(getModel().getIsAutoAssign().getEntity());
    if (clusterSupportsHostCpu && (nonMigratable || manuallyMigratableAndAnyHostInCluster)) {
        getModel().getHostCpu().setIsChangable(true);
    } else {
        getModel().getHostCpu().setEntity(false);
        getModel().getHostCpu().setChangeProhibitionReason(constants.hosCPUUnavailable());
        getModel().getHostCpu().setIsChangable(false);
    }
}
#end_block

#method_before
public void numOfSocketChanged() {
    int numOfSockets = extractIntFromListModel(getModel().getNumOfSockets());
    int totalCpuCores = getTotalCpuCores();
    if (numOfSockets == 0 || numOfSockets == 0) {
        return;
    }
    getModel().getCoresPerSocket().setSelectedItem(totalCpuCores / numOfSockets);
}
#method_after
public void numOfSocketChanged() {
    int numOfSockets = extractIntFromListModel(getModel().getNumOfSockets());
    int totalCpuCores = getTotalCpuCores();
    if (numOfSockets == 0) {
        return;
    }
    getModel().getCoresPerSocket().setSelectedItem(totalCpuCores / numOfSockets);
}
#end_block

#method_before
protected void updateNumOfSockets() {
    VDSGroup cluster = getModel().getSelectedCluster();
    if (cluster == null) {
        return;
    }
    String version = cluster.getcompatibility_version().toString();
    AsyncDataProvider.getMaxNumOfVmSockets(new AsyncQuery(new Object[] { this, getModel() }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) array[0];
            behavior.maxNumOfSockets = ((Integer) returnValue);
            behavior.updataMaxVmsInPool();
        }
    }, getModel().getHash()), version);
}
#method_after
protected void updateNumOfSockets() {
    Version version = getClusterCompatibilityVersion();
    if (version == null) {
        return;
    }
    AsyncDataProvider.getMaxNumOfVmSockets(new AsyncQuery(new Object[] { this, getModel() }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) array[0];
            behavior.maxNumOfSockets = ((Integer) returnValue);
            behavior.updataMaxVmsInPool();
        }
    }, getModel().getHash()), version.toString());
}
#end_block

#method_before
protected void updateOSValues() {
    List<Integer> vmOsValues;
    VDSGroup cluster = getModel().getSelectedCluster();
    if (cluster != null) {
        vmOsValues = AsyncDataProvider.getOsIds(cluster.getArchitecture());
        getModel().getOSType().setItems(vmOsValues);
        postOsItemChanged();
    }
}
#method_after
protected void updateOSValues() {
    List<Integer> vmOsValues;
    VDSGroup cluster = getModel().getSelectedCluster();
    if (cluster != null) {
        vmOsValues = AsyncDataProvider.getOsIds(cluster.getArchitecture());
        Integer selectedOsId = getModel().getOSType().getSelectedItem();
        getModel().getOSType().setItems(vmOsValues);
        if (selectedOsId != null && vmOsValues.contains(selectedOsId)) {
            getModel().getOSType().setSelectedItem(selectedOsId);
        }
        postOsItemChanged();
    }
}
#end_block

#method_before
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            vmInitLoaded((VM) result);
        }
    };
    AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
}
#method_after
private void edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
    }
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(AsyncDataProvider.getCustomPropertiesList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("OnSave", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
private void runOnce() {
    VM vm = (VM) getSelectedItem();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel((VM) result, getCustomPropertiesKeysList().get(((VM) result).getVdsGroupCompatibilityVersion()), VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
}
#method_after
private void runOnce() {
    VM vm = (VM) getSelectedItem();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel((VM) result, VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
}
#end_block

#method_before
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        model.setIsValid(false);
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#method_after
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#end_block

#method_before
private void powerAction(String actionName, String title, String message) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, false);
    } else {
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null) {
                    powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
                }
            }
        }), clusterId);
    }
}
#end_block

#method_before
private void powerAction(String actionName, String title, String message) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void powerAction(String actionName, String title, String message, boolean reasonVisible) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    model.setReasonVisible(reasonVisible);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onShutdown() {
    onPowerAction(VdcActionType.ShutdownVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new ShutdownVmParameters(vm.getId(), true);
        }
    });
}
#method_after
private void onShutdown() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(VdcActionType.ShutdownVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new ShutdownVmParameters(vm.getId(), true, model.getReason().getEntity());
        }
    });
}
#end_block

#method_before
private void onStop() {
    onPowerAction(VdcActionType.StopVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL);
        }
    });
}
#method_after
private void onStop() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(VdcActionType.StopVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL, model.getReason().getEntity());
        }
    });
}
#end_block

#method_before
private void reboot() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(REBOOT, constants.rebootVirtualMachinesTitle(), constants.areYouSureYouWantToRebootTheFollowingVirtualMachinesMsg());
}
#method_after
private void reboot() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(REBOOT, constants.rebootVirtualMachinesTitle(), constants.areYouSureYouWantToRebootTheFollowingVirtualMachinesMsg(), false);
}
#end_block

#method_before
private void changeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                _attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    final VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem().toString(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem().toString();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            setRngDeviceToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VM vm = getcurrentVm();
                vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                VmManagementParametersBase params = new VmManagementParametersBase(vm);
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                setRngDeviceToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        Guid newClusterID = model.getSelectedCluster().getId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        setRngDeviceToParams(model, updateVmParams);
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            setRngDeviceToParams(model, updateVmParams);
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        final VM selectedItem = (VM) getSelectedItem();
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        getcurrentVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.isNextRunConfigurationChanged(editedVm, getcurrentVm(), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    if (((VdcQueryReturnValue) returnValue).<Boolean>getReturnValue()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(false);
                    }
                }
            }));
        } else {
            updateExistingVm(false);
        }
    }
}
#end_block

#method_before
private void setRngDeviceToParams(UnitVmModel model, VmManagementParametersBase parameters) {
    parameters.setUpdateRngDevice(true);
    boolean rngEnabledAndValid = (Boolean) model.getIsRngEnabled().getEntity() && !model.getSelectedCluster().getRequiredRngSources().isEmpty();
    parameters.setRngDevice(rngEnabledAndValid ? model.generateRngDevice() : null);
}
#method_after
private void setRngDeviceToParams(UnitVmModel model, VmManagementParametersBase parameters) {
    parameters.setUpdateRngDevice(true);
    parameters.setRngDevice(model.getIsRngEnabled().getEntity() ? model.generateRngDevice() : null);
}
#end_block

#method_before
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#method_after
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm) && AsyncDataProvider.canVmsBePaused(items));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnClone".equals(command.getName())) {
        onClone();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(model.getApplyCpuLater().getEntity());
        cancelConfirmation();
    }
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setArchitecture(new ListModel<ArchitectureType>());
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setArchitecture(new ListModel<ArchitectureType>());
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if (senderEntityModel == getSpiceProxyEnabled()) {
            getSpiceProxy().setIsChangable(getSpiceProxyEnabled().getEntity());
        } else if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        } else if (sender == getCPU()) {
            CPU_SelectedItemChanged(args);
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if (senderEntityModel == getSpiceProxyEnabled()) {
            getSpiceProxy().setIsChangable(getSpiceProxyEnabled().getEntity());
        } else if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    setRngSourcesCheckboxes(version);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    setRngSourcesCheckboxes(version);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
}
#end_block

#method_before
private void setRngSourcesCheckboxes(Version ver) {
    boolean rngSupported = isRngSupportedForClusterVersion(ver);
    getRngRandomSourceRequired().setIsAvailable(rngSupported);
    getRngHwrngSourceRequired().setIsAvailable(rngSupported);
    String defaultRequiredRngSourcesCsv = defaultClusterRngSourcesCsv(ver);
    if (rngSupported) {
        getRngRandomSourceRequired().setEntity(getIsNew() ? defaultRequiredRngSourcesCsv.contains(VmRngDevice.Source.RANDOM.toString()) : getEntity().getRequiredRngSources().contains(VmRngDevice.Source.RANDOM));
        getRngHwrngSourceRequired().setEntity(getIsNew() ? defaultRequiredRngSourcesCsv.contains(VmRngDevice.Source.HWRNG.toString()) : getEntity().getRequiredRngSources().contains(VmRngDevice.Source.HWRNG));
    } else {
        // reset
        getRngRandomSourceRequired().setEntity(false);
        getRngHwrngSourceRequired().setEntity(false);
    }
}
#method_after
private void setRngSourcesCheckboxes(Version ver) {
    boolean rngSupported = isRngSupportedForClusterVersion(ver);
    getRngRandomSourceRequired().setIsChangable(rngSupported);
    getRngHwrngSourceRequired().setIsChangable(rngSupported);
    String defaultRequiredRngSourcesCsv = defaultClusterRngSourcesCsv(ver);
    if (rngSupported) {
        getRngRandomSourceRequired().setEntity(getIsNew() ? defaultRequiredRngSourcesCsv.contains(VmRngDevice.Source.RANDOM.toString()) : getEntity().getRequiredRngSources().contains(VmRngDevice.Source.RANDOM));
        getRngHwrngSourceRequired().setEntity(getIsNew() ? defaultRequiredRngSourcesCsv.contains(VmRngDevice.Source.HWRNG.toString()) : getEntity().getRequiredRngSources().contains(VmRngDevice.Source.HWRNG));
    } else {
        // reset
        getRngRandomSourceRequired().setEntity(false);
        getRngHwrngSourceRequired().setEntity(false);
        getRngRandomSourceRequired().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().rngNotSupportedByClusterCV());
        getRngHwrngSourceRequired().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().rngNotSupportedByClusterCV());
    }
}
#end_block

#method_before
private void populateCPUList(ClusterModel clusterModel, List<ServerCpu> cpus, boolean canChangeArchitecture) {
    ServerCpu oldSelectedCpu = clusterModel.getCPU().getSelectedItem();
    clusterModel.getCPU().setItems(cpus);
    clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.firstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
    if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
        initCPU();
    }
    if (clusterModel.getIsEdit()) {
        if (canChangeArchitecture) {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(ArchitectureType.values())));
        } else {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(clusterModel.getEntity().getArchitecture())));
        }
        ArchitectureType oldSelectedArch = (ArchitectureType) clusterModel.getArchitecture().getSelectedItem();
        if (oldSelectedArch != null) {
            getArchitecture().setSelectedItem(oldSelectedArch);
        } else {
            getArchitecture().setSelectedItem(getEntity().getArchitecture());
        }
    } else {
        getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(ArchitectureType.values())));
        getArchitecture().setSelectedItem(ArchitectureType.undefined);
    }
}
#method_after
private void populateCPUList(ClusterModel clusterModel, List<ServerCpu> cpus, boolean canChangeArchitecture) {
    ServerCpu oldSelectedCpu = clusterModel.getCPU().getSelectedItem();
    clusterModel.getCPU().setItems(cpus);
    initSupportedArchitectures(clusterModel);
    clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.firstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
    if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
        initCPU();
    }
    if (clusterModel.getIsEdit()) {
        if (!canChangeArchitecture) {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(clusterModel.getEntity().getArchitecture())));
        }
        ArchitectureType oldSelectedArch = clusterModel.getArchitecture().getSelectedItem();
        if (oldSelectedArch != null) {
            getArchitecture().setSelectedItem(oldSelectedArch);
        } else {
            getArchitecture().setSelectedItem(getEntity().getArchitecture());
        }
    } else {
        getArchitecture().setSelectedItem(ArchitectureType.undefined);
    }
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
}
#end_block

#method_before
private void storagePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        return;
    }
    if (selectedDataCenter.isLocal()) {
        setIsResiliencePolicyTabAvailable(false);
    } else {
        setIsResiliencePolicyTabAvailable(true);
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            Version selectedVersion = clusterModel.getVersion().getSelectedItem();
            clusterModel.getVersion().setItems(versions);
            if (selectedVersion == null || !versions.contains(selectedVersion)) {
                clusterModel.getVersion().setSelectedItem(Linq.selectHighestVersion(versions));
            } else if (clusterModel.getIsEdit()) {
                clusterModel.getVersion().setSelectedItem(Linq.firstOrDefault(versions, new Linq.VersionPredicate(clusterModel.getEntity().getcompatibility_version())));
            } else {
                clusterModel.getVersion().setSelectedItem(selectedVersion);
            }
        }
    };
    AsyncDataProvider.getDataCenterVersions(_asyncQuery, selectedDataCenter.getId());
}
#method_after
private void storagePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    final StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        return;
    }
    if (selectedDataCenter.isLocal()) {
        setIsResiliencePolicyTabAvailable(false);
    } else {
        setIsResiliencePolicyTabAvailable(true);
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            Version selectedVersion = clusterModel.getVersion().getSelectedItem();
            clusterModel.getVersion().setItems(versions);
            if (selectedVersion == null || !versions.contains(selectedVersion) || selectedVersion.compareTo(selectedDataCenter.getcompatibility_version()) > 0) {
                if (ApplicationModeHelper.getUiMode().equals(ApplicationMode.GlusterOnly)) {
                    clusterModel.getVersion().setSelectedItem(Linq.selectHighestVersion(versions));
                } else {
                    clusterModel.getVersion().setSelectedItem(selectedDataCenter.getcompatibility_version());
                }
            } else if (clusterModel.getIsEdit()) {
                clusterModel.getVersion().setSelectedItem(Linq.firstOrDefault(versions, new Linq.VersionPredicate(clusterModel.getEntity().getcompatibility_version())));
            } else {
                clusterModel.getVersion().setSelectedItem(selectedVersion);
            }
        }
    };
    AsyncDataProvider.getDataCenterVersions(_asyncQuery, selectedDataCenter.getId());
}
#end_block

#method_before
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validateRngRequiredSource();
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    boolean generalTabValid = getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true);
    setIsGeneralTabValid(generalTabValid);
    return generalTabValid && getCustomPropertySheet().getIsValid();
}
#method_after
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validateRngRequiredSource();
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    boolean generalTabValid = getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getRngRandomSourceRequired().getIsValid() && getRngHwrngSourceRequired().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && isFingerprintVerified()) : true);
    setIsGeneralTabValid(generalTabValid);
    return generalTabValid && getCustomPropertySheet().getIsValid();
}
#end_block

#method_before
private void validateRngRequiredSource() {
    Version cluVersion = (Version) getVersion().getSelectedItem();
    boolean rngSupportedForCluster = isRngSupportedForClusterVersion(cluVersion);
    getRngRandomSourceRequired().setIsValid(rngSupportedForCluster);
    getRngHwrngSourceRequired().setIsValid(rngSupportedForCluster);
}
#method_after
private void validateRngRequiredSource() {
    Version clusterVersion = getVersion().getSelectedItem();
    boolean rngSupportedForCluster = isRngSupportedForClusterVersion(clusterVersion);
    getRngRandomSourceRequired().setIsValid(rngSupportedForCluster || !getRngRandomSourceRequired().getEntity());
    getRngHwrngSourceRequired().setIsValid(rngSupportedForCluster || !getRngHwrngSourceRequired().getEntity());
}
#end_block

#method_before
private boolean isRngSupportedForClusterVersion(Version ver) {
    if (ver == null) {
        return false;
    }
    Boolean supported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VirtIoRngDeviceSupported, ver.toString());
    return (supported == null) ? false : supported;
}
#method_after
private boolean isRngSupportedForClusterVersion(Version version) {
    if (version == null) {
        return false;
    }
    Boolean supported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VirtIoRngDeviceSupported, version.toString());
    return (supported == null) ? false : supported;
}
#end_block

#method_before
protected void connectAllHostsToStorage(List<String> connectionIds) {
    final List<StorageServerConnections> connections = getDbFacade().getStorageServerConnectionDao().getByIds(connectionIds);
    List<VDS> hosts = getVdsDAO().getAllForStoragePoolAndStatus(getIscsiBond().getStoragePoolId(), VDSStatus.Up);
    for (final VDS host : hosts) {
        try {
            final List<StorageServerConnections> conns = ISCSIStorageHelper.updateIfaces(connections, host.getId());
            runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(host.getId(), Guid.Empty, StorageType.ISCSI, conns));
        } catch (VdcBLLException e) {
            log.errorFormat("Could not connect Host {0} - {1} to Iscsi Storage Server. The exception is: {2}", host.getName(), host.getId(), e);
        }
    }
}
#method_after
protected void connectAllHostsToStorage(List<String> connectionIds) {
    List<Callable<Void>> tasks = new ArrayList<>();
    final List<StorageServerConnections> connections = getDbFacade().getStorageServerConnectionDao().getByIds(connectionIds);
    List<VDS> hosts = getVdsDAO().getAllForStoragePoolAndStatus(getIscsiBond().getStoragePoolId(), VDSStatus.Up);
    for (final VDS host : hosts) {
        tasks.add(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                try {
                    final List<StorageServerConnections> conns = ISCSIStorageHelper.updateIfaces(connections, host.getId());
                    runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(host.getId(), Guid.Empty, StorageType.ISCSI, conns));
                } catch (VdcBLLException e) {
                    log.errorFormat("Could not connect Host {0} - {1} to Iscsi Storage Server. The exception is: {2}", host.getName(), host.getId(), e);
                }
                return null;
            }
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#end_block

#method_before
private void onProviderChosen() {
    final Provider provider = (Provider) providers.getSelectedItem();
    if (provider == null) {
        return;
    }
    final List<StoragePool> dataCenters = new LinkedList<StoragePool>();
    final AsyncQuery networkQuery = new AsyncQuery();
    networkQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<Network, Set<Guid>> externalNetworkToDataCenters = (Map<Network, Set<Guid>>) returnValue;
            List<ExternalNetwork> items = new LinkedList<ExternalNetwork>();
            for (Map.Entry<Network, Set<Guid>> entry : externalNetworkToDataCenters.entrySet()) {
                Network network = entry.getKey();
                Set<Guid> attachedDataCenters = entry.getValue();
                ExternalNetwork externalNetwork = new ExternalNetwork();
                externalNetwork.setNetwork(network);
                externalNetwork.setDisplayName(network.getName());
                externalNetwork.setPublicUse(true);
                List<StoragePool> availableDataCenters = new LinkedList<StoragePool>();
                for (StoragePool dc : dataCenters) {
                    if (!attachedDataCenters.contains(dc.getId())) {
                        availableDataCenters.add(dc);
                    }
                }
                externalNetwork.getDataCenters().setItems(availableDataCenters);
                externalNetwork.getDataCenters().setSelectedItem(Linq.firstOrDefault(availableDataCenters));
                items.add(externalNetwork);
            }
            Collections.sort(items, new Linq.ExternalNetworkComparator());
            providerNetworks.setItems(items);
            importedNetworks.setItems(new LinkedList<ExternalNetwork>());
            stopProgress();
        }
    };
    final AsyncQuery dcQuery = new AsyncQuery();
    dcQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            dataCenters.addAll((Collection<StoragePool>) returnValue);
            Collections.sort(dataCenters, new NameableComparator());
            AsyncDataProvider.getExternalNetworkMap(networkQuery, provider.getId());
        }
    };
    startProgress(null);
    AsyncDataProvider.getDataCenterList(dcQuery);
}
#method_after
private void onProviderChosen() {
    final Provider provider = (Provider) providers.getSelectedItem();
    if (provider == null) {
        return;
    }
    final List<StoragePool> dataCenters = new LinkedList<StoragePool>();
    final AsyncQuery networkQuery = new AsyncQuery();
    networkQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<Network, Set<Guid>> externalNetworkToDataCenters = (Map<Network, Set<Guid>>) returnValue;
            List<ExternalNetwork> items = new LinkedList<ExternalNetwork>();
            for (Map.Entry<Network, Set<Guid>> entry : externalNetworkToDataCenters.entrySet()) {
                Network network = entry.getKey();
                Set<Guid> attachedDataCenters = entry.getValue();
                ExternalNetwork externalNetwork = new ExternalNetwork();
                externalNetwork.setNetwork(network);
                externalNetwork.setDisplayName(network.getName());
                externalNetwork.setPublicUse(true);
                List<StoragePool> availableDataCenters = new LinkedList<StoragePool>();
                for (StoragePool dc : dataCenters) {
                    if (!attachedDataCenters.contains(dc.getId())) {
                        availableDataCenters.add(dc);
                    }
                }
                externalNetwork.getDataCenters().setItems(availableDataCenters);
                externalNetwork.getDataCenters().setSelectedItem(treeSelectedDc != null && availableDataCenters.contains(treeSelectedDc) ? treeSelectedDc : Linq.firstOrDefault(availableDataCenters));
                items.add(externalNetwork);
            }
            Collections.sort(items, new Linq.ExternalNetworkComparator());
            providerNetworks.setItems(items);
            importedNetworks.setItems(new LinkedList<ExternalNetwork>());
            stopProgress();
        }
    };
    final AsyncQuery dcQuery = new AsyncQuery();
    dcQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            dataCenters.addAll((Collection<StoragePool>) returnValue);
            Collections.sort(dataCenters, new NameableComparator());
            AsyncDataProvider.getExternalNetworkMap(networkQuery, provider.getId());
        }
    };
    startProgress(null);
    AsyncDataProvider.getDataCenterList(dcQuery);
}
#end_block

#method_before
private void fetchDcClusters(final Guid dcId, final Network network, final boolean publicUse) {
    if (dcClusters.containsKey(dcId)) {
        attachNetworkToClusters(network, dcClusters.get(dcId), publicUse);
    } else {
        AsyncDataProvider.getClusterList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                Collection<VDSGroup> clusters = (Collection<VDSGroup>) returnValue;
                dcClusters.put(dcId, clusters);
                attachNetworkToClusters(network, clusters, publicUse);
            }
        }), dcId);
    }
}
#method_after
private void fetchDcClusters(final Guid dcId, final Network network, final boolean publicUse) {
    if (dcClusters.containsKey(dcId)) {
        attachNetworkToClusters(network, dcClusters.get(dcId), publicUse);
    } else {
        AsyncDataProvider.getClusterList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                Collection<VDSGroup> clusters = Linq.where((Collection<VDSGroup>) returnValue, new IPredicate<VDSGroup>() {

                    @Override
                    public boolean match(VDSGroup source) {
                        return (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.SupportCustomDeviceProperties, source.getcompatibility_version().getValue());
                    }
                });
                dcClusters.put(dcId, clusters);
                attachNetworkToClusters(network, clusters, publicUse);
            }
        }), dcId);
    }
}
#end_block

#method_before
public void runMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state) {
    runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, false, null);
}
#method_after
public void runMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state) {
    runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, false);
}
#end_block

#method_before
public void runMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state, boolean aggregateErrors) {
    runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, aggregateErrors, aggregateErrors ? new ArrayList<String>() : null);
}
#method_after
public void runMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state, boolean aggregateErrors) {
    runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, aggregateErrors, aggregateErrors ? new ArrayList<VdcActionType>() : null, aggregateErrors ? new ArrayList<VdcReturnValueBase>() : null);
}
#end_block

#method_before
private void runMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state, final boolean aggregateErrors, final List<String> errorMessages) {
    if (actionTypes.isEmpty() || parameters.isEmpty() || callbacks.isEmpty()) {
        if (aggregateErrors && errorMessages != null && !errorMessages.isEmpty()) {
            failureEventHandler(null, errorMessages);
        }
        return;
    }
    runAction(actionTypes.get(0), parameters.get(0), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(final FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success || failureCallback == null) {
                IFrontendActionAsyncCallback callback = callbacks.get(0);
                if (callback != null) {
                    callback.executed(result);
                }
                actionTypes.remove(0);
                parameters.remove(0);
                callbacks.remove(0);
                if (aggregateErrors && returnValue != null && !returnValue.getSucceeded()) {
                    errorMessages.addAll(returnValue.getCanDoActionMessages());
                }
                runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, aggregateErrors, errorMessages);
            } else {
                failureCallback.executed(result);
            }
        }
    }, state, !aggregateErrors);
}
#method_after
private void runMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state, final boolean aggregateErrors, final List<VdcActionType> failedActions, final List<VdcReturnValueBase> failedReturnValues) {
    if (actionTypes.isEmpty() || parameters.isEmpty() || callbacks.isEmpty()) {
        if (aggregateErrors && failedReturnValues != null && !failedReturnValues.isEmpty()) {
            getEventsHandler().runMultipleActionsFailed(failedActions, failedReturnValues);
        }
        return;
    }
    runAction(actionTypes.get(0), parameters.get(0), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(final FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success || failureCallback == null) {
                IFrontendActionAsyncCallback callback = callbacks.get(0);
                if (callback != null) {
                    callback.executed(result);
                }
                if (aggregateErrors && returnValue != null && (!returnValue.getCanDoAction() || !returnValue.getSucceeded())) {
                    failedActions.add(actionTypes.get(0));
                    failedReturnValues.add(returnValue);
                }
                actionTypes.remove(0);
                parameters.remove(0);
                callbacks.remove(0);
                runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, aggregateErrors, failedActions, failedReturnValues);
            } else {
                failureCallback.executed(result);
            }
        }
    }, state, !aggregateErrors);
}
#end_block

#method_before
void handleActionResult(final VdcActionType actionType, final VdcActionParametersBase parameters, final VdcReturnValueBase result, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    // $NON-NLS-1$
    logger.log(Level.FINER, "Retrieved action result from RunAction.");
    FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, result, state);
    boolean success = false;
    if (!result.getCanDoAction()) {
        result.setCanDoActionMessages((ArrayList<String>) translateError(result));
        callback.executed(f);
    } else if (showErrorDialog && result.getIsSyncronious() && !result.getSucceeded()) {
        runActionExecutionFailed(actionType, result.getFault());
        callback.executed(f);
        // Prevent another (untranslated) error message pop-up display
        // ('runActionExecutionFailed' invokes an error pop-up displaying,
        // therefore calling 'failureEventHandler' is redundant)
        success = true;
    } else {
        success = true;
        callback.executed(f);
    }
    if (showErrorDialog && (!success) && (getEventsHandler() != null) && (getEventsHandler().isRaiseErrorModalPanel(actionType, result.getFault()))) {
        if (result.getCanDoActionMessages().size() <= 1) {
            String errorMessage = !result.getCanDoAction() || !result.getCanDoActionMessages().isEmpty() ? getRunActionErrorMessage(result.getCanDoActionMessages()) : result.getFault().getMessage();
            failureEventHandler(result.getDescription(), errorMessage);
        } else {
            failureEventHandler(result.getDescription(), result.getCanDoActionMessages());
        }
    }
}
#method_after
void handleActionResult(final VdcActionType actionType, final VdcActionParametersBase parameters, final VdcReturnValueBase result, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    // $NON-NLS-1$
    logger.log(Level.FINER, "Retrieved action result from RunAction.");
    FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, result, state);
    boolean failedOnCanDoAction = !result.getCanDoAction();
    if (failedOnCanDoAction) {
        result.setCanDoActionMessages((ArrayList<String>) translateError(result));
    } else if (!result.getSucceeded()) {
        VdcFault fault = result.getFault();
        fault.setMessage(translateVdcFault(fault));
        if (showErrorDialog && result.getIsSyncronious() && getEventsHandler() != null) {
            getEventsHandler().runActionExecutionFailed(actionType, fault);
        }
    }
    callback.executed(f);
    // only needed for canDoAction failure
    if (showErrorDialog && failedOnCanDoAction && (getEventsHandler() != null) && (getEventsHandler().isRaiseErrorModalPanel(actionType, result.getFault()))) {
        ArrayList<String> messages = result.getCanDoActionMessages();
        failureEventHandler(result.getDescription(), // $NON-NLS-1$
        messages.isEmpty() ? Collections.singletonList(getConstants().noCanDoActionMessage()) : messages);
    }
}
#end_block

#method_before
private void failureEventHandler(final Throwable caught) {
    String errorMessage;
    if (caught instanceof StatusCodeException) {
        errorMessage = // $NON-NLS-1$
        getConstants().requestToServerFailedWithCode() + ": " + ((StatusCodeException) caught).getStatusCode();
    } else {
        errorMessage = getConstants().requestToServerFailed() + ": " + // $NON-NLS-1$
        caught.getLocalizedMessage();
    }
    failureEventHandler(errorMessage);
}
#method_after
private void failureEventHandler(final Throwable caught) {
    String errorMessage;
    if (caught instanceof StatusCodeException) {
        errorMessage = // $NON-NLS-1$
        getConstants().requestToServerFailedWithCode() + ": " + ((StatusCodeException) caught).getStatusCode();
    } else {
        errorMessage = getConstants().requestToServerFailed() + ": " + // $NON-NLS-1$
        caught.getLocalizedMessage();
    }
    failureEventHandler(null, Collections.singletonList(errorMessage));
}
#end_block

#method_before
private void failureEventHandler(final String description, final List<String> errorMessages) {
    ArrayList<Message> messages = new ArrayList<Message>();
    for (String errorMessage : errorMessages) {
        messages.add(new Message(description, errorMessage));
    }
    frontendFailureEvent.raise(Frontend.class, new FrontendFailureEventArgs(messages));
}
#method_after
private void failureEventHandler(final String description, final List<String> errorMessages) {
    ArrayList<Message> messages = new ArrayList<Message>();
    for (String errorMessage : errorMessages) {
        handleNotLoggedInEvent(errorMessage);
        messages.add(new Message(description, errorMessage));
    }
    frontendFailureEvent.raise(Frontend.class, new FrontendFailureEventArgs(messages));
}
#end_block

#method_before
public void runMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state) {
    runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, false, null);
}
#method_after
public void runMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state) {
    runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, false);
}
#end_block

#method_before
public void runMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state, boolean aggregateErrors) {
    runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, aggregateErrors, aggregateErrors ? new ArrayList<String>() : null);
}
#method_after
public void runMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state, boolean aggregateErrors) {
    runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, aggregateErrors, aggregateErrors ? new ArrayList<VdcActionType>() : null, aggregateErrors ? new ArrayList<VdcReturnValueBase>() : null);
}
#end_block

#method_before
private void runMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state, final boolean aggregateErrors, final List<String> errorMessages) {
    if (actionTypes.isEmpty() || parameters.isEmpty() || callbacks.isEmpty()) {
        if (aggregateErrors && errorMessages != null && !errorMessages.isEmpty()) {
            failureEventHandler(null, errorMessages);
        }
        return;
    }
    runAction(actionTypes.get(0), parameters.get(0), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(final FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success || failureCallback == null) {
                IFrontendActionAsyncCallback callback = callbacks.get(0);
                if (callback != null) {
                    callback.executed(result);
                }
                actionTypes.remove(0);
                parameters.remove(0);
                callbacks.remove(0);
                if (aggregateErrors && returnValue != null && !returnValue.getSucceeded()) {
                    errorMessages.addAll(returnValue.getCanDoActionMessages());
                }
                runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, aggregateErrors, errorMessages);
            } else {
                failureCallback.executed(result);
            }
        }
    }, state, !aggregateErrors);
}
#method_after
private void runMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state, final boolean aggregateErrors, final List<VdcActionType> failedActions, final List<VdcReturnValueBase> failedReturnValues) {
    if (actionTypes.isEmpty() || parameters.isEmpty() || callbacks.isEmpty()) {
        if (aggregateErrors && failedReturnValues != null && !failedReturnValues.isEmpty()) {
            getEventsHandler().runMultipleActionsFailed(failedActions, failedReturnValues);
        }
        return;
    }
    runAction(actionTypes.get(0), parameters.get(0), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(final FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success || failureCallback == null) {
                IFrontendActionAsyncCallback callback = callbacks.get(0);
                if (callback != null) {
                    callback.executed(result);
                }
                if (aggregateErrors && returnValue != null && (!returnValue.getCanDoAction() || !returnValue.getSucceeded())) {
                    failedActions.add(actionTypes.get(0));
                    failedReturnValues.add(returnValue);
                }
                actionTypes.remove(0);
                parameters.remove(0);
                callbacks.remove(0);
                runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, aggregateErrors, failedActions, failedReturnValues);
            } else {
                failureCallback.executed(result);
            }
        }
    }, state, !aggregateErrors);
}
#end_block

#method_before
void handleActionResult(final VdcActionType actionType, final VdcActionParametersBase parameters, final VdcReturnValueBase result, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    // $NON-NLS-1$
    logger.log(Level.FINER, "Retrieved action result from RunAction.");
    FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, result, state);
    boolean success = false;
    if (!result.getCanDoAction()) {
        result.setCanDoActionMessages((ArrayList<String>) translateError(result));
        callback.executed(f);
    } else if (showErrorDialog && result.getIsSyncronious() && !result.getSucceeded()) {
        runActionExecutionFailed(actionType, result.getFault());
        callback.executed(f);
        // Prevent another (untranslated) error message pop-up display
        // ('runActionExecutionFailed' invokes an error pop-up displaying,
        // therefore calling 'failureEventHandler' is redundant)
        success = true;
    } else {
        success = true;
        callback.executed(f);
    }
    if (showErrorDialog && (!success) && (getEventsHandler() != null) && (getEventsHandler().isRaiseErrorModalPanel(actionType, result.getFault()))) {
        if (result.getCanDoActionMessages().size() <= 1) {
            String errorMessage = !result.getCanDoAction() || !result.getCanDoActionMessages().isEmpty() ? getRunActionErrorMessage(result.getCanDoActionMessages()) : result.getFault().getMessage();
            failureEventHandler(result.getDescription(), errorMessage);
        } else {
            failureEventHandler(result.getDescription(), result.getCanDoActionMessages());
        }
    }
}
#method_after
void handleActionResult(final VdcActionType actionType, final VdcActionParametersBase parameters, final VdcReturnValueBase result, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    // $NON-NLS-1$
    logger.log(Level.FINER, "Retrieved action result from RunAction.");
    FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, result, state);
    boolean failedOnCanDoAction = !result.getCanDoAction();
    if (failedOnCanDoAction) {
        result.setCanDoActionMessages((ArrayList<String>) translateError(result));
    } else if (!result.getSucceeded()) {
        VdcFault fault = result.getFault();
        fault.setMessage(translateVdcFault(fault));
        if (showErrorDialog && result.getIsSyncronious() && getEventsHandler() != null) {
            getEventsHandler().runActionExecutionFailed(actionType, fault);
        }
    }
    callback.executed(f);
    // only needed for canDoAction failure
    if (showErrorDialog && failedOnCanDoAction && (getEventsHandler() != null) && (getEventsHandler().isRaiseErrorModalPanel(actionType, result.getFault()))) {
        ArrayList<String> messages = result.getCanDoActionMessages();
        failureEventHandler(result.getDescription(), // $NON-NLS-1$
        messages.isEmpty() ? Collections.singletonList(getConstants().noCanDoActionMessage()) : messages);
    }
}
#end_block

#method_before
private void failureEventHandler(final Throwable caught) {
    String errorMessage;
    if (caught instanceof StatusCodeException) {
        errorMessage = // $NON-NLS-1$
        getConstants().requestToServerFailedWithCode() + ": " + ((StatusCodeException) caught).getStatusCode();
    } else {
        errorMessage = getConstants().requestToServerFailed() + ": " + // $NON-NLS-1$
        caught.getLocalizedMessage();
    }
    failureEventHandler(errorMessage);
}
#method_after
private void failureEventHandler(final Throwable caught) {
    String errorMessage;
    if (caught instanceof StatusCodeException) {
        errorMessage = // $NON-NLS-1$
        getConstants().requestToServerFailedWithCode() + ": " + ((StatusCodeException) caught).getStatusCode();
    } else {
        errorMessage = getConstants().requestToServerFailed() + ": " + // $NON-NLS-1$
        caught.getLocalizedMessage();
    }
    failureEventHandler(null, Collections.singletonList(errorMessage));
}
#end_block

#method_before
private void failureEventHandler(final String description, final List<String> errorMessages) {
    ArrayList<Message> messages = new ArrayList<Message>();
    for (String errorMessage : errorMessages) {
        messages.add(new Message(description, errorMessage));
    }
    frontendFailureEvent.raise(Frontend.class, new FrontendFailureEventArgs(messages));
}
#method_after
private void failureEventHandler(final String description, final List<String> errorMessages) {
    ArrayList<Message> messages = new ArrayList<Message>();
    for (String errorMessage : errorMessages) {
        handleNotLoggedInEvent(errorMessage);
        messages.add(new Message(description, errorMessage));
    }
    frontendFailureEvent.raise(Frontend.class, new FrontendFailureEventArgs(messages));
}
#end_block

#method_before
protected boolean isDetachAllowed(final boolean isRemoveLast) {
    boolean returnValue = true;
    if (getStoragePoolIsoMap() == null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.STORAGE_DOMAIN_NOT_ATTACHED_TO_STORAGE_POOL);
    } else if (hasImages()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_STORAGE_DOMAIN_WITH_IMAGES);
    } else if (!isRemoveLast && isMaster()) {
        StorageDomain storage_domains = LinqUtils.firstOrNull(getStorageDomainDAO().getAllForStoragePool(getStorageDomain().getStoragePoolId()), new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain a) {
                return a.getId().equals(getStorageDomain().getId()) && a.getStatus() == StorageDomainStatus.Active;
            }
        });
        if (storage_domains == null) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_LAST_STORAGE_DOMAIN);
        }
    }
    return returnValue;
}
#method_after
protected boolean isDetachAllowed(final boolean isRemoveLast) {
    boolean returnValue = true;
    if (getStoragePoolIsoMap() == null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.STORAGE_DOMAIN_NOT_ATTACHED_TO_STORAGE_POOL);
    } else if (!isRemoveLast && isMaster()) {
        StorageDomain storage_domains = LinqUtils.firstOrNull(getStorageDomainDAO().getAllForStoragePool(getStorageDomain().getStoragePoolId()), new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain a) {
                return a.getId().equals(getStorageDomain().getId()) && a.getStatus() == StorageDomainStatus.Active;
            }
        });
        if (storage_domains == null) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_LAST_STORAGE_DOMAIN);
        }
    }
    return returnValue;
}
#end_block

#method_before
private String resolveMessage(String message, Map<String, LinkedList<String>> variables) {
    String returnValue = message;
    // $NON-NLS-1$ //$NON-NLS-2$
    RegExp regex = RegExp.compile(VARIABLE_PATTERN, "gi");
    MatchResult result;
    while (returnValue.length() > 0) {
        result = regex.exec(returnValue);
        if (result == null) {
            // No more matches
            break;
        }
        String match = result.getGroup(0);
        String key = match.substring(2, match.length() - 1);
        if (variables.containsKey(key)) {
            LinkedList<String> values = variables.get(key);
            String value = values.size() == 1 ? values.getFirst() : // $NON-NLS-1$
            values.size() > 1 ? values.removeFirst() : "";
            returnValue = returnValue.replace(match, value);
        }
        // Make the next search start from the beginning
        regex.setLastIndex(0);
    }
    return returnValue;
}
#method_after
private String resolveMessage(String message, Map<String, LinkedList<String>> variables) {
    String returnValue = message;
    // $NON-NLS-1$ //$NON-NLS-2$
    RegExp regex = RegExp.compile(VARIABLE_PATTERN, "gi");
    MatchResult result;
    while (returnValue.length() > 0) {
        result = regex.exec(returnValue);
        if (result == null) {
            // No more matches
            break;
        }
        String match = result.getGroup(0);
        String key = match.substring(2, match.length() - 1);
        if (variables.containsKey(key)) {
            LinkedList<String> values = variables.get(key);
            String value = values.size() == 1 ? values.getFirst() : // $NON-NLS-1$
            values.size() > 1 ? values.removeFirst() : "";
            returnValue = returnValue.replace(match, value);
        } else {
            // infinite loop
            break;
        }
        // Make the next search start from the beginning
        regex.setLastIndex(0);
    }
    return returnValue;
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    boolean filteredOutHosts = false;
    if (StringUtils.isNotEmpty(vm.getCpuName())) {
        List<VDS> hostsToRunOn = new ArrayList<VDS>();
        for (VDS host : hosts) {
            String hostCpuName = CpuFlagsManagerHandler.FindMaxServerCpuByFlags(host.getCpuFlags(), host.getVdsGroupCompatibilityVersion()).getCpuName();
            if (StringUtils.isNotEmpty(hostCpuName)) {
                int compareResult = CpuFlagsManagerHandler.compareCpuLevels(vm.getCpuName(), hostCpuName, vm.getVdsGroupCompatibilityVersion());
                if (compareResult <= 0) {
                    hostsToRunOn.add(host);
                    log.debugFormat("Host {0} wasn't filtered out as it has a CPU level ({1}) which is higher or equal than the CPU level the VM was run with ({2})", host.getName(), hostCpuName, vm.getCpuName());
                } else {
                    log.debugFormat("Host {0} was filtered out as it has a CPU level ({1}) which is lower than the CPU level the VM was run with ({2})", host.getName(), hostCpuName, vm.getCpuName());
                    messages.addMessage(host.getId(), String.format("$hostCPULevel %1$s", hostCpuName));
                    messages.addMessage(host.getId(), String.format("$vmCPULevel %1$s", vm.getCpuName()));
                    messages.addMessage(host.getId(), VdcBllMessages.VAR__DETAIL__LOW_CPU_LEVEL.toString());
                }
            }
        }
        return hostsToRunOn;
    } else {
        return hosts;
    }
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    boolean filteredOutHosts = false;
    if (StringUtils.isNotEmpty(vm.getCpuName())) {
        List<VDS> hostsToRunOn = new ArrayList<VDS>();
        for (VDS host : hosts) {
            ServerCpu cpu = CpuFlagsManagerHandler.FindMaxServerCpuByFlags(host.getCpuFlags(), host.getVdsGroupCompatibilityVersion());
            String hostCpuName = cpu == null ? null : cpu.getCpuName();
            if (StringUtils.isNotEmpty(hostCpuName)) {
                int compareResult = CpuFlagsManagerHandler.compareCpuLevels(vm.getCpuName(), hostCpuName, vm.getVdsGroupCompatibilityVersion());
                if (compareResult <= 0) {
                    hostsToRunOn.add(host);
                    log.debugFormat("Host {0} wasn't filtered out as it has a CPU level ({1}) which is higher or equal than the CPU level the VM was run with ({2})", host.getName(), hostCpuName, vm.getCpuName());
                } else {
                    log.debugFormat("Host {0} was filtered out as it has a CPU level ({1}) which is lower than the CPU level the VM was run with ({2})", host.getName(), hostCpuName, vm.getCpuName());
                    messages.addMessage(host.getId(), String.format("$hostCPULevel %1$s", hostCpuName));
                    messages.addMessage(host.getId(), String.format("$vmCPULevel %1$s", vm.getCpuName()));
                    messages.addMessage(host.getId(), VdcBllMessages.VAR__DETAIL__LOW_CPU_LEVEL.toString());
                }
            }
        }
        return hostsToRunOn;
    } else {
        return hosts;
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling();
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<VDS>();
                boolean status = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!status) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(Entities.objectNames(returnedFailedHosts), ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION);
                    log.infoFormat("Cluster: {0} fail to pass HA reservation check.", cluster.getName());
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#method_after
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling();
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<VDS>();
                boolean clusterHaStatus = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!clusterHaStatus) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(Entities.objectNames(returnedFailedHosts), ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION);
                    log.infoFormat("Cluster: {0} fail to pass HA reservation check.", cluster.getName());
                }
                boolean clusterHaStatusFromPreviousCycle = clusterId2isHaReservationSafe.containsKey(cluster.getId()) ? clusterId2isHaReservationSafe.get(cluster.getId()) : true;
                // Update the status map with the new status
                clusterId2isHaReservationSafe.put(cluster.getId(), clusterHaStatus);
                // Create Alert if the status was changed from false to true
                if (!clusterHaStatusFromPreviousCycle && clusterHaStatus) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION_DOWN);
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#end_block

#method_before
private void cleanUpOrphanTasks(Map<Guid, Set<Guid>> runningTasksInClusterMap) {
    // if map is empty, no tasks from clusters fetched. so return
    if (runningTasksInClusterMap.isEmpty()) {
        log.debug("Clean up of tasks has been skipped");
        return;
    }
    // Populate the list of tasks that need to be monitored from database
    List<Guid> taskListInDB = getProvider().getMonitoredTaskIDsInDB();
    if (taskListInDB == null || taskListInDB.isEmpty()) {
        return;
    }
    Set<Guid> allRunningTasksInCluster = new HashSet<>();
    for (Set<Guid> taskSet : runningTasksInClusterMap.values()) {
        if (taskSet != null) {
            allRunningTasksInCluster.addAll(taskSet);
        }
    }
    // if task is in DB but not in running task list
    final Set<Guid> tasksNotRunning = new HashSet<Guid>(taskListInDB);
    tasksNotRunning.removeAll(allRunningTasksInCluster);
    log.debugFormat("tasks to be cleaned up in db {0}", tasksNotRunning);
    for (Guid taskId : tasksNotRunning) {
        GlusterVolumeEntity vol = getVolumeDao().getVolumeByGlusterTask(taskId);
        if (vol != null && (vol.getStatus() != GlusterStatus.UP || !runningTasksInClusterMap.keySet().contains(vol.getClusterId()))) {
            // contain the cluster id in such case
            continue;
        }
        // Volume is up, but gluster does not know of task
        // will mark job ended with status unknown.
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        Map<String, String> values = new HashMap<String, String>();
        values.put(GlusterConstants.CLUSTER, vol == null ? "" : vol.getVdsGroupName());
        values.put(GlusterConstants.VOLUME, vol == null ? "" : vol.getName());
        values.put(GlusterConstants.JOB_STATUS, JobExecutionStatus.UNKNOWN.toString());
        values.put(GlusterConstants.JOB_INFO, " ");
        for (Step step : steps) {
            if (TimeUnit.MILLISECONDS.toMinutes(System.currentTimeMillis() - step.getStartTime().getTime()) < 10) {
                // This task has been recently created. We will give it 10 mins before clearing it.
                continue;
            }
            step.markStepEnded(JobExecutionStatus.UNKNOWN);
            step.setStatus(JobExecutionStatus.UNKNOWN);
            step.setDescription(ExecutionMessageDirector.resolveStepMessage(step.getStepType(), values));
            getGlusterTaskUtils().endStepJob(step);
            if (vol != null) {
                logTaskStoppedFromCLI(step, vol);
            }
        }
        getGlusterTaskUtils().releaseVolumeLock(taskId);
    }
}
#method_after
private void cleanUpOrphanTasks(Map<Guid, Set<Guid>> runningTasksInClusterMap) {
    // if map is empty, no tasks from clusters fetched. so return
    if (runningTasksInClusterMap.isEmpty()) {
        log.debug("Clean up of tasks has been skipped");
        return;
    }
    // Populate the list of tasks that need to be monitored from database
    List<Guid> taskListInDB = getProvider().getMonitoredTaskIDsInDB();
    if (taskListInDB == null || taskListInDB.isEmpty()) {
        return;
    }
    Set<Guid> allRunningTasksInCluster = new HashSet<>();
    for (Set<Guid> taskSet : runningTasksInClusterMap.values()) {
        if (taskSet != null) {
            allRunningTasksInCluster.addAll(taskSet);
        }
    }
    // if task is in DB but not in running task list
    final Set<Guid> tasksNotRunning = new HashSet<Guid>(taskListInDB);
    tasksNotRunning.removeAll(allRunningTasksInCluster);
    log.debugFormat("tasks to be cleaned up in db {0}", tasksNotRunning);
    for (Guid taskId : tasksNotRunning) {
        GlusterVolumeEntity vol = getVolumeDao().getVolumeByGlusterTask(taskId);
        if (vol != null && (vol.getStatus() != GlusterStatus.UP || !runningTasksInClusterMap.keySet().contains(vol.getClusterId()))) {
            // contain the cluster id in such case
            continue;
        }
        // Volume is up, but gluster does not know of task
        // will mark job ended with status unknown.
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        Map<String, String> values = new HashMap<String, String>();
        values.put(GlusterConstants.CLUSTER, vol == null ? "" : vol.getVdsGroupName());
        values.put(GlusterConstants.VOLUME, vol == null ? "" : vol.getName());
        values.put(GlusterConstants.JOB_STATUS, JobExecutionStatus.UNKNOWN.toString());
        values.put(GlusterConstants.JOB_INFO, " ");
        for (Step step : steps) {
            if (TimeUnit.MILLISECONDS.toMinutes(System.currentTimeMillis() - step.getStartTime().getTime()) < getMininumWaitInMins()) {
                // This task has been recently created. We will give it 10 mins before clearing it.
                continue;
            }
            step.markStepEnded(JobExecutionStatus.UNKNOWN);
            step.setStatus(JobExecutionStatus.UNKNOWN);
            step.setDescription(ExecutionMessageDirector.resolveStepMessage(step.getStepType(), values));
            getGlusterTaskUtils().endStepJob(step);
            if (vol != null) {
                logTaskStoppedFromCLI(step, vol);
            }
        }
        getGlusterTaskUtils().releaseVolumeLock(taskId);
    }
}
#end_block

#method_before
public static Snapshot prepareSnapshotConfigWithoutImageSingleImage(Snapshot snapshot, Guid imageId) {
    try {
        OvfManager ovfManager = new OvfManager();
        String snapConfig = snapshot.getVmConfiguration();
        if (snapshot.isVmConfigurationAvailable() && snapConfig != null) {
            VM vmSnapshot = new VM();
            ArrayList<DiskImage> snapshotImages = new ArrayList<DiskImage>();
            ovfManager.ImportVm(snapConfig, vmSnapshot, snapshotImages, new ArrayList<VmNetworkInterface>());
            // Remove the image form the disk list
            Iterator<DiskImage> diskIter = snapshotImages.iterator();
            while (diskIter.hasNext()) {
                DiskImage imageInList = diskIter.next();
                if (imageInList.getImageId().equals(imageId)) {
                    log.debugFormat("Recreating vmSnapshot {0} without the image {1}", snapshot.getId(), imageId);
                    diskIter.remove();
                    break;
                }
            }
            String newOvf = ovfManager.ExportVm(vmSnapshot, snapshotImages, ClusterUtils.getCompatibilityVersion(vmSnapshot));
            snapshot.setVmConfiguration(newOvf);
        }
    } catch (OvfReaderException e) {
        log.errorFormat("Can't remove image {0} from snapshot {1}", imageId, snapshot.getId());
    }
    return snapshot;
}
#method_after
public static Snapshot prepareSnapshotConfigWithoutImageSingleImage(Snapshot snapshot, Guid imageId) {
    try {
        OvfManager ovfManager = new OvfManager();
        String snapConfig = snapshot.getVmConfiguration();
        if (snapshot.isVmConfigurationAvailable() && snapConfig != null) {
            VM vmSnapshot = new VM();
            ArrayList<DiskImage> snapshotImages = new ArrayList<DiskImage>();
            ovfManager.ImportVm(snapConfig, vmSnapshot, snapshotImages, new ArrayList<VmNetworkInterface>());
            // Remove the image from the disk list
            Iterator<DiskImage> diskIter = snapshotImages.iterator();
            while (diskIter.hasNext()) {
                DiskImage imageInList = diskIter.next();
                if (imageInList.getImageId().equals(imageId)) {
                    log.debugFormat("Recreating vmSnapshot {0} without the image {1}", snapshot.getId(), imageId);
                    diskIter.remove();
                    break;
                }
            }
            String newOvf = ovfManager.ExportVm(vmSnapshot, snapshotImages, ClusterUtils.getCompatibilityVersion(vmSnapshot));
            snapshot.setVmConfiguration(newOvf);
        }
    } catch (OvfReaderException e) {
        log.errorFormat("Can't remove image {0} from snapshot {1}", imageId, snapshot.getId());
    }
    return snapshot;
}
#end_block

#method_before
private List<Snapshot> prepareSnapshotConfigWithoutImage(Guid imageGroupToRemove) {
    List<Snapshot> result = new LinkedList<Snapshot>();
    List<DiskImage> snapshotDisks = getDiskImageDao().getAllSnapshotsForImageGroup(imageGroupToRemove);
    for (DiskImage snapshotDisk : snapshotDisks) {
        Guid vmSnapshotId = snapshotDisk.getVmSnapshotId();
        if (vmSnapshotId != null && !Guid.Empty.equals(vmSnapshotId)) {
            Snapshot updated = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(vmSnapshotId, snapshotDisk.getImageId());
            if (updated != null) {
                result.add(updated);
            }
        }
    }
    return result;
}
#method_after
private List<Snapshot> prepareSnapshotConfigWithoutImage(Guid imageGroupToRemove) {
    List<Snapshot> result = new LinkedList<Snapshot>();
    List<DiskImage> snapshotDisks = getDiskImageDao().getAllSnapshotsForImageGroup(imageGroupToRemove);
    for (DiskImage snapshotDisk : snapshotDisks) {
        Guid vmSnapshotId = snapshotDisk.getVmSnapshotId();
        if (vmSnapshotId != null && !Guid.Empty.equals(vmSnapshotId)) {
            Snapshot snapshot = getSnapshotDao().get(vmSnapshotId);
            Snapshot updated = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snapshot, snapshotDisk.getImageId());
            if (updated != null) {
                result.add(updated);
            }
        }
    }
    return result;
}
#end_block

#method_before
protected void updateSnapshotVmConfiguration() {
    Guid imageId = getParameters().getImageIds().get(getParameters().getExecutionIndex());
    Snapshot snapshotWithoutImage = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(getSnapshotId(), imageId);
    getSnapshotDao().update(snapshotWithoutImage);
}
#method_after
protected void updateSnapshotVmConfiguration() {
    Guid imageId = getParameters().getImageIds().get(getParameters().getExecutionIndex());
    Snapshot snapshot = getSnapshotDao().get(getSnapshotId());
    Snapshot snapshotWithoutImage = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snapshot, imageId);
    getSnapshotDao().update(snapshotWithoutImage);
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        Guid storagePoolId = getDestinationDiskImage().getStoragePoolId() != null ? getDestinationDiskImage().getStoragePoolId() : Guid.Empty;
        Guid newImageGroupId = getDestinationDiskImage().getId() != null ? getDestinationDiskImage().getId() : Guid.Empty;
        Guid newImageId = getDestinationDiskImage().getImageId();
        Guid newStorageDomainID = getDestinationDiskImage().getStorageIds().get(0);
        // complete IRS data to DB disk image:
        try {
            DiskImage newImageIRS = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
            if (newImageIRS != null) {
                completeImageData(newImageIRS);
            }
        } catch (VdcBLLException e) {
            // Logging only
            log.errorFormat("Unable to update the image info for image {0} (image group: {1}) on domain {2}", newImageId, newImageGroupId, newStorageDomainID);
        } finally {
            if (!getParameters().isLeaveLocked()) {
                getDestinationDiskImage().setImageStatus(ImageStatus.OK);
            }
            getImageDao().update(getDestinationDiskImage().getImage());
        }
    }
    if (!getParameters().isLeaveLocked()) {
        unLockImage();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        Guid storagePoolId = getDestinationDiskImage().getStoragePoolId() != null ? getDestinationDiskImage().getStoragePoolId() : Guid.Empty;
        Guid newImageGroupId = getDestinationDiskImage().getId() != null ? getDestinationDiskImage().getId() : Guid.Empty;
        Guid newImageId = getDestinationDiskImage().getImageId();
        Guid newStorageDomainID = getDestinationDiskImage().getStorageIds().get(0);
        // complete IRS data to DB disk image:
        try {
            DiskImage newImageIRS = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
            if (newImageIRS != null) {
                completeImageData(newImageIRS);
                // Set volume type/format before updating DB in the 'finally' branch
                getDestinationDiskImage().getImage().setVolumeType(newImageIRS.getVolumeType());
                getDestinationDiskImage().getImage().setVolumeFormat(newImageIRS.getVolumeFormat());
            }
        } catch (VdcBLLException e) {
            // Logging only
            log.errorFormat("Unable to update the image info for image {0} (image group: {1}) on domain {2}", newImageId, newImageGroupId, newStorageDomainID);
        } finally {
            if (!getParameters().isLeaveLocked()) {
                getDestinationDiskImage().setImageStatus(ImageStatus.OK);
            }
            getImageDao().update(getDestinationDiskImage().getImage());
        }
    }
    if (!getParameters().isLeaveLocked()) {
        unLockImage();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    log.info("Start detach storage domain");
    if (!canStorageDomainBeDetached()) {
        setSucceeded(Boolean.FALSE.booleanValue());
        return;
    }
    changeStorageDomainStatusInTransaction(getStorageDomain().getStoragePoolIsoMapData(), StorageDomainStatus.Locked);
    log.info(" Detach storage domain: before connect");
    connectAllHostsToPool();
    log.info(" Detach storage domain: after connect");
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, new DetachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, getStoragePool().getmaster_domain_version()));
    log.info(" Detach storage domain: after detach in vds");
    disconnectAllHostsInPool();
    log.info(" Detach storage domain: after disconnect storage");
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            StoragePoolIsoMap mapToRemove = getStorageDomain().getStoragePoolIsoMapData();
            getCompensationContext().snapshotEntity(mapToRemove);
            DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(mapToRemove.getstorage_id(), mapToRemove.getstorage_pool_id()));
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (returnValue.getSucceeded() && getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
        // reset iso for this pool in vdsBroker cache
        runVdsCommand(VDSCommandType.ResetISOPath, new IrsBaseVDSCommandParameters(getParameters().getStoragePoolId()));
    }
    log.info("End detach storage domain");
    setSucceeded(returnValue.getSucceeded());
}
#method_after
@Override
protected void executeCommand() {
    log.info("Start detach storage domain");
    changeStorageDomainStatusInTransaction(getStorageDomain().getStoragePoolIsoMapData(), StorageDomainStatus.Locked);
    log.info(" Detach storage domain: before connect");
    connectAllHostsToPool();
    log.info(" Detach storage domain: after connect");
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, new DetachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, getStoragePool().getmaster_domain_version()));
    log.info(" Detach storage domain: after detach in vds");
    disconnectAllHostsInPool();
    log.info(" Detach storage domain: after disconnect storage");
    if (!detachStorageDomainWithEntities()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                StoragePoolIsoMap mapToRemove = getStorageDomain().getStoragePoolIsoMapData();
                getCompensationContext().snapshotEntity(mapToRemove);
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(mapToRemove.getstorage_id(), mapToRemove.getstorage_pool_id()));
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (returnValue.getSucceeded() && getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
        // reset iso for this pool in vdsBroker cache
        runVdsCommand(VDSCommandType.ResetISOPath, new IrsBaseVDSCommandParameters(getParameters().getStoragePoolId()));
    }
    log.info("End detach storage domain");
    setSucceeded(returnValue.getSucceeded());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return canDetachDomain(getParameters().getDestroyingPool(), getParameters().getRemoveLast(), isInternalExecution());
}
#method_after
@Override
protected boolean canDoAction() {
    canDetachStorageDomainWithVmsAndDisks();
    return canDetachDomain(getParameters().getDestroyingPool(), getParameters().getRemoveLast(), isInternalExecution());
}
#end_block

#method_before
public static void proceedLUNInDb(final LUNs lun, StorageType storageType, String volumeGroupId) {
    lun.setvolume_group_id(volumeGroupId);
    if (DbFacade.getInstance().getLunDao().get(lun.getLUN_id()) == null) {
        DbFacade.getInstance().getLunDao().save(lun);
    } else if (!volumeGroupId.isEmpty()) {
        DbFacade.getInstance().getLunDao().update(lun);
    }
    for (StorageServerConnections connection : lun.getLunConnections()) {
        List<StorageServerConnections> connections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForConnection(connection);
        if (connections.isEmpty()) {
            connection.setid(Guid.newGuid().toString());
            connection.setstorage_type(storageType);
            DbFacade.getInstance().getStorageServerConnectionDao().save(connection);
        } else {
            connection.setid(connections.get(0).getid());
        }
        if (DbFacade.getInstance().getStorageServerConnectionLunMapDao().get(new LUN_storage_server_connection_map_id(lun.getLUN_id(), connection.getid())) == null) {
            DbFacade.getInstance().getStorageServerConnectionLunMapDao().save(new LUN_storage_server_connection_map(lun.getLUN_id(), connection.getid()));
        }
    }
}
#method_after
public static void proceedLUNInDb(final LUNs lun, StorageType storageType, String volumeGroupId) {
    lun.setvolume_group_id(volumeGroupId);
    if (DbFacade.getInstance().getLunDao().get(lun.getLUN_id()) == null) {
        DbFacade.getInstance().getLunDao().save(lun);
    } else if (!volumeGroupId.isEmpty()) {
        DbFacade.getInstance().getLunDao().update(lun);
    }
    if (storageType == StorageType.FCP) {
        // No need to handle connections (FCP storage doesn't utilize connections).
        return;
    }
    for (StorageServerConnections connection : lun.getLunConnections()) {
        List<StorageServerConnections> connections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForConnection(connection);
        if (connections.isEmpty()) {
            connection.setid(Guid.newGuid().toString());
            connection.setstorage_type(storageType);
            DbFacade.getInstance().getStorageServerConnectionDao().save(connection);
        } else {
            connection.setid(connections.get(0).getid());
        }
        if (DbFacade.getInstance().getStorageServerConnectionLunMapDao().get(new LUN_storage_server_connection_map_id(lun.getLUN_id(), connection.getid())) == null) {
            DbFacade.getInstance().getStorageServerConnectionLunMapDao().save(new LUN_storage_server_connection_map(lun.getLUN_id(), connection.getid()));
        }
    }
}
#end_block

#method_before
@SuppressWarnings("unused")
@Override
public OvfEntityData mapRow(ResultSet rs, int rowNum) throws SQLException {
    OvfEntityData entity = new OvfEntityData();
    entity.setVmId(getGuid(rs, "vm_guid"));
    entity.setVmName(rs.getString("vm_name"));
    entity.setEntityType(rs.getString("entity_type"));
    entity.setStorageDomainId(getGuid(rs, "storage_domain_id"));
    entity.setOvfData(rs.getString("ovf_data"));
    entity.setOvfExtraData(rs.getString("ovf_extra_data"));
    entity.setOsId(rs.getInt("os_id"));
    entity.setLowestCompVersion(rs.getInt("lowest_comp_version"));
    return entity;
}
#method_after
@Override
public OvfEntityData mapRow(ResultSet rs, int rowNum) throws SQLException {
    OvfEntityData entity = new OvfEntityData();
    entity.setEntityId(getGuid(rs, "entity_guid"));
    entity.setEntityName(rs.getString("entity_name"));
    entity.setEntityType(VmEntityType.valueOf(rs.getString("entity_type")));
    entity.setArchitecture(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setLowestCompVersion(new Version(rs.getString("lowest_comp_version")));
    entity.setStorageDomainId(getGuid(rs, "storage_domain_id"));
    entity.setOvfData(rs.getString("ovf_data"));
    entity.setOvfExtraData(rs.getString("ovf_extra_data"));
    return entity;
}
#end_block

#method_before
public String getEntityType() {
    return entityType;
}
#method_after
public VmEntityType getEntityType() {
    return entityType;
}
#end_block

#method_before
public void setEntityType(String entityType) {
    this.entityType = entityType;
}
#method_after
public void setEntityType(VmEntityType entityType) {
    this.entityType = entityType;
}
#end_block

#method_before
public int getLowestCompVersion() {
    return lowestCompVersion;
}
#method_after
public Version getLowestCompVersion() {
    return lowestCompVersion;
}
#end_block

#method_before
public void setLowestCompVersion(int lowestCompVersion) {
    this.lowestCompVersion = lowestCompVersion;
}
#method_after
public void setLowestCompVersion(Version lowestCompVersion) {
    this.lowestCompVersion = lowestCompVersion;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((entityType == null) ? 0 : entityType.hashCode());
    result = prime * result + lowestCompVersion;
    result = prime * result + osId;
    result = prime * result + ((ovfData == null) ? 0 : ovfData.hashCode());
    result = prime * result + ((ovfExtraData == null) ? 0 : ovfExtraData.hashCode());
    result = prime * result + ((storageDomainId == null) ? 0 : storageDomainId.hashCode());
    result = prime * result + ((vmId == null) ? 0 : vmId.hashCode());
    result = prime * result + ((vmName == null) ? 0 : vmName.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((architecture == null) ? 0 : architecture.hashCode());
    result = prime * result + ((entityId == null) ? 0 : entityId.hashCode());
    result = prime * result + ((entityName == null) ? 0 : entityName.hashCode());
    result = prime * result + ((entityType == null) ? 0 : entityType.hashCode());
    result = prime * result + ((lowestCompVersion == null) ? 0 : lowestCompVersion.hashCode());
    result = prime * result + ((ovfData == null) ? 0 : ovfData.hashCode());
    result = prime * result + ((ovfExtraData == null) ? 0 : ovfExtraData.hashCode());
    result = prime * result + ((storageDomainId == null) ? 0 : storageDomainId.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    OvfEntityData other = (OvfEntityData) obj;
    if (entityType == null) {
        if (other.entityType != null)
            return false;
    } else if (!entityType.equals(other.entityType))
        return false;
    if (lowestCompVersion != other.lowestCompVersion)
        return false;
    if (osId != other.osId)
        return false;
    if (ovfData == null) {
        if (other.ovfData != null)
            return false;
    } else if (!ovfData.equals(other.ovfData))
        return false;
    if (ovfExtraData == null) {
        if (other.ovfExtraData != null)
            return false;
    } else if (!ovfExtraData.equals(other.ovfExtraData))
        return false;
    if (storageDomainId == null) {
        if (other.storageDomainId != null)
            return false;
    } else if (!storageDomainId.equals(other.storageDomainId))
        return false;
    if (vmId == null) {
        if (other.vmId != null)
            return false;
    } else if (!vmId.equals(other.vmId))
        return false;
    if (vmName == null) {
        if (other.vmName != null)
            return false;
    } else if (!vmName.equals(other.vmName))
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    OvfEntityData other = (OvfEntityData) obj;
    if (architecture != other.architecture)
        return false;
    if (entityId == null) {
        if (other.entityId != null)
            return false;
    } else if (!entityId.equals(other.entityId))
        return false;
    if (entityName == null) {
        if (other.entityName != null)
            return false;
    } else if (!entityName.equals(other.entityName))
        return false;
    if (entityType != other.entityType)
        return false;
    if (lowestCompVersion == null) {
        if (other.lowestCompVersion != null)
            return false;
    } else if (!lowestCompVersion.equals(other.lowestCompVersion))
        return false;
    if (ovfData == null) {
        if (other.ovfData != null)
            return false;
    } else if (!ovfData.equals(other.ovfData))
        return false;
    if (ovfExtraData == null) {
        if (other.ovfExtraData != null)
            return false;
    } else if (!ovfExtraData.equals(other.ovfExtraData))
        return false;
    if (storageDomainId == null) {
        if (other.storageDomainId != null)
            return false;
    } else if (!storageDomainId.equals(other.storageDomainId))
        return false;
    return true;
}
#end_block

#method_before
@Test
public void testGetVMsForStorageDomain() {
    dao = dbFacade.getUnregisteredOVFDataDao();
    List<OvfEntityData> ovfEntityDataList = dao.getAllForStorageDomain(FixturesTool.STORAGE_DOAMIN_NFS2_1, "VM");
    assertTrue("a VM should be fetched for the specified storage domain", !ovfEntityDataList.isEmpty());
}
#method_after
@Test
public void testGetVMsForStorageDomain() {
    List<OvfEntityData> ovfEntityDataList = dao.getAllForStorageDomainByEntityType(FixturesTool.STORAGE_DOAMIN_NFS2_1, VmEntityType.VM);
    assertTrue("A VM should be fetched for the specified storage domain", !ovfEntityDataList.isEmpty());
}
#end_block

#method_before
@Test
public void testGetTempaltesForStorageDomain() {
    dao = dbFacade.getUnregisteredOVFDataDao();
    List<OvfEntityData> ovfEntityDataList = dao.getAllForStorageDomain(FixturesTool.STORAGE_DOAMIN_NFS2_1, "Template");
    assertTrue("a Tempalte should not be fetched for the specified storage domain", ovfEntityDataList.isEmpty());
}
#method_after
@Test
public void testGetTempaltesForStorageDomain() {
    List<OvfEntityData> ovfEntityDataList = dao.getAllForStorageDomainByEntityType(FixturesTool.STORAGE_DOAMIN_NFS2_1, VmEntityType.TEMPLATE);
    assertTrue("A Tempalte should not be fetched for the specified storage domain", ovfEntityDataList.isEmpty());
}
#end_block

#method_before
@Test
public void testGetTemplatesForNotRelatedStorageDomain() {
    dao = dbFacade.getUnregisteredOVFDataDao();
    List<OvfEntityData> ovfEntityDataList = dao.getAllForStorageDomain(FixturesTool.STORAGE_DOAMIN_NFS2_2, "Template");
    assertTrue("No Template should be fetched for the specified storage domain", ovfEntityDataList.isEmpty());
}
#method_after
@Test
public void testGetTemplatesForNotRelatedStorageDomain() {
    List<OvfEntityData> ovfEntityDataList = dao.getAllForStorageDomainByEntityType(FixturesTool.STORAGE_DOAMIN_NFS2_2, VmEntityType.TEMPLATE);
    assertTrue("No Template should be fetched for the specified storage domain", ovfEntityDataList.isEmpty());
}
#end_block

#method_before
@Test
public void testInsertTemplateToUnregisteredEntity() {
    dao = dbFacade.getUnregisteredOVFDataDao();
    final String OVF_DATA = "<ovf> temporary </ovf>";
    dao.insertOVFDataForEntities(FixturesTool.VM_TEMPLATE_RHEL5, FixturesTool.STORAGE_DOAMIN_NFS2_1, OVF_DATA);
    OvfEntityData ovfEntityData = dao.getByVmId(FixturesTool.VM_TEMPLATE_RHEL5);
    assertNotNull(ovfEntityData);
    assertTrue("The entity type should be template", ovfEntityData.getEntityType().equals("Template"));
    assertTrue("The entity OVF data should be updated", ovfEntityData.getOvfData().equals(OVF_DATA));
}
#method_after
@Test
public void testInsertTemplateToUnregisteredEntity() {
    final String ovfExtraData = "<ovf> Some extra OVF data </ovf>";
    OvfEntityData ovfEntityData = new OvfEntityData(FixturesTool.VM_TEMPLATE_RHEL5, "AnyVM", VmEntityType.TEMPLATE, ArchitectureType.x86_64, Version.v3_4, FixturesTool.STORAGE_DOAMIN_NFS2_1, null, ovfExtraData);
    dao.saveOVFData(ovfEntityData);
    OvfEntityData fetchedOvfEntityData = dao.getByEntityIdAndStorageDomain(FixturesTool.VM_TEMPLATE_RHEL5, FixturesTool.STORAGE_DOAMIN_NFS2_1);
    assertNotNull(fetchedOvfEntityData);
    assertTrue("The entity type should be template", fetchedOvfEntityData.getEntityType().isTemplateType());
    assertTrue("The entity OVF extra data should be updated", fetchedOvfEntityData.getOvfExtraData().equals(ovfExtraData));
}
#end_block

#method_before
private boolean regularRemoveStorageDomains(List<StorageDomain> storageDomains) {
    boolean retVal = true;
    List<StorageDomain> temp = LinqUtils.filter(storageDomains, new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain storage_domain) {
            return storage_domain.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    final StorageDomain masterDomain = LinqUtils.first(temp);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(masterDomain.getStoragePoolIsoMapData());
            masterDomain.setStatus(StorageDomainStatus.Locked);
            getDbFacade().getStoragePoolIsoMapDao().update(masterDomain.getStoragePoolIsoMapData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // destroying a pool is an SPM action. We need to connect all hosts
    // to the pool. Later on, during spm election, one of the hosts will
    // lock the pool
    // and the spm status will be FREE. Only then we can invoke the
    // destroy verb.
    connectAllHostToPoolAndDomain(masterDomain);
    List<VDS> vdss = getAllRunningVdssInPool();
    for (StorageDomain storageDomain : storageDomains) {
        detachStorageDomainWithEntities(storageDomain);
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            if (!removeDomainFromPool(storageDomain, vdss.get(0))) {
                log.errorFormat("Unable to detach storage domain {0} {1}", storageDomain.getStorageName(), storageDomain.getId());
                retVal = false;
            }
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(masterDomain.getStorageStaticData());
            masterDomain.setStorageDomainType(StorageDomainType.Data);
            getDbFacade().getStorageDomainStaticDao().update(masterDomain.getStorageStaticData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(getStoragePool());
            handleDestroyStoragePoolCommand();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    setSucceeded(true);
    if (!getStoragePool().isLocal()) {
        for (VDS vds : vdss) {
            StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vds.getId());
        }
    } else {
        try {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FormatStorageDomain, new FormatStorageDomainVDSCommandParameters(vdss.get(0).getId(), masterDomain.getId()));
        } catch (VdcBLLException e) {
        // Do nothing, exception already printed at logs
        }
        StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vdss.get(0).getId());
        removeDomainFromDb(masterDomain);
    }
    runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    return retVal;
}
#method_after
private boolean regularRemoveStorageDomains(List<StorageDomain> storageDomains) {
    boolean retVal = true;
    List<StorageDomain> temp = LinqUtils.filter(storageDomains, new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain storage_domain) {
            return storage_domain.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    final StorageDomain masterDomain = LinqUtils.first(temp);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(masterDomain.getStoragePoolIsoMapData());
            masterDomain.setStatus(StorageDomainStatus.Locked);
            getDbFacade().getStoragePoolIsoMapDao().update(masterDomain.getStoragePoolIsoMapData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // destroying a pool is an SPM action. We need to connect all hosts
    // to the pool. Later on, during spm election, one of the hosts will
    // lock the pool
    // and the spm status will be FREE. Only then we can invoke the
    // destroy verb.
    connectAllHostToPoolAndDomain(masterDomain);
    List<VDS> vdss = getAllRunningVdssInPool();
    for (StorageDomain storageDomain : storageDomains) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            if (!removeDomainFromPool(storageDomain, vdss.get(0))) {
                log.errorFormat("Unable to detach storage domain {0} {1}", storageDomain.getStorageName(), storageDomain.getId());
                retVal = false;
            }
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            detachStorageDomainWithEntities(masterDomain);
            getCompensationContext().snapshotEntity(masterDomain.getStorageStaticData());
            masterDomain.setStorageDomainType(StorageDomainType.Data);
            getDbFacade().getStorageDomainStaticDao().update(masterDomain.getStorageStaticData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(getStoragePool());
            handleDestroyStoragePoolCommand();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    setSucceeded(true);
    if (!getStoragePool().isLocal()) {
        for (VDS vds : vdss) {
            StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vds.getId());
        }
    } else {
        try {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FormatStorageDomain, new FormatStorageDomainVDSCommandParameters(vdss.get(0).getId(), masterDomain.getId()));
        } catch (VdcBLLException e) {
        // Do nothing, exception already printed at logs
        }
        StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vdss.get(0).getId());
        removeDomainFromDb(masterDomain);
    }
    runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    return retVal;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    initVmTemplate();
    if (isImagesAlreadyOnTarget()) {
        if (ovfEntityData == null && !getParameters().isImportAsNewEntity()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
            return false;
        }
        if (vmTemplateFromConfiguration == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
            return false;
        }
        setStorageDomainId(ovfEntityData.getStorageDomainId());
        if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
            return false;
        }
        if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED, String.format("$domainId %1$s", getParameters().getStorageDomainId()), String.format("$domainType %1$s", getStorageDomain().getStorageDomainType()));
        }
    }
    List<DiskImage> disks = new ArrayList(getVmTemplate().getDiskTemplateMap().values());
    setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), disks);
    getParameters().setImages(disks);
    getVmTemplate().setImages((ArrayList) disks);
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    initVmTemplate();
    if (isImagesAlreadyOnTarget()) {
        if (ovfEntityData == null && !getParameters().isImportAsNewEntity()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
            return false;
        }
        if (vmTemplateFromConfiguration == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
            return false;
        }
        setStorageDomainId(ovfEntityData.getStorageDomainId());
        if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
            return false;
        }
        if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED, String.format("$domainId %1$s", getParameters().getStorageDomainId()), String.format("$domainType %1$s", getStorageDomain().getStorageDomainType()));
        }
    }
    ArrayList<DiskImage> disks = new ArrayList(getVmTemplate().getDiskTemplateMap().values());
    setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), disks);
    getParameters().setImages(disks);
    getVmTemplate().setImages(disks);
    return super.canDoAction();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (getVdsGroup() == null || getVm().getVdsGroupId() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > MacPoolManager.getInstance().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#method_after
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > MacPoolManager.getInstance().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#end_block

#method_before
private boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
    if (validator.isDomainExistAndActive().isValid() && !isUnregisteredVM() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getVm().getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#method_after
private boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
    if (validator.isDomainExistAndActive().isValid() && !isImagesAlreadyOnTarget() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getVm().getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!isImagesAlreadyOnTarget() && !validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#end_block

#method_before
private boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isUnregisteredVM()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        if (!setDomainsForMemoryImages(domainMap)) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    return true;
}
#method_after
private boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        if (!setDomainsForMemoryImages(domainMap)) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = getParameters().isImportAsNewEntity() || (!isUnregisteredVM() && checkIfDisksExist(imageList)) || isUnregisteredVM();
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = verifyDisksIfNeeded();
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    executeImportVm(!isUnregisteredVM());
}
#method_after
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        processImages(!isImagesAlreadyOnTarget());
        // vm related ops
        if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
            endVmRelatedOps();
        }
        // Save Vm Init
        VmHandler.addVmInitToDB(getVm().getStaticData());
    } catch (RuntimeException e) {
        MacPoolManager.getInstance().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#end_block

#method_before
private int computeMinAllocatedMem() {
    int vmMem = getVm().getMemSizeMb();
    int minAllocatedMem = vmMem;
    if (getVm().getMinAllocatedMem() > 0) {
        minAllocatedMem = getVm().getMinAllocatedMem();
    } else {
        // first get cluster memory over commit value
        VDSGroup vdsGroup = getVdsGroupDAO().get(getVm().getVdsGroupId());
        if (vdsGroup != null && vdsGroup.getmax_vds_memory_over_commit() > 0) {
            minAllocatedMem = (vmMem * 100) / vdsGroup.getmax_vds_memory_over_commit();
        }
    }
    return minAllocatedMem;
}
#method_after
private int computeMinAllocatedMem() {
    int vmMem = getVm().getMemSizeMb();
    int minAllocatedMem = vmMem;
    if (getVm().getMinAllocatedMem() > 0) {
        minAllocatedMem = getVm().getMinAllocatedMem();
    } else {
        // first get cluster memory over commit value
        VDSGroup vdsGroup = getVdsGroup();
        if (vdsGroup != null && vdsGroup.getmax_vds_memory_over_commit() > 0) {
            minAllocatedMem = (vmMem * 100) / vdsGroup.getmax_vds_memory_over_commit();
        }
    }
    return minAllocatedMem;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVm().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // special permission is needed to use custom properties
    if (getVm() != null && !StringUtils.isEmpty(getVm().getCustomProperties())) {
        permissionList.add(new PermissionSubject(getVm().getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // special permission is needed to use custom properties
    if (getVm() != null && !StringUtils.isEmpty(getVm().getCustomProperties())) {
        permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
    }
    return permissionList;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVmTemplate() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    } else if (getTemplateDisks() != null && !getTemplateDisks().isEmpty()) {
        ensureDomainMap(getTemplateDisks(), getParameters().getStorageDomainId());
        // check that images are ok
        ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), imageFromSourceDomainMap, null, true);
        if (getVmTemplate().getDiskTemplateMap().values().size() != imageFromSourceDomainMap.size()) {
            log.errorFormat("Can not found any default active domain for one of the disks of template with id : {0}", getVmTemplate().getId());
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
            retValue = false;
        }
        retValue = retValue && VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), null, getReturnValue().getCanDoActionMessages(), true, true, true, false, getTemplateDisks());
        if (retValue) {
            setStoragePoolId(getVmTemplate().getStoragePoolId());
            retValue = checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && (getParameters().getForceOverride() || (!isUnregisteredVM() && checkIfDisksExist(getTemplateDisks()))) && checkFreeSpaceOnDestinationDomain(getStorageDomain(), (int) getVmTemplate().getActualDiskSize());
        }
        if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVmTemplate().getStoragePoolId())) == null) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVmTemplate() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    } else if (getTemplateDisks() != null && !getTemplateDisks().isEmpty()) {
        ensureDomainMap(getTemplateDisks(), getParameters().getStorageDomainId());
        // check that images are ok
        ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), imageFromSourceDomainMap, null, true);
        if (getVmTemplate().getDiskTemplateMap().values().size() != imageFromSourceDomainMap.size()) {
            log.errorFormat("Can not found any default active domain for one of the disks of template with id : {0}", getVmTemplate().getId());
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
            retValue = false;
        }
        retValue = retValue && VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), null, getReturnValue().getCanDoActionMessages(), true, true, true, false, getTemplateDisks());
        if (retValue) {
            setStoragePoolId(getVmTemplate().getStoragePoolId());
            retValue = checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && (getParameters().getForceOverride() || (!isImagesAlreadyOnTarget() && checkIfDisksExist(getTemplateDisks()))) && checkFreeSpaceOnDestinationDomain(getStorageDomain(), (int) getVmTemplate().getActualDiskSize());
        }
        if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVmTemplate().getStoragePoolId())) == null) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (isUnregisteredVM()) {
        if (ovfEntityData == null && !getParameters().isImportAsNewEntity()) {
            // TODO: Add CDA message.
            return false;
        }
        setStorageDomainId(ovfEntityData.getStorageDomainId());
        if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
            return false;
        }
        if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
            addCanDoActionMessage("$domainId " + getParameters().getStorageDomainId());
            addCanDoActionMessage("$domainType " + getStorageDomain().getStorageDomainType());
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED);
            return false;
        }
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    if (isImagesAlreadyOnTarget()) {
        if (ovfEntityData == null && !getParameters().isImportAsNewEntity()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
            return false;
        }
        if (vmFromConfiguration == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
            return false;
        }
        setStorageDomainId(ovfEntityData.getStorageDomainId());
        if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
            return false;
        }
        if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED, String.format("$domainId %1$s", getParameters().getStorageDomainId()), String.format("$domainType %1$s", getStorageDomain().getStorageDomainType()));
        }
    }
    return super.canDoAction();
}
#end_block

#method_before
@Override
protected void init(T parameters) {
    VM vmFromConfiguration = getParameters().getVm();
    if (vmFromConfiguration != null) {
        vmFromConfiguration.getStaticData().setVdsGroupId(getParameters().getVdsGroupId());
        if (!isUnregisteredVM()) {
            setDisksToBeAttached(vmFromConfiguration);
        }
        getParameters().setContainerId(vmFromConfiguration.getId());
    } else {
        initUnregisteredVM();
    }
    setVdsGroupId(getParameters().getVdsGroupId());
    getParameters().setStoragePoolId(getVdsGroup().getStoragePoolId());
    super.init(parameters);
}
#method_after
@Override
protected void init(T parameters) {
    VM vmFromConfiguration = getParameters().getVm();
    if (vmFromConfiguration != null) {
        vmFromConfiguration.getStaticData().setVdsGroupId(getParameters().getVdsGroupId());
        if (!isImagesAlreadyOnTarget()) {
            setDisksToBeAttached(vmFromConfiguration);
        }
        getParameters().setContainerId(vmFromConfiguration.getId());
    } else {
        initUnregisteredVM();
    }
    setVdsGroupId(getParameters().getVdsGroupId());
    getParameters().setStoragePoolId(getVdsGroup().getStoragePoolId());
    super.init(parameters);
}
#end_block

#method_before
private void initUnregisteredVM() {
    VM vmFromConfiguration;
    ovfEntityData = getUnregisteredOVFDataDao().getByVmId(getParameters().getContainerId());
    if (ovfEntityData != null) {
        try {
            OvfHelper ovfHelper = new OvfHelper();
            vmFromConfiguration = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration.setVdsGroupId(getParameters().getVdsGroupId());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
        } catch (OvfReaderException e) {
            log.errorFormat("failed to parse a given ovf configuration: \n" + ovfEntityData.getOvfData(), e);
        // addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
        }
    }
}
#method_after
private void initUnregisteredVM() {
    OvfHelper ovfHelper = new OvfHelper();
    ovfEntityData = getUnregisteredOVFDataDao().getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (ovfEntityData != null) {
        try {
            vmFromConfiguration = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration.setVdsGroupId(getParameters().getVdsGroupId());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
        } catch (OvfReaderException e) {
            log.errorFormat("failed to parse a given ovf configuration: \n" + ovfEntityData.getOvfData(), e);
        }
    }
}
#end_block

#method_before
@Override
public void executeCommand() {
    super.executeImportVm(!isUnregisteredVM());
    if (isUnregisteredVM()) {
        getUnregisteredOVFDataDao().removeEntity(ovfEntityData.getVmId(), ovfEntityData.getStorageDomainId());
    } else if (!vmDisksToAttach.isEmpty()) {
        AuditLogDirector.log(this, attemptToAttachDisksToImportedVm(vmDisksToAttach));
    }
    setActionReturnValue(getVm().getId());
}
#method_after
@Override
public void executeCommand() {
    super.executeCommand();
    if (getSucceeded()) {
        if (isImagesAlreadyOnTarget()) {
            getUnregisteredOVFDataDao().removeEntity(ovfEntityData.getEntityId(), ovfEntityData.getStorageDomainId());
        } else if (!vmDisksToAttach.isEmpty()) {
            AuditLogDirector.log(this, attemptToAttachDisksToImportedVm(vmDisksToAttach));
        }
    }
    setActionReturnValue(getVm().getId());
}
#end_block

#method_before
@Override
public Guid getVmTemplateId() {
    if (isImagesAlreadyOnTarget()) {
        return getParameters().getContainerId();
    } else {
        return super.getVmTemplateId();
    }
}
#method_after
@Override
public Guid getVmTemplateId() {
    if (isImagesAlreadyOnTarget()) {
        return getParameters().getContainerId();
    }
    return super.getVmTemplateId();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    init();
    if (isImagesAlreadyOnTarget()) {
        if (ovfEntityData == null && !getParameters().isImportAsNewEntity()) {
            // addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
            return false;
        }
        setStorageDomainId(ovfEntityData.getStorageDomainId());
        if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
            return false;
        }
        if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
            addCanDoActionMessage("$domainId " + getParameters().getStorageDomainId());
            addCanDoActionMessage("$domainType " + getStorageDomain().getStorageDomainType());
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED);
            return false;
        }
    }
    getParameters().setImages(getVmTemplate().getImages());
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    initVmTemplate();
    if (isImagesAlreadyOnTarget()) {
        if (ovfEntityData == null && !getParameters().isImportAsNewEntity()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
            return false;
        }
        if (vmTemplateFromConfiguration == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
            return false;
        }
        setStorageDomainId(ovfEntityData.getStorageDomainId());
        if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
            return false;
        }
        if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED, String.format("$domainId %1$s", getParameters().getStorageDomainId()), String.format("$domainType %1$s", getStorageDomain().getStorageDomainType()));
        }
    }
    getParameters().setImages(getVmTemplate().getImages());
    return super.canDoAction();
}
#end_block

#method_before
public VmTemplate readVmTemplateFromOvf(String ovf) throws OvfReaderException {
    VmTemplate vmTemplate = new VmTemplate();
    ArrayList<DiskImage> diskImages = new ArrayList<DiskImage>();
    ArrayList<VmNetworkInterface> interfaces = new ArrayList<VmNetworkInterface>();
    ovfManager.ImportTemplate(ovf, vmTemplate, diskImages, interfaces);
    // add images
    vmTemplate.setImages(diskImages);
    // add interfaces
    vmTemplate.setInterfaces(interfaces);
    // add disk map
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(diskImages);
    for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
        List<DiskImage> list = entry.getValue();
        vmTemplate.getDiskTemplateMap().put(entry.getKey(), list.get(list.size() - 1));
    }
    return vmTemplate;
}
#method_after
public VmTemplate readVmTemplateFromOvf(String ovf) throws OvfReaderException {
    ArrayList<DiskImage> diskImages = new ArrayList<DiskImage>();
    ArrayList<VmNetworkInterface> interfaces = new ArrayList<VmNetworkInterface>();
    VmTemplate template = new VmTemplate();
    ovfManager.ImportTemplate(ovf, template, diskImages, interfaces);
    template.setInterfaces(interfaces);
    // add disk map
    for (DiskImage disk : diskImages) {
        template.getDiskTemplateMap().put(disk.getId(), disk);
    }
    return template;
}
#end_block

#method_before
@Override
public Response register(Action action) {
    validateParameters(action, "cluster.id|name");
    ImportVmParameters params = new ImportVmParameters();
    params.setContainerId(guid);
    params.setVdsGroupId(getClusterId(action));
    params.setImagesExistOnStorageDomain(true);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getVm().isSetName()) {
            params.getVm().setName(action.getVm().getName());
        }
    }
    return doAction(VdcActionType.ImportVmFromConfiguration, params, action);
}
#method_after
@Override
public Response register(Action action) {
    validateParameters(action, "cluster.id|name");
    ImportVmParameters params = new ImportVmParameters();
    params.setContainerId(guid);
    params.setStorageDomainId(parent.getStorageDomainId());
    params.setVdsGroupId(getClusterId(action));
    params.setImagesExistOnTargetStorageDomain(true);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getVm().isSetName()) {
            params.getVm().setName(action.getVm().getName());
        }
    }
    return doAction(VdcActionType.ImportVmFromConfiguration, params, action);
}
#end_block

#method_before
@Test
public void testRegisterVM() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    try {
        control.replay();
        resource.register(new Action());
        fail("expected WebApplicationException on incomplete parameters");
    } catch (WebApplicationException wae) {
        verifyIncompleteException(wae, "Action", "register", "cluster.id|name", "storageDomain.id|name");
    }
}
#method_after
@Test
public void testRegisterVM() throws Exception {
    Cluster cluster = new Cluster();
    cluster.setId(GUIDS[1].toString());
    doTestRegister(cluster, false);
}
#end_block

#method_before
@Override
public Response register(Action action) {
    validateParameters(action, "cluster.id|name");
    ImportVmTemplateParameters params = new ImportVmTemplateParameters();
    params.setContainerId(guid);
    params.setVdsGroupId(getClusterId(action));
    params.setImagesExistOnStorageDomain(true);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getTemplate().isSetName()) {
            params.getVmTemplate().setName(action.getTemplate().getName());
        }
    }
    return doAction(VdcActionType.ImportVmTemplateFromConfiguration, params, action);
}
#method_after
@Override
public Response register(Action action) {
    validateParameters(action, "cluster.id|name");
    ImportVmTemplateParameters params = new ImportVmTemplateParameters();
    params.setContainerId(guid);
    params.setStorageDomainId(parent.getStorageDomainId());
    params.setVdsGroupId(getClusterId(action));
    params.setImagesExistOnTargetStorageDomain(true);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getTemplate().isSetName()) {
            params.getVmTemplate().setName(action.getTemplate().getName());
        }
    }
    return doAction(VdcActionType.ImportVmTemplateFromConfiguration, params, action);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<OvfEntityData> entityList = getDbFacade().getUnregisteredOVFDataDao().getAllForStorageDomain(getParameters().getId(), getParameters().getName());
    List<VM> vmList = new ArrayList<>();
    for (OvfEntityData ovf : entityList) {
        VM vm = new VM();
        vm.setId(ovf.getVmId());
        vm.setName(ovf.getVmName());
        vmList.add(vm);
    }
    getQueryReturnValue().setReturnValue(vmList);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<OvfEntityData> entityList = getOvfEntityList(VmEntityType.VM);
    List<VM> vmList = new ArrayList<>();
    OvfHelper ovfHelper = getOvfHelper();
    for (OvfEntityData ovf : entityList) {
        try {
            VM vm = ovfHelper.readVmFromOvf(ovf.getOvfData());
            // Setting the rest of the VM attributes which are not in the OVF.
            vm.setVdsGroupCompatibilityVersion(ovf.getLowestCompVersion());
            vm.setClusterArch(ovf.getArchitecture());
            vmList.add(vm);
        } catch (OvfReaderException e) {
            log.debug("failed to parse a given ovf configuration: \n" + ovf.getOvfData(), e);
            getQueryReturnValue().setExceptionString("failed to parse a given ovf configuration " + e.getMessage());
        }
    }
    getQueryReturnValue().setSucceeded(true);
    getQueryReturnValue().setReturnValue(vmList);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<OvfEntityData> entityList = getDbFacade().getUnregisteredOVFDataDao().getAllForStorageDomain(getParameters().getId(), getParameters().getName());
    List<VmTemplate> vmTemplates = new ArrayList<>();
    for (OvfEntityData ovf : entityList) {
        VmTemplate vmTemplate = new VmTemplate();
        vmTemplate.setId(ovf.getVmId());
        vmTemplate.setName(ovf.getVmName());
        vmTemplates.add(vmTemplate);
    }
    getQueryReturnValue().setReturnValue(vmTemplates);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<OvfEntityData> entityList = getOvfEntityList(VmEntityType.TEMPLATE);
    List<VmTemplate> vmTemplates = new ArrayList<>();
    OvfHelper ovfHelper = getOvfHelper();
    for (OvfEntityData ovf : entityList) {
        try {
            vmTemplates.add(ovfHelper.readVmTemplateFromOvf(ovf.getOvfData()));
        } catch (OvfReaderException e) {
            log.debug("failed to parse a given ovf configuration: \n" + ovf.getOvfData(), e);
            getQueryReturnValue().setExceptionString("failed to parse a given ovf configuration " + e.getMessage());
        }
    }
    getQueryReturnValue().setSucceeded(true);
    getQueryReturnValue().setReturnValue(vmTemplates);
}
#end_block

#method_before
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateVmsMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    List<VM> vms = getVmDao().getVmsByIds(idsToProcess);
    for (VM vm : vms) {
        if (VMStatus.ImageLocked != vm.getStatus()) {
            updateVmDisksFromDb(vm);
            if (!verifyImagesStatus(vm.getDiskList())) {
                continue;
            }
            ArrayList<DiskImage> vmImages = getVmImagesFromDb(vm);
            if (!verifyImagesStatus(vmImages)) {
                continue;
            }
            vm.setSnapshots(getSnapshotDao().getAllWithConfiguration(vm.getId()));
            if (!verifySnapshotsStatus(vm.getSnapshots())) {
                continue;
            }
            loadVmData(vm);
            Long currentDbGeneration = getVmStaticDao().getDbGeneration(vm.getId());
            if (currentDbGeneration == null) {
                log.warnFormat("currentDbGeneration of VM (name: {0}, id: {1}) is null, probably because the VM was deleted during the run of OvfDataUpdater.", vm.getName(), vm.getId());
            } else if (vm.getStaticData().getDbGeneration() == currentDbGeneration) {
                proccessedOvfConfigurationsInfo.add(buildMetadataDictionaryForVm(vm, vmsAndTemplateMetadata, vmImages));
                proccessedIdsInfo.add(vm.getId());
                proccessedOvfGenerationsInfo.add(vm.getStaticData().getDbGeneration());
                proccessDisksDomains(vm.getDiskList());
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#method_after
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateVmsMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    List<VM> vms = getVmDao().getVmsByIds(idsToProcess);
    for (VM vm : vms) {
        if (VMStatus.ImageLocked != vm.getStatus()) {
            updateVmDisksFromDb(vm);
            if (!verifyImagesStatus(vm.getDiskList())) {
                continue;
            }
            ArrayList<DiskImage> vmImages = getVmImagesFromDb(vm);
            if (!verifyImagesStatus(vmImages)) {
                continue;
            }
            vm.setSnapshots(getSnapshotDao().getAllWithConfiguration(vm.getId()));
            if (!verifySnapshotsStatus(vm.getSnapshots())) {
                continue;
            }
            loadVmData(vm);
            Long currentDbGeneration = getVmStaticDao().getDbGeneration(vm.getId());
            if (currentDbGeneration == null) {
                log.warnFormat("currentDbGeneration of VM (name: {0}, id: {1}) is null, probably because the VM was deleted during the run of OvfDataUpdater.", vm.getName(), vm.getId());
                continue;
            }
            if (vm.getStaticData().getDbGeneration() == currentDbGeneration) {
                proccessedOvfConfigurationsInfo.add(buildMetadataDictionaryForVm(vm, vmsAndTemplateMetadata, vmImages));
                proccessedIdsInfo.add(vm.getId());
                proccessedOvfGenerationsInfo.add(vm.getStaticData().getDbGeneration());
                proccessDisksDomains(vm.getDiskList());
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#end_block

#method_before
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateTemplatesMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    List<VmTemplate> templates = getVmTemplateDao().getVmTemplatesByIds(idsToProcess);
    for (VmTemplate template : templates) {
        if (VmTemplateStatus.Locked != template.getStatus()) {
            updateTemplateDisksFromDb(template);
            boolean verifyDisksNotLocked = verifyDisksNotLocked(template.getDiskList());
            if (verifyDisksNotLocked) {
                loadTemplateData(template);
                Long currentDbGeneration = getVmStaticDao().getDbGeneration(template.getId());
                // currentDbGeneration can be null in case that the template was deleted during the run of OvfDataUpdater.
                if (currentDbGeneration != null && template.getDbGeneration() == currentDbGeneration) {
                    proccessedOvfConfigurationsInfo.add(buildMetadataDictionaryForTemplate(template, vmsAndTemplateMetadata));
                    proccessedIdsInfo.add(template.getId());
                    proccessedOvfGenerationsInfo.add(template.getDbGeneration());
                    proccessDisksDomains(template.getDiskList());
                }
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#method_after
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateTemplatesMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    List<VmTemplate> templates = getVmTemplateDao().getVmTemplatesByIds(idsToProcess);
    for (VmTemplate template : templates) {
        if (VmTemplateStatus.Locked != template.getStatus()) {
            updateTemplateDisksFromDb(template);
            boolean verifyDisksNotLocked = verifyImagesStatus(template.getDiskList());
            if (verifyDisksNotLocked) {
                loadTemplateData(template);
                Long currentDbGeneration = getVmStaticDao().getDbGeneration(template.getId());
                // currentDbGeneration can be null in case that the template was deleted during the run of OvfDataUpdater.
                if (currentDbGeneration != null && template.getDbGeneration() == currentDbGeneration) {
                    proccessedOvfConfigurationsInfo.add(buildMetadataDictionaryForTemplate(template, vmsAndTemplateMetadata));
                    proccessedIdsInfo.add(template.getId());
                    proccessedOvfGenerationsInfo.add(template.getDbGeneration());
                    proccessDisksDomains(template.getDiskList());
                }
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#end_block

#method_before
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateVmsMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    List<VM> vms = getVmDao().getVmsByIds(idsToProcess);
    for (VM vm : vms) {
        if (VMStatus.ImageLocked != vm.getStatus()) {
            updateVmDisksFromDb(vm);
            vm.setSnapshots(getSnapshotDao().getAllWithConfiguration(vm.getId()));
            if (verifyDisksNotLocked(vm.getDiskList()) && verifySnapshotsNotLocked(vm.getSnapshots())) {
                loadVmData(vm);
                Long currentDbGeneration = getVmStaticDao().getDbGeneration(vm.getId());
                // currentDbGeneration can be null in case that the vm was deleted during the run of OvfDataUpdater.
                if (currentDbGeneration != null && vm.getStaticData().getDbGeneration() == currentDbGeneration) {
                    proccessedOvfConfigurationsInfo.add(buildMetadataDictionaryForVm(vm, vmsAndTemplateMetadata));
                    proccessedIdsInfo.add(vm.getId());
                    proccessedOvfGenerationsInfo.add(vm.getStaticData().getDbGeneration());
                    proccessDisksDomains(vm.getDiskList());
                }
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#method_after
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateVmsMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    List<VM> vms = getVmDao().getVmsByIds(idsToProcess);
    for (VM vm : vms) {
        if (VMStatus.ImageLocked != vm.getStatus()) {
            updateVmDisksFromDb(vm);
            if (!verifyImagesStatus(vm.getDiskList())) {
                continue;
            }
            ArrayList<DiskImage> vmImages = getVmImagesFromDb(vm);
            if (!verifyImagesStatus(vmImages)) {
                continue;
            }
            vm.setSnapshots(getSnapshotDao().getAllWithConfiguration(vm.getId()));
            if (!verifySnapshotsStatus(vm.getSnapshots())) {
                continue;
            }
            loadVmData(vm);
            Long currentDbGeneration = getVmStaticDao().getDbGeneration(vm.getId());
            // currentDbGeneration can be null in case that the vm was deleted during the run of OvfDataUpdater.
            if (currentDbGeneration != null && vm.getStaticData().getDbGeneration() == currentDbGeneration) {
                proccessedOvfConfigurationsInfo.add(buildMetadataDictionaryForVm(vm, vmsAndTemplateMetadata, vmImages));
                proccessedIdsInfo.add(vm.getId());
                proccessedOvfGenerationsInfo.add(vm.getStaticData().getDbGeneration());
                proccessDisksDomains(vm.getDiskList());
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#end_block

#method_before
protected String buildMetadataDictionaryForVm(VM vm, Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary) {
    ArrayList<DiskImage> AllVmImages = new ArrayList<DiskImage>();
    List<DiskImage> filteredDisks = ImagesHandler.filterImageDisks(vm.getDiskList(), false, true, true);
    for (DiskImage diskImage : filteredDisks) {
        AllVmImages.addAll(getAllImageSnapshots(diskImage));
    }
    String vmMeta = generateVmMetadata(vm, AllVmImages);
    metaDictionary.put(vm.getId(), new KeyValuePairCompat<String, List<Guid>>(vmMeta, LinqUtils.foreach(vm.getDiskMap().values(), new Function<Disk, Guid>() {

        @Override
        public Guid eval(Disk a) {
            return a.getId();
        }
    })));
    return vmMeta;
}
#method_after
protected String buildMetadataDictionaryForVm(VM vm, Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary, ArrayList<DiskImage> allVmImages) {
    String vmMeta = generateVmMetadata(vm, allVmImages);
    metaDictionary.put(vm.getId(), new KeyValuePairCompat<String, List<Guid>>(vmMeta, LinqUtils.foreach(vm.getDiskMap().values(), new Function<Disk, Guid>() {

        @Override
        public Guid eval(Disk a) {
            return a.getId();
        }
    })));
    return vmMeta;
}
#end_block

#method_before
@Override
public Templates list() {
    Templates templates = new Templates();
    if (QueryHelper.hasMatrixParam(getUriInfo(), UNREGISTERED_CONSTRAINT_PARAMETER)) {
        List<org.ovirt.engine.core.common.businessentities.VmTemplate> unregisteredTemplates = getBackendCollection(VdcQueryType.GetUnregisteredVmTemplates, new UnregisteredEntitiesQueryParameters(storageDomainId, VmEntityType.TEMPLATE.name()));
        List<Template> collection = new ArrayList<Template>();
        for (org.ovirt.engine.core.common.businessentities.VmTemplate entity : unregisteredTemplates) {
            Template vmTemplate = map(entity);
            collection.add(addLinks(populate(vmTemplate, entity)));
        }
        templates.getTemplates().addAll(collection);
    }
    templates.getTemplates().addAll(getCollection());
    return templates;
}
#method_after
@Override
public Templates list() {
    Templates templates = new Templates();
    if (QueryHelper.hasMatrixParam(getUriInfo(), UNREGISTERED_CONSTRAINT_PARAMETER)) {
        List<org.ovirt.engine.core.common.businessentities.VmTemplate> unregisteredTemplates = getBackendCollection(VdcQueryType.GetUnregisteredVmTemplates, new UnregisteredEntitiesQueryParameters(storageDomainId));
        List<Template> collection = new ArrayList<Template>();
        for (org.ovirt.engine.core.common.businessentities.VmTemplate entity : unregisteredTemplates) {
            Template vmTemplate = map(entity);
            collection.add(addLinks(populate(vmTemplate, entity)));
        }
        templates.getTemplates().addAll(collection);
    } else {
        templates.getTemplates().addAll(getCollection());
    }
    return templates;
}
#end_block

#method_before
@Override
public VMs list() {
    VMs vms = new VMs();
    if (QueryHelper.hasMatrixParam(getUriInfo(), UNREGISTERED_CONSTRAINT_PARAMETER)) {
        List<org.ovirt.engine.core.common.businessentities.VM> unregisteredVms = getBackendCollection(VdcQueryType.GetUnregisteredVms, new UnregisteredEntitiesQueryParameters(storageDomainId, VmEntityType.VM.name()));
        List<VM> collection = new ArrayList<VM>();
        for (org.ovirt.engine.core.common.businessentities.VM entity : unregisteredVms) {
            VM vm = map(entity);
            collection.add(addLinks(populate(vm, entity)));
        }
        vms.getVMs().addAll(collection);
    }
    vms.getVMs().addAll(getCollection());
    return vms;
}
#method_after
@Override
public VMs list() {
    VMs vms = new VMs();
    if (QueryHelper.hasMatrixParam(getUriInfo(), UNREGISTERED_CONSTRAINT_PARAMETER)) {
        List<org.ovirt.engine.core.common.businessentities.VM> unregisteredVms = getBackendCollection(VdcQueryType.GetUnregisteredVms, new UnregisteredEntitiesQueryParameters(storageDomainId));
        List<VM> collection = new ArrayList<VM>();
        for (org.ovirt.engine.core.common.businessentities.VM entity : unregisteredVms) {
            VM vm = map(entity);
            collection.add(addLinks(populate(vm, entity)));
        }
        vms.getVMs().addAll(collection);
    } else {
        vms.getVMs().addAll(getCollection());
    }
    return vms;
}
#end_block

#method_before
@Override
public Response performRemove(String id) {
    RemoveVmFromImportExportParameters params = new RemoveVmFromImportExportParameters(GuidUtils.asGuid(id), storageDomainId, getDataCenterId(storageDomainId));
    return performAction(VdcActionType.RemoveVmFromImportExport, params);
}
#method_after
@Override
public Response performRemove(String id) {
    RemoveVmFromImportExportParameters params = new RemoveVmFromImportExportParameters(asGuid(id), storageDomainId, getDataCenterId(storageDomainId));
    return performAction(VdcActionType.RemoveVmFromImportExport, params);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    fakeScheduler = new FakeGWTScheduler();
    CommunicationProvider communicationsProvider = new GWTRPCCommunicationProvider(mockService, mockEventBus);
    OperationProcessor operationProcessor = new OperationProcessor(communicationsProvider);
    operationProcessor.setScheduler(fakeScheduler);
    VdcOperationManager operationsManager = new VdcOperationManager(operationProcessor);
    operationsManager.setLoggedIn(true);
    frontend = new Frontend(operationsManager, mockCanDoActionErrorsTranslator, mockVdsmErrorsTranslator, mockEventBus);
    frontend.setEventsHandler(mockEventsHandler);
    frontend.setConstants(mockConstants);
    frontend.frontendFailureEvent = mockFrontendFailureEvent;
    frontend.setLoginHandler(mockLoginHandler);
    when(mockAsyncQuery.getDel()).thenReturn(mockAsyncCallback);
}
#method_after
@Before
public void setUp() throws Exception {
    mockService = mock(GenericApiGWTServiceAsync.class, withSettings().extraInterfaces(ServiceDefTarget.class));
    fakeScheduler = new FakeGWTScheduler();
    CommunicationProvider communicationsProvider = new GWTRPCCommunicationProvider(mockService);
    OperationProcessor operationProcessor = new OperationProcessor(communicationsProvider);
    operationProcessor.setScheduler(fakeScheduler);
    VdcOperationManager operationsManager = new VdcOperationManager(operationProcessor);
    operationsManager.setLoggedIn(true);
    frontend = new Frontend(operationsManager, mockCanDoActionErrorsTranslator, mockVdsmErrorsTranslator, mockEventBus);
    frontend.setEventsHandler(mockEventsHandler);
    frontend.setConstants(mockConstants);
    frontend.frontendFailureEvent = mockFrontendFailureEvent;
    frontend.setLoginHandler(mockLoginHandler);
    when(mockAsyncQuery.getDel()).thenReturn(mockAsyncCallback);
    when(mockConstants.noCanDoActionMessage()).thenReturn(NO_MESSAGE);
}
#end_block

#method_before
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_actionMessageSize_1_or_less() {
    VdcFault testFault = new VdcFault();
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    Object testState = new Object();
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, false);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Descriptions should match", // $NON-NLS-1$ //$NON-NLS-2$
    "This is a description", failureCaptor.getValue().getMessage().getDescription());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    "No Message", failureCaptor.getValue().getMessage().getText());
}
#method_after
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_actionMessageSize_1_or_less() {
    VdcFault testFault = new VdcFault();
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    Object testState = new Object();
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, false);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Descriptions should match", // $NON-NLS-1$ //$NON-NLS-2$
    "This is a description", failureCaptor.getValue().getMessages().get(0).getDescription());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    NO_MESSAGE, failureCaptor.getValue().getMessages().get(0).getText());
}
#end_block

#method_before
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_withActionMessageSize1() {
    VdcFault testFault = new VdcFault();
    // $NON-NLS-1$
    ArrayList<String> translatedErrors = new ArrayList<String>(Arrays.asList("Translated Message 1"));
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    when(mockCanDoActionErrorsTranslator.translateErrorText(any(ArrayList.class))).thenReturn(translatedErrors);
    Object testState = new Object();
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 1");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, false);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Descriptions should match", // $NON-NLS-1$ //$NON-NLS-2$
    "This is a description", failureCaptor.getValue().getMessage().getDescription());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match translation", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 1", failureCaptor.getValue().getMessage().getText());
}
#method_after
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_withActionMessageSize1() {
    VdcFault testFault = new VdcFault();
    // $NON-NLS-1$
    ArrayList<String> translatedErrors = new ArrayList<String>(Arrays.asList("Translated Message 1"));
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    when(mockCanDoActionErrorsTranslator.translateErrorText(any(ArrayList.class))).thenReturn(translatedErrors);
    Object testState = new Object();
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 1");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, false);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Descriptions should match", // $NON-NLS-1$ //$NON-NLS-2$
    "This is a description", failureCaptor.getValue().getMessages().get(0).getDescription());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match translation", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 1", failureCaptor.getValue().getMessages().get(0).getText());
}
#end_block

#method_before
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_withActionMessageSizeGreaterThan1() {
    VdcFault testFault = new VdcFault();
    ArrayList<String> translatedErrors = new ArrayList<String>(Arrays.asList("Translated Message 1", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 2"));
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    when(mockCanDoActionErrorsTranslator.translateErrorText(any(ArrayList.class))).thenReturn(translatedErrors);
    Object testState = new Object();
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 1");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 2");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, false);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    // $NON-NLS-1$
    assertNull("Message should be null", failureCaptor.getValue().getMessage());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 1", failureCaptor.getValue().getMessages().get(0).getText());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 2", failureCaptor.getValue().getMessages().get(1).getText());
}
#method_after
@Test
public void testHandleActionResult_isRaiseErrorModalPanel_withActionMessageSizeGreaterThan1() {
    VdcFault testFault = new VdcFault();
    ArrayList<String> translatedErrors = new ArrayList<String>(Arrays.asList("Translated Message 1", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 2"));
    when(mockEventsHandler.isRaiseErrorModalPanel(VdcActionType.AddDisk, testFault)).thenReturn(true);
    when(mockCanDoActionErrorsTranslator.translateErrorText(any(ArrayList.class))).thenReturn(translatedErrors);
    Object testState = new Object();
    VdcActionParametersBase testParameters = new VdcActionParametersBase();
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setFault(testFault);
    // $NON-NLS-1$
    returnValue.setDescription("This is a description");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 1");
    // $NON-NLS-1$
    returnValue.getCanDoActionMessages().add("Message 2");
    // Yes this is the default, but to make sure.
    returnValue.setCanDoAction(false);
    frontend.handleActionResult(VdcActionType.AddDisk, testParameters, returnValue, mockActionCallback, testState, false);
    verify(mockActionCallback).executed(callbackParam.capture());
    // $NON-NLS-1$
    assertEquals("Parameters should match", testParameters, callbackParam.getValue().getParameters());
    // $NON-NLS-1$
    assertEquals("Result should match", returnValue, callbackParam.getValue().getReturnValue());
    // $NON-NLS-1$
    assertEquals("States should match", testState, callbackParam.getValue().getState());
    assertEquals(// $NON-NLS-1$
    "Action type should match", // $NON-NLS-1$
    VdcActionType.AddDisk, callbackParam.getValue().getActionType());
    ArgumentCaptor<FrontendFailureEventArgs> failureCaptor = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), failureCaptor.capture());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 1", failureCaptor.getValue().getMessages().get(0).getText());
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Text should match", // $NON-NLS-1$ //$NON-NLS-2$
    "Translated Message 2", failureCaptor.getValue().getMessages().get(1).getText());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    fakeScheduler = new FakeGWTScheduler();
    CommunicationProvider communicationsProvider = new GWTRPCCommunicationProvider(mockService, mockEventBus);
    OperationProcessor operationProcessor = new OperationProcessor(communicationsProvider);
    operationProcessor.setScheduler(fakeScheduler);
    VdcOperationManager operationsManager = new VdcOperationManager(operationProcessor);
    operationsManager.setLoggedIn(true);
    frontend = new Frontend(operationsManager, mockCanDoActionErrorsTranslator, mockVdsmErrorsTranslator, mockEventBus);
    frontend.queryCompleteEvent = queryCompleteEvent;
    frontend.queryStartedEvent = queryStartEvent;
    frontend.frontendFailureEvent = mockFrontendFailureEvent;
    frontend.frontendNotLoggedInEvent = mockFrontendNotLoggedInEvent;
    frontend.subscribe(new VdcQueryType[] { VdcQueryType.Search });
    frontend.setEventsHandler(mockEventsHandler);
    frontend.setConstants(mockConstants);
    // $NON-NLS-1$
    when(mockAsyncQuery.getContext()).thenReturn("test");
    when(mockAsyncQuery.getDel()).thenReturn(mockAsyncCallback);
}
#method_after
@Before
public void setUp() throws Exception {
    mockService = mock(GenericApiGWTServiceAsync.class, withSettings().extraInterfaces(ServiceDefTarget.class));
    fakeScheduler = new FakeGWTScheduler();
    CommunicationProvider communicationsProvider = new GWTRPCCommunicationProvider(mockService);
    OperationProcessor operationProcessor = new OperationProcessor(communicationsProvider);
    operationProcessor.setScheduler(fakeScheduler);
    VdcOperationManager operationsManager = new VdcOperationManager(operationProcessor);
    operationsManager.setLoggedIn(true);
    frontend = new Frontend(operationsManager, mockCanDoActionErrorsTranslator, mockVdsmErrorsTranslator, mockEventBus);
    frontend.queryCompleteEvent = queryCompleteEvent;
    frontend.queryStartedEvent = queryStartEvent;
    frontend.frontendFailureEvent = mockFrontendFailureEvent;
    frontend.frontendNotLoggedInEvent = mockFrontendNotLoggedInEvent;
    frontend.subscribe(new VdcQueryType[] { VdcQueryType.Search });
    frontend.setEventsHandler(mockEventsHandler);
    frontend.setConstants(mockConstants);
    // $NON-NLS-1$
    when(mockAsyncQuery.getContext()).thenReturn("test");
    when(mockAsyncQuery.getDel()).thenReturn(mockAsyncCallback);
}
#end_block

#method_before
@Test
public void testRunMultipleQueries_404_failure() {
    // Don't immediately call process until both queries are in the queue.
    fakeScheduler.setThreshold(2);
    when(mockConstants.requestToServerFailedWithCode()).thenReturn(// $NON-NLS-1$
    "A Request to the Server failed with the following Status Code");
    ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
    queryTypeList.add(VdcQueryType.Search);
    queryTypeList.add(VdcQueryType.Search);
    ArrayList<VdcQueryParametersBase> queryParamsList = new ArrayList<VdcQueryParametersBase>();
    // $NON-NLS-1$
    queryParamsList.add(new SearchParameters("*win*", SearchType.VM));
    // $NON-NLS-1$
    queryParamsList.add(new SearchParameters("*lin*", SearchType.VM));
    // $NON-NLS-1$
    frontend.runMultipleQueries(queryTypeList, queryParamsList, mockMultipleQueryCallback, "test");
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, // $NON-NLS-1$
    "404 status code");
    // Repeat 4 times, because of retries.
    for (int i = 1; i < RETRY_COUNT; i++) {
        // Reset the count so we can re-add both entries again.
        fakeScheduler.resetCount();
        verify(mockService, times(i)).RunMultipleQueries(eq(queryTypeList), eq(queryParamsList), callbackMultipleQueries.capture());
        // Call the failure handler.
        callbackMultipleQueries.getValue().onFailure(exception);
    }
    ArgumentCaptor<FrontendFailureEventArgs> eventArgs = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), eventArgs.capture());
    assertEquals(// $NON-NLS-1$
    "Message text didn't match", // $NON-NLS-1$
    "A Request to the Server failed with the following Status Code: 404", eventArgs.getValue().getMessage().getText());
}
#method_after
@Test
public void testRunMultipleQueries_404_failure() {
    // Don't immediately call process until both queries are in the queue.
    fakeScheduler.setThreshold(2);
    when(mockConstants.requestToServerFailedWithCode()).thenReturn(// $NON-NLS-1$
    "A Request to the Server failed with the following Status Code");
    ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
    queryTypeList.add(VdcQueryType.Search);
    queryTypeList.add(VdcQueryType.Search);
    ArrayList<VdcQueryParametersBase> queryParamsList = new ArrayList<VdcQueryParametersBase>();
    // $NON-NLS-1$
    queryParamsList.add(new SearchParameters("*win*", SearchType.VM));
    // $NON-NLS-1$
    queryParamsList.add(new SearchParameters("*lin*", SearchType.VM));
    // $NON-NLS-1$
    frontend.runMultipleQueries(queryTypeList, queryParamsList, mockMultipleQueryCallback, "test");
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, // $NON-NLS-1$
    "404 status code");
    // Repeat 4 times, because of retries.
    for (int i = 1; i < RETRY_COUNT; i++) {
        // Reset the count so we can re-add both entries again.
        fakeScheduler.resetCount();
        verify(mockService, times(i)).RunMultipleQueries(eq(queryTypeList), eq(queryParamsList), callbackMultipleQueries.capture());
        // Call the failure handler.
        callbackMultipleQueries.getValue().onFailure(exception);
    }
    ArgumentCaptor<FrontendFailureEventArgs> eventArgs = ArgumentCaptor.forClass(FrontendFailureEventArgs.class);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), eventArgs.capture());
    assertEquals(// $NON-NLS-1$
    "Message text didn't match", // $NON-NLS-1$
    "A Request to the Server failed with the following Status Code: 404", eventArgs.getValue().getMessages().get(0).getText());
}
#end_block

#method_before
protected void handleAutoLogin(AutoLoginData autoLoginData) {
    final DbUser loggedUser = autoLoginData.getDbUser();
    // Use deferred command because CommonModel change needs to happen
    // after all model providers have been properly initialized
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            lockInteractionManager.showLoadingIndicator();
            getLoginModel().autoLogin(loggedUser);
        }
    });
    SSOTokenChangeEvent.fire(eventBus, SSOTokenData.instance().getSsoToken());
    // Indicate that the user should be logged in automatically
    user.setAutoLogin(true);
}
#method_after
protected void handleAutoLogin(AutoLoginData autoLoginData) {
    final DbUser loggedUser = autoLoginData.getDbUser();
    // Use deferred command because CommonModel change needs to happen
    // after all model providers have been properly initialized
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            lockInteractionManager.showLoadingIndicator();
            getLoginModel().autoLogin(loggedUser);
        }
    });
    SSOTokenChangeEvent.fire(eventBus, SSOTokenData.instance().getToken());
    // Indicate that the user should be logged in automatically
    user.setAutoLogin(true);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    testProvider = new GWTRPCCommunicationProvider(mockService, mockEventBus);
}
#method_after
@Before
public void setUp() throws Exception {
    mockService = mock(GenericApiGWTServiceAsync.class, withSettings().extraInterfaces(ServiceDefTarget.class));
    testProvider = new GWTRPCCommunicationProvider(mockService);
}
#end_block

#method_before
@Override
public VdcReturnValueBase Login(String userName, String password, String profileName, VdcActionType loginType) {
    LoginUserParameters params = new LoginUserParameters(profileName, userName, password);
    HttpSession originalSession = getSession();
    // Prevent session fixation.
    getSession().invalidate();
    // Calling getSession again after invalidating it should create a new session.
    HttpSession newSession = getSession();
    // $NON-NLS-1$
    assert !newSession.equals(originalSession) : "new session the same as old session";
    params.setSessionId(getSession().getId());
    params.setActionType(loginType);
    VdcReturnValueBase returnValue = getBackend().login(params);
    if (returnValue.getSucceeded()) {
        // $NON-NLS-1$
        this.getThreadLocalResponse().addHeader("X-SSO-TOKEN", getSession().getId());
    }
    return returnValue;
}
#method_after
@Override
public VdcReturnValueBase Login(String userName, String password, String profileName, VdcActionType loginType) {
    LoginUserParameters params = new LoginUserParameters(profileName, userName, password);
    HttpSession originalSession = getSession();
    // Prevent session fixation.
    getSession().invalidate();
    // Calling getSession again after invalidating it should create a new session.
    HttpSession newSession = getSession();
    // $NON-NLS-1$
    assert !newSession.equals(originalSession) : "new session the same as old session";
    params.setSessionId(getSession().getId());
    params.setActionType(loginType);
    VdcReturnValueBase returnValue = getBackend().login(params);
    if (returnValue.getSucceeded()) {
        // $NON-NLS-1$
        this.getThreadLocalResponse().addHeader("OVIRT-SSO-TOKEN", getSession().getId());
    }
    return returnValue;
}
#end_block

#method_before
public void initHandlers(EventBus eventBus) {
    if (ssoTokenHandlerRegistration != null) {
        ssoTokenHandlerRegistration.removeHandler();
    }
    // Register to listen for session id acquired events.
    ssoTokenHandlerRegistration = eventBus.addHandler(SSOTokenChangeEvent.getType(), new SSOTokenChangeHandler() {

        @Override
        public void onSSOTokenChange(SSOTokenChangeEvent event) {
            ssoToken = event.getSsoToken();
            checkIfInitFinished();
        }
    });
}
#method_after
public void initHandlers(EventBus eventBus) {
    if (ssoTokenHandlerRegistration != null) {
        ssoTokenHandlerRegistration.removeHandler();
    }
    // Register to listen for session id acquired events.
    ssoTokenHandlerRegistration = eventBus.addHandler(SSOTokenChangeEvent.getType(), new SSOTokenChangeHandler() {

        @Override
        public void onSSOTokenChange(SSOTokenChangeEvent event) {
            ReportInit.this.ssoToken = event.getToken();
            if (ReportInit.this.ssoToken == null) {
                // This should not happen
                // This will make the login continue, just the reports will be broken.
                ReportInit.this.ssoToken = "";
            }
            checkIfInitFinished();
        }
    });
}
#end_block

#method_before
protected void setComparator(Comparator<T> comparator) {
    if (comparator == this.comparator) {
        return;
    }
    this.comparator = comparator;
    Iterable<T> items = getItems();
    if (items == null) {
        return;
    }
    Collection<T> identicalItems = (comparator == null) ? new ArrayList<T>() : new TreeSet<T>(comparator);
    for (T item : items) {
        identicalItems.add(item);
    }
    setItems(identicalItems);
}
#method_after
@Override
public void setComparator(Comparator<? super T> comparator, boolean sortAscending) {
    super.setComparator(comparator, sortAscending);
    Collection<T> items = getItems();
    if (items != null) {
        Collection<T> maybeSortedItems = (comparator != null) ? sortItems(items) : new ArrayList<T>(items);
        setItems(maybeSortedItems);
    }
}
#end_block

#method_before
@Override
public void setItems(Collection<T> value) {
    if (items != value) {
        T lastSelectedItem = getSelectedItem();
        List<T> lastSelectedItems = new ArrayList<T>();
        if (getSelectedItems() != null) {
            for (T item : getSelectedItems()) {
                lastSelectedItems.add(item);
            }
        }
        if (comparator == null || ((value instanceof SortedSet) && (((SortedSet) value).comparator() == comparator))) {
            itemsChanging(value, items);
            items = value;
        } else {
            TreeSet<T> sortedValue = null;
            if (value != null) {
                sortedValue = new TreeSet<T>(comparator);
                for (T item : value) {
                    sortedValue.add(item);
                }
            }
            itemsChanging(sortedValue, items);
            items = sortedValue;
        }
        updatePagingAvailability();
        getItemsChangedEvent().raise(this, EventArgs.EMPTY);
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Items"));
        selectedItem = null;
        if (getSelectedItems() != null) {
            getSelectedItems().clear();
        }
        if (lastSelectedItem != null && items != null) {
            T newSelectedItem = null;
            List<T> newItems = new ArrayList<T>();
            for (T item : items) {
                newItems.add(item);
            }
            if (newItems != null) {
                newSelectedItem = determineSelectedItems(newItems, lastSelectedItem, lastSelectedItems);
            }
            if (newSelectedItem != null) {
                selectedItem = newSelectedItem;
                if (selectedItems != null) {
                    selectedItems.add(newSelectedItem);
                }
            }
        }
        onSelectedItemChanged();
    }
}
#method_after
@Override
public void setItems(Collection<T> value) {
    if (items != value) {
        T lastSelectedItem = getSelectedItem();
        List<T> lastSelectedItems = new ArrayList<T>();
        if (getSelectedItems() != null) {
            for (T item : getSelectedItems()) {
                lastSelectedItems.add(item);
            }
        }
        if (comparator == null || ((value instanceof SortedSet) && ObjectUtils.objectsEqual(((SortedSet<?>) value).comparator(), comparator))) {
            itemsChanging(value, items);
            items = value;
        } else {
            Collection<T> sortedItems = sortItems(value);
            itemsChanging(sortedItems, items);
            items = sortedItems;
        }
        updatePagingAvailability();
        getItemsChangedEvent().raise(this, EventArgs.EMPTY);
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Items"));
        selectedItem = null;
        if (getSelectedItems() != null) {
            getSelectedItems().clear();
        }
        if (lastSelectedItem != null && items != null) {
            T newSelectedItem = null;
            List<T> newItems = new ArrayList<T>();
            for (T item : items) {
                newItems.add(item);
            }
            if (newItems != null) {
                newSelectedItem = determineSelectedItems(newItems, lastSelectedItem, lastSelectedItems);
            }
            if (newSelectedItem != null) {
                selectedItem = newSelectedItem;
                if (selectedItems != null) {
                    selectedItems.add(newSelectedItem);
                }
            }
        }
        onSelectedItemChanged();
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<Set<String>, Set<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Set<String>> problematicNicsWithNetworks = new HashMap<String, Set<String>>();
    try {
        reportNicStatusChanges();
        problematicNicsWithNetworks = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!problematicNicsWithNetworks.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String problematicNicsWithNetworksString = constructNicsWithNetworksString(problematicNicsWithNetworks);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.infoFormat("Host '{0}' moved to Non-Operational state because interface/s which are down are needed by required network/s in the current cluster: '{1}'", _vds.getName(), problematicNicsWithNetworksString);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("NicsWithNetworks", problematicNicsWithNetworksString);
                logable.setCustomId(problematicNicsWithNetworksString);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    DbFacade dbFacade = getDbFacade();
    check(dbFacade.getVdsDao(), VdcActionType.ActivateVds, new DoWithClosure<VDS, VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase doWith(final VDS arg) {
            final VdsActionParameters params = new VdsActionParameters(arg.getId());
            params.setRunSilent(true);
            return params;
        }
    }, new FilterClosure<VDS>() {

        @Override
        public List<VDS> filter(List<VDS> list) {
            List<VDS> filtered = new ArrayList<>(list.size());
            List<VdsNetworkInterface> nics;
            for (VDS vds : list) {
                if (vds.getNonOperationalReason() == NonOperationalReason.NETWORK_INTERFACE_IS_DOWN) {
                    getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
                    nics = vds.getInterfaces();
                } else {
                    nics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(vds.getId());
                }
                Pair<Set<String>, Set<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(nics, getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId()));
                if (problematicNics.getFirst().isEmpty()) {
                    filtered.add(vds);
                }
            }
            return filtered;
        }
    }, "hosts");
    check(dbFacade.getStorageDomainDao(), VdcActionType.ConnectDomainToStorage, new DoWithClosure<StorageDomain, VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase doWith(final StorageDomain arg) {
            final StorageDomainPoolParametersBase params = new StorageDomainPoolParametersBase(arg.getId(), arg.getStoragePoolId());
            params.setRunSilent(true);
            return params;
        }
    }, new FilterClosure<StorageDomain>() {

        @Override
        public List<StorageDomain> filter(List<StorageDomain> list) {
            return list;
        }
    }, "storage domains");
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    DbFacade dbFacade = getDbFacade();
    check(dbFacade.getVdsDao(), VdcActionType.ActivateVds, new DoWithClosure<VDS, VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase doWith(final VDS arg) {
            final VdsActionParameters params = new VdsActionParameters(arg.getId());
            params.setRunSilent(true);
            return params;
        }
    }, new FilterClosure<VDS>() {

        @Override
        public List<VDS> filter(List<VDS> list) {
            List<VDS> filtered = new ArrayList<>(list.size());
            List<VdsNetworkInterface> nics;
            for (VDS vds : list) {
                if (vds.getNonOperationalReason() == NonOperationalReason.NETWORK_INTERFACE_IS_DOWN) {
                    getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
                    nics = vds.getInterfaces();
                } else {
                    nics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(vds.getId());
                }
                Map<String, Set<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(nics, getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId()));
                if (problematicNics.isEmpty()) {
                    filtered.add(vds);
                }
            }
            return filtered;
        }
    }, "hosts");
    check(dbFacade.getStorageDomainDao(), VdcActionType.ConnectDomainToStorage, new DoWithClosure<StorageDomain, VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase doWith(final StorageDomain arg) {
            final StorageDomainPoolParametersBase params = new StorageDomainPoolParametersBase(arg.getId(), arg.getStoragePoolId());
            params.setRunSilent(true);
            return params;
        }
    }, new FilterClosure<StorageDomain>() {

        @Override
        public List<StorageDomain> filter(List<StorageDomain> list) {
            return list;
        }
    }, "storage domains");
}
#end_block

#method_before
public static Pair<Set<String>, Set<String>> determineProblematicNics(List<VdsNetworkInterface> interfaces, List<Network> clusterNetworks) {
    Set<String> networks = new HashSet<String>();
    Set<String> brokenNics = new HashSet<String>();
    Map<String, Network> networksByName = NetworkUtils.networksByName(clusterNetworks);
    for (VdsNetworkInterface iface : interfaces) {
        if (isRequiredInterfaceDown(networksByName, interfaces, iface)) {
            brokenNics.add(NetworkUtils.stripVlan(iface));
            networks.add(iface.getNetworkName());
        }
    }
    return new Pair<Set<String>, Set<String>>(brokenNics, networks);
}
#method_after
public static Map<String, Set<String>> determineProblematicNics(List<VdsNetworkInterface> interfaces, List<Network> clusterNetworks) {
    Map<String, Set<String>> brokenNicsToNetworks = new HashMap<>();
    Map<String, Network> networksByName = NetworkUtils.networksByName(clusterNetworks);
    for (VdsNetworkInterface iface : interfaces) {
        if (isRequiredInterfaceDown(networksByName, interfaces, iface)) {
            String baseNicName = NetworkUtils.stripVlan(iface);
            Set<String> networks = brokenNicsToNetworks.get(baseNicName);
            if (networks == null) {
                networks = new HashSet<String>();
                brokenNicsToNetworks.put(baseNicName, networks);
            }
            networks.add(iface.getNetworkName());
        }
    }
    return brokenNicsToNetworks;
}
#end_block

#method_before
private static boolean isRequiredInterfaceDown(Map<String, Network> networksByName, List<VdsNetworkInterface> interfaces, VdsNetworkInterface iface) {
    if (iface.getNetworkName() != null && !isBaseInterfaceUp(iface, interfaces) && networksByName.containsKey(iface.getNetworkName())) {
        Network net = networksByName.get(iface.getNetworkName());
        if (net.getCluster().getStatus() == NetworkStatus.OPERATIONAL && net.getCluster().isRequired()) {
            return true;
        }
    }
    return false;
}
#method_after
private static boolean isRequiredInterfaceDown(Map<String, Network> networksByName, List<VdsNetworkInterface> interfaces, VdsNetworkInterface iface) {
    if (iface.getNetworkName() != null && isBaseInterfaceDown(iface, interfaces)) {
        Network net = networksByName.get(iface.getNetworkName());
        if (net != null && net.getCluster().getStatus() == NetworkStatus.OPERATIONAL && net.getCluster().isRequired()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, VM vm, VmBase vmBase, boolean isVm, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, boolean copySnapshotDevices) {
    Guid id;
    String isoPath = vmBase.getIsoPath();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    boolean hasSoundDevice = false;
    boolean hasAlreadyConsoleDevice = false;
    boolean hasVirtioScsiController = false;
    for (VmDevice device : devicesDataToUse) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        id = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, specParams, true, true, null);
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(vmBase, isBalloonEnabled);
        }
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                        id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    // check here is source VM had CD (Vm from snapshot)
                    String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                    shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
                    if (!hasAlreadyCD && shouldHaveCD) {
                        setCdPath(specParams, srcCdPath, isoPath);
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                    id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsiController = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (isVm) {
                    // to the new VMStatic params
                    continue;
                } else {
                    specParams.putAll(getMemExpr(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci()));
                }
                break;
            case BALLOON:
                specParams.put(VdsProperties.Model, VdsProperties.Virtio);
                break;
            case SMARTCARD:
                specParams = new SmartcardSpecParams();
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                hasAlreadyConsoleDevice = true;
                if (!isConsoleEnabled) {
                    continue;
                }
                break;
            case SOUND:
                hasSoundDevice = true;
                if (!soundDeviceEnabled) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if source doesnt have sound device and requested, add it
    if (soundDeviceEnabled && !hasSoundDevice) {
        if (isVm) {
            addSoundCard(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion());
        } else {
            VDSGroup cluster = vmBase.getVdsGroupId() != null ? DbFacade.getInstance().getVdsGroupDao().get(vmBase.getVdsGroupId()) : null;
            if (cluster != null) {
                addSoundCard(vmBase, cluster.getcompatibility_version());
            }
        }
    }
    if (isConsoleEnabled && !hasAlreadyConsoleDevice) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsiController) {
        addVirtioScsiController(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
        int numOfMonitors = (vmBase.getDefaultDisplayType() == DisplayType.vnc) ? Math.max(1, vmBase.getNumOfMonitors()) : vmBase.getSingleQxlPci() ? 1 : vmBase.getNumOfMonitors();
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vmBase);
        }
    }
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, VM vm, VmBase vmBase, boolean isVm, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, boolean copySnapshotDevices) {
    Guid id;
    String isoPath = vmBase.getIsoPath();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    boolean hasSoundDevice = false;
    boolean hasAlreadyConsoleDevice = false;
    boolean hasVirtioScsiController = false;
    for (VmDevice device : devicesDataToUse) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        id = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, specParams, true, true, null);
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(vmBase, isBalloonEnabled);
        }
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                        id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    // check here is source VM had CD (Vm from snapshot)
                    String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                    shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
                    if (!hasAlreadyCD && shouldHaveCD) {
                        setCdPath(specParams, srcCdPath, isoPath);
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                    id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsiController = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (isVm) {
                    // to the new VMStatic params
                    continue;
                } else {
                    specParams.putAll(getMemExpr(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci()));
                }
                break;
            case BALLOON:
                specParams.put(VdsProperties.Model, VdsProperties.Virtio);
                break;
            case SMARTCARD:
                specParams = new SmartcardSpecParams();
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                hasAlreadyConsoleDevice = true;
                if (!isConsoleEnabled) {
                    continue;
                }
                break;
            case SOUND:
                hasSoundDevice = true;
                if (!soundDeviceEnabled) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if source doesnt have sound device and requested, add it
    if (soundDeviceEnabled && !hasSoundDevice) {
        if (isVm) {
            addSoundCard(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion());
        } else {
            VDSGroup cluster = vmBase.getVdsGroupId() != null ? DbFacade.getInstance().getVdsGroupDao().get(vmBase.getVdsGroupId()) : null;
            if (cluster != null) {
                addSoundCard(vmBase, cluster.getcompatibility_version());
            }
        }
    }
    if (isConsoleEnabled && !hasAlreadyConsoleDevice) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsiController) {
        addVirtioScsiController(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
        int numOfMonitors = (vmBase.getDefaultDisplayType() == DisplayType.vnc) ? Math.max(1, vmBase.getNumOfMonitors()) : vmBase.getSingleQxlPci() ? 1 : vmBase.getNumOfMonitors();
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vmBase);
        }
    }
}
#end_block

#method_before
@Mapping(from = VmRngDevice.class, to = RngDevice.class)
public static RngDevice map(VmRngDevice entity, RngDevice template) {
    RngDevice model = (template == null) ? new RngDevice() : template;
    if (entity.getBytes() != null) {
        model.setRate(new Rate());
        model.getRate().setBytes(entity.getBytes());
        if (entity.getPeriod() != null) {
            model.getRate().setPeriod(entity.getPeriod());
        }
    }
    model.setSource(entity.getSource().toString());
    return model;
}
#method_after
@Mapping(from = VmRngDevice.class, to = RngDevice.class)
public static RngDevice map(VmRngDevice entity, RngDevice template) {
    RngDevice model = (template == null) ? new RngDevice() : template;
    if (entity.getBytes() != null) {
        model.setRate(new Rate());
        model.getRate().setBytes(entity.getBytes());
        if (entity.getPeriod() != null) {
            model.getRate().setPeriod(entity.getPeriod());
        }
    }
    RngSource restSource = map(entity.getSource(), null);
    model.setSource(restSource.toString());
    return model;
}
#end_block

#method_before
@Mapping(from = RngDevice.class, to = VmRngDevice.class)
public static VmRngDevice map(RngDevice model, VmRngDevice template) {
    if (model != null && model.isSetSource()) {
        VmRngDevice dev = new VmRngDevice();
        if (model.isSetRate()) {
            dev.setBytes(model.getRate().getBytes());
            if (model.getRate().isSetPeriod()) {
                dev.setPeriod(model.getRate().getPeriod());
            }
        }
        VmRngDevice.Source source = VmRngDevice.Source.valueOf(model.getSource());
        if (source != null) {
            dev.setSource(source);
            return dev;
        }
    }
    return null;
}
#method_after
@Mapping(from = VmRngDevice.Source.class, to = RngSource.class)
public static RngSource map(VmRngDevice.Source backend, RngSource rest) {
    if (backend != null) {
        return RngSource.fromValue(backend.name());
    }
    return null;
}
#end_block

#method_before
@Mapping(from = RngDevice.class, to = VmRngDevice.class)
public static VmRngDevice map(RngDevice model, VmRngDevice template) {
    if (model != null && model.isSetSource()) {
        VmRngDevice dev = new VmRngDevice();
        if (model.isSetRate()) {
            dev.setBytes(model.getRate().getBytes());
            if (model.getRate().isSetPeriod()) {
                dev.setPeriod(model.getRate().getPeriod());
            }
        }
        VmRngDevice.Source source = VmRngDevice.Source.valueOf(model.getSource());
        if (source != null) {
            dev.setSource(source);
            return dev;
        }
    }
    return null;
}
#method_after
@Mapping(from = RngDevice.class, to = VmRngDevice.class)
public static VmRngDevice map(RngDevice model, VmRngDevice template) {
    if (model != null && model.isSetSource()) {
        VmRngDevice dev = new VmRngDevice();
        if (model.isSetRate()) {
            dev.setBytes(model.getRate().getBytes());
            if (model.getRate().isSetPeriod()) {
                dev.setPeriod(model.getRate().getPeriod());
            }
        }
        RngSource restSource = RngSource.fromValue(model.getSource());
        VmRngDevice.Source source = VmRngDevice.Source.valueOf(restSource.name());
        if (source != null) {
            dev.setSource(source);
            return dev;
        }
    }
    return null;
}
#end_block

#method_before
protected void verifyQuery(AbstractStatisticalQuery<VM, org.ovirt.engine.core.common.businessentities.VM> query, org.ovirt.engine.core.common.businessentities.VM entity) throws Exception {
    assertEquals(VM.class, query.getParentType());
    assertSame(entity, query.resolve(GUIDS[0]));
    List<Statistic> statistics = query.getStatistics(entity);
    verifyStatistics(statistics, new String[] { "memory.installed", "memory.used", "cpu.current.guest", "cpu.current.hypervisor", "cpu.current.total" }, new BigDecimal[] { asDec(10 * Mb), asDec(2 * Mb), asDec(30), asDec(40), asDec(70) });
    Statistic adopted = query.adopt(new Statistic());
    assertTrue(adopted.isSetVm());
    assertEquals(GUIDS[0].toString(), adopted.getVm().getId());
}
#method_after
protected void verifyQuery(AbstractStatisticalQuery<VM, org.ovirt.engine.core.common.businessentities.VM> query, org.ovirt.engine.core.common.businessentities.VM entity) throws Exception {
    assertEquals(VM.class, query.getParentType());
    assertSame(entity, query.resolve(GUIDS[0]));
    List<Statistic> statistics = query.getStatistics(entity);
    verifyStatistics(statistics, new String[] { "memory.installed", "memory.used", "cpu.current.guest", "cpu.current.hypervisor", "cpu.current.total", "migration.progress" }, new BigDecimal[] { asDec(10 * Mb), asDec(2 * Mb), asDec(30), asDec(40), asDec(70), asDec(50) });
    Statistic adopted = query.adopt(new Statistic());
    assertTrue(adopted.isSetVm());
    assertEquals(GUIDS[0].toString(), adopted.getVm().getId());
}
#end_block

#method_before
@Override
public VM get() {
    VM vm = performGet(VdcQueryType.GetVmByVmId, new IdQueryParameters(guid));
    return removeRestrictedInfo(vm);
}
#method_after
@Override
public VM get() {
    VM vm;
    if (isNextRunRequested()) {
        vm = performGet(VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(guid));
    } else {
        vm = performGet(VdcQueryType.GetVmByVmId, new IdQueryParameters(guid));
    }
    return removeRestrictedInfo(vm);
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(VM incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), lookupCluster(updated.getVdsGroupId())));
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    if (incoming.isSetPayloads()) {
        if (incoming.isSetPayloads() && incoming.getPayloads().isSetPayload()) {
            params.setVmPayload(parent.getPayload(incoming));
        } else {
            params.setClearPayload(true);
        }
    }
    if (incoming.isSetMemoryPolicy() && incoming.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(incoming.getMemoryPolicy().isBallooning());
    }
    if (incoming.isSetConsole() && incoming.getConsole().isSetEnabled()) {
        params.setConsoleEnabled(incoming.getConsole().isEnabled());
    }
    if (incoming.isSetVirtioScsi()) {
        params.setVirtioScsiEnabled(incoming.getVirtioScsi().isEnabled());
    }
    if (incoming.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    return params;
}
#method_after
@Override
public VdcActionParametersBase getParameters(VM incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), lookupCluster(updated.getVdsGroupId())));
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    params.setApplyChangesLater(isNextRunRequested());
    if (incoming.isSetPayloads()) {
        if (incoming.isSetPayloads() && incoming.getPayloads().isSetPayload()) {
            params.setVmPayload(parent.getPayload(incoming));
        } else {
            params.setClearPayload(true);
        }
    }
    if (incoming.isSetMemoryPolicy() && incoming.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(incoming.getMemoryPolicy().isBallooning());
    }
    if (incoming.isSetConsole() && incoming.getConsole().isSetEnabled()) {
        params.setConsoleEnabled(incoming.getConsole().isEnabled());
    }
    if (incoming.isSetVirtioScsi()) {
        params.setVirtioScsiEnabled(incoming.getVirtioScsi().isEnabled());
    }
    if (incoming.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    return params;
}
#end_block

#method_before
@Test
public void testMapFromBackendToRest() throws Exception {
    VmRngDevice entity = VmRngDevice.create(Guid.Empty, Guid.Empty, 11, 10, VmRngDevice.Source.RANDOM);
    RngDevice expected = new RngDevice();
    expected.setRate(new Rate());
    expected.getRate().setBytes(11);
    expected.getRate().setPeriod(10);
    expected.setSource(VmRngDevice.Source.RANDOM.toString());
    assertEquals(expected.getRate().getBytes(), RngDeviceMapper.map(entity, null).getRate().getBytes());
    assertEquals(expected.getRate().getPeriod(), RngDeviceMapper.map(entity, null).getRate().getPeriod());
    assertEquals(expected.getSource(), RngDeviceMapper.map(entity, null).getSource());
}
#method_after
@Test
public void testMapFromBackendToRest() throws Exception {
    VmRngDevice entity = new VmRngDevice();
    entity.setBytes(11);
    entity.setPeriod(10);
    entity.setSource(VmRngDevice.Source.RANDOM);
    RngDevice expected = new RngDevice();
    expected.setRate(new Rate());
    expected.getRate().setBytes(11);
    expected.getRate().setPeriod(10);
    expected.setSource(VmRngDevice.Source.RANDOM.toString());
    assertEquals(expected.getRate().getBytes(), RngDeviceMapper.map(entity, null).getRate().getBytes());
    assertEquals(expected.getRate().getPeriod(), RngDeviceMapper.map(entity, null).getRate().getPeriod());
    assertEquals(expected.getSource(), RngDeviceMapper.map(entity, null).getSource());
}
#end_block

#method_before
@Test
public void testMapFromRestToBackend() throws Exception {
    RngDevice model = new RngDevice();
    model.setSource(VmRngDevice.Source.HWRNG.toString());
    model.setRate(new Rate());
    model.getRate().setBytes(10);
    model.getRate().setPeriod(11);
    VmRngDevice expected = VmRngDevice.create(null, null, 10, 11, VmRngDevice.Source.HWRNG);
    assertEquals(expected, RngDeviceMapper.map(model, null));
}
#method_after
@Test
public void testMapFromRestToBackend() throws Exception {
    RngDevice model = new RngDevice();
    model.setSource(VmRngDevice.Source.HWRNG.toString());
    model.setRate(new Rate());
    model.getRate().setBytes(10);
    model.getRate().setPeriod(11);
    VmRngDevice expected = new VmRngDevice();
    expected.setBytes(10);
    expected.setPeriod(11);
    expected.setSource(VmRngDevice.Source.HWRNG);
    assertEquals(expected, RngDeviceMapper.map(model, null));
}
#end_block

#method_before
@Test
public void testListIncludeStatistics() throws Exception {
    try {
        accepts.add("application/xml; detail=statistics");
        UriInfo uriInfo = setUpUriExpectations(null);
        org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
        VmStatistics vmStatistics = new VmStatistics();
        vmStatistics.setcpu_sys(0D);
        vmStatistics.setcpu_user(0D);
        vmStatistics.setelapsed_time(0D);
        vmStatistics.setRoundedElapsedTime(0D);
        vmStatistics.setusage_cpu_percent(0);
        vmStatistics.setusage_mem_percent(0);
        vmStatistics.setusage_network_percent(0);
        vm.setStatisticsData(vmStatistics);
        for (int i = 0; i < GUIDS.length - 1; i++) {
            setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[i] }, vm);
        }
        setUpQueryExpectations("");
        collection.setUriInfo(uriInfo);
        List<VM> vms = getCollection();
        assertTrue(vms.get(0).isSetStatistics());
        verifyCollection(vms);
    } finally {
        accepts.clear();
    }
}
#method_after
@Test
public void testListIncludeStatistics() throws Exception {
    try {
        accepts.add("application/xml; detail=statistics");
        UriInfo uriInfo = setUpUriExpectations(null);
        org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
        VmStatistics vmStatistics = new VmStatistics();
        vmStatistics.setcpu_sys(0D);
        vmStatistics.setcpu_user(0D);
        vmStatistics.setelapsed_time(0D);
        vmStatistics.setRoundedElapsedTime(0D);
        vmStatistics.setusage_cpu_percent(0);
        vmStatistics.setusage_mem_percent(0);
        vmStatistics.setusage_network_percent(0);
        vm.setStatisticsData(vmStatistics);
        vm.setMigrationProgressPercent(50);
        for (int i = 0; i < GUIDS.length - 1; i++) {
            setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[i] }, vm);
        }
        setUpQueryExpectations("");
        collection.setUriInfo(uriInfo);
        List<VM> vms = getCollection();
        assertTrue(vms.get(0).isSetStatistics());
        verifyCollection(vms);
    } finally {
        accepts.clear();
    }
}
#end_block

#method_before
@Test
public void testRemoveNonExistant() throws Exception {
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { NON_EXISTANT_GUID }, null);
    control.replay();
    try {
        collection.remove(NON_EXISTANT_GUID.toString());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        assertNotNull(wae.getResponse());
        assertEquals(404, wae.getResponse().getStatus());
    }
}
#method_after
@Test
public void testRemoveNonExistant() throws Exception {
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { NON_EXISTANT_GUID }, null);
    setUriInfo(setUpBasicUriExpectations());
    control.replay();
    try {
        collection.remove(NON_EXISTANT_GUID.toString());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        assertNotNull(wae.getResponse());
        assertEquals(404, wae.getResponse().getStatus());
    }
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.VM setUpStatisticalEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics) {
    expect(entity.getMemSizeMb()).andReturn(10).anyTimes();
    expect(entity.getStatisticsData()).andReturn(statistics).anyTimes();
    expect(statistics.getusage_mem_percent()).andReturn(20).anyTimes();
    expect(statistics.getcpu_user()).andReturn(Double.valueOf(30L)).anyTimes();
    expect(statistics.getcpu_sys()).andReturn(Double.valueOf(40L)).anyTimes();
    expect(statistics.getusage_cpu_percent()).andReturn(50).anyTimes();
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.VM setUpStatisticalEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics) {
    expect(entity.getMemSizeMb()).andReturn(10).anyTimes();
    expect(entity.getStatisticsData()).andReturn(statistics).anyTimes();
    expect(statistics.getusage_mem_percent()).andReturn(20).anyTimes();
    expect(statistics.getcpu_user()).andReturn(Double.valueOf(30L)).anyTimes();
    expect(statistics.getcpu_sys()).andReturn(Double.valueOf(40L)).anyTimes();
    expect(statistics.getusage_cpu_percent()).andReturn(50).anyTimes();
    expect(entity.getMigrationProgressPercent()).andReturn(50).anyTimes();
    return entity;
}
#end_block

#method_before
void initEditors(ApplicationConstants constants) {
    rebalanceHostsTable = new EntityModelCellTable<ListModel>(false, true);
    statusTimeEditor = getInstanceOfDateEditor();
    startTimeEditor = getInstanceOfDateEditor();
    stopTimeEditor = getInstanceOfDateEditor();
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getHostName();
        }
    }, constants.rebalanceSessionHost());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getFilesMoved() + "";
        }
    }, getColumnHeaderForFilesMoved());
    rebalanceHostsTable.addEntityModelColumn(new RebalanceFileSizeColumn<EntityModel>(messages) {

        @Override
        protected Long getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getTotalSizeMoved();
        }
    }, constants.rebalanceSize());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesScanned());
        }
    }, constants.rebalanceScannedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesFailed());
        }
    }, constants.rebalanceFailedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesSkipped());
        }
    }, constants.rebalanceSkippedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getStatus().toString();
        }
    }, constants.rebalanceStatus());
    rebalanceHostsTable.addEntityModelColumn(new HumanReadableTimeColumn<EntityModel>() {

        @Override
        protected Double getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getRunTime();
        }
    }, constants.rebalanceRunTime());
}
#method_after
void initEditors(ApplicationConstants constants) {
    rebalanceHostsTable = new EntityModelCellTable<ListModel>(false, true);
    statusTimeEditor = getInstanceOfDateEditor();
    startTimeEditor = getInstanceOfDateEditor();
    stopTimeEditor = getInstanceOfDateEditor();
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getHostName();
        }
    }, constants.rebalanceSessionHost());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getFilesMoved() + "";
        }
    }, getColumnHeaderForFilesMoved());
    rebalanceHostsTable.addEntityModelColumn(new RebalanceFileSizeColumn<EntityModel>(messages) {

        @Override
        protected Long getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getTotalSizeMoved();
        }
    }, constants.rebalanceSize());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesScanned());
        }
    }, constants.rebalanceScannedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesFailed());
        }
    }, constants.rebalanceFailedFileCount());
    if (isSkippedFileCountNeeded()) {
        rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

            @Override
            protected String getText(GlusterVolumeTaskStatusForHost entity) {
                return String.valueOf(entity.getFilesSkipped());
            }
        }, constants.rebalanceSkippedFileCount());
    }
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getStatus().toString();
        }
    }, constants.rebalanceStatus());
    rebalanceHostsTable.addEntityModelColumn(new HumanReadableTimeColumn<EntityModel>() {

        @Override
        protected Double getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getRunTime();
        }
    }, constants.rebalanceRunTime());
}
#end_block

#method_before
private EntityModelLabelEditor<Date> getInstanceOfDateEditor() {
    return new EntityModelLabelEditor<Date>(new AbstractRenderer<Date>() {

        @Override
        public String render(Date entity) {
            if (entity == null) {
                return constants.unAvailablePropertyLabel();
            }
            return GlusterRebalanceDateTimeRenderer.getLocalizedDateTimeFormat().format(entity);
        }
    }, new Parser<Date>() {

        @Override
        public Date parse(CharSequence text) throws ParseException {
            if (text.toString().isEmpty() || text == null) {
                return null;
            } else {
                return new Date(Date.parse(text.toString()));
            }
        }
    });
}
#method_after
private EntityModelLabelEditor<Date> getInstanceOfDateEditor() {
    return new EntityModelLabelEditor<Date>(new AbstractRenderer<Date>() {

        @Override
        public String render(Date entity) {
            if (entity == null) {
                return constants.unAvailablePropertyLabel();
            }
            return GlusterRebalanceDateTimeRenderer.getLocalizedDateTimeFormat().format(entity);
        }
    }, new Parser<Date>() {

        @Override
        public Date parse(CharSequence text) throws ParseException {
            if (text == null || text.toString().isEmpty()) {
                return null;
            } else {
                return new Date(Date.parse(text.toString()));
            }
        }
    });
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmType().setIsChangable(true);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    AsyncDataProvider.getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            if (returnValue != null) {
                StoragePool dataCenter = (StoragePool) returnValue;
                final List<StoragePool> dataCenters = new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCenter }));
                initClusters(dataCenters);
            } else {
                ExistingVmModelBehavior behavior = (ExistingVmModelBehavior) model.getBehavior();
                VM currentVm = behavior.vm;
                VDSGroup tempVar = new VDSGroup();
                tempVar.setId(currentVm.getVdsGroupId());
                tempVar.setName(currentVm.getVdsGroupName());
                tempVar.setcompatibility_version(currentVm.getVdsGroupCompatibilityVersion());
                tempVar.setStoragePoolId(currentVm.getStoragePoolId());
                VDSGroup cluster = tempVar;
                DataCenterWithCluster dataCenterWithCluster = new DataCenterWithCluster(null, cluster);
                model.getDataCenterWithClustersList().setItems(Arrays.asList(dataCenterWithCluster));
                model.getDataCenterWithClustersList().setSelectedItem(Arrays.asList(dataCenterWithCluster));
                behavior.initTemplate();
                behavior.initCdImage();
                behavior.initSoundCard(vm.getId());
            }
        }
    }, getModel().getHash()), vm.getStoragePoolId());
    AsyncDataProvider.GetWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            VdcQueryReturnValue val = (VdcQueryReturnValue) returnValue;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = (Collection<VmWatchdog>) val.getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction() == null ? null : watchdog.getAction().name().toLowerCase());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel() == null ? "" : watchdog.getModel().name());
            }
        }
    }), vm.getId());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(getVm().getVmInit() != null);
    getModel().getVmInitModel().init(getVm().getStaticData());
    getModel().getVmType().setIsChangable(true);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getInstanceTypes().setIsChangable(!vm.isRunning());
    loadDataCenter();
    instanceTypeManager = new ExistingVmInstanceTypeManager(getModel(), vm);
}
#end_block

#method_before
protected void initClusters(final List<StoragePool> dataCenters) {
    AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            model.setDataCentersAndClusters(model, dataCenters, (List<VDSGroup>) returnValue, vm.getVdsGroupId());
            initTemplate();
            initCdImage();
            initSoundCard(vm.getId());
        }
    }, getModel().getHash()), true, false);
}
#method_after
protected void initClusters(final List<StoragePool> dataCenters) {
    AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
            List<VDSGroup> filteredClusters = AsyncDataProvider.filterByArchitecture(clusters, vm.getClusterArch());
            model.setDataCentersAndClusters(model, dataCenters, filteredClusters, vm.getVdsGroupId());
            initTemplate();
            initCdImage();
        }
    }, getModel().getHash()), true, false);
}
#end_block

#method_before
@Override
public void template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getComment().setEntity(vm.getComment());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOsId());
    getModel().getDomain().setSelectedItem(vm.getVmDomain());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getIsSingleQxlEnabled().setEntity(vm.getSingleQxlPci());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isRunning());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsRunAndPause().setEntity(vm.isRunAndPause());
    getModel().getIsRunAndPause().setIsChangable(!vm.isRunning());
    getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(!vm.isRunning());
    getModel().getCoresPerSocket().setIsChangable(!vm.isRunning());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().setEntity(vm.getCustomProperties());
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
    updateCpuSharesSelection();
    Frontend.RunQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmWatchdog> watchdogs = (List<VmWatchdog>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (watchdogs.isEmpty()) {
                getModel().getWatchdogAction().setSelectedItem(null);
                getModel().getWatchdogModel().setSelectedItem(null);
            } else {
                VmWatchdog vmWatchdog = watchdogs.get(0);
                getModel().getWatchdogAction().setSelectedItem(vmWatchdog.getAction() == null ? null : vmWatchdog.getAction().name().toLowerCase());
                getModel().getWatchdogModel().setSelectedItem(vmWatchdog.getModel() == null ? "" : vmWatchdog.getModel().name());
            }
        }
    }));
    Frontend.RunQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmRngDevice> devs = (List<VmRngDevice>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (devs.isEmpty()) {
                getModel().getIsRngEnabled().setEntity(false);
            } else {
                VmRngDevice dev = devs.get(0);
                getModel().getRngDevice().setEntity(dev);
            }
        }
    }));
    updateConsoleDevice(getVm().getId());
    getModel().getVncKeyboardLayout().setSelectedItem(vm.getVncKeyboardLayout());
    Frontend.RunQuery(VdcQueryType.IsBalloonEnabled, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            getModel().getMemoryBalloonDeviceEnabled().setEntity(((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    }));
    if (vm.isInitialized()) {
        UIConstants constants = ConstantsManager.getInstance().getConstants();
        getModel().getTimeZone().setChangeProhibitionReason(constants.timeZoneCannotBeChangedAfterVMInit());
        getModel().getTimeZone().setIsChangable(false);
    }
    updateTimeZone(vm.getTimeZone());
    // Update domain list
    updateDomain();
    updateHostPinning(vm.getMigrationSupport());
    getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (Object item : getModel().getDisplayProtocol().getItems()) {
        EntityModel model = (EntityModel) item;
        DisplayType displayType = (DisplayType) model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(item);
            break;
        }
    }
    initPriority(vm.getPriority());
}
#method_after
@Override
public void template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getComment().setEntity(vm.getComment());
    getModel().getOSType().setSelectedItem(vm.getVmOsId());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsRunAndPause().setEntity(vm.isRunAndPause());
    getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().selectSsoMethod(vm.getSsoMethod());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
    updateCpuSharesSelection();
    getModel().getVncKeyboardLayout().setSelectedItem(vm.getDefaultVncKeyboardLayout());
    updateRngDevice(getVm().getId());
    updateTimeZone(vm.getTimeZone());
    getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    if (isHotSetCpuSupported()) {
        // cancel related events while fetching data
        getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
        getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
        getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
        AsyncDataProvider.getHostById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ExistingVmModelBehavior existingVmModelBehavior = (ExistingVmModelBehavior) model;
                runningOnHost = (VDS) returnValue;
                hostCpu = calculateHostCpus();
                existingVmModelBehavior.updateNumOfSockets();
            }
        }), vm.getRunOnVds());
    }
    BuilderExecutor.build(vm.getStaticData(), getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
    getModel().getBootMenuEnabled().setEntity(vm.isBootMenuEnabled());
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateCustomPropertySheet();
    updateNumOfSockets();
    updateQuotaByCluster(vm.getQuotaId(), vm.getQuotaName());
    updateCpuPinningVisibility();
    initNetworkInterfaces();
    updateMemoryBalloon();
    updateCpuSharesAvailability();
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateCustomPropertySheet();
    updateNumOfSockets();
    updateQuotaByCluster(vm.getQuotaId(), vm.getQuotaName());
    updateCpuPinningVisibility();
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateOSValues();
    instanceTypeManager.updateAll();
}
#end_block

#method_before
@Override
public void updateMinAllocatedMemory() {
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    VDSGroup cluster = dataCenterWithCluster.getCluster();
    if (cluster == null) {
        return;
    }
    if ((Integer) getModel().getMemSize().getEntity() < vm.getVmMemSizeMb()) {
        double overCommitFactor = 100.0 / cluster.getmax_vds_memory_over_commit();
        getModel().getMinAllocatedMemory().setEntity((int) ((Integer) getModel().getMemSize().getEntity() * overCommitFactor));
    } else {
        getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    }
}
#method_after
@Override
public void updateMinAllocatedMemory() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    VDSGroup cluster = dataCenterWithCluster.getCluster();
    if (cluster == null) {
        return;
    }
    if (getModel().getMemSize().getEntity() < vm.getVmMemSizeMb()) {
        double overCommitFactor = 100.0 / cluster.getmax_vds_memory_over_commit();
        getModel().getMinAllocatedMemory().setEntity((int) ((Integer) getModel().getMemSize().getEntity() * overCommitFactor));
    } else {
        getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    }
}
#end_block

#method_before
public void initTemplate() {
    setupTemplate(vm, getModel().getTemplate());
}
#method_after
protected void initTemplate() {
    setupTemplate(vm.getVmtGuid(), vm.isUseLatestVersion());
}
#end_block

#method_before
private void onExport() {
    ExportVmModel model = (ExportVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VmTemplate a = (VmTemplate) item;
        if (a.getId().equals(Guid.Empty)) {
            continue;
        }
        MoveOrCopyParameters tempVar = new MoveOrCopyParameters(a.getId(), ((StorageDomain) model.getStorage().getSelectedItem()).getId());
        tempVar.setForceOverride((Boolean) model.getForceOverride().getEntity());
        list.add(tempVar);
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.ExportVmTemplate, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ExportVmModel localModel = (ExportVmModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onExport() {
    ExportVmModel model = (ExportVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.startProgress(null);
    getTemplatesNotPresentOnExportDomain();
}
#end_block

#method_before
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.VmTemplate);
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#method_after
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.VmTemplate, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#end_block

#method_before
private void edit() {
    VmTemplate template = (VmTemplate) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(createBehavior(template));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("edit_template");
    model.getVmType().setSelectedItem(template.getVmType());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand("OnSave", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#method_after
private void edit() {
    VmTemplate template = (VmTemplate) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            vmInitLoaded((VmTemplate) result);
        }
    };
    AsyncDataProvider.getTemplateById(getVmInitQuery, template.getId());
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeTemplatesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_template");
    model.setMessage(ConstantsManager.getInstance().getConstants().templatesMsg());
    ArrayList<String> items = new ArrayList<String>();
    ArrayList<VmTemplate> templates = Linq.<VmTemplate>cast(getSelectedItems());
    for (VmTemplate template : templates) {
        if (!template.getId().equals(Guid.Empty)) {
            items.add(template.getName());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeTemplatesTitle());
    model.setHelpTag(HelpTag.remove_template);
    // $NON-NLS-1$
    model.setHashName("remove_template");
    ArrayList<String> items = new ArrayList<String>();
    ArrayList<VmTemplate> templates = Linq.<VmTemplate>cast(getSelectedItems());
    for (VmTemplate template : templates) {
        if (!template.getId().equals(Guid.Empty)) {
            items.add(template.getName());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VmTemplate a = (VmTemplate) item;
        list.add(new VmTemplateParametersBase(a.getId()));
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.RemoveVmTemplate, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VmTemplate a = (VmTemplate) item;
        list.add(new VmTemplateParametersBase(a.getId()));
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveVmTemplate, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void onSave() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate()) {
        return;
    }
    String name = (String) model.getName().getEntity();
    AsyncDataProvider.isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            TemplateListModel templateListModel = (TemplateListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            templateListModel.postNameUniqueCheck(isNameUnique);
        }
    }), name);
}
#method_after
private void onSave() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate()) {
        return;
    }
    String name = model.getName().getEntity();
    if (((TemplateVmModelBehavior) model.getBehavior()).getVmTemplate().isBaseTemplate()) {
        AsyncDataProvider.isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                TemplateListModel templateListModel = (TemplateListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                templateListModel.postNameUniqueCheck(isNameUnique);
            }
        }), name);
    } else {
        postNameUniqueCheck(true);
    }
}
#end_block

#method_before
public void postNameUniqueCheck(boolean isNameUnique) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VmTemplate selectedItem = (VmTemplate) getSelectedItem();
    final VmTemplate template = (VmTemplate) Cloner.clone(selectedItem);
    String name = (String) model.getName().getEntity();
    // Check name unicitate.
    if (!isNameUnique && name.compareToIgnoreCase(template.getName()) != 0) {
        model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
        model.getName().setIsValid(false);
        model.setIsGeneralTabValid(false);
        return;
    }
    // Save changes.
    template.setVmType((VmType) model.getVmType().getSelectedItem());
    template.setName(name);
    template.setOsId((Integer) model.getOSType().getSelectedItem());
    template.setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    template.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    template.setDescription((String) model.getDescription().getEntity());
    template.setComment((String) model.getComment().getEntity());
    // $NON-NLS-1$
    template.setDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    template.setMemSizeMb((Integer) model.getMemSize().getEntity());
    template.setMinAllocatedMem(((Integer) model.getMinAllocatedMemory().getEntity()));
    template.setVdsGroupId((model.getSelectedCluster()).getId());
    template.setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    template.setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    template.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    template.setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    template.setStateless((Boolean) model.getIsStateless().getEntity());
    template.setRunAndPause((Boolean) model.getIsRunAndPause().getEntity());
    template.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    template.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    template.setDefaultBootSequence(model.getBootSequence());
    // $NON-NLS-1$
    template.setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    template.setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    template.setKernelUrl((String) model.getKernel_path().getEntity());
    template.setKernelParams((String) model.getKernel_parameters().getEntity());
    template.setInitrdUrl((String) model.getInitrd_path().getEntity());
    template.setVncKeyboardLayout((String) model.getVncKeyboardLayout().getSelectedItem());
    template.setCreatedByUserId(selectedItem.getCreatedByUserId());
    template.setSingleQxlPci((Boolean) model.getIsSingleQxlEnabled().getEntity());
    if (model.getQuota().getIsAvailable() && model.getQuota().getSelectedItem() != null) {
        template.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    template.setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    template.setPriority((Integer) prioritySelectedItem.getEntity());
    // host migration configuration
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        template.setDedicatedVmForVds(null);
    } else {
        template.setDedicatedVmForVds(defaultHost.getId());
    }
    template.setMigrationSupport((MigrationSupport) model.getMigrationMode().getSelectedItem());
    model.startProgress(null);
    UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
    parameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    setVmRngDeviceToParams(model, parameters);
    parameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
    Frontend.RunAction(VdcActionType.UpdateVmTemplate, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            TemplateListModel localModel = (TemplateListModel) result.getState();
            localModel.postUpdateVmTemplate(result.getReturnValue());
        }
    }, this);
}
#method_after
public void postNameUniqueCheck(boolean isNameUnique) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VmTemplate selectedItem = ((TemplateVmModelBehavior) model.getBehavior()).getVmTemplate();
    final VmTemplate template = (VmTemplate) Cloner.clone(selectedItem);
    String name = model.getName().getEntity();
    // Check name unicitate.
    if (!isNameUnique && name.compareToIgnoreCase(template.getName()) != 0) {
        model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
        model.getName().setIsValid(false);
        model.setIsGeneralTabValid(false);
        return;
    }
    // Save changes.
    buildTemplateOnSave(model, template);
    template.setCreatedByUserId(selectedItem.getCreatedByUserId());
    model.startProgress(null);
    template.setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    setVmRngDeviceToParams(model, parameters);
    Frontend.getInstance().runAction(VdcActionType.UpdateVmTemplate, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            TemplateListModel localModel = (TemplateListModel) result.getState();
            localModel.postUpdateVmTemplate(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
private void setVmWatchdogToParams(final UnitVmModel model, UpdateVmTemplateParameters updateVmParams) {
    VmWatchdogType wdModel = VmWatchdogType.getByName((String) model.getWatchdogModel().getSelectedItem());
    updateVmParams.setUpdateWatchdog(true);
    if (wdModel != null) {
        VmWatchdog vmWatchdog = new VmWatchdog();
        vmWatchdog.setAction(VmWatchdogAction.getByName((String) model.getWatchdogAction().getSelectedItem()));
        vmWatchdog.setModel(wdModel);
        updateVmParams.setWatchdog(vmWatchdog);
    }
}
#method_after
private void setVmWatchdogToParams(final UnitVmModel model, UpdateVmTemplateParameters updateVmParams) {
    VmWatchdogType wdModel = VmWatchdogType.getByName(model.getWatchdogModel().getSelectedItem());
    updateVmParams.setUpdateWatchdog(true);
    if (wdModel != null) {
        VmWatchdog vmWatchdog = new VmWatchdog();
        vmWatchdog.setAction(VmWatchdogAction.getByName(model.getWatchdogAction().getSelectedItem()));
        vmWatchdog.setModel(wdModel);
        updateVmParams.setWatchdog(vmWatchdog);
    }
}
#end_block

#method_before
private void setVmRngDeviceToParams(UnitVmModel model, UpdateVmTemplateParameters parameters) {
    parameters.setUpdateRngDevice(true);
    parameters.setRngDevice((VmRngDevice) model.getRngDevice().getEntity());
}
#method_after
private void setVmRngDeviceToParams(UnitVmModel model, UpdateVmTemplateParameters parameters) {
    parameters.setUpdateRngDevice(true);
    parameters.setRngDevice(model.getIsRngEnabled().getEntity() ? model.generateRngDevice() : null);
}
#end_block

#method_before
private void cancel() {
    Frontend.Unsubscribe();
    setWindow(null);
}
#method_after
private void cancel() {
    Frontend.getInstance().unsubscribe();
    cancelConfirmation();
    setWindow(null);
    updateActionAvailability();
}
#end_block

#method_before
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (// $NON-NLS-1$
    e.PropertyName.equals("status")) {
        updateActionAvailability();
    }
}
#method_after
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (// $NON-NLS-1$
    e.propertyName.equals("status")) {
        updateActionAvailability();
    }
}
#end_block

#method_before
protected void updateActionAvailability() {
    VmTemplate item = (VmTemplate) getSelectedItem();
    ArrayList items = (((ArrayList) getSelectedItems()) != null) ? (ArrayList) getSelectedItems() : new ArrayList();
    boolean blankSelected = isBlankTemplateSelected();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && item != null && item.getStatus() != VmTemplateStatus.Locked);
    if (getEditCommand().getIsExecutionAllowed() && blankSelected) {
        getEditCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeEdited());
        getEditCommand().setIsExecutionAllowed(false);
    }
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VmTemplate.class, VdcActionType.RemoveVmTemplate));
    if (getRemoveCommand().getIsExecutionAllowed() && blankSelected) {
        getRemoveCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeRemoved());
        getRemoveCommand().setIsExecutionAllowed(false);
    }
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VmTemplate.class, VdcActionType.ExportVmTemplate));
    if (getExportCommand().getIsExecutionAllowed() && blankSelected) {
        getExportCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeExported());
        getExportCommand().setIsExecutionAllowed(false);
    }
}
#method_after
protected void updateActionAvailability() {
    VmTemplate item = (VmTemplate) getSelectedItem();
    ArrayList items = ((getSelectedItems()) != null) ? (ArrayList) getSelectedItems() : new ArrayList();
    boolean blankSelected = isBlankTemplateSelected();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && item != null && item.getStatus() != VmTemplateStatus.Locked);
    if (getEditCommand().getIsExecutionAllowed() && blankSelected) {
        getEditCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeEdited());
        getEditCommand().setIsExecutionAllowed(false);
    }
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VmTemplate.class, VdcActionType.RemoveVmTemplate));
    if (getRemoveCommand().getIsExecutionAllowed() && blankSelected) {
        getRemoveCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeRemoved());
        getRemoveCommand().setIsExecutionAllowed(false);
    }
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VmTemplate.class, VdcActionType.ExportVmTemplate));
    if (getExportCommand().getIsExecutionAllowed() && blankSelected) {
        getExportCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeExported());
        getExportCommand().setIsExecutionAllowed(false);
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportTemplateTitle());
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        onExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        onSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportTemplateTitle());
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        doExport();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    }
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    AsyncDataProvider.getDataCenterByClusterServiceList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getstatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    UnitVmModel model = (UnitVmModel) target;
                    model.setDataCentersAndClusters(model, dataCenters, (List<VDSGroup>) returnValue, null);
                    initCdImage();
                }
            }, getModel().getHash()), true, false);
        }
    }, getModel().getHash()), true, false);
    initPriority(0);
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    AsyncDataProvider.getDataCenterByClusterServiceList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (!dataCenters.isEmpty()) {
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        List<VDSGroup> clusterList = (List<VDSGroup>) returnValue;
                        List<VDSGroup> filteredClusterList = AsyncDataProvider.filterClustersWithoutArchitecture(clusterList);
                        model.setDataCentersAndClusters(model, dataCenters, filteredClusterList, null);
                        initCdImage();
                    }
                }, getModel().getHash()), true, false);
            } else {
                getModel().disableEditing(ConstantsManager.getInstance().getConstants().notAvailableWithNoUpDC());
            }
        }
    }, getModel().getHash()), true, false);
    initPriority(0);
    getModel().getVmInitModel().init(null);
    instanceTypeManager = new NewVmInstanceTypeManager(getModel());
}
#end_block

#method_before
@Override
public void template_SelectedItemChanged() {
    VmTemplate template = (VmTemplate) getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(template.getOsId());
        getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
        getModel().getDomain().setSelectedItem(template.getDomain());
        getModel().getMemSize().setEntity(template.getMemSizeMb());
        getModel().setBootSequence(template.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
        updateHostPinning(template.getMigrationSupport());
        doChangeDefautlHost(template.getDedicatedVmForVds());
        getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
        getModel().getIsStateless().setEntity(template.isStateless());
        getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getIsoPath());
        }
        updateConsoleDevice(template.getId());
        updateTimeZone(template.getTimeZone());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel displayProtocol = null;
        boolean isFirst = true;
        for (Object item : getModel().getDisplayProtocol().getItems()) {
            EntityModel a = (EntityModel) item;
            if (isFirst) {
                displayProtocol = a;
                isFirst = false;
            }
            DisplayType dt = (DisplayType) a.getEntity();
            if (dt == template.getDefaultDisplayType()) {
                displayProtocol = a;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(template.getKernelUrl());
        getModel().getKernel_parameters().setEntity(template.getKernelParams());
        getModel().getInitrd_path().setEntity(template.getInitrdUrl());
        if (!template.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().getVmType().setSelectedItem(template.getVmType());
            getModel().setIsBlankTemplate(false);
            getModel().getCopyPermissions().setIsAvailable(true);
            initDisks();
            initSoundCard(template.getId());
            setRngDevice(template.getId());
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().getCopyPermissions().setIsAvailable(false);
            getModel().setDisks(null);
        }
        initPriority(template.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (template.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
        }
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
        updateNetworkInterfacesByTemplate(template);
    }
}
#method_after
@Override
public void template_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // Copy VM parameters from template.
        setSelectedOSType(template, getModel().getSelectedCluster().getArchitecture());
        doChangeDefautlHost(template.getDedicatedVmForVds());
        getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
        getModel().selectSsoMethod(template.getSsoMethod());
        getModel().getIsStateless().setEntity(template.isStateless());
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getIsoPath());
        }
        updateTimeZone(template.getTimeZone());
        getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(template.getKernelUrl());
        getModel().getKernel_parameters().setEntity(template.getKernelParams());
        getModel().getInitrd_path().setEntity(template.getInitrdUrl());
        if (!template.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().getVmType().setSelectedItem(template.getVmType());
            getModel().setIsBlankTemplate(false);
            getModel().getCopyPermissions().setIsAvailable(true);
            getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
            initDisks();
            updateRngDevice(template.getId());
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().getCopyPermissions().setIsAvailable(false);
            getModel().setDisks(null);
        }
        initStorageDomains();
        InstanceType selectedInstanceType = getModel().getInstanceTypes().getSelectedItem();
        int instanceTypeMinAllocatedMemory = selectedInstanceType != null ? selectedInstanceType.getMinAllocatedMem() : 0;
        // do not update if specified on template or instance type
        if (template.getMinAllocatedMem() == 0 && instanceTypeMinAllocatedMemory == 0) {
            updateMinAllocatedMemory();
        }
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
        getModel().getVmInitModel().init(template);
        getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
        BuilderExecutor.build(template, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
        getModel().getBootMenuEnabled().setEntity(template.isBootMenuEnabled());
    }
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateCustomPropertySheet();
    updateMinAllocatedMemory();
    updateNumOfSockets();
    if (getModel().getTemplate().getSelectedItem() != null) {
        VmTemplate template = (VmTemplate) getModel().getTemplate().getSelectedItem();
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    }
    updateCpuPinningVisibility();
    updateTemplate();
    initNetworkInterfaces(networkBehavior, null);
    updateMemoryBalloon();
    updateCpuSharesAvailability();
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

        @Override
        public void activated() {
            getInstanceTypeManager().updateAll();
        }
    });
    updateDefaultHost();
    updateCustomPropertySheet();
    updateMinAllocatedMemory();
    updateNumOfSockets();
    if (getModel().getTemplate().getSelectedItem() != null) {
        VmTemplate template = getModel().getTemplate().getSelectedItem();
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    }
    updateCpuPinningVisibility();
    updateTemplate();
    updateOSValues();
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    activateInstanceTypeManager();
}
#end_block

#method_before
@Override
public void provisioning_SelectedItemChanged() {
    boolean provisioning = (Boolean) getModel().getProvisioning().getEntity();
    getModel().getProvisioningThin_IsSelected().setEntity(!provisioning);
    getModel().getProvisioningClone_IsSelected().setEntity(provisioning);
    getModel().getDisksAllocationModel().setIsVolumeFormatAvailable(true);
    getModel().getDisksAllocationModel().setIsVolumeFormatChangable(provisioning);
    getModel().getDisksAllocationModel().setIsAliasChangable(true);
    initStorageDomains();
}
#method_after
@Override
public void provisioning_SelectedItemChanged() {
    boolean provisioning = getModel().getProvisioning().getEntity();
    getModel().getProvisioningThin_IsSelected().setEntity(!provisioning);
    getModel().getProvisioningClone_IsSelected().setEntity(provisioning);
    getModel().getDisksAllocationModel().setIsVolumeFormatAvailable(true);
    getModel().getDisksAllocationModel().setIsVolumeFormatChangable(provisioning);
    getModel().getDisksAllocationModel().setIsAliasChangable(true);
    initStorageDomains();
}
#end_block

#method_before
@Override
public void updateMinAllocatedMemory() {
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getModel().getDataCenterWithClustersList().getSelectedItem();
    VDSGroup cluster = dataCenterWithCluster == null ? null : dataCenterWithCluster.getCluster();
    if (cluster == null) {
        return;
    }
    double overCommitFactor = 100.0 / cluster.getmax_vds_memory_over_commit();
    getModel().getMinAllocatedMemory().setEntity((int) ((Integer) getModel().getMemSize().getEntity() * overCommitFactor));
}
#method_after
@Override
public void updateMinAllocatedMemory() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    VDSGroup cluster = dataCenterWithCluster == null ? null : dataCenterWithCluster.getCluster();
    if (cluster == null) {
        return;
    }
    double overCommitFactor = 100.0 / cluster.getmax_vds_memory_over_commit();
    getModel().getMinAllocatedMemory().setEntity((int) (getModel().getMemSize().getEntity() * overCommitFactor));
}
#end_block

#method_before
private void updateTemplate() {
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getModel().getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain storage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        AsyncDataProvider.getTemplateListByDataCenter(new AsyncQuery(new Object[] { this, storage }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target1, Object returnValue1) {
                Object[] array1 = (Object[]) target1;
                NewVmModelBehavior behavior1 = (NewVmModelBehavior) array1[0];
                StorageDomain storage1 = (StorageDomain) array1[1];
                AsyncDataProvider.getTemplateListByStorage(new AsyncQuery(new Object[] { behavior1, returnValue1 }, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target2, Object returnValue2) {
                        Object[] array2 = (Object[]) target2;
                        NewVmModelBehavior behavior2 = (NewVmModelBehavior) array2[0];
                        ArrayList<VmTemplate> templatesByDataCenter = (ArrayList<VmTemplate>) array2[1];
                        ArrayList<VmTemplate> templatesByStorage = (ArrayList<VmTemplate>) returnValue2;
                        VmTemplate blankTemplate = Linq.firstOrDefault(templatesByDataCenter, new Linq.TemplatePredicate(Guid.Empty));
                        if (blankTemplate != null) {
                            templatesByStorage.add(0, blankTemplate);
                        }
                        behavior2.postInitTemplate((ArrayList<VmTemplate>) returnValue2);
                    }
                }), storage1.getId());
            }
        }, getModel().getHash()), dataCenter.getId());
    } else {
        AsyncDataProvider.getTemplateListByDataCenter(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                NewVmModelBehavior behavior = (NewVmModelBehavior) target;
                behavior.postInitTemplate((ArrayList<VmTemplate>) returnValue);
            }
        }, getModel().getHash()), dataCenter.getId());
    }
}
#method_after
private void updateTemplate() {
    final DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getModel().getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain storage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        AsyncDataProvider.getTemplateListByDataCenter(new AsyncQuery(new Object[] { this, storage }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target1, Object returnValue1) {
                Object[] array1 = (Object[]) target1;
                NewVmModelBehavior behavior1 = (NewVmModelBehavior) array1[0];
                StorageDomain storage1 = (StorageDomain) array1[1];
                AsyncDataProvider.getTemplateListByStorage(new AsyncQuery(new Object[] { behavior1, returnValue1 }, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target2, Object returnValue2) {
                        Object[] array2 = (Object[]) target2;
                        NewVmModelBehavior behavior2 = (NewVmModelBehavior) array2[0];
                        List<VmTemplate> templatesByDataCenter = (List<VmTemplate>) array2[1];
                        List<VmTemplate> templatesByStorage = (List<VmTemplate>) returnValue2;
                        VmTemplate blankTemplate = Linq.firstOrDefault(templatesByDataCenter, new Linq.TemplatePredicate(Guid.Empty));
                        if (blankTemplate != null) {
                            templatesByStorage.add(0, blankTemplate);
                        }
                        List<VmTemplate> templateList = AsyncDataProvider.filterTemplatesByArchitecture(templatesByStorage, dataCenterWithCluster.getCluster().getArchitecture());
                        behavior2.postInitTemplate(templateList);
                    }
                }), storage1.getId());
            }
        }, getModel().getHash()), dataCenter.getId());
    } else {
        AsyncDataProvider.getTemplateListByDataCenter(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                NewVmModelBehavior behavior = (NewVmModelBehavior) target;
                List<VmTemplate> templates = (List<VmTemplate>) returnValue;
                behavior.postInitTemplate(AsyncDataProvider.filterTemplatesByArchitecture(templates, dataCenterWithCluster.getCluster().getArchitecture()));
            }
        }, getModel().getHash()), dataCenter.getId());
    }
}
#end_block

#method_before
private void postInitTemplate(ArrayList<VmTemplate> templates) {
    // If there was some template selected before, try select it again.
    VmTemplate oldTemplate = (VmTemplate) getModel().getTemplate().getSelectedItem();
    getModel().getTemplate().setItems(templates);
    getModel().getTemplate().setSelectedItem(Linq.firstOrDefault(templates, oldTemplate != null ? new Linq.TemplatePredicate(oldTemplate.getId()) : new Linq.TemplatePredicate(Guid.Empty)));
    updateIsDisksAvailable();
}
#method_after
private void postInitTemplate(List<VmTemplate> templates) {
    List<VmTemplate> baseTemplates = filterNotBaseTemplates(templates);
    // If there was some template selected before, try select it again.
    VmTemplate prevBaseTemplate = getModel().getBaseTemplate().getSelectedItem();
    getModel().getBaseTemplate().setItems(baseTemplates);
    getModel().getBaseTemplate().setSelectedItem(Linq.firstOrDefault(baseTemplates, new Linq.TemplatePredicate(prevBaseTemplate != null ? prevBaseTemplate.getId() : Guid.Empty)));
    updateIsDisksAvailable();
}
#end_block

#method_before
public void initCdImage() {
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null || dataCenterWithCluster.getDataCenter() == null) {
        return;
    }
    updateUserCdImage(dataCenterWithCluster.getDataCenter().getId());
}
#method_after
public void initCdImage() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null || dataCenterWithCluster.getDataCenter() == null) {
        return;
    }
    updateUserCdImage(dataCenterWithCluster.getDataCenter().getId());
}
#end_block

#method_before
@Override
public void updateIsDisksAvailable() {
    getModel().setIsDisksAvailable(getModel().getDisks() != null && getModel().getProvisioning().getIsChangable());
}
#method_after
@Override
public void updateIsDisksAvailable() {
    getModel().setIsDisksAvailable(getModel().getDisks() != null && !getModel().getDisks().isEmpty() && getModel().getProvisioning().getIsChangable());
}
#end_block

#method_before
@Override
public void vmTypeChanged(VmType vmType) {
    super.vmTypeChanged(vmType);
    // provisioning clone -> true
    if (getModel().getProvisioning().getIsAvailable()) {
        getModel().getProvisioning().setEntity(vmType == VmType.Server);
    }
}
#method_after
@Override
public void vmTypeChanged(VmType vmType) {
    deactivateInstanceTypeManager();
    // provisioning clone -> true
    if (getModel().getProvisioning().getIsAvailable()) {
        getModel().getProvisioning().setEntity(vmType == VmType.Server);
    }
    super.vmTypeChanged(vmType);
    activateInstanceTypeManager();
}
#end_block

#method_before
private void setConsoleHelpers() {
    this.consoleUtils = (ConsoleUtils) TypeResolver.getInstance().resolve(ConsoleUtils.class);
    this.consoleManager = (ConsoleManager) TypeResolver.getInstance().resolve(ConsoleManager.class);
    this.errorPopupManager = (ErrorPopupManager) TypeResolver.getInstance().resolve(ErrorPopupManager.class);
}
#method_after
private void setConsoleHelpers() {
    this.errorPopupManager = (ErrorPopupManager) TypeResolver.getInstance().resolve(ErrorPopupManager.class);
}
#end_block

#method_before
private void assignTags() {
    if (getWindow() != null) {
        return;
    }
    TagListModel model = new TagListModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().assignTagsTitle());
    // $NON-NLS-1$
    model.setHashName("assign_tags_vms");
    getAttachedTagsToSelectedVMs(model);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnAssignTags", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void assignTags() {
    if (getWindow() != null) {
        return;
    }
    TagListModel model = new TagListModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().assignTagsTitle());
    model.setHelpTag(HelpTag.assign_tags_vms);
    // $NON-NLS-1$
    model.setHashName("assign_tags_vms");
    getAttachedTagsToSelectedVMs(model);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnAssignTags", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void getAttachedTagsToSelectedVMs(TagListModel model) {
    ArrayList<Guid> vmIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<org.ovirt.engine.core.common.businessentities.tags>();
    selectedItemsCounter = 0;
    for (Guid id : vmIds) {
        AsyncDataProvider.getAttachedTagsToVm(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                VmListModel vmListModel = (VmListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                vmListModel.allAttachedTags.addAll((ArrayList<org.ovirt.engine.core.common.businessentities.tags>) returnValue);
                vmListModel.selectedItemsCounter++;
                if (vmListModel.selectedItemsCounter == vmListModel.getSelectedItems().size()) {
                    postGetAttachedTags(vmListModel, tagListModel);
                }
            }
        }), id);
    }
}
#method_after
private void getAttachedTagsToSelectedVMs(TagListModel model) {
    ArrayList<Guid> vmIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<Tags>();
    selectedItemsCounter = 0;
    for (Guid id : vmIds) {
        AsyncDataProvider.getAttachedTagsToVm(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                VmListModel vmListModel = (VmListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                vmListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                vmListModel.selectedItemsCounter++;
                if (vmListModel.selectedItemsCounter == vmListModel.getSelectedItems().size()) {
                    postGetAttachedTags(vmListModel, tagListModel);
                }
            }
        }), id);
    }
}
#end_block

#method_before
private void postGetAttachedTags(VmListModel vmListModel, TagListModel tagListModel) {
    if (vmListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<org.ovirt.engine.core.common.businessentities.tags> attachedTags = Linq.distinct(vmListModel.allAttachedTags, new TagsEqualityComparer());
        for (org.ovirt.engine.core.common.businessentities.tags tag : attachedTags) {
            int count = 0;
            for (org.ovirt.engine.core.common.businessentities.tags tag2 : vmListModel.allAttachedTags) {
                if (tag2.gettag_id().equals(tag.gettag_id())) {
                    count++;
                }
            }
            vmListModel.attachedTagsToEntities.put(tag.gettag_id(), count == vmListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(vmListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(vmListModel.getLastExecutedCommand().getName(), "OnAssignTags")) {
        vmListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#method_after
private void postGetAttachedTags(VmListModel vmListModel, TagListModel tagListModel) {
    if (vmListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(vmListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : vmListModel.allAttachedTags) {
                if (tag2.gettag_id().equals(tag.gettag_id())) {
                    count++;
                }
            }
            vmListModel.attachedTagsToEntities.put(tag.gettag_id(), count == vmListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(vmListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(vmListModel.getLastExecutedCommand().getName())) {
        vmListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#end_block

#method_before
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> vmIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<Guid>();
    ArrayList<Guid> tagsToDetach = new ArrayList<Guid>();
    if (model.getItems() != null && ((ArrayList<TagModel>) model.getItems()).size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    for (Guid a : tagsToAttach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.RunMultipleAction(VdcActionType.AttachVmsToTag, parameters);
    parameters = new ArrayList<VdcActionParametersBase>();
    for (Guid a : tagsToDetach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.RunMultipleAction(VdcActionType.DetachVmFromTag, parameters);
    cancel();
}
#method_after
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> vmIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<Guid>();
    ArrayList<Guid> tagsToDetach = new ArrayList<Guid>();
    if (model.getItems() != null && ((ArrayList<TagModel>) model.getItems()).size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    for (Guid a : tagsToAttach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachVmsToTag, parameters);
    parameters = new ArrayList<VdcActionParametersBase>();
    for (Guid a : tagsToDetach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.DetachVmFromTag, parameters);
    cancel();
}
#end_block

#method_before
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = (VM) getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    model.setHelpTag(HelpTag.new_virtual_machine___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = (VM) getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VmGeneralModel());
    list.add(new VmInterfaceListModel());
    VmDiskListModel diskListModel = new VmDiskListModel();
    diskListModel.setSystemTreeContext(this);
    list.add(diskListModel);
    list.add(new VmSnapshotListModel());
    list.add(new VmEventListModel());
    list.add(new VmAppListModel());
    list.add(new PermissionListModel());
    list.add(new VmSessionsModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VmGeneralModel());
    list.add(new VmInterfaceListModel());
    VmDiskListModel diskListModel = new VmDiskListModel();
    diskListModel.setSystemTreeContext(this);
    list.add(diskListModel);
    list.add(new VmSnapshotListModel());
    list.add(new VmEventListModel());
    list.add(new VmAppListModel());
    list.add(new PermissionListModel());
    list.add(new VmAffinityGroupListModel());
    list.add(new VmSessionsModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.VM);
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#method_after
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.VM, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#end_block

#method_before
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void editConsole() {
    if (getWindow() != null) {
        return;
    }
    final HasConsoleModel hasConsoleModel = getSelectedHasConsoleModel();
    if (hasConsoleModel == null) {
        return;
    }
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setConsoleContext(ConsoleContext.WA);
    model.setModel(hasConsoleModel);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForEntity(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    model.setHelpTag(HelpTag.editConsole);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
    }
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    window.setMessage(ConstantsManager.getInstance().getConstants().virtualMachinesMsg());
    vmsRemoveMap = new HashMap<Guid, EntityModel>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    window.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<Guid, EntityModel>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    window.getCommands().add(tempVar2);
}
#end_block

#method_before
private void initRemoveDisksCheckboxes(final Map<Guid, EntityModel> vmsMap) {
    ArrayList<VdcQueryParametersBase> params = new ArrayList<VdcQueryParametersBase>();
    ArrayList<VdcQueryType> queries = new ArrayList<VdcQueryType>();
    for (Entry<Guid, EntityModel> entry : vmsMap.entrySet()) {
        if (entry.getValue().getIsChangable()) {
            // No point in fetching VM disks from ones that already determined
            // is unchangeable since they are already initialized
            params.add(new IdQueryParameters(entry.getKey()));
            queries.add(VdcQueryType.GetAllDisksByVmId);
        }
    }
    // revise when refactoring org.ovirt.engine.ui.Frontend to support runMultipleQuery with a single query
    if (!params.isEmpty()) {
        Frontend.RunMultipleQueries(queries, params, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                for (int i = 0; i < result.getReturnValues().size(); i++) {
                    if (result.getReturnValues().get(i).getSucceeded()) {
                        Guid vmId = ((IdQueryParameters) result.getParameters().get(i)).getId();
                        initRemoveDisksChecboxesPost(vmId, (List<Disk>) result.getReturnValues().get(i).getReturnValue());
                    }
                }
            }
        });
    }
}
#method_after
private void initRemoveDisksCheckboxes(final Map<Guid, EntityModel> vmsMap) {
    ArrayList<VdcQueryParametersBase> params = new ArrayList<VdcQueryParametersBase>();
    ArrayList<VdcQueryType> queries = new ArrayList<VdcQueryType>();
    for (Entry<Guid, EntityModel> entry : vmsMap.entrySet()) {
        if (entry.getValue().getIsChangable()) {
            // No point in fetching VM disks from ones that already determined
            // is unchangeable since they are already initialized
            params.add(new IdQueryParameters(entry.getKey()));
            queries.add(VdcQueryType.GetAllDisksByVmId);
        }
    }
    // revise when refactoring org.ovirt.engine.ui.Frontend to support runMultipleQuery with a single query
    if (!params.isEmpty()) {
        Frontend.getInstance().runMultipleQueries(queries, params, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                for (int i = 0; i < result.getReturnValues().size(); i++) {
                    if (result.getReturnValues().get(i).getSucceeded()) {
                        Guid vmId = ((IdQueryParameters) result.getParameters().get(i)).getId();
                        initRemoveDisksChecboxesPost(vmId, (List<Disk>) result.getReturnValues().get(i).getReturnValue());
                    }
                }
            }
        });
    }
}
#end_block

#method_before
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.setValidateByVmSnapshots(true);
    model.initialize();
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.setCloseCommand(closeCommand);
}
#method_after
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = SnapshotModel.createNewSnapshotModel(this);
    model.setValidateByVmSnapshots(true);
    setWindow(model);
    model.setVm(vm);
    model.initialize();
}
#end_block

#method_before
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveVmParameters parameter = new MoveVmParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride((Boolean) model.getForceOverride().getEntity());
        parameter.setCopyCollapse((Boolean) model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!(Boolean) model.getCollapseSnapshots().getEntity()) {
        if ((missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0)) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnExportNoTemplates", this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("CancelConfirmation", this);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            Frontend.RunMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ExportVmModel localModel = (ExportVmModel) result.getState();
                    localModel.stopProgress();
                    cancel();
                }
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveVmParameters parameter = (MoveVmParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress(null);
        Frontend.RunMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#method_after
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveVmParameters parameter = new MoveVmParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride((Boolean) model.getForceOverride().getEntity());
        parameter.setCopyCollapse((Boolean) model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!(Boolean) model.getCollapseSnapshots().getEntity()) {
        if ((missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0)) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnExportNoTemplates", this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("CancelConfirmation", this);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ExportVmModel localModel = (ExportVmModel) result.getState();
                    localModel.stopProgress();
                    cancel();
                }
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveVmParameters parameter = (MoveVmParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress(null);
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#end_block

#method_before
private void onExportNoTemplates() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        MoveVmParameters parameters = new MoveVmParameters(a.getId(), storageDomainId);
        parameters.setForceOverride((Boolean) model.getForceOverride().getEntity());
        parameters.setCopyCollapse((Boolean) model.getCollapseSnapshots().getEntity());
        parameters.setTemplateMustExists(false);
        list.add(parameters);
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.ExportVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ExportVmModel localModel = (ExportVmModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onExportNoTemplates() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        MoveVmParameters parameters = new MoveVmParameters(a.getId(), storageDomainId);
        parameters.setForceOverride((Boolean) model.getForceOverride().getEntity());
        parameters.setCopyCollapse((Boolean) model.getCollapseSnapshots().getEntity());
        parameters.setTemplateMustExists(false);
        list.add(parameters);
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ExportVmModel localModel = (ExportVmModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void runOnce() {
    VM vm = (VM) getSelectedItem();
    RunOnceModel model = new WebadminRunOnceModel(vm, getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()), this);
    setWindow(model);
    model.init();
}
#method_after
private void runOnce() {
    VM vm = (VM) getSelectedItem();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel((VM) result, VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
}
#end_block

#method_before
private void newTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(vm.getVmType());
    model.initialize(getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnNewTemplate", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().isAutoStartup());
}
#method_after
private void newTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    model.setHelpTag(HelpTag.new_template);
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(vm.getVmType());
    model.initialize(getSystemTreeSelectedItem());
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("OnNewTemplate", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().isAutoStartup());
}
#end_block

#method_before
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        model.setIsValid(false);
    } else {
        String name = (String) model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#method_after
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#end_block

#method_before
public void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType((VmType) model.getVmType().getSelectedItem());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    tempVar.setVmOs((Integer) model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    tempVar.setSingleQxlPci((Boolean) model.getIsSingleQxlEnabled().getEntity());
    tempVar.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(model.getSelectedCluster().getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setStateless((Boolean) model.getIsStateless().getEntity());
    tempVar.setRunAndPause(((Boolean) model.getIsRunAndPause().getEntity()));
    tempVar.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    tempVar.setVncKeyboardLayout(vm.getVncKeyboardLayout());
    VM newvm = tempVar;
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    newvm.setPriority((Integer) prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, (String) model.getName().getEntity(), (String) model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse((Boolean) model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions((Boolean) model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
    Frontend.RunAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#method_after
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    if (model.getIsSubTemplate().getEntity()) {
        addVmTemplateParameters.setBaseTemplateId(model.getBaseTemplate().getSelectedItem().getId());
        addVmTemplateParameters.setTemplateVersionName(model.getTemplateVersionName().getEntity());
    }
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#end_block

#method_before
private void migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>cast(getSelectedItems()));
    AsyncDataProvider.getUpHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            vmListModel.postMigrateGetUpHosts((ArrayList<VDS>) returnValue);
        }
    }), vm.getVdsGroupName());
}
#method_after
private void migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    model.setHelpTag(HelpTag.migrate_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>cast(getSelectedItems()));
    AsyncDataProvider.getUpHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            vmListModel.postMigrateGetUpHosts((ArrayList<VDS>) returnValue);
        }
    }), vm.getVdsGroupName());
}
#end_block

#method_before
private void cancelMigration() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.RunMultipleAction(VdcActionType.CancelMigrateVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void cancelMigration() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.CancelMigrateVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
private void onMigrate() {
    MigrateModel model = (MigrateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress(null);
    if (model.getIsAutoSelect()) {
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            list.add(new MigrateVmParameters(true, a.getId()));
        }
        Frontend.RunMultipleAction(VdcActionType.MigrateVm, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    } else {
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            if (a.getRunOnVds().equals(((VDS) model.getHosts().getSelectedItem()).getId())) {
                continue;
            }
            list.add(new MigrateVmToServerParameters(true, a.getId(), ((VDS) model.getHosts().getSelectedItem()).getId()));
        }
        Frontend.RunMultipleAction(VdcActionType.MigrateVmToServer, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#method_after
private void onMigrate() {
    MigrateModel model = (MigrateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress(null);
    if (model.getIsAutoSelect()) {
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            list.add(new MigrateVmParameters(true, a.getId()));
        }
        Frontend.getInstance().runMultipleAction(VdcActionType.MigrateVm, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    } else {
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            if (a.getRunOnVds().equals(((VDS) model.getHosts().getSelectedItem()).getId())) {
                continue;
            }
            list.add(new MigrateVmToServerParameters(true, a.getId(), ((VDS) model.getHosts().getSelectedItem()).getId()));
        }
        Frontend.getInstance().runMultipleAction(VdcActionType.MigrateVmToServer, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#end_block

#method_before
private void shutdown() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().shutdownVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("shut_down_virtual_machine");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToShutDownTheFollowingVirtualMachinesMsg());
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnShutdown", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void shutdown() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(SHUTDOWN, constants.shutdownVirtualMachinesTitle(), constants.areYouSureYouWantToShutDownTheFollowingVirtualMachinesMsg());
}
#end_block

#method_before
private void onShutdown() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new ShutdownVmParameters(a.getId(), true));
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.ShutdownVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onShutdown() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(VdcActionType.ShutdownVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new ShutdownVmParameters(vm.getId(), true, model.getReason().getEntity());
        }
    });
}
#end_block

#method_before
private void stop() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("stop_virtual_machine");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToStopTheFollowingVirtualMachinesMsg());
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnStop", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void stop() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(STOP, constants.stopVirtualMachinesTitle(), constants.areYouSureYouWantToStopTheFollowingVirtualMachinesMsg());
}
#end_block

#method_before
private void onStop() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new StopVmParameters(a.getId(), StopVmTypeEnum.NORMAL));
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.StopVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onStop() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(VdcActionType.StopVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL, model.getReason().getEntity());
        }
    });
}
#end_block

#method_before
private void pause() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.RunMultipleAction(VdcActionType.HibernateVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void pause() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.HibernateVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
private void run() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new RunVmParams(a.getId()));
    }
    Frontend.RunMultipleAction(VdcActionType.RunVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void run() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new RunVmParams(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.RunVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
private void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Entry<Guid, EntityModel> entry : vmsRemoveMap.entrySet()) {
        list.add(new RemoveVmParameters(entry.getKey(), false, (Boolean) entry.getValue().getEntity()));
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.RemoveVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onRemove() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    final ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Entry<Guid, EntityModel> entry : vmsRemoveMap.entrySet()) {
        list.add(new RemoveVmParameters(entry.getKey(), false, (Boolean) entry.getValue().getEntity()));
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void changeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.EjectLabel);
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                _attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    final VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (StringHelper.stringsEqual(model.getIsoImage().getSelectedItem().toString(), ConsoleModel.EjectLabel)) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem().toString();
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void preSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    final String name = (String) model.getName().getEntity();
    if (model.getIsNew() == false && selectedItem == null) {
        cancel();
        return;
    }
    setcurrentVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem));
    if (!model.validate()) {
        return;
    }
    AsyncDataProvider.isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (!(Boolean) returnValue && name.compareToIgnoreCase(getcurrentVm().getName()) != 0) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setIsGeneralTabValid(false);
            } else {
                model.getName().getInvalidityReasons().clear();
                model.getName().setIsValid(true);
                model.setIsGeneralTabValid(true);
                onSave();
            }
        }
    }), name);
}
#method_after
private void preSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    final String name = model.getName().getEntity();
    if (model.getIsNew() == false && selectedItem == null) {
        cancel();
        return;
    }
    setcurrentVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem));
    if (!model.validate()) {
        return;
    }
    AsyncDataProvider.isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (!(Boolean) returnValue && name.compareToIgnoreCase(getcurrentVm().getName()) != 0) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setIsGeneralTabValid(false);
            } else {
                model.getName().getInvalidityReasons().clear();
                model.getName().setIsValid(true);
                model.setIsGeneralTabValid(true);
                onSave();
            }
        }
    }), name);
}
#end_block

#method_before
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    String name = (String) model.getName().getEntity();
    // Save changes.
    VmTemplate template = (VmTemplate) model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType((VmType) model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    getcurrentVm().setVmOs((Integer) model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setSingleQxlPci((Boolean) model.getIsSingleQxlEnabled().getEntity());
    getcurrentVm().setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setVmDescription((String) model.getDescription().getEntity());
    getcurrentVm().setComment((String) model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless((Boolean) model.getIsStateless().getEntity());
    getcurrentVm().setRunAndPause((Boolean) model.getIsRunAndPause().getEntity());
    getcurrentVm().setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl((String) model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl((String) model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams((String) model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().getEntity());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    getcurrentVm().setPriority((Integer) prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning((String) model.getCpuPinning().getEntity());
    getcurrentVm().setVncKeyboardLayout((String) model.getVncKeyboardLayout().getSelectedItem());
    if (model.getCpuSharesAmount().getIsAvailable() && !model.getCpuSharesAmount().getEntity().toString().equals("")) {
        // $NON-NLS-1$
        try {
            getcurrentVm().setCpuShares(Integer.parseInt(model.getCpuSharesAmount().getEntity().toString()));
        } catch (NumberFormatException ignored) {
        }
    }
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setDedicatedVmForVds(null);
    } else {
        VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
        getcurrentVm().setDedicatedVmForVds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport((MigrationSupport) model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags((Boolean) model.getHostCpu().getEntity());
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            setRngDeviceToParams(model, parameters);
            Frontend.RunAction(VdcActionType.AddVmFromScratch, parameters, new NetworkCreateFrontendAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if ((Boolean) model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                        param.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions((Boolean) model.getCopyPermissions().getEntity());
                        Frontend.RunAction(VdcActionType.AddVmFromTemplate, param, new NetworkCreateOrUpdateFrontendActionAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions((Boolean) model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                setRngDeviceToParams(model, params);
                Frontend.RunAction(VdcActionType.AddVm, params, new NetworkCreateOrUpdateFrontendActionAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.RunAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vmListModel.getcurrentVm());
                        setVmWatchdogToParams(model, updateVmParams);
                        setRngDeviceToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        Frontend.RunAction(VdcActionType.UpdateVm, updateVmParams, new NetworkUpdateFrontendAsyncCallback(model, defaultNetworkCreatingManager, vmListModel.getcurrentVm().getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
            setVmWatchdogToParams(model, updateVmParams);
            setRngDeviceToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            Frontend.RunAction(VdcActionType.UpdateVm, updateVmParams, new NetworkUpdateFrontendAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        final VM selectedItem = (VM) getSelectedItem();
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        getcurrentVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.isNextRunConfigurationChanged(editedVm, getcurrentVm(), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    if (((VdcQueryReturnValue) returnValue).<Boolean>getReturnValue()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(false);
                    }
                }
            }));
        } else {
            updateExistingVm(false);
        }
    }
}
#end_block

#method_before
private boolean balloonEnabled(UnitVmModel model) {
    return (Boolean) model.getMemoryBalloonDeviceEnabled().getEntity() && model.getSelectedCluster().getcompatibility_version().compareTo(BALLOON_DEVICE_MIN_VERSION) >= 0;
}
#method_after
private boolean balloonEnabled(UnitVmModel model) {
    return model.getMemoryBalloonDeviceEnabled().getEntity() && model.getSelectedCluster().getcompatibility_version().compareTo(BALLOON_DEVICE_MIN_VERSION) >= 0;
}
#end_block

#method_before
private void setVmWatchdogToParams(final UnitVmModel model, VmManagementParametersBase updateVmParams) {
    VmWatchdogType wdModel = VmWatchdogType.getByName((String) model.getWatchdogModel().getSelectedItem());
    updateVmParams.setUpdateWatchdog(true);
    if (wdModel != null) {
        VmWatchdog vmWatchdog = new VmWatchdog();
        vmWatchdog.setAction(VmWatchdogAction.getByName((String) model.getWatchdogAction().getSelectedItem()));
        vmWatchdog.setModel(wdModel);
        updateVmParams.setWatchdog(vmWatchdog);
    }
}
#method_after
private void setVmWatchdogToParams(final UnitVmModel model, VmManagementParametersBase updateVmParams) {
    VmWatchdogType wdModel = VmWatchdogType.getByName(model.getWatchdogModel().getSelectedItem());
    updateVmParams.setUpdateWatchdog(true);
    if (wdModel != null) {
        VmWatchdog vmWatchdog = new VmWatchdog();
        vmWatchdog.setAction(VmWatchdogAction.getByName(model.getWatchdogAction().getSelectedItem()));
        vmWatchdog.setModel(wdModel);
        updateVmParams.setWatchdog(vmWatchdog);
    }
}
#end_block

#method_before
private void setRngDeviceToParams(UnitVmModel model, VmManagementParametersBase parameters) {
    parameters.setUpdateRngDevice(true);
    parameters.setRngDevice((VmRngDevice) model.getRngDevice().getEntity());
}
#method_after
private void setRngDeviceToParams(UnitVmModel model, VmManagementParametersBase parameters) {
    parameters.setUpdateRngDevice(true);
    parameters.setRngDevice((Boolean) model.getIsRngEnabled().getEntity() ? model.generateRngDevice() : null);
}
#end_block

#method_before
private void retrieveIsoImages() {
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    getIsoImages().clear();
    ChangeCDModel tempVar2 = new ChangeCDModel();
    tempVar2.setTitle(ConsoleModel.EjectLabel);
    ChangeCDModel ejectModel = tempVar2;
    ejectModel.getExecutedEvent().addListener(this);
    getIsoImages().add(ejectModel);
    ChangeCDModel tempVar4 = new ChangeCDModel();
    tempVar4.setTitle(ConstantsManager.getInstance().getConstants().noCds());
    getIsoImages().add(tempVar4);
}
#method_after
private void retrieveIsoImages() {
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    getIsoImages().clear();
    ChangeCDModel tempVar2 = new ChangeCDModel();
    tempVar2.setTitle(ConsoleModel.getEjectLabel());
    ChangeCDModel ejectModel = tempVar2;
    ejectModel.getExecutedEvent().addListener(this);
    getIsoImages().add(ejectModel);
    ChangeCDModel tempVar4 = new ChangeCDModel();
    tempVar4.setTitle(ConstantsManager.getInstance().getConstants().noCds());
    getIsoImages().add(tempVar4);
}
#end_block

#method_before
private void changeCD(Object sender, EventArgs e) {
    ChangeCDModel model = (ChangeCDModel) sender;
    // TODO: Patch!
    String isoName = model.getTitle();
    if (StringHelper.stringsEqual(isoName, ConstantsManager.getInstance().getConstants().noCds())) {
        return;
    }
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Frontend.RunMultipleAction(VdcActionType.ChangeDisk, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ChangeDiskCommandParameters(vm.getId(), // $NON-NLS-1$
    StringHelper.stringsEqual(isoName, ConsoleModel.EjectLabel) ? "" : isoName) })), new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void changeCD(Object sender, EventArgs e) {
    ChangeCDModel model = (ChangeCDModel) sender;
    // TODO: Patch!
    String isoName = model.getTitle();
    if (ObjectUtils.objectsEqual(isoName, ConstantsManager.getInstance().getConstants().noCds())) {
        return;
    }
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeDisk, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ChangeDiskCommandParameters(vm.getId(), // $NON-NLS-1$
    ObjectUtils.objectsEqual(isoName, ConsoleModel.getEjectLabel()) ? "" : isoName) })), new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
public void cancel() {
    Frontend.Unsubscribe();
    cancelConfirmation();
    setGuideContext(null);
    setWindow(null);
    updateActionAvailability();
}
#method_after
public void cancel() {
    Frontend.getInstance().unsubscribe();
    cancelConfirmation();
    setGuideContext(null);
    setWindow(null);
    updateActionAvailability();
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateConsoleModels();
    updateActionAvailability();
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
}
#end_block

#method_before
@Override
protected void selectedItemsChanged() {
    super.selectedItemsChanged();
    updateConsoleModels();
    updateActionAvailability();
}
#method_after
@Override
protected void selectedItemsChanged() {
    super.selectedItemsChanged();
    updateActionAvailability();
}
#end_block

#method_before
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (// $NON-NLS-1$
    e.PropertyName.equals("status")) {
        updateActionAvailability();
    } else if (// $NON-NLS-1$
    e.PropertyName.equals("display_type")) {
        updateConsoleModels();
    }
}
#method_after
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.propertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.RunVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.StopVm));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#method_after
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm) && AsyncDataProvider.canVmsBePaused(items));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#end_block

#method_before
private boolean isConsoleCommandsExecutionAllowed() {
    final List<HasConsoleModel> list = getSelectedHasConsoleModels();
    if (list == null || list.isEmpty()) {
        return false;
    }
    // return true, if at least one console is available
    for (HasConsoleModel hasConsoleModel : list) {
        final ConsoleProtocol protocol = consoleUtils.determineConnectionProtocol(hasConsoleModel);
        if (consoleUtils.canShowConsole(protocol, hasConsoleModel)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItem() == null ? null : getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForEntity(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ChangeCDModel.executedEventDefinition)) {
        changeCD(sender, args);
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        onExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        onShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        onStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnClone".equals(command.getName())) {
        onClone();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(model.getApplyCpuLater().getEntity());
        cancelConfirmation();
    }
}
#end_block

#method_before
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<HasConsoleModel> list = getSelectedHasConsoleModels();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (HasConsoleModel model : list) {
        final String errorMessage = consoleManager.connectToConsole(model);
        if (errorMessage != null) {
            if (errorMessages == null) {
                errorMessages = new StringBuilder();
            } else {
                // $NON-NLS-1$
                errorMessages.append("\r\n");
            }
            errorMessages.append(model.getVM().getName()).append(// $NON-NLS-1$
            " - ").append(errorMessage);
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#method_after
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForEntity(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getProvisioning().setIsChangable(false);
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    if (template.getStoragePoolId() != null && !template.getStoragePoolId().equals(Guid.Empty)) {
        AsyncDataProvider.getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                final StoragePool dataCenter = (StoragePool) returnValue;
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
                        ArrayList<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
                        // filter clusters supporting virt service only
                        for (VDSGroup cluster : clusters) {
                            if (cluster.supportsVirtService()) {
                                filteredClusters.add(cluster);
                            }
                        }
                        model.setDataCentersAndClusters(model, new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCenter })), filteredClusters, template.getVdsGroupId());
                        AsyncDataProvider.isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                getModel().getIsSoundcardEnabled().setEntity(returnValue);
                                initTemplate();
                                initCdImage();
                            }
                        }), template.getId());
                    }
                }, getModel().getHash()), true, false);
            }
        }, getModel().getHash()), template.getStoragePoolId());
    }
    AsyncDataProvider.GetWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = (Collection<VmWatchdog>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction().name().toLowerCase());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel().name());
            }
        }
    }), template.getId());
    Frontend.RunQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(template.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmRngDevice> devs = (List<VmRngDevice>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (devs.isEmpty()) {
                getModel().getIsRngEnabled().setEntity(false);
            } else {
                VmRngDevice dev = devs.get(0);
                getModel().getRngDevice().setEntity(dev);
            }
        }
    }));
    getModel().getMigrationMode().setSelectedItem(template.getMigrationSupport());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getBaseTemplate().setIsChangable(false);
    getModel().getProvisioning().setIsChangable(false);
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    getModel().getTemplateVersionName().setIsChangable(!template.isBaseTemplate());
    getModel().getName().setIsChangable(template.isBaseTemplate());
    if (template.getStoragePoolId() != null && !template.getStoragePoolId().equals(Guid.Empty)) {
        AsyncDataProvider.getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                final StoragePool dataCenter = (StoragePool) returnValue;
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
                        ArrayList<VDSGroup> clustersSupportingVirt = new ArrayList<VDSGroup>();
                        // filter clusters supporting virt service only
                        for (VDSGroup cluster : clusters) {
                            if (cluster.supportsVirtService()) {
                                clustersSupportingVirt.add(cluster);
                            }
                        }
                        List<VDSGroup> filteredClusters = AsyncDataProvider.filterByArchitecture(clustersSupportingVirt, template.getClusterArch());
                        model.setDataCentersAndClusters(model, new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCenter })), filteredClusters, template.getVdsGroupId());
                        AsyncDataProvider.isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                                initTemplate();
                                initCdImage();
                            }
                        }), template.getId());
                    }
                }, getModel().getHash()), true, false);
            }
        }, getModel().getHash()), template.getStoragePoolId());
    }
    AsyncDataProvider.getWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction().name().toLowerCase());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel().name());
            }
        }
    }), template.getId());
    updateRngDevice(template.getId());
    getModel().getMigrationMode().setSelectedItem(template.getMigrationSupport());
    setupBaseTemplate(template.getBaseTemplateId());
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateNumOfSockets();
    updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    updateMemoryBalloon();
    updateCpuSharesAvailability();
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateNumOfSockets();
    updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateMigrationForLocalSD();
    updateOSValues();
}
#end_block

#method_before
private void initTemplate() {
    // Update model state according to VM properties.
    getModel().getName().setEntity(this.template.getName());
    getModel().getDescription().setEntity(this.template.getDescription());
    getModel().getComment().setEntity(this.template.getComment());
    getModel().getMinAllocatedMemory().setEntity(this.template.getMinAllocatedMem());
    getModel().getMinAllocatedMemory().setIsChangable(false);
    getModel().getMemSize().setEntity(this.template.getMemSizeMb());
    getModel().getOSType().setSelectedItem(this.template.getOsId());
    getModel().getDomain().setSelectedItem(this.template.getDomain());
    getModel().getUsbPolicy().setSelectedItem(this.template.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(this.template.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(this.template.isAllowConsoleReconnect());
    getModel().setBootSequence(this.template.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(this.template.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(this.template.getNumOfCpus()));
    getModel().getNumOfSockets().setSelectedItem(this.template.getNumOfSockets());
    getModel().getIsStateless().setEntity(this.template.isStateless());
    getModel().getIsRunAndPause().setEntity(this.template.isRunAndPause());
    getModel().getIsDeleteProtected().setEntity(this.template.isDeleteProtected());
    getModel().getIsSmartcardEnabled().setEntity(this.template.isSmartcardEnabled());
    getModel().getVncKeyboardLayout().setSelectedItem(this.template.getVncKeyboardLayout());
    getModel().getKernel_parameters().setEntity(this.template.getKernelParams());
    getModel().getKernel_path().setEntity(this.template.getKernelUrl());
    getModel().getInitrd_path().setEntity(this.template.getInitrdUrl());
    getModel().getIsSingleQxlEnabled().setEntity(this.template.getSingleQxlPci());
    updateTimeZone(template.getTimeZone());
    // Update domain list
    updateDomain();
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (Object item : getModel().getDisplayProtocol().getItems()) {
        EntityModel model = (EntityModel) item;
        DisplayType displayType = (DisplayType) model.getEntity();
        if (displayType == this.template.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(item);
            break;
        }
    }
    updateConsoleDevice(template.getId());
    initPriority(this.template.getPriority());
}
#method_after
private void initTemplate() {
    // Update model state according to VM properties.
    getModel().getName().setEntity(template.getName());
    getModel().getDescription().setEntity(template.getDescription());
    getModel().getComment().setEntity(template.getComment());
    getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
    getModel().getMinAllocatedMemory().setIsChangable(false);
    getModel().getMemSize().setEntity(template.getMemSizeMb());
    getModel().getOSType().setSelectedItem(template.getOsId());
    getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
    getModel().setBootSequence(template.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
    getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
    getModel().getIsStateless().setEntity(template.isStateless());
    getModel().getIsRunAndPause().setEntity(template.isRunAndPause());
    getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
    getModel().selectSsoMethod(template.getSsoMethod());
    getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
    getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
    getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
    getModel().getKernel_parameters().setEntity(template.getKernelParams());
    getModel().getKernel_path().setEntity(template.getKernelUrl());
    getModel().getInitrd_path().setEntity(template.getInitrdUrl());
    getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
    updateTimeZone(template.getTimeZone());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == template.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    updateConsoleDevice(template.getId());
    getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
    getModel().getVmInitModel().init(template);
    getModel().getTemplateVersionName().setEntity(template.getTemplateVersionName());
    initPriority(template.getPriority());
    BuilderExecutor.build(template, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
}
#end_block

#method_before
public EntityModel getIsSoundcardEnabled() {
    return isSoundcardEnabled;
}
#method_after
public EntityModel<Boolean> getIsSoundcardEnabled() {
    return isSoundcardEnabled;
}
#end_block

#method_before
private void setIsSoundcardEnabled(NotChangableForVmInPoolEntityModel isSoundcardEnabled) {
    this.isSoundcardEnabled = isSoundcardEnabled;
}
#method_after
private void setIsSoundcardEnabled(NotChangableForVmInPoolEntityModel<Boolean> isSoundcardEnabled) {
    this.isSoundcardEnabled = isSoundcardEnabled;
}
#end_block

#method_before
public ListModel getDataCenterWithClustersList() {
    return dataCenterWithClustersList;
}
#method_after
public ListModel<DataCenterWithCluster> getDataCenterWithClustersList() {
    return dataCenterWithClustersList;
}
#end_block

#method_before
private void setDataCenterWithClustersList(NotChangableForVmInPoolListModel dataCenterWithClustersList) {
    this.dataCenterWithClustersList = dataCenterWithClustersList;
}
#method_after
private void setDataCenterWithClustersList(NotChangableForVmInPoolListModel<DataCenterWithCluster> dataCenterWithClustersList) {
    this.dataCenterWithClustersList = dataCenterWithClustersList;
}
#end_block

#method_before
public ListModel getNicsWithLogicalNetworks() {
    return nicsWithLogicalNetworks;
}
#method_after
public VnicInstancesModel getNicsWithLogicalNetworks() {
    return nicsWithLogicalNetworks;
}
#end_block

#method_before
public void setNicsWithLogicalNetworks(ListModel nicsWithLogicalNetworks) {
    this.nicsWithLogicalNetworks = nicsWithLogicalNetworks;
}
#method_after
public void setNicsWithLogicalNetworks(VnicInstancesModel nicsWithLogicalNetworks) {
    this.nicsWithLogicalNetworks = nicsWithLogicalNetworks;
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsAvailable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
public void setCPUNotification(String value) {
    if (!StringHelper.stringsEqual(cpuNotification, value)) {
        cpuNotification = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("CPUNotification"));
    }
}
#method_after
public void setCPUNotification(String value) {
    if (!ObjectUtils.objectsEqual(cpuNotification, value)) {
        cpuNotification = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("CPUNotification"));
    }
}
#end_block

#method_before
public ListModel getStorageDomain() {
    return privateStorageDomain;
}
#method_after
public ListModel<StorageDomain> getStorageDomain() {
    return privateStorageDomain;
}
#end_block

#method_before
private void setStorageDomain(NotChangableForVmInPoolListModel value) {
    privateStorageDomain = value;
}
#method_after
private void setStorageDomain(NotChangableForVmInPoolListModel<StorageDomain> value) {
    privateStorageDomain = value;
}
#end_block

#method_before
public ListModel getTemplate() {
    return privateTemplate;
}
#method_after
public ListModel<VmTemplate> getTemplate() {
    return privateTemplate;
}
#end_block

#method_before
private void setTemplate(NotChangableForVmInPoolListModel value) {
    privateTemplate = value;
}
#method_after
private void setTemplate(NotChangableForVmInPoolListModel<VmTemplate> value) {
    privateTemplate = value;
}
#end_block

#method_before
public void setVmType(NotChangableForVmInPoolListModel vmType) {
    this.vmType = vmType;
}
#method_after
public void setVmType(NotChangableForVmInPoolListModel<VmType> vmType) {
    this.vmType = vmType;
}
#end_block

#method_before
public ListModel getVmType() {
    return vmType;
}
#method_after
public ListModel<VmType> getVmType() {
    return vmType;
}
#end_block

#method_before
public EntityModel getName() {
    return privateName;
}
#method_after
public EntityModel<String> getName() {
    return privateName;
}
#end_block

#method_before
private void setName(EntityModel value) {
    privateName = value;
}
#method_after
private void setName(EntityModel<String> value) {
    privateName = value;
}
#end_block

#method_before
public ListModel getOSType() {
    return privateOSType;
}
#method_after
public ListModel<Integer> getOSType() {
    return privateOSType;
}
#end_block

#method_before
private void setOSType(NotChangableForVmInPoolListModel value) {
    privateOSType = value;
}
#method_after
private void setOSType(NotChangableForVmInPoolListModel<Integer> value) {
    privateOSType = value;
}
#end_block

#method_before
public ListModel getNumOfMonitors() {
    return privateNumOfMonitors;
}
#method_after
public ListModel<Integer> getNumOfMonitors() {
    return privateNumOfMonitors;
}
#end_block

#method_before
private void setNumOfMonitors(NotChangableForVmInPoolListModel value) {
    privateNumOfMonitors = value;
}
#method_after
private void setNumOfMonitors(NotChangableForVmInPoolListModel<Integer> value) {
    privateNumOfMonitors = value;
}
#end_block

#method_before
public EntityModel getIsSingleQxlEnabled() {
    return privateIsSingleQxlEnabled;
}
#method_after
public EntityModel<Boolean> getIsSingleQxlEnabled() {
    return privateIsSingleQxlEnabled;
}
#end_block

#method_before
private void setIsSingleQxlEnabled(NotChangableForVmInPoolEntityModel value) {
    privateIsSingleQxlEnabled = value;
}
#method_after
private void setIsSingleQxlEnabled(NotChangableForVmInPoolEntityModel<Boolean> value) {
    privateIsSingleQxlEnabled = value;
}
#end_block

#method_before
public EntityModel getAllowConsoleReconnect() {
    return privateAllowConsoleReconnect;
}
#method_after
public EntityModel<Boolean> getAllowConsoleReconnect() {
    return privateAllowConsoleReconnect;
}
#end_block

#method_before
private void setAllowConsoleReconnect(NotChangableForVmInPoolEntityModel value) {
    privateAllowConsoleReconnect = value;
}
#method_after
private void setAllowConsoleReconnect(NotChangableForVmInPoolEntityModel<Boolean> value) {
    privateAllowConsoleReconnect = value;
}
#end_block

#method_before
public EntityModel getDescription() {
    return privateDescription;
}
#method_after
public EntityModel<String> getDescription() {
    return privateDescription;
}
#end_block

#method_before
private void setDescription(NotChangableForVmInPoolEntityModel value) {
    privateDescription = value;
}
#method_after
private void setDescription(NotChangableForVmInPoolEntityModel<String> value) {
    privateDescription = value;
}
#end_block

#method_before
public EntityModel getComment() {
    return privateComment;
}
#method_after
public EntityModel<String> getComment() {
    return privateComment;
}
#end_block

#method_before
private void setComment(NotChangableForVmInPoolEntityModel value) {
    privateComment = value;
}
#method_after
private void setComment(NotChangableForVmInPoolEntityModel<String> value) {
    privateComment = value;
}
#end_block

#method_before
public EntityModel getMemSize() {
    return privateMemSize;
}
#method_after
public EntityModel<Integer> getMemSize() {
    return privateMemSize;
}
#end_block

#method_before
private void setMemSize(NotChangableForVmInPoolEntityModel value) {
    privateMemSize = value;
}
#method_after
private void setMemSize(NotChangableForVmInPoolEntityModel<Integer> value) {
    privateMemSize = value;
}
#end_block

#method_before
public EntityModel getMinAllocatedMemory() {
    return privateMinAllocatedMemory;
}
#method_after
public EntityModel<Integer> getMinAllocatedMemory() {
    return privateMinAllocatedMemory;
}
#end_block

#method_before
private void setMinAllocatedMemory(NotChangableForVmInPoolEntityModel value) {
    privateMinAllocatedMemory = value;
}
#method_after
private void setMinAllocatedMemory(NotChangableForVmInPoolEntityModel<Integer> value) {
    privateMinAllocatedMemory = value;
}
#end_block

#method_before
public ListModel getQuota() {
    return privateQuota;
}
#method_after
public ListModel<Quota> getQuota() {
    return privateQuota;
}
#end_block

#method_before
private void setQuota(NotChangableForVmInPoolListModel value) {
    privateQuota = value;
}
#method_after
private void setQuota(NotChangableForVmInPoolListModel<Quota> value) {
    privateQuota = value;
}
#end_block

#method_before
public ListModel getUsbPolicy() {
    return privateUsbPolicy;
}
#method_after
public ListModel<UsbPolicy> getUsbPolicy() {
    return privateUsbPolicy;
}
#end_block

#method_before
private void setUsbPolicy(NotChangableForVmInPoolListModel value) {
    privateUsbPolicy = value;
}
#method_after
private void setUsbPolicy(NotChangableForVmInPoolListModel<UsbPolicy> value) {
    privateUsbPolicy = value;
}
#end_block

#method_before
public ListModel getTimeZone() {
    return privateTimeZone;
}
#method_after
public ListModel<TimeZoneModel> getTimeZone() {
    return privateTimeZone;
}
#end_block

#method_before
private void setTimeZone(NotChangableForVmInPoolListModel value) {
    privateTimeZone = value;
}
#method_after
private void setTimeZone(NotChangableForVmInPoolListModel<TimeZoneModel> value) {
    privateTimeZone = value;
}
#end_block

#method_before
public ListModel getNumOfSockets() {
    return privateNumOfSockets;
}
#method_after
public ListModel<Integer> getNumOfSockets() {
    return privateNumOfSockets;
}
#end_block

#method_before
private void setNumOfSockets(NotChangableForVmInPoolListModel value) {
    privateNumOfSockets = value;
}
#method_after
private void setNumOfSockets(NotChangableForVmInPoolListModel<Integer> value) {
    privateNumOfSockets = value;
}
#end_block

#method_before
public EntityModel getTotalCPUCores() {
    return privateTotalCPUCores;
}
#method_after
public EntityModel<String> getTotalCPUCores() {
    return privateTotalCPUCores;
}
#end_block

#method_before
private void setTotalCPUCores(NotChangableForVmInPoolEntityModel value) {
    privateTotalCPUCores = value;
}
#method_after
private void setTotalCPUCores(NotChangableForVmInPoolEntityModel<String> value) {
    privateTotalCPUCores = value;
}
#end_block

#method_before
public ListModel getCoresPerSocket() {
    return privateCoresPerSocket;
}
#method_after
public ListModel<Integer> getCoresPerSocket() {
    return privateCoresPerSocket;
}
#end_block

#method_before
private void setCoresPerSocket(NotChangableForVmInPoolListModel value) {
    privateCoresPerSocket = value;
}
#method_after
private void setCoresPerSocket(NotChangableForVmInPoolListModel<Integer> value) {
    privateCoresPerSocket = value;
}
#end_block

#method_before
public ListModel getDefaultHost() {
    return privateDefaultHost;
}
#method_after
public ListModel<VDS> getDefaultHost() {
    return privateDefaultHost;
}
#end_block

#method_before
private void setDefaultHost(NotChangableForVmInPoolListModel value) {
    privateDefaultHost = value;
}
#method_after
private void setDefaultHost(NotChangableForVmInPoolListModel<VDS> value) {
    privateDefaultHost = value;
}
#end_block

#method_before
public EntityModel getIsSmartcardEnabled() {
    return privateisSmartcardEnabled;
}
#method_after
public EntityModel<Boolean> getIsSmartcardEnabled() {
    return privateisSmartcardEnabled;
}
#end_block

#method_before
private void setIsSmartcardEnabled(NotChangableForVmInPoolEntityModel value) {
    privateisSmartcardEnabled = value;
}
#method_after
private void setIsSmartcardEnabled(NotChangableForVmInPoolEntityModel<Boolean> value) {
    privateisSmartcardEnabled = value;
}
#end_block

#method_before
public void setRngDevice(NotChangableForVmInPoolEntityModel rngDevice) {
    this.rngDevice = rngDevice;
}
#method_after
public void setRngDevice(VmRngDevice dev) {
    rngBytes.setEntity(dev.getBytes() == null ? null : dev.getBytes());
    rngPeriod.setEntity(dev.getPeriod() == null ? null : dev.getPeriod());
    rngSourceRandom.setEntity(dev.getSource() == VmRngDevice.Source.RANDOM);
    rngSourceHwrng.setEntity(dev.getSource() == VmRngDevice.Source.HWRNG);
}
#end_block

#method_before
public EntityModel getIsRngEnabled() {
    return isRngEnabled;
}
#method_after
public EntityModel<Boolean> getIsRngEnabled() {
    return isRngEnabled;
}
#end_block

#method_before
public void setIsRngEnabled(NotChangableForVmInPoolEntityModel rngEnabled) {
    isRngEnabled = rngEnabled;
}
#method_after
public void setIsRngEnabled(NotChangableForVmInPoolEntityModel<Boolean> rngEnabled) {
    isRngEnabled = rngEnabled;
}
#end_block

#method_before
public EntityModel getIsConsoleDeviceEnabled() {
    return isConsoleDeviceEnabled;
}
#method_after
public EntityModel<Boolean> getIsConsoleDeviceEnabled() {
    return isConsoleDeviceEnabled;
}
#end_block

#method_before
private void setConsoleDeviceEnabled(NotChangableForVmInPoolEntityModel consoleDeviceEnabled) {
    this.isConsoleDeviceEnabled = consoleDeviceEnabled;
}
#method_after
private void setConsoleDeviceEnabled(NotChangableForVmInPoolEntityModel<Boolean> consoleDeviceEnabled) {
    this.isConsoleDeviceEnabled = consoleDeviceEnabled;
}
#end_block

#method_before
public EntityModel getIsStateless() {
    return privateIsStateless;
}
#method_after
public EntityModel<Boolean> getIsStateless() {
    return privateIsStateless;
}
#end_block

#method_before
private void setIsStateless(NotChangableForVmInPoolEntityModel value) {
    privateIsStateless = value;
}
#method_after
private void setIsStateless(NotChangableForVmInPoolEntityModel<Boolean> value) {
    privateIsStateless = value;
}
#end_block

#method_before
public EntityModel getIsRunAndPause() {
    return privateIsRunAndPause;
}
#method_after
public EntityModel<Boolean> getIsRunAndPause() {
    return privateIsRunAndPause;
}
#end_block

#method_before
private void setIsRunAndPause(NotChangableForVmInPoolEntityModel value) {
    privateIsRunAndPause = value;
}
#method_after
private void setIsRunAndPause(NotChangableForVmInPoolEntityModel<Boolean> value) {
    privateIsRunAndPause = value;
}
#end_block

#method_before
public EntityModel getIsDeleteProtected() {
    return privateIsDeleteProtected;
}
#method_after
public EntityModel<Boolean> getIsDeleteProtected() {
    return privateIsDeleteProtected;
}
#end_block

#method_before
public void setIsDeleteProtected(NotChangableForVmInPoolEntityModel deleteProtected) {
    this.privateIsDeleteProtected = deleteProtected;
}
#method_after
public void setIsDeleteProtected(NotChangableForVmInPoolEntityModel<Boolean> deleteProtected) {
    this.privateIsDeleteProtected = deleteProtected;
}
#end_block

#method_before
public EntityModel getCopyPermissions() {
    return copyPermissions;
}
#method_after
public EntityModel<Boolean> getCopyPermissions() {
    return copyPermissions;
}
#end_block

#method_before
private void setCopyPermissions(NotChangableForVmInPoolEntityModel copyPermissions) {
    this.copyPermissions = copyPermissions;
}
#method_after
private void setCopyPermissions(NotChangableForVmInPoolEntityModel<Boolean> copyPermissions) {
    this.copyPermissions = copyPermissions;
}
#end_block

#method_before
public EntityModel getMemoryBalloonDeviceEnabled() {
    return memoryBalloonDeviceEnabled;
}
#method_after
public EntityModel<Boolean> getMemoryBalloonDeviceEnabled() {
    return memoryBalloonDeviceEnabled;
}
#end_block

#method_before
public void setMemoryBalloonDeviceEnabled(EntityModel memoryBalloonDeviceEnabled) {
    this.memoryBalloonDeviceEnabled = memoryBalloonDeviceEnabled;
}
#method_after
public void setMemoryBalloonDeviceEnabled(EntityModel<Boolean> memoryBalloonDeviceEnabled) {
    this.memoryBalloonDeviceEnabled = memoryBalloonDeviceEnabled;
}
#end_block

#method_before
public ListModel getDisplayProtocol() {
    return privateDisplayProtocol;
}
#method_after
public ListModel<EntityModel<DisplayType>> getDisplayProtocol() {
    return privateDisplayProtocol;
}
#end_block

#method_before
private void setDisplayProtocol(NotChangableForVmInPoolListModel value) {
    privateDisplayProtocol = value;
}
#method_after
private void setDisplayProtocol(NotChangableForVmInPoolListModel<EntityModel<DisplayType>> value) {
    privateDisplayProtocol = value;
}
#end_block

#method_before
public EntityModel getProvisioning() {
    return privateProvisioning;
}
#method_after
public EntityModel<Boolean> getProvisioning() {
    return privateProvisioning;
}
#end_block

#method_before
private void setProvisioning(NotChangableForVmInPoolEntityModel value) {
    privateProvisioning = value;
}
#method_after
private void setProvisioning(NotChangableForVmInPoolEntityModel<Boolean> value) {
    privateProvisioning = value;
}
#end_block

#method_before
public EntityModel getProvisioningThin_IsSelected() {
    return privateProvisioningThin_IsSelected;
}
#method_after
public EntityModel<Boolean> getProvisioningThin_IsSelected() {
    return privateProvisioningThin_IsSelected;
}
#end_block

#method_before
public void setProvisioningThin_IsSelected(NotChangableForVmInPoolEntityModel value) {
    privateProvisioningThin_IsSelected = value;
}
#method_after
public void setProvisioningThin_IsSelected(NotChangableForVmInPoolEntityModel<Boolean> value) {
    privateProvisioningThin_IsSelected = value;
}
#end_block

#method_before
public EntityModel getProvisioningClone_IsSelected() {
    return privateProvisioningClone_IsSelected;
}
#method_after
public EntityModel<Boolean> getProvisioningClone_IsSelected() {
    return privateProvisioningClone_IsSelected;
}
#end_block

#method_before
public void setProvisioningClone_IsSelected(NotChangableForVmInPoolEntityModel value) {
    privateProvisioningClone_IsSelected = value;
}
#method_after
public void setProvisioningClone_IsSelected(NotChangableForVmInPoolEntityModel<Boolean> value) {
    privateProvisioningClone_IsSelected = value;
}
#end_block

#method_before
public ListModel getPriority() {
    return privatePriority;
}
#method_after
public ListModel<EntityModel<Integer>> getPriority() {
    return privatePriority;
}
#end_block

#method_before
private void setPriority(NotChangableForVmInPoolListModel value) {
    privatePriority = value;
}
#method_after
private void setPriority(NotChangableForVmInPoolListModel<EntityModel<Integer>> value) {
    privatePriority = value;
}
#end_block

#method_before
public EntityModel getIsHighlyAvailable() {
    return privateIsHighlyAvailable;
}
#method_after
public EntityModel<Boolean> getIsHighlyAvailable() {
    return privateIsHighlyAvailable;
}
#end_block

#method_before
private void setIsHighlyAvailable(NotChangableForVmInPoolEntityModel value) {
    privateIsHighlyAvailable = value;
}
#method_after
private void setIsHighlyAvailable(NotChangableForVmInPoolEntityModel<Boolean> value) {
    privateIsHighlyAvailable = value;
}
#end_block

#method_before
public ListModel getFirstBootDevice() {
    return privateFirstBootDevice;
}
#method_after
public ListModel<EntityModel<BootSequence>> getFirstBootDevice() {
    return privateFirstBootDevice;
}
#end_block

#method_before
private void setFirstBootDevice(NotChangableForVmInPoolListModel value) {
    privateFirstBootDevice = value;
}
#method_after
private void setFirstBootDevice(NotChangableForVmInPoolListModel<EntityModel<BootSequence>> value) {
    privateFirstBootDevice = value;
}
#end_block

#method_before
public ListModel getSecondBootDevice() {
    return privateSecondBootDevice;
}
#method_after
public ListModel<EntityModel<BootSequence>> getSecondBootDevice() {
    return privateSecondBootDevice;
}
#end_block

#method_before
private void setSecondBootDevice(NotChangableForVmInPoolListModel value) {
    privateSecondBootDevice = value;
}
#method_after
private void setSecondBootDevice(NotChangableForVmInPoolListModel<EntityModel<BootSequence>> value) {
    privateSecondBootDevice = value;
}
#end_block

#method_before
public ListModel getCdImage() {
    return privateCdImage;
}
#method_after
public ListModel<String> getCdImage() {
    return privateCdImage;
}
#end_block

#method_before
private void setCdImage(NotChangableForVmInPoolListModel value) {
    privateCdImage = value;
}
#method_after
private void setCdImage(NotChangableForVmInPoolListModel<String> value) {
    privateCdImage = value;
}
#end_block

#method_before
public EntityModel getCdAttached() {
    return cdAttached;
}
#method_after
public EntityModel<Boolean> getCdAttached() {
    return cdAttached;
}
#end_block

#method_before
public void setCdAttached(NotChangableForVmInPoolEntityModel value) {
    cdAttached = value;
}
#method_after
public void setCdAttached(NotChangableForVmInPoolEntityModel<Boolean> value) {
    cdAttached = value;
}
#end_block

#method_before
public EntityModel getInitrd_path() {
    return privateInitrd_path;
}
#method_after
public EntityModel<String> getInitrd_path() {
    return privateInitrd_path;
}
#end_block

#method_before
private void setInitrd_path(NotChangableForVmInPoolEntityModel value) {
    privateInitrd_path = value;
}
#method_after
private void setInitrd_path(NotChangableForVmInPoolEntityModel<String> value) {
    privateInitrd_path = value;
}
#end_block

#method_before
public EntityModel getKernel_path() {
    return privateKernel_path;
}
#method_after
public EntityModel<String> getKernel_path() {
    return privateKernel_path;
}
#end_block

#method_before
private void setKernel_path(NotChangableForVmInPoolEntityModel value) {
    privateKernel_path = value;
}
#method_after
private void setKernel_path(NotChangableForVmInPoolEntityModel<String> value) {
    privateKernel_path = value;
}
#end_block

#method_before
public EntityModel getKernel_parameters() {
    return privateKernel_parameters;
}
#method_after
public EntityModel<String> getKernel_parameters() {
    return privateKernel_parameters;
}
#end_block

#method_before
private void setKernel_parameters(NotChangableForVmInPoolEntityModel value) {
    privateKernel_parameters = value;
}
#method_after
private void setKernel_parameters(NotChangableForVmInPoolEntityModel<String> value) {
    privateKernel_parameters = value;
}
#end_block

#method_before
public EntityModel getCustomProperties() {
    return privateCustomProperties;
}
#method_after
public EntityModel<String> getCustomProperties() {
    return privateCustomProperties;
}
#end_block

#method_before
private void setCustomProperties(NotChangableForVmInPoolEntityModel value) {
    privateCustomProperties = value;
}
#method_after
private void setCustomProperties(NotChangableForVmInPoolEntityModel<String> value) {
    privateCustomProperties = value;
}
#end_block

#method_before
public HashMap<Version, ArrayList<String>> getCustomPropertiesKeysList() {
    return privateCustomPropertiesKeysList;
}
#method_after
public Map<Version, List<String>> getCustomPropertiesKeysList() {
    return privateCustomPropertiesKeysList;
}
#end_block

#method_before
public void setCustomPropertiesKeysList(HashMap<Version, ArrayList<String>> value) {
    privateCustomPropertiesKeysList = value;
}
#method_after
public void setCustomPropertiesKeysList(Map<Version, List<String>> value) {
    privateCustomPropertiesKeysList = value;
}
#end_block

#method_before
public EntityModel getIsAutoAssign() {
    return privateIsAutoAssign;
}
#method_after
public EntityModel<Boolean> getIsAutoAssign() {
    return privateIsAutoAssign;
}
#end_block

#method_before
public void setIsAutoAssign(NotChangableForVmInPoolEntityModel value) {
    privateIsAutoAssign = value;
}
#method_after
public void setIsAutoAssign(NotChangableForVmInPoolEntityModel<Boolean> value) {
    privateIsAutoAssign = value;
}
#end_block

#method_before
public EntityModel getHostCpu() {
    return hostCpu;
}
#method_after
public EntityModel<Boolean> getHostCpu() {
    return hostCpu;
}
#end_block

#method_before
public void setHostCpu(NotChangableForVmInPoolEntityModel hostCpu) {
    this.hostCpu = hostCpu;
}
#method_after
public void setHostCpu(NotChangableForVmInPoolEntityModel<Boolean> hostCpu) {
    this.hostCpu = hostCpu;
}
#end_block

#method_before
public ListModel getMigrationMode() {
    return migrationMode;
}
#method_after
public ListModel<MigrationSupport> getMigrationMode() {
    return migrationMode;
}
#end_block

#method_before
public void setMigrationMode(NotChangableForVmInPoolListModel value) {
    migrationMode = value;
}
#method_after
public void setMigrationMode(NotChangableForVmInPoolListModel<MigrationSupport> value) {
    migrationMode = value;
}
#end_block

#method_before
public EntityModel getIsTemplatePublic() {
    return privateIsTemplatePublic;
}
#method_after
public EntityModel<Boolean> getIsTemplatePublic() {
    return privateIsTemplatePublic;
}
#end_block

#method_before
private void setIsTemplatePublic(NotChangableForVmInPoolEntityModel value) {
    privateIsTemplatePublic = value;
}
#method_after
private void setIsTemplatePublic(NotChangableForVmInPoolEntityModel<Boolean> value) {
    privateIsTemplatePublic = value;
}
#end_block

#method_before
public EntityModel getCpuPinning() {
    return cpuPinning;
}
#method_after
public EntityModel<String> getCpuPinning() {
    return cpuPinning;
}
#end_block

#method_before
public void setCpuPinning(NotChangableForVmInPoolEntityModel cpuPinning) {
    this.cpuPinning = cpuPinning;
}
#method_after
public void setCpuPinning(NotChangableForVmInPoolEntityModel<String> cpuPinning) {
    this.cpuPinning = cpuPinning;
}
#end_block

#method_before
public EntityModel getCpuSharesAmount() {
    return cpuSharesAmount;
}
#method_after
public EntityModel<Integer> getCpuSharesAmount() {
    return cpuSharesAmount;
}
#end_block

#method_before
public void setCpuSharesAmount(NotChangableForVmInPoolEntityModel cpuSharesAmount) {
    this.cpuSharesAmount = cpuSharesAmount;
}
#method_after
public void setCpuSharesAmount(NotChangableForVmInPoolEntityModel<Integer> cpuSharesAmount) {
    this.cpuSharesAmount = cpuSharesAmount;
}
#end_block

#method_before
public ListModel getCpuSharesAmountSelection() {
    return cpuSharesAmountSelection;
}
#method_after
public ListModel<CpuSharesAmount> getCpuSharesAmountSelection() {
    return cpuSharesAmountSelection;
}
#end_block

#method_before
public void setCpuSharesAmountSelection(NotChangableForVmInPoolListModel cpuSharesAmountSelection) {
    this.cpuSharesAmountSelection = cpuSharesAmountSelection;
}
#method_after
public void setCpuSharesAmountSelection(NotChangableForVmInPoolListModel<CpuSharesAmount> cpuSharesAmountSelection) {
    this.cpuSharesAmountSelection = cpuSharesAmountSelection;
}
#end_block

#method_before
public ListModel getVncKeyboardLayout() {
    return vncKeyboardLayout;
}
#method_after
public ListModel<String> getVncKeyboardLayout() {
    return vncKeyboardLayout;
}
#end_block

#method_before
public void setVncKeyboardLayout(ListModel vncKeyboardLayout) {
    this.vncKeyboardLayout = vncKeyboardLayout;
}
#method_after
public void setVncKeyboardLayout(ListModel<String> vncKeyboardLayout) {
    this.vncKeyboardLayout = vncKeyboardLayout;
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getIsSingleQxlEnabled().setEntity(false);
    isRngEnabled.setEntity(true);
    rngDevice.setEntity(VmRngDevice.getInitVmDevice());
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initOSType();
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMinimalVmMemSize();
    initMaximalVmMemSize32OS();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    isRngEnabled.setEntity(false);
    rngSourceRandom.setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            oSType_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        }
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            vmTypeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#end_block

#method_before
private void vmTypeChanged() {
    behavior.vmTypeChanged(((VmType) getVmType().getSelectedItem()));
}
#method_after
private void vmTypeChanged() {
    behavior.vmTypeChanged(getVmType().getSelectedItem());
}
#end_block

#method_before
protected void initNumOfMonitors() {
    AsyncDataProvider.getNumOfMonitorList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            Integer oldNumOfMonitors = null;
            if (model.getNumOfMonitors().getSelectedItem() != null) {
                oldNumOfMonitors = (Integer) model.getNumOfMonitors().getSelectedItem();
            }
            ArrayList<Integer> numOfMonitors = (ArrayList<Integer>) returnValue;
            model.getNumOfMonitors().setItems(numOfMonitors);
            if (oldNumOfMonitors != null) {
                model.getNumOfMonitors().setSelectedItem(oldNumOfMonitors);
            }
        }
    }, getHash()));
}
#method_after
protected void initNumOfMonitors() {
    AsyncDataProvider.getNumOfMonitorList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            Integer oldNumOfMonitors = null;
            if (model.getNumOfMonitors().getSelectedItem() != null) {
                oldNumOfMonitors = model.getNumOfMonitors().getSelectedItem();
            }
            ArrayList<Integer> numOfMonitors = (ArrayList<Integer>) returnValue;
            model.getNumOfMonitors().setItems(numOfMonitors);
            if (oldNumOfMonitors != null) {
                model.getNumOfMonitors().setSelectedItem(oldNumOfMonitors);
            }
        }
    }, getHash()));
}
#end_block

#method_before
protected void initAllowConsoleReconnect() {
    getAllowConsoleReconnect().setEntity(true);
}
#method_after
protected void initAllowConsoleReconnect() {
    getAllowConsoleReconnect().setEntity(getVmType().getSelectedItem() == VmType.Server);
}
#end_block

#method_before
private void initUsbPolicy() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = (Integer) getOSType().getSelectedItem();
    DisplayType displayType = (DisplayType) (getDisplayProtocol().getSelectedItem() != null ? ((EntityModel) getDisplayProtocol().getSelectedItem()).getEntity() : null);
    if (osType == null || cluster == null || displayType == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) > 0) {
        if (AsyncDataProvider.isWindowsOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) <= 0) {
        if (AsyncDataProvider.isLinuxOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (displayType != DisplayType.qxl) {
        getUsbPolicy().setIsChangable(false);
    }
    getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
}
#method_after
private void initUsbPolicy() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    DisplayType displayType = (getDisplayProtocol().getSelectedItem() != null ? getDisplayProtocol().getSelectedItem().getEntity() : null);
    if (osType == null || cluster == null || displayType == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    UsbPolicy prevSelectedUsbPolicy = getUsbPolicy().getSelectedItem();
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) > 0) {
        if (AsyncDataProvider.isWindowsOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) <= 0) {
        if (AsyncDataProvider.isLinuxOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (displayType != DisplayType.qxl) {
        getUsbPolicy().setIsChangable(false);
    }
    Collection<UsbPolicy> policies = getUsbPolicy().getItems();
    if (policies.contains(prevSelectedUsbPolicy)) {
        getUsbPolicy().setSelectedItem(prevSelectedUsbPolicy);
    } else if (policies.size() > 0) {
        getUsbPolicy().setSelectedItem(policies.iterator().next());
    }
}
#end_block

#method_before
private void initDisplayProtocol() {
    ArrayList<EntityModel> displayProtocolOptions = new ArrayList<EntityModel>();
    EntityModel spiceProtocol = new EntityModel();
    spiceProtocol.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    spiceProtocol.setEntity(DisplayType.qxl);
    EntityModel vncProtocol = new EntityModel();
    vncProtocol.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    vncProtocol.setEntity(DisplayType.vnc);
    displayProtocolOptions.add(spiceProtocol);
    displayProtocolOptions.add(vncProtocol);
    getDisplayProtocol().setItems(displayProtocolOptions);
    getDisplayProtocol().getSelectedItemChangedEvent().addListener(this);
}
#method_after
private void initDisplayProtocol() {
    getDisplayProtocol().getSelectedItemChangedEvent().addListener(this);
}
#end_block

#method_before
private void initFirstBootDevice() {
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().hardDiskTitle());
    tempVar.setEntity(BootSequence.C);
    EntityModel hardDiskOption = tempVar;
    ArrayList<EntityModel> firstBootDeviceItems = new ArrayList<EntityModel>();
    firstBootDeviceItems.add(hardDiskOption);
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cdromTitle());
    tempVar2.setEntity(BootSequence.D);
    firstBootDeviceItems.add(tempVar2);
    EntityModel tempVar3 = new EntityModel();
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().networkPXETitle());
    tempVar3.setEntity(BootSequence.N);
    firstBootDeviceItems.add(tempVar3);
    getFirstBootDevice().setItems(firstBootDeviceItems);
    getFirstBootDevice().setSelectedItem(hardDiskOption);
}
#method_after
private void initFirstBootDevice() {
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().hardDiskTitle());
    tempVar.setEntity(BootSequence.C);
    EntityModel hardDiskOption = tempVar;
    List<EntityModel<BootSequence>> firstBootDeviceItems = new ArrayList<EntityModel<BootSequence>>();
    firstBootDeviceItems.add(hardDiskOption);
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cdromTitle());
    tempVar2.setEntity(BootSequence.D);
    firstBootDeviceItems.add(tempVar2);
    EntityModel tempVar3 = new EntityModel();
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().networkPXETitle());
    tempVar3.setEntity(BootSequence.N);
    firstBootDeviceItems.add(tempVar3);
    getFirstBootDevice().setItems(firstBootDeviceItems);
    getFirstBootDevice().setSelectedItem(hardDiskOption);
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMaximalVmMemSize();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
}
#end_block

#method_before
private void template_SelectedItemChanged(Object sender, EventArgs args) {
    behavior.template_SelectedItemChanged();
}
#method_after
private void template_SelectedItemChanged(Object sender, EventArgs args) {
    behavior.template_SelectedItemChanged();
    behavior.updateMigrationForLocalSD();
}
#end_block

#method_before
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = (Integer) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateDefaultTimeZone();
}
#method_after
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
}
#end_block

#method_before
private void firstBootDevice_SelectedItemChanged(Object sender, EventArgs args) {
    EntityModel entityModel = (EntityModel) getFirstBootDevice().getSelectedItem();
    BootSequence firstDevice = (BootSequence) entityModel.getEntity();
    ArrayList<EntityModel> list = new ArrayList<EntityModel>();
    for (Object item : getFirstBootDevice().getItems()) {
        EntityModel a = (EntityModel) item;
        if ((BootSequence) a.getEntity() != firstDevice) {
            list.add(a);
        }
    }
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().noneTitle());
    EntityModel noneOption = tempVar;
    list.add(0, noneOption);
    getSecondBootDevice().setItems(list);
    getSecondBootDevice().setSelectedItem(noneOption);
}
#method_after
private void firstBootDevice_SelectedItemChanged(Object sender, EventArgs args) {
    EntityModel<BootSequence> entityModel = getFirstBootDevice().getSelectedItem();
    BootSequence firstDevice = entityModel.getEntity();
    List<EntityModel<BootSequence>> list = new ArrayList<EntityModel<BootSequence>>();
    for (EntityModel<BootSequence> item : getFirstBootDevice().getItems()) {
        if (item.getEntity() != firstDevice) {
            list.add(item);
        }
    }
    EntityModel<BootSequence> tempVar = new EntityModel<BootSequence>();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().noneTitle());
    EntityModel<BootSequence> noneOption = tempVar;
    list.add(0, noneOption);
    getSecondBootDevice().setItems(list);
    getSecondBootDevice().setSelectedItem(noneOption);
}
#end_block

#method_before
private void displayProtocol_SelectedItemChanged(Object sender, EventArgs args) {
    EntityModel entityModel = (EntityModel) getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return;
    }
    DisplayType type = (DisplayType) entityModel.getEntity();
    if (type == DisplayType.vnc) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    getBehavior().updateSingleQxl(type == DisplayType.qxl);
    getUsbPolicy().setIsChangable(type == DisplayType.qxl);
    getIsSmartcardEnabled().setIsChangable(type == DisplayType.qxl);
    getVncKeyboardLayout().setIsAvailable(type == DisplayType.vnc);
    updateNumOfMonitors();
}
#method_after
private void displayProtocol_SelectedItemChanged(Object sender, EventArgs args) {
    if (getDisplayType() == null) {
        getBehavior().activateInstanceTypeManager();
        return;
    }
    DisplayType type = getDisplayType();
    if (type == DisplayType.vnc) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    handleQxlClusterLevel();
    getUsbPolicy().setIsChangable(type == DisplayType.qxl);
    getIsSmartcardEnabled().setIsChangable(type == DisplayType.qxl);
    getVncKeyboardLayout().setIsAvailable(type == DisplayType.vnc);
    updateNumOfMonitors();
}
#end_block

#method_before
private boolean isVncSelected() {
    boolean isVnc = false;
    if (getDisplayProtocol().getSelectedItem() != null) {
        DisplayType displayType = (DisplayType) ((EntityModel) getDisplayProtocol().getSelectedItem()).getEntity();
        isVnc = displayType == DisplayType.vnc;
    }
    return isVnc;
}
#method_after
private boolean isVncSelected() {
    boolean isVnc = false;
    if (getDisplayProtocol().getSelectedItem() != null) {
        DisplayType displayType = getDisplayProtocol().getSelectedItem().getEntity();
        isVnc = displayType == DisplayType.vnc;
    }
    return isVnc;
}
#end_block

#method_before
public BootSequence getBootSequence() {
    EntityModel firstSelectedItem = (EntityModel) getFirstBootDevice().getSelectedItem();
    EntityModel secondSelectedItem = (EntityModel) getSecondBootDevice().getSelectedItem();
    String firstSelectedString = // $NON-NLS-1$
    firstSelectedItem.getEntity() == null ? "" : firstSelectedItem.getEntity().toString();
    String secondSelectedString = // $NON-NLS-1$
    secondSelectedItem.getEntity() == null ? "" : secondSelectedItem.getEntity().toString();
    return BootSequence.valueOf(firstSelectedString + secondSelectedString);
}
#method_after
public BootSequence getBootSequence() {
    EntityModel<BootSequence> firstSelectedItem = getFirstBootDevice().getSelectedItem();
    EntityModel<BootSequence> secondSelectedItem = getSecondBootDevice().getSelectedItem();
    String firstSelectedString = // $NON-NLS-1$
    firstSelectedItem.getEntity() == null ? "" : firstSelectedItem.getEntity().toString();
    String secondSelectedString = // $NON-NLS-1$
    secondSelectedItem.getEntity() == null ? "" : secondSelectedItem.getEntity().toString();
    return BootSequence.valueOf(firstSelectedString + secondSelectedString);
}
#end_block

#method_before
public void setBootSequence(BootSequence value) {
    ArrayList<BootSequence> items = new ArrayList<BootSequence>();
    for (char a : value.toString().toCharArray()) {
        items.add(BootSequence.valueOf(String.valueOf(a)));
    }
    Object firstBootDevice = null;
    for (Object item : getFirstBootDevice().getItems()) {
        EntityModel a = (EntityModel) item;
        if ((BootSequence) a.getEntity() == Linq.firstOrDefault(items)) {
            firstBootDevice = a;
        }
    }
    getFirstBootDevice().setSelectedItem(firstBootDevice);
    ArrayList<EntityModel> secondDeviceOptions = Linq.<EntityModel>cast(getSecondBootDevice().getItems());
    if (items.size() > 1) {
        BootSequence last = items.get(items.size() - 1);
        for (EntityModel a : secondDeviceOptions) {
            if (a.getEntity() != null && (BootSequence) a.getEntity() == last) {
                getSecondBootDevice().setSelectedItem(a);
                break;
            }
        }
    } else {
        for (EntityModel a : secondDeviceOptions) {
            if (a.getEntity() == null) {
                getSecondBootDevice().setSelectedItem(a);
                break;
            }
        }
    }
}
#method_after
public void setBootSequence(BootSequence value) {
    ArrayList<BootSequence> items = new ArrayList<BootSequence>();
    for (char a : value.toString().toCharArray()) {
        items.add(BootSequence.valueOf(String.valueOf(a)));
    }
    EntityModel<BootSequence> firstBootDevice = null;
    for (EntityModel<BootSequence> item : getFirstBootDevice().getItems()) {
        if (item.getEntity() == Linq.firstOrDefault(items)) {
            firstBootDevice = item;
        }
    }
    getFirstBootDevice().setSelectedItem(firstBootDevice);
    Iterable<EntityModel<BootSequence>> secondDeviceOptions = getSecondBootDevice().getItems();
    if (items.size() > 1) {
        BootSequence last = items.get(items.size() - 1);
        for (EntityModel<BootSequence> a : secondDeviceOptions) {
            if (a.getEntity() != null && a.getEntity() == last) {
                getSecondBootDevice().setSelectedItem(a);
                break;
            }
        }
    } else {
        for (EntityModel<BootSequence> a : secondDeviceOptions) {
            if (a.getEntity() == null) {
                getSecondBootDevice().setSelectedItem(a);
                break;
            }
        }
    }
}
#end_block

#method_before
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    selectDataCenterWithCluster(selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        if (dataCenterToCluster.containsKey(dataCenter.getId())) {
            for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
                dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
            }
        }
    }
    selectDataCenterWithCluster(selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
protected void selectDataCenterWithCluster(UnitVmModel model, Guid selectedCluster, List<DataCenterWithCluster> dataCentersWithClusters) {
    if (selectedCluster == null) {
        getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(dataCentersWithClusters));
    } else {
        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(dataCentersWithClusters, new Linq.DataCenterWithClusterAccordingClusterPredicate((Guid) selectedCluster)));
    }
}
#method_after
protected void selectDataCenterWithCluster(Guid selectedCluster, List<DataCenterWithCluster> dataCentersWithClusters) {
    DataCenterWithCluster selectedDataCenterWithCluster = (selectedCluster == null) ? Linq.firstOrDefault(dataCentersWithClusters) : Linq.firstOrDefault(dataCentersWithClusters, new Linq.DataCenterWithClusterAccordingClusterPredicate(selectedCluster));
    getDataCenterWithClustersList().setItems(dataCentersWithClusters, selectedDataCenterWithCluster);
}
#end_block

#method_before
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = (Integer) getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, ((VDSGroup) getSelectedCluster()).getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && ((Boolean) getIsAutoAssign().getEntity()) == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty((String) getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty((String) getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty((String) getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    validateRngDevice();
    setRngTabValid(isRngRateValid() && isRngEgdPathValid());
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behavior.validate() && customPropertySheetValid && getQuota().getIsValid() && isRngEgdPathValid() && isRngRateValid();
}
#method_after
public boolean validate() {
    boolean hwPartValid = validateHwPart();
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    setIsSystemTabValid(true);
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    setIsGeneralTabValid(getIsGeneralTabValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsHostTabValid(getIsHostTabValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getIsAllocationTabValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    return hwPartValid && vmInitIsValid && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && getQuota().getIsValid();
}
#end_block

#method_before
@Override
public ValidationResult validate(Object value) {
    boolean isOk = behavior.isNumOfSocketsCorrect(Integer.parseInt(getTotalCPUCores().getEntity().toString()));
    ValidationResult res = new ValidationResult();
    res.setSuccess(isOk);
    res.setReasons(Arrays.asList(ConstantsManager.getInstance().getMessages().incorrectVCPUNumber()));
    return res;
}
#method_after
@Override
public ValidationResult validate(Object value) {
    boolean isOk = behavior.isNumOfSocketsCorrect(Integer.parseInt(getTotalCPUCores().getEntity()));
    ValidationResult res = new ValidationResult();
    res.setSuccess(isOk);
    res.setReasons(Arrays.asList(ConstantsManager.getInstance().getMessages().incorrectVCPUNumber()));
    return res;
}
#end_block

#method_before
private void validateMemorySize(EntityModel model, int maxMemSize, int minMemSize) {
    boolean isValid = false;
    int memSize = (Integer) model.getEntity();
    if (memSize == 0) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().memSizeBetween(minMemSize, maxMemSize));
    } else if (memSize > maxMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().maxMemSizeIs(maxMemSize));
    } else if (memSize < minMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().minMemSizeIs(minMemSize));
    } else {
        isValid = true;
    }
    model.setIsValid(isValid);
}
#method_after
private void validateMemorySize(EntityModel<Integer> model, int maxMemSize, int minMemSize) {
    boolean isValid = false;
    int memSize = model.getEntity();
    if (memSize == 0) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().memSizeBetween(minMemSize, maxMemSize));
    } else if (memSize > maxMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().maxMemSizeIs(maxMemSize));
    } else if (memSize < minMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().minMemSizeIs(minMemSize));
    } else {
        isValid = true;
    }
    model.setIsValid(isValid);
}
#end_block

#method_before
public ListModel getPoolType() {
    return poolType;
}
#method_after
public ListModel<EntityModel<VmPoolType>> getPoolType() {
    return poolType;
}
#end_block

#method_before
protected void setPoolType(NotChangableForVmInPoolListModel value) {
    poolType = value;
}
#method_after
protected void setPoolType(NotChangableForVmInPoolListModel<EntityModel<VmPoolType>> value) {
    poolType = value;
}
#end_block

#method_before
public EntityModel getNumOfDesktops() {
    return numOfDesktops;
}
#method_after
public EntityModel<Integer> getNumOfDesktops() {
    return numOfDesktops;
}
#end_block

#method_before
protected void setNumOfDesktops(NotChangableForVmInPoolEntityModel value) {
    numOfDesktops = value;
}
#method_after
protected void setNumOfDesktops(NotChangableForVmInPoolEntityModel<Integer> value) {
    numOfDesktops = value;
}
#end_block

#method_before
public EntityModel getAssignedVms() {
    return assignedVms;
}
#method_after
public EntityModel<Integer> getAssignedVms() {
    return assignedVms;
}
#end_block

#method_before
public void setAssignedVms(NotChangableForVmInPoolEntityModel value) {
    assignedVms = value;
}
#method_after
public void setAssignedVms(NotChangableForVmInPoolEntityModel<Integer> value) {
    assignedVms = value;
}
#end_block

#method_before
public EntityModel getPrestartedVms() {
    return prestartedVms;
}
#method_after
public EntityModel<Integer> getPrestartedVms() {
    return prestartedVms;
}
#end_block

#method_before
protected void setPrestartedVms(NotChangableForVmInPoolEntityModel value) {
    prestartedVms = value;
}
#method_after
protected void setPrestartedVms(NotChangableForVmInPoolEntityModel<Integer> value) {
    prestartedVms = value;
}
#end_block

#method_before
public void setPrestartedVmsHint(String value) {
    if (!StringHelper.stringsEqual(prestartedVmsHint, value)) {
        prestartedVmsHint = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("PrestartedVmsHint"));
    }
}
#method_after
public void setPrestartedVmsHint(String value) {
    if (!ObjectUtils.objectsEqual(prestartedVmsHint, value)) {
        prestartedVmsHint = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("PrestartedVmsHint"));
    }
}
#end_block

#method_before
public EntityModel getMaxAssignedVmsPerUser() {
    return maxAssignedVmsPerUser;
}
#method_after
public EntityModel<Integer> getMaxAssignedVmsPerUser() {
    return maxAssignedVmsPerUser;
}
#end_block

#method_before
public void setMaxAssignedVmsPerUser(NotChangableForVmInPoolEntityModel maxAssignedVmsPerUser) {
    this.maxAssignedVmsPerUser = maxAssignedVmsPerUser;
}
#method_after
public void setMaxAssignedVmsPerUser(NotChangableForVmInPoolEntityModel<Integer> maxAssignedVmsPerUser) {
    this.maxAssignedVmsPerUser = maxAssignedVmsPerUser;
}
#end_block

#method_before
@Override
public ListModel setIsChangable(boolean value) {
    if (!isVmAttachedToPool())
        super.setIsChangable(value);
    return this;
}
#method_after
@Override
public ListModel<T> setIsChangable(boolean value) {
    if (!isVmAttachedToPool()) {
        super.setIsChangable(value);
    }
    return this;
}
#end_block

#method_before
@Override
public EntityModel setIsChangable(boolean value) {
    if (!isVmAttachedToPool())
        super.setIsChangable(value);
    return this;
}
#method_after
@Override
public EntityModel<T> setIsChangable(boolean value) {
    if (!isVmAttachedToPool()) {
        super.setIsChangable(value);
    }
    return this;
}
#end_block

#method_before
@Override
public KeyValueModel setIsChangable(boolean value) {
    if (!isVmAttachedToPool())
        super.setIsChangable(value);
    return this;
}
#method_after
@Override
public KeyValueModel setIsChangable(boolean value) {
    if (!isVmAttachedToPool()) {
        super.setIsChangable(value);
    }
    return this;
}
#end_block

#method_before
public ListModel getWatchdogModel() {
    return watchdogModel;
}
#method_after
public ListModel<String> getWatchdogModel() {
    return watchdogModel;
}
#end_block

#method_before
public void setWatchdogModel(ListModel watchdogModel) {
    this.watchdogModel = watchdogModel;
}
#method_after
public void setWatchdogModel(ListModel<String> watchdogModel) {
    this.watchdogModel = watchdogModel;
}
#end_block

#method_before
public ListModel getWatchdogAction() {
    return watchdogAction;
}
#method_after
public ListModel<String> getWatchdogAction() {
    return watchdogAction;
}
#end_block

#method_before
public void setWatchdogAction(ListModel watchdogAction) {
    this.watchdogAction = watchdogAction;
}
#method_after
public void setWatchdogAction(ListModel<String> watchdogAction) {
    this.watchdogAction = watchdogAction;
}
#end_block

#method_before
public StoragePool getSelectedDataCenter() {
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return null;
    }
    return dataCenterWithCluster.getDataCenter();
}
#method_after
public StoragePool getSelectedDataCenter() {
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return null;
    }
    return dataCenterWithCluster.getDataCenter();
}
#end_block

#method_before
public VDSGroup getSelectedCluster() {
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return null;
    }
    return dataCenterWithCluster.getCluster();
}
#method_after
public VDSGroup getSelectedCluster() {
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return null;
    }
    return dataCenterWithCluster.getCluster();
}
#end_block

#method_before
private void initTextBoxEditors() {
    descriptionEditor = new EntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    commentEditor = new EntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    totalvCPUsEditor = new EntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    numOfVmsEditor = new EntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    cpuPinning = new EntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountEditor = new EntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // $NON-NLS-1$
    cpuSharesAmountEditor.asValueBox().setWidth("110px");
    kernel_pathEditor = new EntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    initrd_pathEditor = new EntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    kernel_parametersEditor = new EntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    nameEditor = new EntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    prestartedVmsEditor = new EntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editPrestartedVmsEditor = new EntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    maxAssignedVmsPerUserEditor = new EntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editMaxAssignedVmsPerUserEditor = new EntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
}
#method_after
private void initTextBoxEditors() {
    templateVersionNameEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    descriptionEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    commentEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    numOfVmsEditor = new IntegerEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    cpuPinning = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    kernel_pathEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    initrd_pathEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    kernel_parametersEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    nameEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    prestartedVmsEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editPrestartedVmsEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    maxAssignedVmsPerUserEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editMaxAssignedVmsPerUserEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
protected void initPoolSpecificWidgets(CommonApplicationResources resources, final CommonApplicationMessages messages) {
    createNumOfDesktopEditors();
    incraseNumOfVmsEditor.setKeepTitleOnSetEnabled(true);
    numOfVmsEditor.setKeepTitleOnSetEnabled(true);
    newPoolPrestartedVmsIcon = new InfoIcon(applicationTemplates.italicText(messages.prestartedHelp()), resources);
    editPoolPrestartedVmsIcon = new InfoIcon(applicationTemplates.italicText(messages.prestartedHelp()), resources);
    poolNameIcon = new InfoIcon(applicationTemplates.italicText(messages.poolNameHelp()), resources);
    newPoolMaxAssignedVmsPerUserIcon = new InfoIcon(applicationTemplates.italicText(messages.maxAssignedVmsPerUserHelp()), resources);
    editPoolMaxAssignedVmsPerUserIcon = new InfoIcon(applicationTemplates.italicText(messages.maxAssignedVmsPerUserHelp()), resources);
    outOfxInPool = new ValueLabel<Object>(new AbstractRenderer<Object>() {

        @Override
        public String render(Object object) {
            return messages.outOfXVMsInPool(object.toString());
        }
    });
}
#method_after
protected void initPoolSpecificWidgets(CommonApplicationResources resources, final CommonApplicationMessages messages) {
    createNumOfDesktopEditors();
    incraseNumOfVmsEditor.setKeepTitleOnSetEnabled(true);
    numOfVmsEditor.setKeepTitleOnSetEnabled(true);
    newPoolPrestartedVmsIcon = new InfoIcon(applicationTemplates.italicText(messages.prestartedHelp()), resources);
    editPoolPrestartedVmsIcon = new InfoIcon(applicationTemplates.italicText(messages.prestartedHelp()), resources);
    poolNameIcon = new InfoIcon(applicationTemplates.italicText(messages.poolNameHelp()), resources);
    newPoolMaxAssignedVmsPerUserIcon = new InfoIcon(applicationTemplates.italicText(messages.maxAssignedVmsPerUserHelp()), resources);
    editPoolMaxAssignedVmsPerUserIcon = new InfoIcon(applicationTemplates.italicText(messages.maxAssignedVmsPerUserHelp()), resources);
    outOfxInPool = new ValueLabel<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return messages.outOfXVMsInPool(object.toString());
        }
    });
}
#end_block

#method_before
protected void createNumOfDesktopEditors() {
    incraseNumOfVmsEditor = new EntityModelTextBoxOnlyEditor();
    numOfVmsEditor = new EntityModelTextBoxEditor();
}
#method_after
protected void createNumOfDesktopEditors() {
    incraseNumOfVmsEditor = new IntegerEntityModelTextBoxOnlyEditor();
    numOfVmsEditor = new IntegerEntityModelTextBoxEditor();
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<Object>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Object>() {

        @Override
        public String getReplacementStringNullSafe(Object data) {
            return // $NON-NLS-1$
            ((DataCenterWithCluster) data).getCluster().getName() + "/" + ((DataCenterWithCluster) data).getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(Object data) {
            String dcDescription = ((DataCenterWithCluster) data).getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(((DataCenterWithCluster) data).getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : ((DataCenterWithCluster) data).getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Object>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Object>() {

        @Override
        public String getReplacementStringNullSafe(Object data) {
            return ((Quota) data).getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Object data) {
            return typeAheadNameDescriptionTemplateNullSafe(((Quota) data).getQuotaName(), ((Quota) data).getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<Object>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Object>() {

        @Override
        public String getReplacementStringNullSafe(Object data) {
            return ((VmTemplate) data).getName();
        }

        @Override
        public String getDisplayStringNullSafe(Object data) {
            return typeAheadNameDescriptionTemplateNullSafe(((VmTemplate) data).getName(), ((VmTemplate) data).getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Object>(new AbstractRenderer<Object>() {

        @Override
        public String render(Object object) {
            return AsyncDataProvider.getOsName((Integer) object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<Object>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Object>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditor = new ListModelListBoxEditor<Object>(new ModeSwitchingVisibilityRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            TimeZoneModel timeZone = (TimeZoneModel) object;
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<Object>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<Object>(new AbstractRenderer<Object>() {

        final String globalLayout = (String) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayout);

        @Override
        public String render(Object object) {
            if (object == null) {
                return messages.globalVncKeyboardLayoutCaption(globalLayout);
            } else {
                return object.toString();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDS) object).getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<Object>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return (String) object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxEditor<Object>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    // $NON-NLS-1$
    cpuSharesAmountSelectionEditor.asListBox().setWidth("110px");
    // $NON-NLS-1$
    cpuSharesAmountSelectionEditor.getContentWidgetContainer().setWidth("110px");
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return getDisplayableTemplateVersionName(data);
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(getDisplayableTemplateVersionName(data), data.getDescription());
        }

        private String getDisplayableTemplateVersionName(VmTemplate template) {
            String versionName = template.getTemplateVersionName();
            if (ConstantsManager.getInstance().getConstants().latestTemplateVersionName().equals(versionName)) {
                return constants.latest();
            }
            versionName = template.getId().equals(template.getBaseTemplateId()) ? constants.baseTemplate() : template.getTemplateVersionName();
            return // $NON-NLS-1$
            (versionName == null ? "" : versionName) + // $NON-NLS-1$
            StringFormat.format(" (%d)", template.getTemplateVersionNumber());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<InstanceType>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.tzVmPopup());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo<String>(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(applicationTemplates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    templateEditor.setLabel(constants.basedOnTemplateVmPopup());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    // Rng device tab
    rngDeviceTab.setLabel(constants.rngDeviceTab());
    isRngEnabledEditor.setLabel(constants.rngDevEnabled());
    rngPeriodEditor.setLabel(constants.rngPeriod());
    rngBytesEditor.setLabel(constants.rngBytes());
    rngSourceEgdEditor.setLabel(constants.egdPath());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    cpuSharesAmountSelectionEditor.setLabel(constants.cpuShares());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
}
#method_after
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    instanceTypesEditor.setLabel(constants.instanceType());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Rng device tab
    rngDeviceTab.setLabel(constants.rngDeviceTab());
    isRngEnabledEditor.setLabel(constants.rngDevEnabled());
    rngPeriodEditor.setLabel(constants.rngPeriod());
    rngBytesEditor.setLabel(constants.rngBytes());
    rngSourceRandom.setLabel(constants.rngSourceRandom());
    rngSourceHwrng.setLabel(constants.rngSourceHwrng());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    detachableMemSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditorWithDetachable.setLabel(constants.coresPerSocket());
    numOfSocketsEditorWithDetachable.setLabel(constants.numOfSockets());
}
#end_block

#method_before
protected void applyStyles() {
    hostCpuEditor.addContentWidgetStyleName(style.longCheckboxContent());
    allowConsoleReconnectEditor.addContentWidgetStyleName(style.longCheckboxContent());
    provisioningEditor.addContentWidgetStyleName(style.provisioningEditorContent());
    provisioningThinEditor.addContentWidgetStyleName(style.provisioningRadioContent());
    provisioningCloneEditor.addContentWidgetStyleName(style.provisioningRadioContent());
    cdAttachedEditor.addContentWidgetStyleName(style.cdAttachedLabelWidth());
    cdImageEditor.addContentWidgetStyleName(style.cdImageEditor());
    numOfMonitorsEditor.addContentWidgetStyleName(style.monitorsStyles());
    numOfMonitorsEditor.setStyleName(style.monitorsStyles());
    numOfMonitorsEditor.hideLabel();
}
#method_after
protected void applyStyles() {
    hostCpuEditor.addContentWidgetStyleName(style.longCheckboxContent());
    allowConsoleReconnectEditor.addContentWidgetStyleName(style.longCheckboxContent());
    provisioningEditor.addContentWidgetStyleName(style.provisioningEditorContent());
    provisioningThinEditor.addContentWidgetStyleName(style.provisioningRadioContent());
    provisioningCloneEditor.addContentWidgetStyleName(style.provisioningRadioContent());
    cdAttachedEditor.addContentWidgetStyleName(style.cdAttachedLabelWidth());
    cdImageEditor.addContentWidgetStyleName(style.cdImageEditor());
    numOfMonitorsEditor.addContentWidgetStyleName(style.monitorsStyles());
    numOfMonitorsEditor.setStyleName(style.monitorsStyles());
    numOfMonitorsEditor.hideLabel();
    migrationModeEditor.addContentWidgetStyleName(style.migrationSelectorInner());
    isVirtioScsiEnabled.addContentWidgetStyleName(style.isVirtioScsiEnabledEditor());
}
#end_block

#method_before
@Override
public void edit(UnitVmModel model) {
    super.edit(model);
    unitVmModel = model;
    priorityEditor.setRowData(new ArrayList<EntityModel>());
    priorityEditor.asEditor().edit(model.getPriority());
    driver.edit(model);
    initTabAvailabilityListeners(model);
    initListeners(model);
    initCustomPropertySheet(model);
    hideAlwaysHiddenFields();
}
#method_after
@Override
public void edit(UnitVmModel model) {
    super.edit(model);
    unitVmModel = model;
    priorityEditor.setRowData(new ArrayList<EntityModel>());
    priorityEditor.asEditor().edit(model.getPriority());
    driver.edit(model);
    profilesInstanceTypeEditor.edit(model.getNicsWithLogicalNetworks());
    customPropertiesSheetEditor.edit(model.getCustomPropertySheet());
    vmInitEditor.edit(model.getVmInitModel());
    serialNumberPolicyEditor.edit(model.getSerialNumberPolicy());
    initTabAvailabilityListeners(model);
    initListeners(model);
    hideAlwaysHiddenFields();
    decorateDetachableFields();
}
#end_block

#method_before
private void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsHostAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupHostTabAvailability(object);
            } else if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            } else if ("RngRateValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.isRngRateValid()) {
                    rngPeriodEditor.markAsValid();
                } else {
                    rngBytesEditor.markAsInvalid(Arrays.asList(ConstantsManager.getInstance().getConstants().rngRateInvalid()));
                }
            } else if ("RngEgdPathValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.isRngEgdPathValid()) {
                    rngSourceEgdEditor.markAsValid();
                } else {
                    rngSourceEgdEditor.markAsInvalid(Arrays.asList(ConstantsManager.getInstance().getConstants().rngRateInvalid()));
                }
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = (Boolean) object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getRngDevice().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            VmRngDevice dev = (VmRngDevice) object.getRngDevice().getEntity();
            VmRngDevice.Backend.Model model = dev.getBackend().getModel();
            rngPeriodEditor.asValueBox().setValue(dev.getRate().getPeriod());
            rngBytesEditor.asValueBox().setValue(dev.getRate().getBytes());
            rngRandomRandom.setValue(model == VmRngDevice.Backend.Model.DEV_RANDOM);
            rngRandomHwrng.setValue(model == VmRngDevice.Backend.Model.DEV_HWNNG);
            rngEgd.setValue(model == VmRngDevice.Backend.Model.EGD);
            // $NON-NLS-1$
            rngSourceEgdEditor.asValueBox().setValue(dev.getBackend().getEgdPath());
        }
    });
    // only for non local storage available
    setupHostTabAvailability(object);
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable);
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            rngPanel.setVisible((Boolean) object.getIsRngEnabled().getEntity());
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getcompatibility_version() != null) {
                boolean enabled = AsyncDataProvider.isSerialNumberPolicySupported(vdsGroup.getcompatibility_version().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            rngPanel.setVisible((Boolean) object.getIsRngEnabled().getEntity());
        }
    });
}
#end_block

#method_before
protected void updateUsbNativeMessageVisibility(final UnitVmModel object) {
    VDSGroup vdsGroup = object.getSelectedCluster();
    changeApplicationLevelVisibility(nativeUsbWarningMessage, object.getUsbPolicy().getSelectedItem() == UsbPolicy.ENABLED_NATIVE && vdsGroup != null && vdsGroup.getcompatibility_version() != null && !(Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MigrationSupportForNativeUsb, vdsGroup.getcompatibility_version().getValue()));
}
#method_after
protected void updateUsbNativeMessageVisibility(final UnitVmModel object) {
    Version vdsGroupVersion = clusterVersionOrNull(object);
    changeApplicationLevelVisibility(nativeUsbWarningMessage, object.getUsbPolicy().getSelectedItem() == UsbPolicy.ENABLED_NATIVE && vdsGroupVersion != null && !(Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MigrationSupportForNativeUsb, vdsGroupVersion.getValue()));
}
#end_block

#method_before
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsWindowsOS".equals(propName)) {
                // $NON-NLS-1$
                domainEditor.setEnabled(vm.getIsWindowsOS());
            } else if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsDisplayTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsDisplayTabValid()) {
                    consoleTab.markAsValid();
                } else {
                    consoleTab.markAsInvalid(null);
                }
            } else if ("IsAllocationTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsAllocationTabValid()) {
                    resourceAllocationTab.markAsValid();
                } else {
                    resourceAllocationTab.markAsInvalid(null);
                }
            } else if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(highAvailabilityTab, (Boolean) vm.getIsHighlyAvailable().getEntity());
            } else if ("IsBootSequenceTabValid".equals(propName)) {
                // $NON-NLS-1$
                if ((Boolean) vm.getIsHighlyAvailable().getEntity()) {
                    bootOptionsTab.markAsValid();
                } else {
                    bootOptionsTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsCustomPropertiesTabValid()) {
                    customPropertiesTab.markAsValid();
                } else {
                    customPropertiesTab.markAsInvalid(null);
                }
            } else if ("IsRngTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.isRngTabValid()) {
                    rngDeviceTab.markAsValid();
                } else {
                    rngDeviceTab.markAsInvalid(null);
                }
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable);
                if (isDisksAvailable) {
                    // Update warning message by disks status
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.ILLEGAL);
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.LOCKED);
                } else {
                    // Clear warning message
                    // $NON-NLS-1$
                    generalWarningMessage.setText("");
                }
            }
        }
    });
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsLinuxOS".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(linuxBootOptionsPanel, vm.getIsLinuxOS());
            }
        }
    });
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    rngRandomRandom.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            VmRngDevice dev = (VmRngDevice) vm.getRngDevice().getEntity();
            dev.getBackend().setModel(VmRngDevice.Backend.Model.DEV_RANDOM);
        }
    });
    rngRandomHwrng.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            VmRngDevice dev = (VmRngDevice) vm.getRngDevice().getEntity();
            dev.getBackend().setModel(VmRngDevice.Backend.Model.DEV_HWNNG);
        }
    });
    rngEgd.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            VmRngDevice dev = (VmRngDevice) vm.getRngDevice().getEntity();
            dev.getBackend().setModel(VmRngDevice.Backend.Model.EGD);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    rngPeriodEditor.asValueBox().addValueChangeHandler(new ValueChangeHandler<Object>() {

        @Override
        public void onValueChange(ValueChangeEvent<Object> objectValueChangeEvent) {
            VmRngDevice dev = (VmRngDevice) vm.getRngDevice().getEntity();
            String strValue = (String) objectValueChangeEvent.getValue();
            dev.getRate().setPeriod(strValue == null ? null : Integer.parseInt(strValue));
        }
    });
    rngBytesEditor.asValueBox().addValueChangeHandler(new ValueChangeHandler<Object>() {

        @Override
        public void onValueChange(ValueChangeEvent<Object> objectValueChangeEvent) {
            VmRngDevice dev = (VmRngDevice) vm.getRngDevice().getEntity();
            String strValue = (String) objectValueChangeEvent.getValue();
            dev.getRate().setBytes(strValue == null ? null : Integer.parseInt(strValue));
        }
    });
    rngSourceEgdEditor.asValueBox().addValueChangeHandler(new ValueChangeHandler<Object>() {

        @Override
        public void onValueChange(ValueChangeEvent<Object> objectValueChangeEvent) {
            VmRngDevice dev = (VmRngDevice) vm.getRngDevice().getEntity();
            if (dev.getBackend().getModel() == VmRngDevice.Backend.Model.EGD) {
                dev.getBackend().setEgdPath((String) objectValueChangeEvent.getValue());
            }
        }
    });
}
#method_after
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsSystemTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsSystemTabValid()) {
                    systemTab.markAsValid();
                } else {
                    systemTab.markAsInvalid(null);
                }
            } else if ("IsDisplayTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsDisplayTabValid()) {
                    consoleTab.markAsValid();
                } else {
                    consoleTab.markAsInvalid(null);
                }
            } else if ("IsAllocationTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsAllocationTabValid()) {
                    resourceAllocationTab.markAsValid();
                } else {
                    resourceAllocationTab.markAsInvalid(null);
                }
            } else if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(highAvailabilityTab, vm.getIsHighlyAvailable().getEntity());
            } else if ("IsBootSequenceTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsHighlyAvailable().getEntity()) {
                    bootOptionsTab.markAsValid();
                } else {
                    bootOptionsTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsCustomPropertiesTabValid()) {
                    customPropertiesTab.markAsValid();
                } else {
                    customPropertiesTab.markAsInvalid(null);
                }
            } else if ("IsRngTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.isRngTabValid()) {
                    rngDeviceTab.markAsValid();
                } else {
                    rngDeviceTab.markAsInvalid(null);
                }
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || vm.getIsVirtioScsiEnabled().getIsAvailable());
                if (isDisksAvailable) {
                    // Update warning message by disks status
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.ILLEGAL);
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.LOCKED);
                } else {
                    // Clear warning message
                    // $NON-NLS-1$
                    generalWarningMessage.setText("");
                }
            }
        }
    });
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsLinuxOS".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(linuxBootOptionsPanel, vm.getIsLinuxOS());
            }
        }
    });
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    rngSourceRandom.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            vm.getRngSourceRandom().setEntity(true);
            vm.getRngSourceHwrng().setEntity(false);
        }
    });
    rngSourceHwrng.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            vm.getRngSourceHwrng().setEntity(true);
            vm.getRngSourceRandom().setEntity(false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    ssoMethodGuestAgent.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodNone.asRadioButton(), false);
            }
        }
    });
    ssoMethodNone.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodGuestAgent.asRadioButton(), false);
            }
        }
    });
}
#end_block

#method_before
@Override
public UnitVmModel flush() {
    priorityEditor.flush();
    profilesInstanceTypeEditor.flush();
    return driver.flush();
}
#method_after
@Override
public UnitVmModel flush() {
    priorityEditor.flush();
    profilesInstanceTypeEditor.flush();
    vmInitEditor.flush();
    serialNumberPolicyEditor.flush();
    return driver.flush();
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngRandomRandom.setTabIndex(nextTabIndex++);
    rngRandomHwrng.setTabIndex(nextTabIndex++);
    rngSourceEgdEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceRandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(allTabs(), simpleField().visibleInAdvancedModeOnly()).putAll(adancedFieldsFromGeneralTab(), simpleField().visibleInAdvancedModeOnly()).putAll(consoleTabWidgets(), simpleField().visibleInAdvancedModeOnly()).update(consoleTab, simpleField()).update(numOfMonitorsEditor, simpleField()).update(rngPeriodEditor, simpleField()).update(isSingleQxlEnabledEditor, simpleField()).putOne(isSoundcardEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isConsoleDeviceEnabledEditor, simpleField().visibleInAdvancedModeOnly());
}
#method_after
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(allTabs(), simpleField().visibleInAdvancedModeOnly()).putAll(adancedFieldsFromGeneralTab(), simpleField().visibleInAdvancedModeOnly()).putAll(consoleTabWidgets(), simpleField().visibleInAdvancedModeOnly()).update(consoleTab, simpleField()).update(numOfMonitorsEditor, simpleField()).update(isSingleQxlEnabledEditor, simpleField()).putOne(isSoundcardEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isConsoleDeviceEnabledEditor, simpleField().visibleInAdvancedModeOnly());
}
#end_block

#method_before
protected List<Widget> consoleTabWidgets() {
    return Arrays.<Widget>asList(displayProtocolEditor, usbSupportEditor, isSmartcardEnabledEditor, nativeUsbWarningMessage, expander, numOfMonitorsEditor, vncKeyboardLayoutEditor);
}
#method_after
protected List<Widget> consoleTabWidgets() {
    return Arrays.<Widget>asList(displayProtocolEditor, usbSupportEditor, isSmartcardEnabledEditor, nativeUsbWarningMessage, expander, numOfMonitorsEditor, vncKeyboardLayoutEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent);
}
#end_block

#method_before
protected List<Widget> poolSpecificFields() {
    return Arrays.<Widget>asList(numOfVmsEditor, newPoolEditVmsPanel, editPoolEditVmsPanel, editPoolIncraseNumOfVmsPanel, poolTab, prestartedVmsEditor, poolNameIcon, newPoolEditMaxAssignedVmsPerUserPanel, editPoolEditMaxAssignedVmsPerUserPanel);
}
#method_after
protected List<Widget> poolSpecificFields() {
    return Arrays.<Widget>asList(numOfVmsEditor, newPoolEditVmsPanel, editPoolEditVmsPanel, editPoolIncraseNumOfVmsPanel, poolTab, prestartedVmsEditor, poolNameIcon, newPoolEditMaxAssignedVmsPerUserPanel, editPoolEditMaxAssignedVmsPerUserPanel, spiceProxyEditor, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyOverrideEnabledEditor);
}
#end_block

#method_before
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getRngDevice() == null) {
        return failCanDoAction(VdcBllMessages.RNG_NOT_FOUND);
    }
    if (!getRngDevices().isEmpty()) {
        return failCanDoAction(VdcBllMessages.RNG_ALREADY_EXISTS);
    }
    return true;
}
#method_after
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (!isRngSupportedByClusterLevel()) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!getRngDevices().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_ALREADY_EXISTS);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VmDevice rngDevice = new VmDevice();
    rngDevice.setId(new VmDeviceId(Guid.newGuid(), getParameters().getRngDevice().getVmId()));
    rngDevice.setVmId(getParameters().getRngDevice().getVmId());
    rngDevice.setDevice(VmDeviceType.VIRTIO.getName());
    rngDevice.setType(VmDeviceGeneralType.RNG);
    rngDevice.setAddress(StringUtils.EMPTY);
    rngDevice.setSpecParams(getParameters().getRngDevice().generateSpecParams());
    getDbFacade().getVmDeviceDao().save(rngDevice);
    setSucceeded(true);
    setActionReturnValue(rngDevice.getId());
}
#method_after
@Override
protected void executeCommand() {
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice.getDeviceId() == null) {
        rngDevice.setDeviceId(Guid.newGuid());
    }
    getDbFacade().getVmDeviceDao().save(rngDevice);
    setActionReturnValue(rngDevice.getDeviceId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (VmTemplateHandler.BlankVmTemplateId.equals(getVmTemplate().getId())) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_EDIT_BLANK_TEMPLATE);
    }
    boolean returnValue = false;
    mOldTemplate = DbFacade.getInstance().getVmTemplateDao().get(getVmTemplate().getId());
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    VmTemplateHandler.UpdateDisksFromDb(mOldTemplate);
    if (mOldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IS_LOCKED);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName()) && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    } else {
        if (getVdsGroup() == null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CLUSTER_IS_NOT_VALID);
        } else if (VmHandler.isMemorySizeLegal(mOldTemplate.getOsId(), mOldTemplate.getMemSizeMb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
            if (IsVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && IsDomainLegal(getParameters().getVmTemplateData().getDomain(), getReturnValue().getCanDoActionMessages())) {
                returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
                if (!returnValue) {
                    addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
                }
            }
        }
    }
    // Check that the USB policy is legal
    if (returnValue) {
        returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        returnValue = false;
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVmTemplate().getId())) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_EDIT_BLANK_TEMPLATE);
    }
    boolean returnValue = false;
    mOldTemplate = DbFacade.getInstance().getVmTemplateDao().get(getVmTemplate().getId());
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(VdcBllMessages.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!isInstanceType && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVmTemplate() != null) {
        getVmStaticDAO().incrementDbGeneration(getVmTemplate().getId());
        UpdateVmTemplate();
        updateWatchdog();
        updateRngDevice();
        checkTrustedService();
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getParameters().getVmTemplateData(), getVdsGroup().getcompatibility_version());
    }
    if (getVmTemplate() != null) {
        getVmStaticDAO().incrementDbGeneration(getVmTemplate().getId());
        updateOriginalTemplateNameOnDerivedVms();
        UpdateVmTemplate();
        updateWatchdog(getParameters().getVmTemplateData().getId());
        updateRngDevice(getParameters().getVmTemplateData().getId());
        checkTrustedService();
        setSucceeded(true);
    }
}
#end_block

#method_before
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVmTemplate().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVmTemplate().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    if (getVdsGroup() == null) {
        return;
    }
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVmTemplate().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVmTemplate().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
private void UpdateVmTemplate() {
    DbFacade.getInstance().getVmTemplateDao().update(getVmTemplate());
    // also update the smartcard device
    VmDeviceUtils.updateSmartcardDevice(getVmTemplateId(), getParameters().getVmTemplateData().isSmartcardEnabled());
    // update audio device
    VmDeviceUtils.updateAudioDevice(mOldTemplate, getVmTemplate(), getVdsGroup().getcompatibility_version(), getParameters().isSoundDeviceEnabled());
    VmDeviceUtils.updateConsoleDevice(getVmTemplateId(), getParameters().isConsoleEnabled());
}
#method_after
private void UpdateVmTemplate() {
    VmHandler.updateVmInitToDB(getVmTemplate());
    DbFacade.getInstance().getVmTemplateDao().update(getVmTemplate());
    // also update the smartcard device
    VmDeviceUtils.updateSmartcardDevice(getVmTemplateId(), getParameters().getVmTemplateData().isSmartcardEnabled());
    // update audio device
    VmDeviceUtils.updateAudioDevice(mOldTemplate, getVmTemplate(), getVdsGroup() != null ? getVdsGroup().getcompatibility_version() : null, getParameters().isSoundDeviceEnabled());
    VmDeviceUtils.updateConsoleDevice(getVmTemplateId(), getParameters().isConsoleEnabled());
    VmDeviceUtils.updateVirtioScsiController(getVmTemplateId(), getParameters().isVirtioScsiEnabled());
    VmDeviceUtils.updateMemoryBalloon(getVmTemplateId(), getParameters().isBalloonEnabled());
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    final List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getVmTemplate() != null) {
        // host-specific parameters can be changed by administration role only
        if (!(getVmTemplate().getDedicatedVmForVds() == null ? getParameters().getVmTemplateData().getDedicatedVmForVds() == null : getVmTemplate().getDedicatedVmForVds().equals(getParameters().getVmTemplateData().getDedicatedVmForVds()))) {
            permissionList.add(new PermissionSubject(getParameters().getVmTemplateId(), VdcObjectType.VmTemplate, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
        }
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    final List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getVmTemplate() != null && getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        // host-specific parameters can be changed by administration role only
        if (!(getVmTemplate().getDedicatedVmForVds() == null ? getParameters().getVmTemplateData().getDedicatedVmForVds() == null : getVmTemplate().getDedicatedVmForVds().equals(getParameters().getVmTemplateData().getDedicatedVmForVds()))) {
            permissionList.add(new PermissionSubject(getParameters().getVmTemplateId(), VdcObjectType.VmTemplate, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
        }
    }
    return permissionList;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    final List<VmDevice> vmDevices = getDbFacade().getVmDeviceDao().getVmDeviceByVmIdAndType(getParameters().getId(), VmDeviceGeneralType.RNG);
    if (vmDevices != null && !vmDevices.isEmpty()) {
        VmDevice dev = vmDevices.get(0);
        VmRngDevice.Rate rate = extractRateFromDev(dev);
        VmRngDevice.Backend backend = extractBackendFromDev(dev);
        VmRngDevice rng = new VmRngDevice(dev.getDeviceId(), getParameters().getId(), rate, backend);
        setReturnValue(Collections.singletonList(rng));
    } else {
        setReturnValue(Collections.emptyList());
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    final List<VmDevice> vmDevices = getDbFacade().getVmDeviceDao().getVmDeviceByVmIdAndType(getParameters().getId(), VmDeviceGeneralType.RNG);
    if (vmDevices != null && !vmDevices.isEmpty()) {
        VmDevice dev = vmDevices.get(0);
        setReturnValue(Collections.singletonList(new VmRngDevice(dev)));
    } else {
        setReturnValue(Collections.emptyList());
    }
}
#end_block

#method_before
public void setVm(VM value) {
    _vmStatic = value.getStaticData();
}
#method_after
public void setVm(VM value) {
    // to make the getVm() use the new value
    vm = null;
    _vmStatic = value.getStaticData();
}
#end_block

#method_before
public void setRngDevice(VmRngDevice rngDevice) {
    this.rngDevice = rngDevice;
}
#method_after
public void setRngDevice(VmRngDevice rngDevice) {
    this.rngDevice = rngDevice;
    if (this.rngDevice != null) {
        this.rngDevice.setVmId(getVmId());
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    oldVm = getVm();
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    VmStatic newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    UpdateVmNetworks();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    updateWatchdog();
    updateRngDevice();
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic)) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    if (!getParameters().isApplyChangesLater()) {
        hotSetCpus(cpuPerSocket);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void updateRngDevice() {
    // do not update if this flag is not set
    if (getParameters().isUpdateRngDevice()) {
        VdcQueryReturnValue query = getBackend().runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
        @SuppressWarnings("unchecked")
        List<VmRngDevice> rngDevs = (List<VmRngDevice>) query.getReturnValue();
        if (getParameters().getRngDevice() != null) {
            getParameters().getRngDevice().setVmId(getParameters().getVmId());
        }
        if (rngDevs.isEmpty()) {
            if (getParameters().getRngDevice() != null) {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                getBackend().runInternalAction(VdcActionType.AddRngDevice, params);
            }
        } else {
            if (getParameters().getRngDevice() == null) {
                RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
                getBackend().runInternalAction(VdcActionType.RemoveRngDevice, params);
            } else {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                params.getRngDevice().setId(rngDevs.get(0).getId());
                getBackend().runInternalAction(VdcActionType.UpdateRngDevice, params);
            }
        }
    }
}
#method_after
private boolean updateRngDevice() {
    // do not update if this flag is not set
    if (getParameters().isUpdateRngDevice()) {
        VdcQueryReturnValue query = getBackend().runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
        @SuppressWarnings("unchecked")
        List<VmRngDevice> rngDevs = query.getReturnValue();
        VdcReturnValueBase rngCommandResult = null;
        if (rngDevs.isEmpty()) {
            if (getParameters().getRngDevice() != null) {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                rngCommandResult = getBackend().runInternalAction(VdcActionType.AddRngDevice, params);
            }
        } else {
            if (getParameters().getRngDevice() == null) {
                RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
                rngCommandResult = getBackend().runInternalAction(VdcActionType.RemoveRngDevice, params);
            } else {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
                rngCommandResult = getBackend().runInternalAction(VdcActionType.UpdateRngDevice, params);
            }
        }
        if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void UpdateVmNetworks() {
    // check if the cluster has changed
    if (!getVm().getVdsGroupId().equals(getParameters().getVmStaticData().getVdsGroupId())) {
        List<Network> networks = getNetworkDAO().getAllForCluster(getParameters().getVmStaticData().getVdsGroupId());
        List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNic iface : interfaces) {
            final Network network = NetworkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

                @Override
                public boolean eval(Network n) {
                    return ObjectUtils.equals(n.getId(), network.getId());
                }
            });
            // if network not exists in cluster we remove the network from the interface
            if (net == null) {
                iface.setVnicProfileId(null);
                getVmNicDao().update(iface);
            }
        }
    }
}
#method_after
private void UpdateVmNetworks() {
    // check if the cluster has changed
    if (!Objects.equals(getVm().getVdsGroupId(), getParameters().getVmStaticData().getVdsGroupId())) {
        List<Network> networks = getNetworkDAO().getAllForCluster(getParameters().getVmStaticData().getVdsGroupId());
        List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNic iface : interfaces) {
            final Network network = NetworkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

                @Override
                public boolean eval(Network n) {
                    return ObjectUtils.equals(n.getId(), network.getId());
                }
            });
            // if network not exists in cluster we remove the network from the interface
            if (net == null) {
                iface.setVnicProfileId(null);
                getVmNicDao().update(iface);
            }
        }
    }
}
#end_block

#method_before
@Override
protected List<Class<?>> getValidationGroups() {
    addValidationGroup(UpdateEntity.class);
    return super.getValidationGroups();
}
#method_after
@Override
protected List<Class<?>> getValidationGroups() {
    addValidationGroup(UpdateVm.class);
    return super.getValidationGroups();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(vmFromParams.getOs(), vmFromParams.getMemSizeMb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // if number of monitors has increased, check PCI and IDE limits are ok
    if (vmFromDB.getNumOfMonitors() < vmFromParams.getNumOfMonitors()) {
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
        List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
        if (!checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device console");
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device sound");
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device VirtIO-SCSI");
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#end_block

#method_before
private boolean vmDeviceChanged(VmDeviceGeneralType deviceType, boolean deviceEnabled) {
    List<VmDevice> vmDevices = getVmDeviceDao().getVmDeviceByVmIdAndType(getParameters().getVmId(), deviceType);
    return deviceEnabled == vmDevices.isEmpty();
}
#method_after
private boolean vmDeviceChanged(VmDeviceGeneralType deviceType, String device, boolean deviceEnabled) {
    List<VmDevice> vmDevices = getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(getParameters().getVmId(), deviceType, device);
    return deviceEnabled == vmDevices.isEmpty();
}
#end_block

#method_before
protected boolean areUpdatedFieldsLegal() {
    return VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus());
}
#method_after
protected boolean areUpdatedFieldsLegal() {
    return VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), VMStatus.Down);
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_BEING_UPDATED));
    }
    return null;
}
#end_block

#method_before
private String getDiskSharedLockMessage() {
    if (cachedDiskSharedLockMessage == null) {
        cachedDiskSharedLockMessage = new StringBuilder(VdcBllMessages.ACTION_TYPE_FAILED_DISK_IS_USED_FOR_CREATE_VM.name()).append(String.format("$VmName %1$s", getVmName())).toString();
    }
    return cachedDiskSharedLockMessage;
}
#method_after
protected String getDiskSharedLockMessage() {
    if (cachedDiskSharedLockMessage == null) {
        cachedDiskSharedLockMessage = new StringBuilder(VdcBllMessages.ACTION_TYPE_FAILED_DISK_IS_USED_FOR_CREATE_VM.name()).append(String.format("$VmName %1$s", getVmName())).toString();
    }
    return cachedDiskSharedLockMessage;
}
#end_block

#method_before
protected void initTemplateDisks() {
    if (getVmTemplate() != null) {
        VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
    }
}
#method_after
protected void initTemplateDisks() {
    if (vmDisksSource != null) {
        VmTemplateHandler.updateDisksFromDb(vmDisksSource);
    }
}
#end_block

#method_before
protected List<VmNic> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNic> vmNetworkInterfaces = getVmNicDao().getAllForTemplate(getVmTemplate().getId());
        _vmInterfaces = vmNetworkInterfaces == null ? new ArrayList<VmNic>() : vmNetworkInterfaces;
    }
    return _vmInterfaces;
}
#method_after
protected List<VmNic> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNic> vmNetworkInterfaces = getVmNicDao().getAllForTemplate(vmInterfacesSourceId);
        _vmInterfaces = vmNetworkInterfaces == null ? new ArrayList<VmNic>() : vmNetworkInterfaces;
    }
    return _vmInterfaces;
}
#end_block

#method_before
protected List<? extends Disk> getVmDisks() {
    if (_vmDisks == null) {
        _vmDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId());
    }
    return _vmDisks;
}
#method_after
protected List<? extends Disk> getVmDisks() {
    if (_vmDisks == null) {
        _vmDisks = DbFacade.getInstance().getDiskDao().getAllForVm(vmDisksSource.getId());
    }
    return _vmDisks;
}
#end_block

#method_before
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority());
    if (returnValue) {
        List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    // check that template image and vm are on the same storage pool
    if (returnValue && shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else {
            for (StorageDomain domain : destStorages) {
                StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
                if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                    return false;
                }
                if (!validate(storageDomainValidator.isDomainWithinThresholds()) || !validate(storageDomainValidator.isDomainHasSpaceForRequest(getNeededDiskSize(domain.getId())))) {
                    return false;
                }
            }
        }
    }
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#method_after
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, reasons);
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return isDedicatedVdsOnSameCluster(vmStaticFromParams);
}
#end_block

#method_before
protected boolean shouldCheckSpaceInStorageDomains() {
    return !getImagesToCheckDestinationStorageDomains().isEmpty() && !LinqUtils.firstOrNull(getImagesToCheckDestinationStorageDomains(), new All<DiskImage>()).getImageId().equals(VmTemplateHandler.BlankVmTemplateId);
}
#method_after
protected boolean shouldCheckSpaceInStorageDomains() {
    return !getImagesToCheckDestinationStorageDomains().isEmpty() && !LinqUtils.firstOrNull(getImagesToCheckDestinationStorageDomains(), new All<DiskImage>()).getImageId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
}
#end_block

#method_before
protected Guid getStoragePoolIdFromSourceImageContainer() {
    return getVmTemplate().getStoragePoolId();
}
#method_after
protected Guid getStoragePoolIdFromSourceImageContainer() {
    return vmDisksSource.getStoragePoolId();
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVm().getOs(), getVdsGroup().getcompatibility_version(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
public static boolean checkCpuSockets(int num_of_sockets, int cpu_per_socket, String compatibility_version, List<String> CanDoActionMessages) {
    boolean retValue = true;
    if (retValue && (num_of_sockets * cpu_per_socket) > Config.<Integer>GetValue(ConfigValues.MaxNumOfVmCpus, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_NUM_CPU.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets > Config.<Integer>GetValue(ConfigValues.MaxNumOfVmSockets, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket > Config.<Integer>GetValue(ConfigValues.MaxNumOfCpuPerSocket, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket < 1) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIN_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets < 1) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIN_NUM_SOCKETS.toString());
        retValue = false;
    }
    return retValue;
}
#method_after
public static boolean checkCpuSockets(int num_of_sockets, int cpu_per_socket, String compatibility_version, List<String> CanDoActionMessages) {
    boolean retValue = true;
    if (retValue && (num_of_sockets * cpu_per_socket) > Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_NUM_CPU.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets > Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket > Config.<Integer>getValue(ConfigValues.MaxNumOfCpuPerSocket, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket < 1) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIN_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets < 1) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIN_NUM_SOCKETS.toString());
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
@Override
protected List<Class<?>> getValidationGroups() {
    addValidationGroup(CreateEntity.class);
    return super.getValidationGroups();
}
#method_after
@Override
protected List<Class<?>> getValidationGroups() {
    addValidationGroup(CreateVm.class);
    return super.getValidationGroups();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#end_block

#method_before
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPoolWithVms) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), storage.getId(), reasons, false, false, true, true, storageToDisksMap.get(storage.getId()))) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPoolWithVms) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!VmTemplateCommand.isVmTemplateImagesReady(vmDisksSource, storage.getId(), reasons, false, false, true, true, storageToDisksMap.get(storage.getId()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean buildAndCheckDestStorageDomains() {
    boolean retValue = true;
    if (diskInfoDestinationMap.isEmpty()) {
        retValue = fillDestMap();
    } else {
        retValue = validateProvidedDestinations();
    }
    if (retValue && getImagesToCheckDestinationStorageDomains().size() != diskInfoDestinationMap.size()) {
        log.errorFormat("Can not found any default active domain for one of the disks of template with id : {0}", getVmTemplate().getId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        retValue = false;
    }
    return retValue && validateIsImagesOnDomains();
}
#method_after
protected boolean buildAndCheckDestStorageDomains() {
    boolean retValue = true;
    if (diskInfoDestinationMap.isEmpty()) {
        retValue = fillDestMap();
    } else {
        retValue = validateProvidedDestinations();
    }
    if (retValue && getImagesToCheckDestinationStorageDomains().size() != diskInfoDestinationMap.size()) {
        log.errorFormat("Can not find any default active domain for one of the disks of template with id : {0}", vmDisksSource.getId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        retValue = false;
    }
    return retValue && validateIsImagesOnDomains();
}
#end_block

#method_before
protected Collection<DiskImage> getImagesToCheckDestinationStorageDomains() {
    return getVmTemplate().getDiskTemplateMap().values();
}
#method_after
protected Collection<DiskImage> getImagesToCheckDestinationStorageDomains() {
    return vmDisksSource.getDiskTemplateMap().values();
}
#end_block

#method_before
protected void fillImagesMapBasedOnTemplate() {
    ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), getStorageDomainDAO().getAllForStoragePool(getVmTemplate().getStoragePoolId()), diskInfoDestinationMap, destStorages, false);
}
#method_after
protected void fillImagesMapBasedOnTemplate() {
    ImagesHandler.fillImagesMapBasedOnTemplate(vmDisksSource, getPoolDomains(), diskInfoDestinationMap, destStorages, false);
}
#end_block

#method_before
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.VerifyAddVm(reasons, getVmInterfaces().size(), vmPriority);
}
#method_after
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    addVmPayload();
                    updateSmartCardDevices();
                    addVmWatchdog();
                    addVmRngDevice();
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                addVmRngDevice();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getParameters().getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        getBackend().runInternalAction(VdcActionType.AddRngDevice, params);
    }
}
#method_after
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddRngDevice, params);
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(getVmTemplateId(), getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled());
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), false);
    if (instanceTypeId != null) {
        copyDiskDevicesFromTemplate();
    }
}
#end_block

#method_before
protected boolean areParametersLegal(List<String> reasons) {
    boolean returnValue = false;
    final VmStatic vmStaticData = getParameters().getVmStaticData();
    if (vmStaticData != null) {
        returnValue = isLegalClusterId(vmStaticData.getVdsGroupId(), reasons);
        if (!validatePinningAndMigration(reasons, vmStaticData, getParameters().getVm().getCpuPinning())) {
            returnValue = false;
        }
        returnValue = returnValue && VmHandler.isMemorySizeLegal(vmStaticData.getOsId(), vmStaticData.getMemSizeMb(), reasons, getVdsGroup().getcompatibility_version());
    }
    return returnValue;
}
#method_after
protected boolean areParametersLegal(List<String> reasons) {
    boolean returnValue = false;
    final VmStatic vmStaticData = getParameters().getVmStaticData();
    if (vmStaticData != null) {
        returnValue = isLegalClusterId(vmStaticData.getVdsGroupId(), reasons);
        if (!validatePinningAndMigration(reasons, vmStaticData, getParameters().getVm().getCpuPinning())) {
            returnValue = false;
        }
    }
    return returnValue;
}
#end_block

#method_before
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNic iface : getVmInterfaces()) {
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // Parses the custom properties field that was filled by frontend to
    // predefined and user defined fields
    VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getVdsGroup().getcompatibility_version(), vmStatic);
    updateOriginalTemplate(vmStatic);
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#method_after
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    tempVar.setLastStopTime(new Date());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#end_block

#method_before
protected boolean addVmImages() {
    if (getVmTemplate().getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
protected void addPermissionSubjectForAdminLevelProperties(List<PermissionSubject> permissionList) {
    final VmStatic vmFromParams = getParameters().getVmStaticData();
    if (vmFromParams != null) {
        // user needs specific permission to change custom properties
        if (!StringUtils.isEmpty(vmFromParams.getCustomProperties())) {
            permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
        }
        // host-specific parameters can be changed by administration role only
        if (vmFromParams.getDedicatedVmForVds() != null || !StringUtils.isEmpty(vmFromParams.getCpuPinning())) {
            permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.EDIT_ADMIN_VM_PROPERTIES));
        }
    }
}
#method_after
protected void addPermissionSubjectForAdminLevelProperties(List<PermissionSubject> permissionList) {
    VmStatic vmFromParams = getParameters().getVmStaticData();
    if (vmFromParams != null) {
        // user needs specific permission to change custom properties
        if (!StringUtils.isEmpty(vmFromParams.getCustomProperties())) {
            permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
        }
        // host-specific parameters can be changed by administration role only
        if (vmFromParams.getDedicatedVmForVds() != null || !StringUtils.isEmpty(vmFromParams.getCpuPinning())) {
            permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.EDIT_ADMIN_VM_PROPERTIES));
        }
    }
}
#end_block

#method_before
protected void addVmPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissionsToAdd.addPermission(getCurrentUser().getUserId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
    }
    if (getParameters().isCopyTemplatePermissions() && !getVmTemplateId().equals(VmTemplateHandler.BlankVmTemplateId)) {
        copyTemplatePermissions(permissionsToAdd);
    }
    if (!permissionsToAdd.isEmpty()) {
        List<permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new permissions[permissionsList.size()]));
        getCompensationContext().snapshotNewEntities(permissionsList);
    }
}
#method_after
protected void addVmPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissionsToAdd.addPermission(getCurrentUser().getId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
    }
    if (getParameters().isCopyTemplatePermissions() && !getVmTemplateId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID)) {
        copyTemplatePermissions(permissionsToAdd);
    }
    if (!permissionsToAdd.isEmpty()) {
        List<Permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new Permissions[permissionsList.size()]));
        getCompensationContext().snapshotNewEntities(permissionsList);
    }
}
#end_block

#method_before
private void copyTemplatePermissions(UniquePermissionsSet permissionsToAdd) {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<permissions> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getCurrentUser().getUserId(), false);
    for (permissions templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        permissionsToAdd.addPermission(templatePermission.getad_element_id(), templatePermission.getrole_id(), getVmId(), VdcObjectType.VM);
    }
}
#method_after
private void copyTemplatePermissions(UniquePermissionsSet permissionsToAdd) {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getCurrentUser().getId(), false);
    for (Permissions templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        permissionsToAdd.addPermission(templatePermission.getad_element_id(), templatePermission.getrole_id(), getVmId(), VdcObjectType.VM);
    }
}
#end_block

#method_before
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    permissions[] permsArray = new permissions[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new permissions(getCurrentUser().getUserId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#method_after
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    Permissions[] permsArray = new Permissions[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new Permissions(getCurrentUser().getId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#end_block

#method_before
public void setUpdateRngDevice(boolean updateRngDevice) {
    this.updateRngDevice = updateRngDevice;
}
#method_after
public void setUpdateRngDevice(boolean updateRngDevice) {
    this.updateRngDevice = updateRngDevice;
    if (this.rngDevice != null) {
        this.rngDevice.setVmId(getVmTemplateId());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters().getRngDevice().getVmId() == null || !entityExists()) {
        return failCanDoAction(getParameters().isVm() ? VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND : VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isRngAllowedInEngine()) {
        return failCanDoAction(VdcBllMessages.RNG_NOT_ENABLED_IN_ENGINE);
    }
    VDSGroup cluster = getClusterForEntity();
    if (cluster == null || Version.v3_3.compareTo(cluster.getcompatibility_version()) > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getParameters().getRngDevice().getVmId() == null || cachedEntity == null) {
        return failCanDoAction(getParameters().isVm() ? VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND : VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getParameters().isVm() && getVm() != null && getVm().isRunningOrPaused()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING);
    }
    return true;
}
#end_block

#method_before
protected List<VmDevice> getRngDevices() {
    return getVmDeviceDao().getVmDeviceByVmIdAndType(getParameters().getRngDevice().getVmId(), VmDeviceGeneralType.RNG);
}
#method_after
protected List<VmDevice> getRngDevices() {
    return cachedRngDevices;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getRngDevices().isEmpty()) {
        return failCanDoAction(VdcBllMessages.RNG_NOT_FOUND);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getRngDevices().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_NOT_FOUND);
    }
    return true;
}
#end_block

#method_before
public static void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase entity = params.getVmStaticData();
    if (entity != null) {
        updateCdInVmDevice(oldVmBase, entity);
        if (oldVmBase.getDefaultBootSequence() != entity.getDefaultBootSequence()) {
            updateBootOrderInVmDeviceAndStoreToDB(entity);
        }
        // if the console type has changed, recreate Video devices
        boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != entity.getDefaultDisplayType();
        boolean numOfMonitorsChanged = entity.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != entity.getNumOfMonitors();
        boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != entity.getSingleQxlPci();
        if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged) {
            // delete all video device
            for (VmDevice device : dao.getVmDeviceByVmIdAndType(oldVmBase.getId(), VmDeviceGeneralType.VIDEO)) {
                dao.remove(device.getId());
            }
            // add video device per each monitor
            int monitors = entity.getSingleQxlPci() ? 1 : entity.getNumOfMonitors();
            for (int i = 0; i < monitors; i++) {
                addManagedDevice(new VmDeviceId(Guid.newGuid(), entity.getId()), VmDeviceGeneralType.VIDEO, entity.getDefaultDisplayType().getVmDeviceType(), getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()), true, false, null);
            }
        }
        updateUSBSlots(oldVmBase, entity);
        updateMemoryBalloon(oldVmBase, entity, params.isBalloonEnabled());
        updateAudioDevice(oldVm.getStaticData(), entity, oldVm.getVdsGroupCompatibilityVersion(), params.isSoundDeviceEnabled());
        updateSmartcardDevice(oldVm, entity);
        updateConsoleDevice(entity, params.isConsoleEnabled());
    }
}
#method_after
public static void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase entity = params.getVmStaticData();
    if (entity != null) {
        updateCdInVmDevice(oldVmBase, entity);
        if (oldVmBase.getDefaultBootSequence() != entity.getDefaultBootSequence()) {
            updateBootOrderInVmDeviceAndStoreToDB(entity);
        }
        // if the console type has changed, recreate Video devices
        boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != entity.getDefaultDisplayType();
        boolean numOfMonitorsChanged = entity.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != entity.getNumOfMonitors();
        boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != entity.getSingleQxlPci();
        if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged) {
            // delete all video device
            for (VmDevice device : dao.getVmDeviceByVmIdAndType(oldVmBase.getId(), VmDeviceGeneralType.VIDEO)) {
                dao.remove(device.getId());
            }
            // add video device per each monitor
            int monitors = entity.getSingleQxlPci() ? 1 : entity.getNumOfMonitors();
            for (int i = 0; i < monitors; i++) {
                VmDeviceType vmDeviceType = osRepository.getDisplayDevice(entity.getOsId(), ClusterUtils.getCompatibilityVersion(entity), entity.getDefaultDisplayType());
                addManagedDevice(new VmDeviceId(Guid.newGuid(), entity.getId()), VmDeviceGeneralType.VIDEO, vmDeviceType, getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()), true, false, null);
            }
        }
        updateUSBSlots(oldVmBase, entity);
        updateMemoryBalloon(entity, params.isBalloonEnabled());
        updateAudioDevice(oldVm.getStaticData(), entity, oldVm.getVdsGroupCompatibilityVersion(), params.isSoundDeviceEnabled());
        updateSmartcardDevice(oldVm, entity);
        updateConsoleDevice(entity, params.isConsoleEnabled());
        updateVirtioScsiController(entity.getId(), params.isVirtioScsiEnabled());
    }
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled) {
    VM vm = DbFacade.getInstance().getVmDao().get(dstId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    boolean isVm = (vmBase != null);
    if (!isVm) {
        vmBase = DbFacade.getInstance().getVmTemplateDao().get(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, vm, vmBase, isVm, devices, srcDeviceIdToTargetDeviceIdMapping, soundDeviceEnabled, isConsoleEnabled);
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, VM vm, VmBase vmBase, boolean isVm, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, boolean copySnapshotDevices) {
    Guid id;
    String isoPath = vmBase.getIsoPath();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    boolean hasSoundDevice = false;
    boolean hasAlreadyConsoleDevice = false;
    boolean hasVirtioScsiController = false;
    for (VmDevice device : devicesDataToUse) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        id = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, specParams, true, true, null);
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(vmBase, isBalloonEnabled);
        }
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                        id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    // check here is source VM had CD (Vm from snapshot)
                    String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                    shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
                    if (!hasAlreadyCD && shouldHaveCD) {
                        setCdPath(specParams, srcCdPath, isoPath);
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                    id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsiController = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (isVm) {
                    // to the new VMStatic params
                    continue;
                } else {
                    specParams.putAll(getMemExpr(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci()));
                }
                break;
            case BALLOON:
                specParams.put(VdsProperties.Model, VdsProperties.Virtio);
                break;
            case SMARTCARD:
                specParams = new SmartcardSpecParams();
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                hasAlreadyConsoleDevice = true;
                if (!isConsoleEnabled) {
                    continue;
                }
                break;
            case SOUND:
                hasSoundDevice = true;
                if (!soundDeviceEnabled) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if source doesnt have sound device and requested, add it
    if (soundDeviceEnabled && !hasSoundDevice) {
        if (isVm) {
            addSoundCard(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion());
        } else {
            VDSGroup cluster = vmBase.getVdsGroupId() != null ? DbFacade.getInstance().getVdsGroupDao().get(vmBase.getVdsGroupId()) : null;
            if (cluster != null) {
                addSoundCard(vmBase, cluster.getcompatibility_version());
            }
        }
    }
    if (isConsoleEnabled && !hasAlreadyConsoleDevice) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsiController) {
        addVirtioScsiController(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
        int numOfMonitors = (vmBase.getDefaultDisplayType() == DisplayType.vnc) ? Math.max(1, vmBase.getNumOfMonitors()) : vmBase.getSingleQxlPci() ? 1 : vmBase.getNumOfMonitors();
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vmBase);
        }
    }
}
#end_block

#method_before
private static void addVideoDevice(VmBase vm) {
    addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.VIDEO, vm.getDefaultDisplayType().getVmDeviceType(), getMemExpr(vm.getNumOfMonitors(), vm.getSingleQxlPci()), true, true, null);
}
#method_after
private static void addVideoDevice(VmBase vm) {
    VmDeviceType vmDeviceType = osRepository.getDisplayDevice(vm.getOsId(), ClusterUtils.getCompatibilityVersion(vm), vm.getDefaultDisplayType());
    addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.VIDEO, vmDeviceType, getMemExpr(vm.getNumOfMonitors(), vm.getSingleQxlPci()), true, true, null);
}
#end_block

#method_before
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean is_plugged, boolean isReadOnly, Map<String, String> customProp) {
    VmDevice managedDevice = new VmDevice(id, type, device.getName(), "", 0, specParams, true, is_plugged, isReadOnly, "", customProp);
    dao.save(managedDevice);
    // If we add Disk/Interface/CD/Floppy, we have to recalculate boot order
    if (type == VmDeviceGeneralType.DISK || type == VmDeviceGeneralType.INTERFACE) {
        // recalculate boot sequence
        VmBase vmBase = DbFacade.getInstance().getVmStaticDao().get(id.getVmId());
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
    }
    return managedDevice;
}
#method_after
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean plugged, Boolean readOnly, String address, Map<String, String> customProp) {
    VmDevice managedDevice = addManagedDevice(id, type, device, specParams, plugged, readOnly, customProp);
    if (StringUtils.isNotBlank(address)) {
        managedDevice.setAddress(address);
    }
    return managedDevice;
}
#end_block

#method_before
public static void updateBootOrderInVmDeviceAndStoreToDB(VmBase vmBase) {
    List<VmDevice> devices = updateBootOrderInVmDevice(vmBase);
    for (VmDevice device : devices) {
        dao.update(device);
    }
}
#method_after
public static void updateBootOrderInVmDeviceAndStoreToDB(VmBase vmBase) {
    List<VmDevice> devices = updateBootOrderInVmDevice(vmBase);
    for (VmDevice device : devices) {
        dao.updateBootOrder(device);
    }
}
#end_block

#method_before
public static List<VmDevice> updateBootOrderInVmDevice(VmBase vmBase) {
    if (vmBase instanceof VmStatic) {
        // Returns the devices sorted in ascending order
        List<VmDevice> devices = dao.getVmDeviceByVmId(vmBase.getId());
        // reset current boot order
        for (VmDevice device : devices) {
            device.setBootOrder(0);
        }
        VM vm = DbFacade.getInstance().getVmDao().get(vmBase.getId());
        VmHandler.updateDisksForVm(vm, DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId()));
        boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getVdsGroupCompatibilityVersion());
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, devices, isOldCluster);
        return devices;
    }
    return Collections.emptyList();
}
#method_after
public static List<VmDevice> updateBootOrderInVmDevice(VmBase vmBase) {
    if (vmBase instanceof VmStatic) {
        // Returns the devices sorted in ascending order
        List<VmDevice> devices = dao.getVmDeviceByVmId(vmBase.getId());
        // reset current boot order
        for (VmDevice device : devices) {
            device.setBootOrder(0);
        }
        VM vm = DbFacade.getInstance().getVmDao().get(vmBase.getId());
        VmHandler.updateDisksForVm(vm, DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId()));
        VmHandler.updateNetworkInterfacesFromDb(vm);
        boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getVdsGroupCompatibilityVersion());
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, devices, isOldCluster);
        return devices;
    }
    return Collections.emptyList();
}
#end_block

#method_before
private static void updateUSBSlots(VmBase oldVm, VmBase newVm) {
    UsbPolicy oldUsbPolicy = UsbPolicy.DISABLED;
    UsbPolicy newUsbPolicy = newVm.getUsbPolicy();
    int currentNumberOfSlots = 0;
    if (oldVm != null) {
        oldUsbPolicy = oldVm.getUsbPolicy();
        currentNumberOfSlots = getUsbRedirectDevices(oldVm).size();
    }
    final int usbSlots = Config.<Integer>GetValue(ConfigValues.NumberOfUSBSlots);
    // We add USB slots in case support doesn't exist in the oldVm configuration, but exists in the new one
    if (!oldUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE) && newUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE)) {
        if (usbSlots > 0) {
            removeUsbControllers(newVm);
            addUsbControllers(newVm, getNeededNumberOfUsbControllers(usbSlots));
            addUsbSlots(newVm, usbSlots);
        }
    } else // Remove USB slots and controllers in case we are either in disabled policy or legacy one
    if (newUsbPolicy.equals(UsbPolicy.DISABLED) || newUsbPolicy.equals(UsbPolicy.ENABLED_LEGACY)) {
        removeUsbControllers(newVm);
        removeUsbSlots(newVm);
    // if the USB policy is enabled (and was enabled before), we need to update the number of slots
    } else if (newUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE)) {
        if (currentNumberOfSlots < usbSlots) {
            // Add slots
            if (currentNumberOfSlots == 0) {
                addUsbControllers(newVm, getNeededNumberOfUsbControllers(usbSlots));
            }
            addUsbSlots(newVm, usbSlots - currentNumberOfSlots);
        } else if (currentNumberOfSlots > usbSlots) {
            // Remove slots
            removeUsbSlots(newVm, currentNumberOfSlots - usbSlots);
            // Remove controllers
            if (usbSlots == 0) {
                removeUsbControllers(newVm);
            }
        }
    }
}
#method_after
private static void updateUSBSlots(VmBase oldVm, VmBase newVm) {
    UsbPolicy oldUsbPolicy = UsbPolicy.DISABLED;
    UsbPolicy newUsbPolicy = newVm.getUsbPolicy();
    int currentNumberOfSlots = 0;
    if (oldVm != null) {
        oldUsbPolicy = oldVm.getUsbPolicy();
        currentNumberOfSlots = getUsbRedirectDevices(oldVm).size();
    }
    final int usbSlots = Config.<Integer>getValue(ConfigValues.NumberOfUSBSlots);
    // We add USB slots in case support doesn't exist in the oldVm configuration, but exists in the new one
    if (!oldUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE) && newUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE)) {
        if (usbSlots > 0) {
            removeUsbControllers(newVm);
            addUsbControllers(newVm, getNeededNumberOfUsbControllers(usbSlots));
            addUsbSlots(newVm, usbSlots);
        }
    } else // Remove USB slots and controllers in case we are either in disabled policy or legacy one
    if (newUsbPolicy.equals(UsbPolicy.DISABLED) || newUsbPolicy.equals(UsbPolicy.ENABLED_LEGACY)) {
        removeUsbControllers(newVm);
        removeUsbSlots(newVm);
    // if the USB policy is enabled (and was enabled before), we need to update the number of slots
    } else if (newUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE)) {
        if (currentNumberOfSlots < usbSlots) {
            // Add slots
            if (currentNumberOfSlots == 0) {
                addUsbControllers(newVm, getNeededNumberOfUsbControllers(usbSlots));
            }
            addUsbSlots(newVm, usbSlots - currentNumberOfSlots);
        } else if (currentNumberOfSlots > usbSlots) {
            // Remove slots
            removeUsbSlots(newVm, currentNumberOfSlots - usbSlots);
            // Remove controllers
            if (usbSlots == 0) {
                removeUsbControllers(newVm);
            }
        }
    }
}
#end_block

#method_before
private static <T extends VmBase> void addOtherDevices(T entity, List<VmDevice> vmDeviceToAdd) {
    boolean hasCD = false;
    boolean hasSoundCard = false;
    for (VmDevice vmDevice : entity.getManagedDeviceMap().values()) {
        if (isDiskOrInterface(vmDevice)) {
            // skip disks/interfaces that were added separately.
            continue;
        }
        vmDevice.setIsManaged(true);
        if (vmDevice.getType() == VmDeviceGeneralType.VIDEO) {
            vmDevice.setSpecParams(getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()));
        }
        if (vmDevice.getDevice().equals(VmDeviceType.CDROM.getName())) {
            hasCD = true;
        }
        if (vmDevice.getDevice().equals(VmDeviceType.SOUND.getName())) {
            hasSoundCard = true;
        }
        vmDeviceToAdd.add(vmDevice);
    }
    if (!hasCD) {
        // add an empty CD
        addEmptyCD(entity.getId());
    }
    // add sound card for desktops imported from old versions only, since devices didnt exist
    Version ovfVer = new Version(entity.getOvfVersion());
    if (!hasSoundCard && VmDeviceCommonUtils.isOldClusterVersion(ovfVer) && entity.getVmType() == VmType.Desktop) {
        addSoundCard(entity);
    }
    for (VmDevice vmDevice : entity.getUnmanagedDeviceList()) {
        vmDeviceToAdd.add(vmDevice);
    }
}
#method_after
private static <T extends VmBase> void addOtherDevices(T entity, List<VmDevice> vmDeviceToAdd) {
    boolean hasCD = false;
    boolean hasSoundCard = false;
    for (VmDevice vmDevice : entity.getManagedDeviceMap().values()) {
        if (isDiskOrInterface(vmDevice)) {
            // skip disks/interfaces that were added separately.
            continue;
        }
        vmDevice.setIsManaged(true);
        if (vmDevice.getType() == VmDeviceGeneralType.VIDEO) {
            vmDevice.setSpecParams(getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()));
        }
        if (vmDevice.getDevice().equals(VmDeviceType.CDROM.getName())) {
            hasCD = true;
        }
        if (VmDeviceCommonUtils.isSound(vmDevice)) {
            hasSoundCard = true;
        }
        vmDeviceToAdd.add(vmDevice);
    }
    if (!hasCD) {
        // add an empty CD
        addEmptyCD(entity.getId());
    }
    // add sound card for desktops imported from old versions only, since devices didnt exist
    Version ovfVer = new Version(entity.getOvfVersion());
    if (!hasSoundCard && VmDeviceCommonUtils.isOldClusterVersion(ovfVer) && entity.getVmType() == VmType.Desktop) {
        addSoundCard(entity);
    }
    for (VmDevice vmDevice : entity.getUnmanagedDeviceList()) {
        vmDeviceToAdd.add(vmDevice);
    }
}
#end_block

#method_before
private static Map<String, Object> getMemExpr(int numOfMonitors, boolean singleQxlPci) {
    int heads = singleQxlPci ? numOfMonitors : 1;
    String mem;
    if (singleQxlPci) {
        mem = String.valueOf(VmDeviceCommonUtils.LOW_VIDEO_MEM * heads);
    } else {
        mem = (numOfMonitors < 2 ? String.valueOf(VmDeviceCommonUtils.LOW_VIDEO_MEM) : String.valueOf(VmDeviceCommonUtils.HIGH_VIDEO_MEM));
    }
    Map<String, Object> specParams = new HashMap<String, Object>();
    specParams.put(VRAM, mem);
    specParams.put(HEADS, String.valueOf(heads));
    return specParams;
}
#method_after
private static Map<String, Object> getMemExpr(int numOfMonitors, boolean singleQxlPci) {
    int heads = singleQxlPci ? numOfMonitors : 1;
    Map<String, Object> specParams = new HashMap<String, Object>();
    specParams.put(HEADS, String.valueOf(heads));
    specParams.put(VRAM, VmDeviceCommonUtils.singlePciVRamByHeads(heads));
    if (singleQxlPci) {
        specParams.put(RAM, VmDeviceCommonUtils.singlePciRamByHeads(heads));
    }
    return specParams;
}
#end_block

#method_before
private static void updateMemoryBalloon(VmBase oldVm, VmBase newVm, boolean shouldHaveBalloon) {
    Guid id = newVm.getId();
    boolean hasBalloon = dao.isMemBalloonEnabled(id);
    if (hasBalloon != shouldHaveBalloon) {
        if (!hasBalloon && shouldHaveBalloon) {
            // add a balloon device
            Map<String, Object> specParams = new HashMap<String, Object>();
            specParams.put(VdsProperties.Model, VdsProperties.Virtio);
            addManagedDevice(new VmDeviceId(Guid.newGuid(), newVm.getId()), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON, specParams, true, true, null);
        } else {
            // remove the balloon device
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(newVm.getId(), VmDeviceGeneralType.BALLOON);
            removeNumberOfDevices(list, 1);
        }
    }
}
#method_after
private static void updateMemoryBalloon(VmBase newVm, boolean shouldHaveBalloon) {
    updateMemoryBalloon(newVm.getId(), shouldHaveBalloon);
}
#end_block

#method_before
private static boolean isDiskOrInterface(VmDevice vmDevice) {
    return (vmDevice.getDevice().equals(VmDeviceType.DISK.getName()) && vmDevice.getType() == VmDeviceGeneralType.DISK) || (vmDevice.getDevice().equals(VmDeviceType.BRIDGE.getName()) && vmDevice.getType() == VmDeviceGeneralType.INTERFACE);
}
#method_after
private static boolean isDiskOrInterface(VmDevice vmDevice) {
    return VmDeviceCommonUtils.isDisk(vmDevice) || VmDeviceCommonUtils.isBridge(vmDevice);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getRngDevices().isEmpty()) {
        return failCanDoAction(VdcBllMessages.RNG_NOT_FOUND);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (!isRngSupportedByClusterLevel()) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (getRngDevices().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_NOT_FOUND);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VmDevice rngDevice = getRngDevices().get(0);
    rngDevice.setSpecParams(getParameters().getRngDevice().generateSpecParams());
    getDbFacade().getVmDeviceDao().update(rngDevice);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    VmDevice rngDevice = getParameters().getRngDevice();
    getDbFacade().getVmDeviceDao().update(rngDevice);
    setSucceeded(true);
}
#end_block

#method_before
public void run() {
    MessageContext context = null;
    ObjectMapper mapper = new ObjectMapper();
    while (true) {
        try {
            context = this.queue.take();
            if (context.getClient() == null) {
                break;
            }
            log.info("Message received :" + new String(context.getMessage(), Charset.forName("UTF-8")));
            JsonNode rootNode = mapper.readTree(context.getMessage());
            if (!rootNode.isArray()) {
                processIncomingObject(context.getClient(), rootNode);
            } else {
                final Iterator<JsonNode> iter = rootNode.getElements();
                while (iter.hasNext()) {
                    final JsonNode node = iter.next();
                    processIncomingObject(context.getClient(), node);
                }
            }
        } catch (Exception e) {
            log.warn("Exception thrown during message processing", e);
            continue;
        }
    }
}
#method_after
public void run() {
    MessageContext context = null;
    ObjectMapper mapper = new ObjectMapper();
    while (true) {
        try {
            context = this.queue.take();
            if (context.getClient() == null) {
                break;
            }
            log.info("Message received :" + new String(context.getMessage(), UTF8));
            JsonNode rootNode = mapper.readTree(context.getMessage());
            if (!rootNode.isArray()) {
                processIncomingObject(context.getClient(), rootNode);
            } else {
                final Iterator<JsonNode> iter = rootNode.getElements();
                while (iter.hasNext()) {
                    final JsonNode node = iter.next();
                    processIncomingObject(context.getClient(), node);
                }
            }
        } catch (Exception e) {
            log.warn("Exception thrown during message processing", e);
            continue;
        }
    }
}
#end_block

#method_before
@Override
public void sendMessage(byte[] message) {
    send(new Message().send().withHeader(HEADER_DESTINATION, REQUEST_QUEUE).withContent(new String(message, Charset.forName("UTF-8"))).build());
}
#method_after
@Override
public void sendMessage(byte[] message) {
    send(new Message().send().withHeader(HEADER_DESTINATION, REQUEST_QUEUE).withContent(new String(message, UTF8)).build());
}
#end_block

#method_before
public void send(byte[] message) {
    outbox.addFirst(ByteBuffer.wrap(message));
    LOG.info("Message sent: " + new String(message, Charset.forName("UTF-8")));
    final ReactorClient client = this;
    scheduleTask(new Callable<Void>() {

        @Override
        public Void call() throws ClientConnectionException {
            client.updateInterestedOps();
            return null;
        }
    });
}
#method_after
public void send(byte[] message) {
    outbox.addFirst(ByteBuffer.wrap(message));
    LOG.info("Message sent: " + new String(message, UTF8));
    final ReactorClient client = this;
    scheduleTask(new Callable<Void>() {

        @Override
        public Void call() throws ClientConnectionException {
            client.updateInterestedOps();
            return null;
        }
    });
}
#end_block

#method_before
protected void emitOnMessageReceived(byte[] message) {
    List<Message> messages = Message.buildMessages(new String(message, Charset.forName("UTF-8")));
    for (Message msg : messages) {
        processMessage(msg);
    }
}
#method_after
protected void emitOnMessageReceived(byte[] message) {
    List<Message> messages = Message.buildMessages(new String(message, UTF8));
    for (Message msg : messages) {
        processMessage(msg);
    }
}
#end_block

#method_before
void processMessage(Message message) {
    if (Command.CONNECTED.toString().equals(message.getCommand())) {
        this.connected.countDown();
    } else if (Command.ACK.toString().equals(message.getCommand())) {
        String headerId = message.getHeaders().get(HEADER_ID);
        if (!isEmpty(headerId)) {
            this.subscribed.countDown();
        }
    } else if (Command.ERROR.toString().equals(message.getCommand())) {
        String errorMessage = message.getHeaders().get(HEADER_MESSAGE);
        StringBuilder error = new StringBuilder();
        if (!isEmpty(errorMessage)) {
            error.append(errorMessage);
        }
        if (!isEmpty(message.getContent())) {
            error.append(errorMessage);
        }
        LOG.error("Error Message recieved: " + error);
    } else if (Command.MESSAGE.toString().equals(message.getCommand())) {
        super.emitOnMessageReceived(message.getContent().getBytes(Charset.forName("UTF-8")));
    }
}
#method_after
void processMessage(Message message) {
    if (Command.CONNECTED.toString().equals(message.getCommand())) {
        this.connected.countDown();
    } else if (Command.ACK.toString().equals(message.getCommand())) {
        String headerId = message.getHeaders().get(HEADER_ID);
        if (!isEmpty(headerId)) {
            this.subscribed.countDown();
        }
    } else if (Command.ERROR.toString().equals(message.getCommand())) {
        String errorMessage = message.getHeaders().get(HEADER_MESSAGE);
        StringBuilder error = new StringBuilder();
        if (!isEmpty(errorMessage)) {
            error.append(errorMessage);
        }
        if (!isEmpty(message.getContent())) {
            error.append(errorMessage);
        }
        LOG.error("Error Message recieved: " + error);
    } else if (Command.MESSAGE.toString().equals(message.getCommand())) {
        super.emitOnMessageReceived(message.getContent().getBytes(UTF8));
    }
}
#end_block

#method_before
@Override
public void sendMessage(byte[] message) {
    send(new Message().message().withHeader(HEADER_DESTINATION, RESPONSE_QUEUE).withContent(new String(message, Charset.forName("UTF-8"))).build());
}
#method_after
@Override
public void sendMessage(byte[] message) {
    send(new Message().message().withHeader(HEADER_DESTINATION, RESPONSE_QUEUE).withContent(new String(message, UTF8)).build());
}
#end_block

#method_before
@Test
public void testEcho() throws InterruptedException, ExecutionException, ClientConnectionException {
    final BlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(1);
    Future<ReactorListener> futureListener = this.listeningReactor.createListener(HOSTNAME, PORT, new EventListener() {

        @Override
        public void onAcccept(final ReactorClient client) {
            client.addEventListener(new MessageListener() {

                @Override
                public void onMessageReceived(byte[] message) {
                    client.sendMessage(message);
                }
            });
        }
    });
    ReactorListener listener = futureListener.get();
    assertNotNull(listener);
    ReactorClient client = this.sendingReactor.createClient(HOSTNAME, PORT);
    client.addEventListener(new ReactorClient.MessageListener() {

        @Override
        public void onMessageReceived(byte[] message) {
            queue.add(message);
        }
    });
    client.connect();
    client.sendMessage(MESSAGE.getBytes());
    byte[] message = queue.poll(TIMEOUT_SEC, TimeUnit.SECONDS);
    client.sendMessage(MESSAGE.getBytes());
    message = queue.poll(TIMEOUT_SEC, TimeUnit.SECONDS);
    client.close();
    listener.close();
    assertNotNull(message);
    assertEquals(MESSAGE, new String(message, Charset.forName("UTF-8")));
}
#method_after
@Test
public void testEcho() throws InterruptedException, ExecutionException, ClientConnectionException {
    final BlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(1);
    Future<ReactorListener> futureListener = this.listeningReactor.createListener(HOSTNAME, PORT, new EventListener() {

        @Override
        public void onAcccept(final ReactorClient client) {
            client.addEventListener(new MessageListener() {

                @Override
                public void onMessageReceived(byte[] message) {
                    client.sendMessage(message);
                }
            });
        }
    });
    ReactorListener listener = futureListener.get();
    assertNotNull(listener);
    ReactorClient client = this.sendingReactor.createClient(HOSTNAME, PORT);
    client.addEventListener(new ReactorClient.MessageListener() {

        @Override
        public void onMessageReceived(byte[] message) {
            queue.add(message);
        }
    });
    client.connect();
    client.sendMessage(MESSAGE.getBytes());
    byte[] message = queue.poll(TIMEOUT_SEC, TimeUnit.SECONDS);
    client.sendMessage(MESSAGE.getBytes());
    message = queue.poll(TIMEOUT_SEC, TimeUnit.SECONDS);
    client.close();
    listener.close();
    assertNotNull(message);
    assertEquals(MESSAGE, new String(message, UTF8));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public void run() {
    while (this.isRunning) {
        try {
            this.selector.select();
            if (!selector.isOpen()) {
                continue;
            }
            for (final SelectionKey key : this.selector.selectedKeys()) {
                if (key.isAcceptable()) {
                    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
                    SocketChannel socketChannel = serverSocketChannel.accept();
                    if (socketChannel != null) {
                        socketChannel.configureBlocking(false);
                        int interestedOps = SelectionKey.OP_READ;
                        socketChannel.register(selector, interestedOps, new ConcurrentLinkedDeque<>());
                    }
                }
                if (key.isValid() && key.isReadable()) {
                    SocketChannel socketChannel = (SocketChannel) key.channel();
                    int read = socketChannel.read(this.readBuffer);
                    if (read > 0) {
                        byte[] msgBuff = new byte[read];
                        this.readBuffer.rewind();
                        this.readBuffer.get(msgBuff);
                        this.readBuffer.clear();
                        List<Message> messages = Message.buildMessages(new String(msgBuff, Charset.forName("UTF-8")));
                        for (Message message : messages) {
                            this.reciever.recieve(message, key);
                        }
                    }
                }
                if (key.isValid() && key.isWritable()) {
                    Deque<ByteBuffer> outbox = (Deque<ByteBuffer>) key.attachment();
                    ByteBuffer buffer = outbox.pollLast();
                    if (buffer != null) {
                        SocketChannel socketChannel = (SocketChannel) key.channel();
                        socketChannel.write(buffer);
                        updateInterestedOps(key);
                    }
                }
                if (!key.channel().isOpen()) {
                    key.cancel();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public void run() {
    while (this.isRunning) {
        try {
            this.selector.select();
            if (!selector.isOpen()) {
                continue;
            }
            for (final SelectionKey key : this.selector.selectedKeys()) {
                if (key.isAcceptable()) {
                    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
                    SocketChannel socketChannel = serverSocketChannel.accept();
                    if (socketChannel != null) {
                        socketChannel.configureBlocking(false);
                        int interestedOps = SelectionKey.OP_READ;
                        socketChannel.register(selector, interestedOps, new ConcurrentLinkedDeque<>());
                    }
                }
                if (key.isValid() && key.isReadable()) {
                    SocketChannel socketChannel = (SocketChannel) key.channel();
                    int read = socketChannel.read(this.readBuffer);
                    if (read > 0) {
                        byte[] msgBuff = new byte[read];
                        this.readBuffer.rewind();
                        this.readBuffer.get(msgBuff);
                        this.readBuffer.clear();
                        List<Message> messages = Message.buildMessages(new String(msgBuff, UTF8));
                        for (Message message : messages) {
                            this.reciever.recieve(message, key);
                        }
                    }
                }
                if (key.isValid() && key.isWritable()) {
                    Deque<ByteBuffer> outbox = (Deque<ByteBuffer>) key.attachment();
                    ByteBuffer buffer = outbox.pollLast();
                    if (buffer != null) {
                        SocketChannel socketChannel = (SocketChannel) key.channel();
                        socketChannel.write(buffer);
                        updateInterestedOps(key);
                    }
                }
                if (!key.channel().isOpen()) {
                    key.cancel();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
#end_block

#method_before
@Override
public void sendMessage(byte[] message) {
    waitForConnect();
    send(new Message().send().withHeader(HEADER_DESTINATION, REQUEST_QUEUE).withContent(new String(message, Charset.forName("UTF-8"))).build());
}
#method_after
@Override
public void sendMessage(byte[] message) {
    waitForConnect();
    send(new Message().send().withHeader(HEADER_DESTINATION, REQUEST_QUEUE).withContent(new String(message, UTF8)).build());
}
#end_block

#method_before
public void send(byte[] message) {
    outbox.addFirst(ByteBuffer.wrap(message));
    LOG.info("Message sent: " + new String(message, Charset.forName("UTF-8")));
    final ReactorClient client = this;
    scheduleTask(new Callable<Void>() {

        @Override
        public Void call() throws ClientConnectionException {
            client.updateInterestedOps();
            return null;
        }
    });
}
#method_after
public void send(byte[] message) {
    outbox.addFirst(ByteBuffer.wrap(message));
    LOG.info("Message sent: " + new String(message, UTF8));
    final ReactorClient client = this;
    scheduleTask(new Callable<Void>() {

        @Override
        public Void call() throws ClientConnectionException {
            client.updateInterestedOps();
            return null;
        }
    });
}
#end_block

#method_before
@Override
protected void emitOnMessageReceived(byte[] message) {
    List<Message> messages = Message.buildMessages(new String(message, Charset.forName("UTF-8")));
    for (Message msg : messages) {
        processMessage(msg);
    }
}
#method_after
@Override
protected void emitOnMessageReceived(byte[] message) {
    List<Message> messages = Message.buildMessages(new String(message, UTF8));
    for (Message msg : messages) {
        processMessage(msg);
    }
}
#end_block

#method_before
void processMessage(Message message) {
    if (Command.CONNECTED.toString().equals(message.getCommand())) {
        this.connected.countDown();
    } else if (Command.ACK.toString().equals(message.getCommand())) {
        String headerId = message.getHeaders().get(HEADER_ID);
        if (!isEmpty(headerId)) {
            this.subscribed.countDown();
        }
    } else if (Command.ERROR.toString().equals(message.getCommand())) {
        String errorMessage = message.getHeaders().get(HEADER_MESSAGE);
        StringBuilder error = new StringBuilder();
        if (!isEmpty(errorMessage)) {
            error.append(errorMessage);
        }
        if (!isEmpty(message.getContent())) {
            error.append(errorMessage);
        }
        LOG.error("Error Message recieved: " + error);
    } else if (Command.MESSAGE.toString().equals(message.getCommand())) {
        super.emitOnMessageReceived(message.getContent().getBytes(Charset.forName("UTF-8")));
    }
}
#method_after
void processMessage(Message message) {
    if (Command.CONNECTED.toString().equals(message.getCommand())) {
        this.connected.countDown();
    } else if (Command.ACK.toString().equals(message.getCommand())) {
        String headerId = message.getHeaders().get(HEADER_ID);
        if (!isEmpty(headerId)) {
            this.subscribed.countDown();
        }
    } else if (Command.ERROR.toString().equals(message.getCommand())) {
        String errorMessage = message.getHeaders().get(HEADER_MESSAGE);
        StringBuilder error = new StringBuilder();
        if (!isEmpty(errorMessage)) {
            error.append(errorMessage);
        }
        if (!isEmpty(message.getContent())) {
            error.append(errorMessage);
        }
        LOG.error("Error Message recieved: " + error);
    } else if (Command.MESSAGE.toString().equals(message.getCommand())) {
        super.emitOnMessageReceived(message.getContent().getBytes(UTF8));
    }
}
#end_block

#method_before
@Test
public void testEcho() throws InterruptedException, ExecutionException, ClientConnectionException {
    final BlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(5);
    Future<ReactorListener> futureListener = this.listeningReactor.createListener(HOSTNAME, PORT, new EventListener() {

        @Override
        public void onAcccept(final ReactorClient client) {
            client.addEventListener(new MessageListener() {

                @Override
                public void onMessageReceived(byte[] message) {
                    client.sendMessage(message);
                }
            });
        }
    });
    ReactorListener listener = futureListener.get();
    assertNotNull(listener);
    ReactorClient client = this.sendingReactor.createClient(HOSTNAME, PORT);
    client.addEventListener(new ReactorClient.MessageListener() {

        @Override
        public void onMessageReceived(byte[] message) {
            queue.add(message);
        }
    });
    client.connect();
    client.sendMessage(MESSAGE.getBytes());
    byte[] message = queue.poll(TIMEOUT_SEC, TimeUnit.SECONDS);
    client.sendMessage(MESSAGE.getBytes());
    message = queue.poll(TIMEOUT_SEC, TimeUnit.SECONDS);
    client.close();
    listener.close();
    assertNotNull(message);
    assertEquals(MESSAGE, new String(message, Charset.forName("UTF-8")));
}
#method_after
@Test
public void testEcho() throws InterruptedException, ExecutionException, ClientConnectionException {
    final BlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(5);
    Future<ReactorListener> futureListener = this.listeningReactor.createListener(HOSTNAME, PORT, new EventListener() {

        @Override
        public void onAcccept(final ReactorClient client) {
            client.addEventListener(new MessageListener() {

                @Override
                public void onMessageReceived(byte[] message) {
                    client.sendMessage(message);
                }
            });
        }
    });
    ReactorListener listener = futureListener.get();
    assertNotNull(listener);
    ReactorClient client = this.sendingReactor.createClient(HOSTNAME, PORT);
    client.addEventListener(new ReactorClient.MessageListener() {

        @Override
        public void onMessageReceived(byte[] message) {
            queue.add(message);
        }
    });
    client.connect();
    client.sendMessage(MESSAGE.getBytes());
    byte[] message = queue.poll(TIMEOUT_SEC, TimeUnit.SECONDS);
    client.sendMessage(MESSAGE.getBytes());
    message = queue.poll(TIMEOUT_SEC, TimeUnit.SECONDS);
    client.close();
    listener.close();
    assertNotNull(message);
    assertEquals(MESSAGE, new String(message, UTF8));
}
#end_block

#method_before
@Override
public void sendMessage(byte[] message) {
    send(new Message().message().withHeader(HEADER_DESTINATION, RESPONSE_QUEUE).withContent(new String(message, Charset.forName("UTF-8"))).build());
}
#method_after
@Override
public void sendMessage(byte[] message) {
    send(new Message().message().withHeader(HEADER_DESTINATION, RESPONSE_QUEUE).withContent(new String(message, UTF8)).build());
}
#end_block

#method_before
void processMessage(Message message) {
    String command = message.getCommand();
    CommandExecutor executor = this.commandFactory.getCommandExecutor(command);
    Message response = executor.execute(message);
    if (response != null) {
        this.send(response.build());
    }
    if (Command.DISCONNECT.toString().equals(command)) {
        try {
            channel.close();
        } catch (IOException ignored) {
        }
    }
}
#method_after
void processMessage(Message message) {
    String command = message.getCommand();
    CommandExecutor executor = this.commandFactory.getCommandExecutor(command);
    Message response = executor.execute(message);
    if (response != null) {
        this.send(response.build());
    }
    if (Command.DISCONNECT.toString().equals(command)) {
        try {
            channel.close();
        } catch (IOException ignored) {
        // we do not care about IOE after disconnecting
        }
    }
}
#end_block

#method_before
public byte[] build() {
    if (isEmpty(this.command)) {
        throw new IllegalArgumentException("Command can't be empty");
    }
    StringBuilder builder = new StringBuilder(this.command);
    builder.append("\n");
    for (String key : this.headers.keySet()) {
        builder.append(key);
        builder.append(":");
        builder.append(this.headers.get(key));
        builder.append("\n");
    }
    builder.append("\n");
    if (!isEmpty(this.content)) {
        builder.append(this.content);
    }
    builder.append(END_OF_MESSAGE + "\n");
    return builder.toString().getBytes(Charset.forName("UTF-8"));
}
#method_after
public byte[] build() {
    if (isEmpty(this.command)) {
        throw new IllegalArgumentException("Command can't be empty");
    }
    StringBuilder builder = new StringBuilder(this.command);
    builder.append("\n");
    for (String key : this.headers.keySet()) {
        builder.append(key);
        builder.append(":");
        builder.append(this.headers.get(key));
        builder.append("\n");
    }
    builder.append("\n");
    if (!isEmpty(this.content)) {
        builder.append(this.content);
    }
    builder.append(END_OF_MESSAGE + "\n");
    return builder.toString().getBytes(UTF8);
}
#end_block

#method_before
@Override
public void snapshotEntity(BusinessEntity<?> entity) {
    snapshotEntityInMemory(entity, entity, SnapshotType.CHANGED_ENTITY);
}
#method_after
@Override
public void snapshotEntity(BusinessEntity<?> entity) {
    snapshotEntityInMemory(entity, entity, SnapshotType.DELETED_OR_UPDATED_ENTITY);
}
#end_block

#method_before
@Override
public void snapshotEntityUpdated(BusinessEntity<?> entity) {
    snapshotEntityInMemory(entity, entity, SnapshotType.UPDATED_ENTITY);
}
#method_after
@Override
public void snapshotEntityUpdated(BusinessEntity<?> entity) {
    snapshotEntityInMemory(entity, entity, SnapshotType.UPDATED_ONLY_ENTITY);
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (isInternalExecution() || !isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#method_after
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (!isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#end_block

#method_before
private boolean isQuotaDependant() {
    return getActionType().getQuotaDependency() != VdcActionType.QuotaDependency.NONE;
}
#method_after
protected boolean isQuotaDependant() {
    boolean result;
    if (getActionType().getQuotaDependency() == VdcActionType.QuotaDependency.NONE)
        result = false;
    else if (!isInternalExecution())
        result = true;
    else if (getActionType().isQuotaDependentAsInternalCommand())
        result = true;
    else
        result = false;
    return result;
}
#end_block

#method_before
private boolean isEditAvailable(StorageDomain storageDomain) {
    if (storageDomain == null) {
        return false;
    }
    boolean isEditAvailable;
    boolean isActive = storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Active || storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Mixed;
    boolean isInMaintenance = (storageDomain.getStatus() == StorageDomainStatus.Maintenance || storageDomain.getStatus() == StorageDomainStatus.PreparingForMaintenance);
    boolean isUnattached = (storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached);
    boolean isDataDomain = storageDomain.getStorageDomainType().isDataDomain();
    boolean isBlockStorage = storageDomain.getStorageType().isBlockDomain();
    isEditAvailable = isActive || isBlockStorage || ((isInMaintenance || isUnattached) && isDataDomain);
    return isEditAvailable;
}
#method_after
private boolean isEditAvailable(StorageDomain storageDomain) {
    if (storageDomain == null) {
        return false;
    }
    boolean isEditAvailable;
    boolean isActive = storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Active || storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Mixed;
    boolean isInMaintenance = (storageDomain.getStatus() == StorageDomainStatus.Maintenance || storageDomain.getStatus() == StorageDomainStatus.PreparingForMaintenance);
    boolean isUnattached = (storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached || storageDomain.getStatus() == StorageDomainStatus.Detaching);
    boolean isDataDomain = storageDomain.getStorageDomainType().isDataDomain();
    boolean isBlockStorage = storageDomain.getStorageType().isBlockDomain();
    isEditAvailable = isActive || isBlockStorage || ((isInMaintenance || isUnattached) && isDataDomain);
    return isEditAvailable;
}
#end_block

#method_before
private void updatePosixProperties(IStorageModel storageModel) {
    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    connection.setVfsType(posixModel.getVfsType().getEntity().toString());
    if (posixModel.getMountOptions().getEntity() != null) {
        connection.setMountOptions(posixModel.getMountOptions().getEntity());
    }
}
#method_after
private void updatePosixProperties(IStorageModel storageModel) {
    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    connection.setVfsType(posixModel.getVfsType().getEntity().toString());
    if (posixModel.getMountOptions().getEntity() != null) {
        connection.setMountOptions(posixModel.getMountOptions().getEntity().toString());
    }
}
#end_block

#method_before
@Test
public void storageDomainMappings() {
    assertEquals(StorageDomainStatus.ACTIVE, StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus.Active, null));
    assertEquals(StorageDomainStatus.INACTIVE, StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus.InActive, null));
    assertEquals(StorageDomainStatus.LOCKED, StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus.Locked, null));
    assertEquals(StorageDomainStatus.UNATTACHED, StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus.Unattached, null));
    assertEquals(StorageDomainStatus.UNKNOWN, StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus.Unknown, null));
    assertTrue(StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus.Uninitialized, null) == null);
    assertEquals(StorageDomainStatus.MAINTENANCE, StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus.Maintenance, null));
    assertEquals(org.ovirt.engine.core.common.businessentities.NfsVersion.V3, StorageDomainMapper.map(NfsVersion.V3, null));
    assertEquals(org.ovirt.engine.core.common.businessentities.NfsVersion.V4, StorageDomainMapper.map(NfsVersion.V4, null));
    assertEquals(org.ovirt.engine.core.common.businessentities.NfsVersion.AUTO, StorageDomainMapper.map(NfsVersion.AUTO, null));
    assertEquals(NfsVersion.V3.value(), StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.NfsVersion.V3, null));
    assertEquals(NfsVersion.V4.value(), StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.NfsVersion.V4, null));
    assertEquals(NfsVersion.AUTO.value(), StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.NfsVersion.AUTO, null));
}
#method_after
@Test
public void storageDomainMappings() {
    assertEquals(StorageDomainStatus.ACTIVE, StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus.Active, null));
    assertEquals(StorageDomainStatus.INACTIVE, StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus.Inactive, null));
    assertEquals(StorageDomainStatus.LOCKED, StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus.Locked, null));
    assertEquals(StorageDomainStatus.UNATTACHED, StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus.Unattached, null));
    assertEquals(StorageDomainStatus.UNKNOWN, StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus.Unknown, null));
    assertTrue(StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus.Uninitialized, null) == null);
    assertEquals(StorageDomainStatus.MAINTENANCE, StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus.Maintenance, null));
    assertEquals(org.ovirt.engine.core.common.businessentities.NfsVersion.V3, StorageDomainMapper.map(NfsVersion.V3, null));
    assertEquals(org.ovirt.engine.core.common.businessentities.NfsVersion.V4, StorageDomainMapper.map(NfsVersion.V4, null));
    assertEquals(org.ovirt.engine.core.common.businessentities.NfsVersion.AUTO, StorageDomainMapper.map(NfsVersion.AUTO, null));
    assertEquals(NfsVersion.V3.value(), StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.NfsVersion.V3, null));
    assertEquals(NfsVersion.V4.value(), StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.NfsVersion.V4, null));
    assertEquals(NfsVersion.AUTO.value(), StorageDomainMapper.map(org.ovirt.engine.core.common.businessentities.NfsVersion.AUTO, null));
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageDomainStatus.class, to = StorageDomainStatus.class)
public static StorageDomainStatus map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus status, StorageDomainStatus template) {
    switch(status) {
        case Unattached:
            return StorageDomainStatus.UNATTACHED;
        case Active:
            return StorageDomainStatus.ACTIVE;
        case InActive:
            return StorageDomainStatus.INACTIVE;
        case Locked:
            return StorageDomainStatus.LOCKED;
        case PreparingForMaintenance:
            return StorageDomainStatus.PREPARING_FOR_MAINTENANCE;
        case Maintenance:
            return StorageDomainStatus.MAINTENANCE;
        case Unknown:
            return StorageDomainStatus.UNKNOWN;
        case Uninitialized:
            return null;
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageDomainStatus.class, to = StorageDomainStatus.class)
public static StorageDomainStatus map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus status, StorageDomainStatus template) {
    switch(status) {
        case Unattached:
            return StorageDomainStatus.UNATTACHED;
        case Active:
            return StorageDomainStatus.ACTIVE;
        case Inactive:
            return StorageDomainStatus.INACTIVE;
        case Locked:
            return StorageDomainStatus.LOCKED;
        case PreparingForMaintenance:
            return StorageDomainStatus.PREPARING_FOR_MAINTENANCE;
        case Detaching:
            return StorageDomainStatus.DETACHING;
        case Maintenance:
            return StorageDomainStatus.MAINTENANCE;
        case Unknown:
            return StorageDomainStatus.UNKNOWN;
        case Uninitialized:
            return null;
        default:
            return null;
    }
}
#end_block

#method_before
void localize(ApplicationConstants constants) {
    pathLabel.setText(constants.storagePopupNfsPathLabel());
    pathHintLabel.setText(constants.storagePopupNfsPathHintLabel());
    warningLabel.setText(constants.advancedOptionsLabel());
    overrideEditor.setLabel(constants.storagePopupNfsOverrideLabel());
    versionLabel.setText(constants.storagePopupNfsVersionLabel());
    retransmissionsLabel.setText(constants.storagePopupNfsRetransmissionsLabel());
    timeoutLabel.setText(constants.storagePopupNfsTimeoutLabel());
    mountOptionsLabel.setText(constants.storagePopupMountOptionsLabel());
}
#method_after
void localize(ApplicationConstants constants) {
    pathLabel.setText(constants.storagePopupNfsPathLabel());
    pathHintLabel.setText(constants.storagePopupNfsPathHintLabel());
    warningLabel.setText(constants.advancedOptionsLabel());
    overrideEditor.setLabel(constants.storagePopupNfsOverrideLabel());
    versionLabel.setText(constants.storagePopupNfsVersionLabel());
    retransmissionsLabel.setText(constants.storagePopupNfsRetransmissionsLabel());
    timeoutLabel.setText(constants.storagePopupNfsTimeoutLabel());
    mountOptionsLabel.setText(constants.storagePopupAdditionalMountOptionsLabel());
}
#end_block

#method_before
private int computeMinAllocatedMem() {
    int vmMem = getVm().getMemSizeMb();
    int minAllocatedMem = vmMem;
    if (getVm().getMinAllocatedMem() > 0) {
        minAllocatedMem = getVm().getMinAllocatedMem();
    } else {
        // first get cluster memory over commit value
        VDSGroup vdsGroup = getVdsGroupDAO().get(getVm().getVdsGroupId());
        if (vdsGroup != null && vdsGroup.getmax_vds_memory_over_commit() > 0) {
            minAllocatedMem = (vmMem * 100) / vdsGroup.getmax_vds_memory_over_commit();
        }
    }
    return minAllocatedMem;
}
#method_after
private int computeMinAllocatedMem() {
    int vmMem = getVm().getMemSizeMb();
    int minAllocatedMem = vmMem;
    if (getVm().getMinAllocatedMem() > 0) {
        minAllocatedMem = getVm().getMinAllocatedMem();
    } else {
        // first get cluster memory over commit value
        VDSGroup vdsGroup = getVdsGroup();
        if (vdsGroup != null && vdsGroup.getmax_vds_memory_over_commit() > 0) {
            minAllocatedMem = (vmMem * 100) / vdsGroup.getmax_vds_memory_over_commit();
        }
    }
    return minAllocatedMem;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVm().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // special permission is needed to use custom properties
    if (getVm() != null && !StringUtils.isEmpty(getVm().getCustomProperties())) {
        permissionList.add(new PermissionSubject(getVm().getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // special permission is needed to use custom properties
    if (getVm() != null && !StringUtils.isEmpty(getVm().getCustomProperties())) {
        permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
    }
    return permissionList;
}
#end_block

#method_before
private StatsInfo getStatInfo(Map<String, Object> statsInfoMap, String statType) {
    StatsInfo statsInfo = new StatsInfo();
    Pair<Long, TimeUnit> statsDuration = TimeConverter.autoConvert(Integer.valueOf((String) statsInfoMap.get(DURATION)), TimeUnit.SECONDS);
    statsInfo.setDuration(statsDuration.getFirst().intValue());
    statsInfo.setDurationUnit(statsDuration.getSecond().toString());
    statsInfo.setTotalWrite(Long.valueOf((String) statsInfoMap.get(TOTAL_WRITE)));
    statsInfo.setTotalRead(Long.valueOf((String) statsInfoMap.get(TOTAL_READ)));
    statsInfo.setBlockStats(getBlockStats((Object[]) statsInfoMap.get(BLOCK_STATS)));
    statsInfo.setFopStats(getFopStats((Object[]) statsInfoMap.get(FOP_STATS)));
    statsInfo.setProfileStatsType((statType.equals(CUMULATIVE_STATS) ? ProfileStatsType.CUMULATIVE : ProfileStatsType.INTERVAL));
    return statsInfo;
}
#method_after
private StatsInfo getStatInfo(Map<String, Object> statsInfoMap, String statType) {
    StatsInfo statsInfo = new StatsInfo();
    int statsDuration = Integer.valueOf((String) statsInfoMap.get(DURATION));
    statsInfo.setDuration(statsDuration);
    Pair<Long, TimeUnit> statsDurationFormatted = TimeConverter.autoConvert(statsDuration, TimeUnit.SECONDS);
    statsInfo.setDurationFormatted(new Pair<Integer, String>(statsDurationFormatted.getFirst().intValue(), statsDurationFormatted.getSecond().toString()));
    statsInfo.setTotalWrite(Long.valueOf((String) statsInfoMap.get(TOTAL_WRITE)));
    statsInfo.setTotalRead(Long.valueOf((String) statsInfoMap.get(TOTAL_READ)));
    statsInfo.setBlockStats(getBlockStats((Object[]) statsInfoMap.get(BLOCK_STATS)));
    statsInfo.setFopStats(getFopStats((Object[]) statsInfoMap.get(FOP_STATS)));
    statsInfo.setProfileStatsType((statType.equals(CUMULATIVE_STATS) ? ProfileStatsType.CUMULATIVE : ProfileStatsType.INTERVAL));
    return statsInfo;
}
#end_block

#method_before
private List<FopStats> getFopStats(Object[] fopStatsObjects) {
    List<FopStats> fopStatsList = new ArrayList<FopStats>();
    for (Object fopStatsObj : fopStatsObjects) {
        FopStats fopStats = new FopStats();
        Map<String, Object> fopStatsMap = (Map<String, Object>) fopStatsObj;
        fopStats.setHits(Integer.valueOf((String) fopStatsMap.get(HITS)));
        fopStats.setName((String) fopStatsMap.get(NAME));
        Pair<Long, TimeUnit> minLatencyConverted = TimeConverter.autoConvert(Double.valueOf((String) fopStatsMap.get(LATENCY_MIN)).longValue(), TimeUnit.MICROSECONDS);
        fopStats.setMinLatency(minLatencyConverted.getFirst());
        fopStats.setMinLatencyUnit(minLatencyConverted.getSecond().toString());
        Pair<Long, TimeUnit> maxLatencyConverted = TimeConverter.autoConvert(Double.valueOf((String) fopStatsMap.get(LATENCY_MAX)).longValue(), TimeUnit.MICROSECONDS);
        fopStats.setMaxLatency(maxLatencyConverted.getFirst());
        fopStats.setMaxLatencyString(maxLatencyConverted.getSecond().toString());
        Pair<Long, TimeUnit> avgLatencyConverted = TimeConverter.autoConvert(Double.valueOf((String) fopStatsMap.get(LATENCY_AVG)).longValue(), TimeUnit.MICROSECONDS);
        fopStats.setAvgLatency(avgLatencyConverted.getFirst());
        fopStats.setAvgLatencyUnit(avgLatencyConverted.getSecond().toString());
        fopStatsList.add(fopStats);
    }
    return fopStatsList;
}
#method_after
private List<FopStats> getFopStats(Object[] fopStatsObjects) {
    List<FopStats> fopStatsList = new ArrayList<FopStats>();
    for (Object fopStatsObj : fopStatsObjects) {
        FopStats fopStats = new FopStats();
        Map<String, Object> fopStatsMap = (Map<String, Object>) fopStatsObj;
        fopStats.setHits(Integer.valueOf((String) fopStatsMap.get(HITS)));
        fopStats.setName((String) fopStatsMap.get(NAME));
        Double minLatency = Double.valueOf((String) fopStatsMap.get(LATENCY_MIN));
        fopStats.setMinLatency(minLatency);
        Pair<Long, TimeUnit> minLatencyConverted = TimeConverter.autoConvert(minLatency.longValue(), TimeUnit.MICROSECONDS);
        fopStats.setMinLatencyFormatted(new Pair<Double, String>(minLatencyConverted.getFirst().doubleValue(), minLatencyConverted.getSecond().toString()));
        Double maxLatency = Double.valueOf((String) fopStatsMap.get(LATENCY_MAX));
        fopStats.setMaxLatency(maxLatency);
        Pair<Long, TimeUnit> maxLatencyConverted = TimeConverter.autoConvert(maxLatency.longValue(), TimeUnit.MICROSECONDS);
        fopStats.setMaxLatencyFormatted(new Pair<Double, String>(maxLatencyConverted.getFirst().doubleValue(), maxLatencyConverted.getSecond().toString()));
        Double avgLatency = Double.valueOf((String) fopStatsMap.get(LATENCY_AVG));
        fopStats.setAvgLatency(avgLatency);
        Pair<Long, TimeUnit> avgLatencyConverted = TimeConverter.autoConvert(avgLatency.longValue(), TimeUnit.MICROSECONDS);
        fopStats.setAvgLatencyFormatted(new Pair<Double, String>(avgLatencyConverted.getFirst().doubleValue(), avgLatencyConverted.getSecond().toString()));
        fopStatsList.add(fopStats);
    }
    return fopStatsList;
}
#end_block

#method_before
public void init(URI ldapURI, boolean setBaseDN, boolean explicitAuth, String explicitBaseDN, LdapProviderType ldapProviderType, long timeout) {
    this.explicitAuth = explicitAuth;
    if (explicitBaseDN != null) {
        this.baseDN = explicitBaseDN;
    } else if (!domain.isEmpty() && setBaseDN) {
        this.baseDN = getBaseDNForDomain(domain);
    }
    adjustUserName(ldapProviderType);
    this.contextSource.setUrl(ldapURI.toString());
    setCredentialsOnContext();
    contextSource.setBase(baseDN);
    contextSource.setContextFactory(LdapCtxFactory.class);
    // binary properties
    Hashtable<String, String> baseEnvironmentProperties = new Hashtable<String, String>();
    // objectGUID
    baseEnvironmentProperties.put("java.naming.ldap.attributes.binary", "objectGUID");
    LdapBrokerUtils.addLdapConfigValues(baseEnvironmentProperties);
    contextSource.setBaseEnvironmentProperties(baseEnvironmentProperties);
}
#method_after
public void init(String ldapURI, boolean setBaseDN, String explicitBaseDN, LdapProviderType ldapProviderType, long timeout) {
    if (explicitBaseDN != null) {
        this.baseDN = explicitBaseDN;
    } else if (!domain.isEmpty() && setBaseDN) {
        this.baseDN = getBaseDNForDomain();
    }
    adjustUserName(ldapProviderType);
    this.contextSource.setUrl(ldapURI.toString());
    setCredentialsOnContext();
    contextSource.setBase(baseDN);
    contextSource.setContextFactory(LdapCtxFactory.class);
    // binary properties
    Hashtable<String, String> baseEnvironmentProperties = new Hashtable<String, String>();
    // objectGUID
    baseEnvironmentProperties.put("java.naming.ldap.attributes.binary", "objectGUID");
    LdapBrokerUtils.addLdapConfigValues(configuration, baseEnvironmentProperties);
    contextSource.setBaseEnvironmentProperties(baseEnvironmentProperties);
}
#end_block

#method_before
private String getBaseDNForDomain(String domainName) {
    if (domainName == null) {
        return null;
    }
    Domain domain = UsersDomainsCacheManagerService.getInstance().getDomain(domainName);
    if (domain == null) {
        log.errorFormat("The domain {0} does not exist in the configuration. A base DN cannot be configured for it", domainName);
        return null;
    }
    RootDSE rootDSE = domain.getRootDSE();
    if (rootDSE != null) {
        return rootDSE.getDefaultNamingContext();
    }
    return null;
}
#method_after
private String getBaseDNForDomain() {
    RootDSE rootDSE = (RootDSE) configuration.get("config.rootDSE");
    if (rootDSE != null) {
        return rootDSE.getDefaultNamingContext();
    }
    return null;
}
#end_block

#method_before
protected NameClassPairCallbackHandler pagedSearch(String baseDN, String filter, String displayFilter, SearchControls searchControls, NameClassPairCallbackHandler handler) {
    /*
         * once a SingleContextSource is constructed, it must be destroyed (see below), otherwise only the garbage
         * collector will close its connection.
         */
    final SingleContextSource singleContextSource = new SingleContextSource(contextSource.getContext(userName, password));
    try {
        ldapTemplate.setContextSource(singleContextSource);
        if (log.isDebugEnabled()) {
            log.debugFormat("LDAP query is {0}", displayFilter);
        }
        int ldapPageSize = Integer.parseInt(Config.getProperty("LdapQueryPageSize"));
        PagedResultsDirContextProcessor requestControl = new PagedResultsDirContextProcessor(ldapPageSize);
        ldapTemplate.search(baseDN, filter, searchControls, handler, requestControl);
        PagedResultsCookie cookie = requestControl.getCookie();
        while (cookie != null) {
            byte[] cookieBytes = cookie.getCookie();
            if (cookieBytes == null) {
                break;
            }
            requestControl = new PagedResultsDirContextProcessor(ldapPageSize, cookie);
            ldapTemplate.search(baseDN, filter, searchControls, handler, requestControl);
            cookie = requestControl.getCookie();
        }
    } catch (Exception ex) {
        log.errorFormat("Error in running LDAP query. BaseDN is {0}, filter is {1}. Exception message is: {2}", baseDN, displayFilter, ex.getMessage());
        if (log.isDebugEnabled()) {
            log.debug("Exception stacktrace: ", ex);
        }
        handleException(ex);
    } finally {
        singleContextSource.destroy();
    }
    return handler;
}
#method_after
protected NameClassPairCallbackHandler pagedSearch(String baseDN, String filter, String displayFilter, SearchControls searchControls, NameClassPairCallbackHandler handler) {
    /*
         * once a SingleContextSource is constructed, it must be destroyed (see below), otherwise only the garbage
         * collector will close its connection.
         */
    final SingleContextSource singleContextSource = new SingleContextSource(contextSource.getContext(userName, password));
    try {
        ldapTemplate.setContextSource(singleContextSource);
        if (log.isDebugEnabled()) {
            log.debugFormat("LDAP query is {0}", displayFilter);
        }
        int ldapPageSize = Integer.parseInt(configuration.getProperty("config.LdapQueryPageSize"));
        PagedResultsDirContextProcessor requestControl = new PagedResultsDirContextProcessor(ldapPageSize);
        ldapTemplate.search(baseDN, filter, searchControls, handler, requestControl);
        PagedResultsCookie cookie = requestControl.getCookie();
        while (cookie != null) {
            byte[] cookieBytes = cookie.getCookie();
            if (cookieBytes == null) {
                break;
            }
            requestControl = new PagedResultsDirContextProcessor(ldapPageSize, cookie);
            ldapTemplate.search(baseDN, filter, searchControls, handler, requestControl);
            cookie = requestControl.getCookie();
        }
    } catch (Exception ex) {
        ex.printStackTrace();
        log.errorFormat("Error in running LDAP query. BaseDN is {0}, filter is {1}. Exception message is: {2}", baseDN, displayFilter, ex.getMessage());
        if (log.isDebugEnabled()) {
            log.debug("Exception stacktrace: ", ex);
        }
        handleException(ex);
    } finally {
        singleContextSource.destroy();
    }
    return handler;
}
#end_block

#method_before
public List<LdapQueryData> getLdapQueriesData(String domain) {
    int queryLimit = Integer.parseInt("MaxLDAPQueryPartsNumber");
    List<LdapQueryData> results = new ArrayList<LdapQueryData>();
    LdapQueryData subQueryData = new LdapQueryDataImpl();
    ArrayList<Object> filterParameters = new ArrayList<Object>();
    int counter = 0;
    for (Guid identifier : ldapIdentifiers) {
        filterParameters.add(identifier);
        // Checking if more than queryLimit query clauses were added to the query
        if (counter >= queryLimit) {
            // More than queryLimit query clauses were added to the query -
            // close the query, add it to the results, and start a new query
            subQueryData.setFilterParameters(filterParameters.toArray());
            subQueryData.setLdapQueryType(LdapQueryType.getUsersByUserGuids);
            subQueryData.setBaseDNParameters(null);
            subQueryData.setDomain(domain);
            results.add(subQueryData);
            subQueryData = new LdapQueryDataImpl();
            filterParameters = new ArrayList<Object>();
            counter = 0;
        }
        counter++;
    }
    if (!filterParameters.isEmpty()) {
        subQueryData.setFilterParameters(filterParameters.toArray());
        subQueryData.setLdapQueryType(LdapQueryType.getUsersByUserGuids);
        subQueryData.setBaseDNParameters(null);
        subQueryData.setDomain(domain);
        results.add(subQueryData);
    }
    return results;
}
#method_after
public List<LdapQueryData> getLdapQueriesData(String domain) {
    int queryLimit = Integer.parseInt(configuration.getProperty("config.LDAPQueryPartsNumber"));
    List<LdapQueryData> results = new ArrayList<LdapQueryData>();
    LdapQueryData subQueryData = new LdapQueryDataImpl();
    ArrayList<Object> filterParameters = new ArrayList<Object>();
    int counter = 0;
    for (Guid identifier : ldapIdentifiers) {
        filterParameters.add(identifier);
        // Checking if more than queryLimit query clauses were added to the query
        if (counter >= queryLimit) {
            // More than queryLimit query clauses were added to the query -
            // close the query, add it to the results, and start a new query
            subQueryData.setFilterParameters(filterParameters.toArray());
            subQueryData.setLdapQueryType(LdapQueryType.getUsersByUserGuids);
            subQueryData.setBaseDNParameters(null);
            subQueryData.setDomain(domain);
            results.add(subQueryData);
            subQueryData = new LdapQueryDataImpl();
            filterParameters = new ArrayList<Object>();
            counter = 0;
        }
        counter++;
    }
    if (!filterParameters.isEmpty()) {
        subQueryData.setFilterParameters(filterParameters.toArray());
        subQueryData.setLdapQueryType(LdapQueryType.getUsersByUserGuids);
        subQueryData.setBaseDNParameters(null);
        subQueryData.setDomain(domain);
        results.add(subQueryData);
    }
    return results;
}
#end_block

#method_before
public ExtMap queryGroups(ExtMap input, ExtMap output, long pageSize) {
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setLdapQueryType(LdapQueryType.searchGroups);
    queryData.setDomain(getDirectoryName());
    queryData.setFilterParameters(new Object[] { generateQueryString(input) });
    // Find the users using the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.SearchGroupsByQuery, new LdapSearchByQueryParameters(null, getDirectoryName(), queryData, false));
    List<LdapGroup> ldapGroups = (List<LdapGroup>) ldapResult.getReturnValue();
    List<ExtMap> results = new ArrayList<>();
    for (LdapGroup ldapGroup : ldapGroups) {
        if (results.size() < pageSize) {
            results.add(mapLdapGroup(ldapGroup));
        }
    }
    return output.mput(Authz.InvokeKeys.QUERY_RESULT, results);
}
#method_after
public ExtMap queryGroups(ExtMap input, ExtMap output, long pageSize) {
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setLdapQueryType(LdapQueryType.searchGroups);
    queryData.setDomain(getDirectoryName());
    queryData.setFilterParameters(new Object[] { generateQueryString(input) });
    // Find the users using the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.SearchGroupsByQuery, new LdapSearchByQueryParameters(configuration, null, getDirectoryName(), queryData, false));
    List<LdapGroup> ldapGroups = (List<LdapGroup>) ldapResult.getReturnValue();
    List<ExtMap> results = new ArrayList<>();
    for (LdapGroup ldapGroup : ldapGroups) {
        if (results.size() < pageSize) {
            results.add(mapLdapGroup(ldapGroup));
        }
    }
    return output.mput(Authz.InvokeKeys.QUERY_RESULT, results);
}
#end_block

#method_before
public ExtMap queryUsers(ExtMap input, ExtMap output, long pageSize) {
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setLdapQueryType(LdapQueryType.searchUsers);
    queryData.setDomain(getDirectoryName());
    queryData.setFilterParameters(new Object[] { generateQueryString(input) });
    // Find the users using the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(null, getDirectoryName(), queryData, input.<Boolean>get(Authz.InvokeKeys.RESOLVE_GROUPS_RECURSIVE, false)));
    List<LdapUser> ldapUsers = (List<LdapUser>) ldapResult.getReturnValue();
    List<ExtMap> results = new ArrayList<>();
    int addedUsers = 0;
    for (LdapUser ldapUser : ldapUsers) {
        if (addedUsers++ < pageSize) {
            results.add(mapLdapUser(ldapUser));
        }
    }
    return output.mput(Authz.InvokeKeys.QUERY_RESULT, results);
}
#method_after
public ExtMap queryUsers(ExtMap input, ExtMap output, long pageSize) {
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setLdapQueryType(LdapQueryType.searchUsers);
    queryData.setDomain(getDirectoryName());
    queryData.setFilterParameters(new Object[] { generateQueryString(input) });
    // Find the users using the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(configuration, null, getDirectoryName(), queryData, input.<Boolean>get(Authz.InvokeKeys.RESOLVE_GROUPS_RECURSIVE, false)));
    List<LdapUser> ldapUsers = (List<LdapUser>) ldapResult.getReturnValue();
    List<ExtMap> results = new ArrayList<>();
    int addedUsers = 0;
    for (LdapUser ldapUser : ldapUsers) {
        if (addedUsers++ < pageSize) {
            results.add(mapLdapUser(ldapUser));
        }
    }
    return output.mput(Authz.InvokeKeys.QUERY_RESULT, results);
}
#end_block

#method_before
@Override
public void invoke(ExtMap input, ExtMap output) {
    try {
        Object command = input.get(Base.InvokeKeys.COMMAND);
        if (command.equals(Base.InvokeCommands.INITIALIZE)) {
            doInit(input, output);
        } else if (command.equals(Authz.InvokeCommands.QUERY_OPEN)) {
            doQueryOpen(input, output);
        } else if (command.equals(Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD)) {
            doFetchPrincipalRecord(input, output);
        } else if (command.equals(Authz.InvokeCommands.QUERY_EXECUTE)) {
            doQueryExecute(input, output);
        } else if (command.equals(Authz.InvokeCommands.QUERY_CLOSE)) {
        } else {
            output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.UNSUPPORTED);
        }
        output.putIfAbsent(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
    } catch (Exception ex) {
        output.mput(Base.InvokeKeys.RESULT, Base.InvokeResult.FAILED).mput(Base.InvokeKeys.MESSAGE, ex.getMessage());
    }
}
#method_after
@Override
public void invoke(ExtMap input, ExtMap output) {
    try {
        Object command = input.get(Base.InvokeKeys.COMMAND);
        if (command.equals(Base.InvokeCommands.LOAD)) {
            doLoad(input, output);
        } else if (command.equals(Base.InvokeCommands.INITIALIZE)) {
            doInit(input, output);
        } else if (command.equals(Authz.InvokeCommands.QUERY_OPEN)) {
            doQueryOpen(input, output);
        } else if (command.equals(Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD)) {
            doFetchPrincipalRecord(input, output);
        } else if (command.equals(Authz.InvokeCommands.QUERY_EXECUTE)) {
            doQueryExecute(input, output);
        } else if (command.equals(Authz.InvokeCommands.QUERY_CLOSE)) {
        } else {
            output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.UNSUPPORTED);
        }
        output.putIfAbsent(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
        output.putIfAbsent(Authz.InvokeKeys.STATUS, Authz.Status.SUCCESS);
    } catch (Exception ex) {
        output.mput(Base.InvokeKeys.RESULT, Base.InvokeResult.FAILED).mput(Base.InvokeKeys.MESSAGE, ex.getMessage()).mput(Authz.InvokeKeys.STATUS, Authz.Status.GENERAL_ERROR);
    }
}
#end_block

#method_before
private void doInit(ExtMap inputMap, ExtMap outputMap) {
    context = inputMap.<ExtMap>get(Base.InvokeKeys.CONTEXT);
    configuration = context.<Properties>get(Base.ContextKeys.CONFIGURATION);
    Config.setConfiguration((Properties) configuration.get("config"));
    broker = LdapFactory.getInstance(getDirectoryName());
    context.mput(Base.ContextKeys.AUTHOR, "The oVirt Project").mput(Base.ContextKeys.EXTENSION_NAME, "Kerberos/Ldap Authz (Built-in)").mput(Base.ContextKeys.LICENSE, "ASL 2.0").mput(Base.ContextKeys.HOME_URL, "http://www.ovirt.org").mput(Base.ContextKeys.VERSION, "N/A").mput(Authz.ContextKeys.QUERY_MAX_FILTER_SIZE, Integer.parseInt(Config.getProperty("MaxLDAPQueryPartsNumber"))).mput(Base.ContextKeys.BUILD_INTERFACE_VERSION, Base.INTERFACE_VERSION_CURRENT);
}
#method_after
private void doInit(ExtMap input, ExtMap output) {
    try {
        Utils.handleApplicationInit(context.<ExtMap>get(Base.ContextKeys.GLOBAL_CONTEXT).<String>get(Base.GlobalContextKeys.APPLICATION_NAME));
    } catch (Exception e) {
        output.mput(Base.InvokeKeys.MESSAGE, e.getMessage()).mput(Base.InvokeKeys.RESULT, Base.InvokeResult.FAILED);
    }
}
#end_block

#method_before
private void doFetchPrincipalRecord(ExtMap input, ExtMap output) {
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.GetAdUserByUserName, new LdapSearchByUserNameParameters(null, getDirectoryName(), input.<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD).<String>get(Authn.AuthRecord.PRINCIPAL)));
    output.mput(Authz.InvokeKeys.PRINCIPAL_RECORD, mapLdapUser(((LdapUser) ldapResult.getReturnValue())));
}
#method_after
private void doFetchPrincipalRecord(ExtMap input, ExtMap output) {
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.GetAdUserByUserName, new LdapSearchByUserNameParameters(configuration, null, getDirectoryName(), input.<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD).<String>get(Authn.AuthRecord.PRINCIPAL)));
    output.mput(Authz.InvokeKeys.PRINCIPAL_RECORD, mapLdapUser(((LdapUser) ldapResult.getReturnValue()))).mput(Authz.InvokeKeys.STATUS, Authz.Status.SUCCESS);
}
#end_block

#method_before
public static List<GroupSearchResult> performGroupQuery(String loginName, String password, String domainName, LdapQueryData queryData) {
    LdapCredentials ldapCredentials = new LdapCredentials(LdapBrokerUtils.modifyLoginNameForKerberos(loginName, domainName), password);
    DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
    try {
        List<GroupSearchResult> searchResults = (List<GroupSearchResult>) directorySearcher.findAll(queryData);
        return searchResults;
    } catch (DomainNotConfiguredException ex) {
        log.errorFormat("User {0} from domain {1} is a member of a group from {2} which is not configured. Please use the manage domains utility if you wish to add this domain.", loginName, domainName, queryData.getDomain());
        return null;
    }
}
#method_after
public static List<GroupSearchResult> performGroupQuery(Properties configuration, String loginName, String password, String domainName, LdapQueryData queryData) {
    LdapCredentials ldapCredentials = new LdapCredentials(LdapBrokerUtils.modifyLoginNameForKerberos(loginName, domainName, configuration), password);
    DirectorySearcher directorySearcher = new DirectorySearcher(configuration, ldapCredentials);
    try {
        List<GroupSearchResult> searchResults = (List<GroupSearchResult>) directorySearcher.findAll(queryData);
        return searchResults;
    } catch (DomainNotConfiguredException ex) {
        log.errorFormat("User {0} from domain {1} is a member of a group from {2} which is not configured. Please use the manage domains utility if you wish to add this domain.", loginName, domainName, queryData.getDomain());
        return null;
    }
}
#end_block

#method_before
public static String modifyLoginNameForKerberos(String loginName, String domain) {
    String[] parts = loginName.split("[@]");
    Domain requestedDomain = UsersDomainsCacheManagerService.getInstance().getDomain(domain);
    if (requestedDomain == null) {
        throw new DomainNotConfiguredException(domain);
    }
    LDAPSecurityAuthentication securityAuthentication = requestedDomain.getLdapSecurityAuthentication();
    boolean isKerberosAuth = securityAuthentication.equals(LDAPSecurityAuthentication.GSSAPI);
    // if loginName is not in format of user@domain
    if (parts.length != 2) {
        // the default REALM, as confugured in krb5.conf will be picked
        return isKerberosAuth ? loginName + "@" + domain.toUpperCase() : loginName;
    }
    // In case the login name is in format of user@domain, it should be
    // transformed to user@realm - realm is a capitalized version of fully
    // qualified domain name
    StringBuilder result = new StringBuilder();
    result.append(parts[0]);
    if (isKerberosAuth) {
        String realm = parts[1].toUpperCase();
        result.append("@").append(realm);
    }
    return result.toString();
}
#method_after
public static String modifyLoginNameForKerberos(String loginName, String domain, Properties configuration) {
    String[] parts = loginName.split("[@]");
    LDAPSecurityAuthentication securityAuthentication = LDAPSecurityAuthentication.valueOf(configuration.getProperty("config.LDAPSecurityAuthentication"));
    boolean isKerberosAuth = securityAuthentication.equals(LDAPSecurityAuthentication.GSSAPI);
    // if loginName is not in format of user@domain
    if (parts.length != 2) {
        // the default REALM, as confugured in krb5.conf will be picked
        return isKerberosAuth ? loginName + "@" + domain.toUpperCase() : loginName;
    }
    // In case the login name is in format of user@domain, it should be
    // transformed to user@realm - realm is a capitalized version of fully
    // qualified domain name
    StringBuilder result = new StringBuilder();
    result.append(parts[0]);
    if (isKerberosAuth) {
        String realm = parts[1].toUpperCase();
        result.append("@").append(realm);
    }
    return result.toString();
}
#end_block

#method_before
public static void addLdapConfigValues(Hashtable<String, String> env) {
    env.put("com.sun.jndi.ldap.read.timeout", Long.toString(Integer.parseInt(Config.getProperty("LDAPQueryTimeout")) * 1000));
    env.put("com.sun.jndi.ldap.connect.timeout", Long.toString(Integer.parseInt(Config.getProperty("LDAPConnectTimeout")) * 1000));
}
#method_after
public static void addLdapConfigValues(Properties config, Hashtable<String, String> env) {
    env.put("com.sun.jndi.ldap.read.timeout", Long.toString(Long.parseLong(config.getProperty("config.LDAPQueryTimeout")) * 1000));
    env.put("com.sun.jndi.ldap.connect.timeout", Long.toString(Long.parseLong(config.getProperty("config.LDAPConnectTimeout")) * 1000));
}
#end_block

#method_before
@Override
public void invoke(ExtMap input, ExtMap output) {
    try {
        if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.INITIALIZE)) {
            doInit(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS)) {
            doAuthenticate(input, output);
        } else {
            output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.UNSUPPORTED);
        }
        output.putIfAbsent(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
    } catch (Exception ex) {
        output.mput(Base.InvokeKeys.RESULT, Base.InvokeResult.FAILED).mput(Base.InvokeKeys.MESSAGE, ex.getMessage());
    }
}
#method_after
@Override
public void invoke(ExtMap input, ExtMap output) {
    try {
        if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.LOAD)) {
            doLoad(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.INITIALIZE)) {
            doInit(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS)) {
            doAuthenticate(input, output);
        } else {
            output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.UNSUPPORTED);
        }
        output.putIfAbsent(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
    } catch (Exception ex) {
        output.mput(Base.InvokeKeys.RESULT, Base.InvokeResult.FAILED).mput(Base.InvokeKeys.MESSAGE, ex.getMessage());
    }
}
#end_block

#method_before
private void doInit(ExtMap inputMap, ExtMap outputMap) {
    context = inputMap.<ExtMap>get(Base.InvokeKeys.CONTEXT);
    configuration = context.<Properties>get(Base.ContextKeys.CONFIGURATION);
    Config.setConfiguration((Properties) configuration.get("config"));
    broker = LdapFactory.getInstance(getAuthzName());
    context.<List<String>>get(Base.ContextKeys.CONFIGURATION_SENSITIVE_KEYS).add("config.authn.user.password");
    context.mput(Base.ContextKeys.AUTHOR, "The oVirt Project").mput(Base.ContextKeys.EXTENSION_NAME, "Kerberos/Ldap Authn (Built-in)").mput(Base.ContextKeys.LICENSE, "ASL 2.0").mput(Base.ContextKeys.HOME_URL, "http://www.ovirt.org").mput(Base.ContextKeys.VERSION, "N/A").mput(Authn.ContextKeys.CAPABILITIES, Authn.Capabilities.AUTHENTICATE_PASSWORD).mput(Base.ContextKeys.BUILD_INTERFACE_VERSION, Base.INTERFACE_VERSION_CURRENT);
    KerberosManager.getInstance();
    UsersDomainsCacheManagerService.getInstance().init();
}
#method_after
private void doInit(ExtMap inputMap, ExtMap outputMap) {
    try {
        Utils.handleApplicationInit(context.<ExtMap>get(Base.ContextKeys.GLOBAL_CONTEXT).<String>get(Base.GlobalContextKeys.APPLICATION_NAME));
    } catch (Exception e) {
        outputMap.mput(Base.InvokeKeys.MESSAGE, e.getMessage()).mput(Base.InvokeKeys.RESULT, Base.InvokeResult.FAILED);
    }
}
#end_block

#method_before
private void doAuthenticate(ExtMap input, ExtMap output) {
    broker.runAdAction(AdActionType.AuthenticateUser, new LdapUserPasswordBaseParameters(input, output));
    // Putting these keys anyway, it's up to BLL to decide if to use them or not
    output.mput(Authn.InvokeKeys.USER_MESSAGE, configuration.getProperty("config.change.password.msg")).mput(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL, configuration.getProperty("config.change.password.url"));
}
#method_after
private void doAuthenticate(ExtMap input, ExtMap output) {
    output.mput((ExtMap) broker.runAdAction(AdActionType.AuthenticateUser, new LdapUserPasswordBaseParameters(configuration, input.<String>get(Authn.InvokeKeys.USER), input.<String>get(Authn.InvokeKeys.CREDENTIALS))).getReturnValue());
    // Putting these keys anyway, it's up to BLL to decide if to use them or not
    output.mput(Authn.InvokeKeys.USER_MESSAGE, configuration.getProperty("config.change.password.msg")).mput(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL, configuration.getProperty("config.change.password.url"));
}
#end_block

#method_before
private void execute(LdapProviderType ldapProviderType, String domain) {
    Hashtable<String, String> env = new Hashtable<String, String>();
    LdapBrokerUtils.addLdapConfigValues(env);
    initContextVariables(env);
    Attributes results = null;
    DirContext ctx = null;
    try {
        ctx = createContext(env);
        LdapQueryData ldapQueryData = new LdapQueryDataImpl();
        ldapQueryData.setLdapQueryType(LdapQueryType.rootDSE);
        ldapQueryData.setDomain(domain);
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(ldapProviderType, ldapQueryData);
        SearchControls searchControls = new SearchControls();
        searchControls.setReturningAttributes(queryExecution.getReturningAttributes());
        searchControls.setSearchScope(queryExecution.getSearchScope());
        // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
        searchControls.setReturningObjFlag(true);
        searchControls.setTimeLimit(Integer.parseInt(Config.getProperty("LDAPOperationTimeout")) * 1000);
        NamingEnumeration<SearchResult> search = ctx.search(queryExecution.getBaseDN(), queryExecution.getFilter(), searchControls);
        try {
            // build a map of attributes and their string values
            results = search.next().getAttributes();
        } finally {
            // make sure we close this search, otherwise the ldap connection will stick until GC kills it
            search.close();
        }
    } catch (NamingException e) {
        String message = LdapBrokerUtils.getFriendlyExceptionMessage(e);
        log.errorFormat("Failed to query rootDSE for LDAP server {0} due to {1}", ldapURI, message);
        throw new DirectoryServiceException(e);
    } finally {
        closeContext(ctx);
    }
    attributes = results;
}
#method_after
private void execute(LdapProviderType ldapProviderType, String domain) {
    Hashtable<String, String> env = new Hashtable<String, String>();
    LdapBrokerUtils.addLdapConfigValues(configuration, env);
    initContextVariables(env);
    Attributes results = null;
    DirContext ctx = null;
    try {
        ctx = createContext(env);
        LdapQueryData ldapQueryData = new LdapQueryDataImpl();
        ldapQueryData.setLdapQueryType(LdapQueryType.rootDSE);
        ldapQueryData.setDomain(domain);
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(ldapProviderType, ldapQueryData);
        SearchControls searchControls = new SearchControls();
        searchControls.setReturningAttributes(queryExecution.getReturningAttributes());
        searchControls.setSearchScope(queryExecution.getSearchScope());
        // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
        searchControls.setReturningObjFlag(true);
        searchControls.setTimeLimit(Integer.parseInt(configuration.getProperty("config.LDAPOperationTimeout")) * 1000);
        NamingEnumeration<SearchResult> search = ctx.search(queryExecution.getBaseDN(), queryExecution.getFilter(), searchControls);
        try {
            // build a map of attributes and their string values
            results = search.next().getAttributes();
        } finally {
            // make sure we close this search, otherwise the ldap connection will stick until GC kills it
            search.close();
        }
    } catch (NamingException e) {
        String message = LdapBrokerUtils.getFriendlyExceptionMessage(e);
        log.errorFormat("Failed to query rootDSE for LDAP server {0} due to {1}", ldapURI, message);
        throw new DirectoryServiceException(e);
    } finally {
        closeContext(ctx);
    }
    attributes = results;
}
#end_block

#method_before
protected URI getLdapURI() {
    return ldapURI;
}
#method_after
protected String getLdapURI() {
    return ldapURI;
}
#end_block

#method_before
@Override
public LDAPTemplateWrapper call() throws Exception {
    String userName = ldapCredentials.getUserName();
    String password = ldapCredentials.getPassword();
    LdapContextSource ldapctx = new LdapContextSource();
    LDAPTemplateWrapper wrapper = LDAPTemplateWrapperFactory.getLDAPTemplateWrapper(ldapctx, userName, password, domain);
    try {
        wrapper.init(ldapURI, searcher.isBaseDNExist(), searcher.getExplicitAuth(), searcher.getExplicitBaseDN(), searcher.getDomainObject(domain).getLdapProviderType(), Integer.parseInt(Config.getProperty("LDAPQueryTimeout")) * 1000);
        ldapctx.afterPropertiesSet();
    } catch (Exception e) {
        log.error("Error connecting to directory server", e);
        throw new AuthenticationResultException(AuthenticationResult.OTHER);
    }
    wrapper.useAuthenticationStrategy();
    wrapper.setIgnorePartialResultException(true);
    return wrapper;
}
#method_after
@Override
public LDAPTemplateWrapper call() throws Exception {
    String userName = ldapCredentials.getUserName();
    String password = ldapCredentials.getPassword();
    LdapContextSource ldapctx = new LdapContextSource();
    LDAPTemplateWrapper wrapper = LDAPTemplateWrapperFactory.getLDAPTemplateWrapper(configuration, ldapctx, userName, password, domain);
    try {
        wrapper.init(ldapURI, searcher.isBaseDNExist(), searcher.getExplicitBaseDN(), LdapProviderType.valueOf(configuration.getProperty("config.LDAPProviderTypes")), Integer.parseInt(configuration.getProperty("config.LDAPQueryTimeout")) * 1000);
        ldapctx.afterPropertiesSet();
    } catch (Exception e) {
        log.error("Error connecting to directory server", e);
        throw new AuthenticationResultException(AuthenticationResult.OTHER);
    }
    wrapper.useAuthenticationStrategy();
    wrapper.setIgnorePartialResultException(true);
    return wrapper;
}
#end_block

#method_before
@Override
public void setupEnvironment(Hashtable env, String userDn, String password) throws NamingException {
    env.put(Context.SECURITY_AUTHENTICATION, GSS_API_AUTHENTICATION);
    String qopValue = Config.getProperty("SASL_QOP");
    env.put("javax.security.sasl.qop", qopValue);
}
#method_after
@Override
public void setupEnvironment(Hashtable env, String userDn, String password) throws NamingException {
    env.put(Context.SECURITY_AUTHENTICATION, GSS_API_AUTHENTICATION);
    String qopValue = configuration.getProperty("config.SASL_QOP");
    env.put("javax.security.sasl.qop", qopValue);
}
#end_block

#method_before
public void authenticate() throws AuthenticationResultException {
    UsersDomainsCacheManager usersDomainsCacheManager = UsersDomainsCacheManagerService.getInstance();
    UserDomainInfo userDomainInfo = usersDomainsCacheManager.associateUserWithDomain(this.userName, this.realm.toLowerCase());
    loginContext = null;
    synchronized (userDomainInfo) {
        // login context from cache
        if (!explicitAuth) {
            loginContext = userDomainInfo.getLoginContext();
        }
        if (!validLoginContext()) {
            explicitAuth(userDomainInfo);
        }
    }
}
#method_after
public void authenticate() throws AuthenticationResultException {
    GSSAPICallbackHandler callbackHandler = new GSSAPICallbackHandler(userName, password);
    authenticateToKDC(callbackHandler);
}
#end_block

#method_before
private void authenticateToKDC(GSSAPICallbackHandler callbackHandler, UserDomainInfo userDomainInfo) throws AuthenticationResultException {
    try {
        loginContext = new LoginContext(LOGIN_MODULE_POLICY_NAME, callbackHandler);
        loginContext.login();
        userDomainInfo.setLoginContext(loginContext);
        if (log.isDebugEnabled()) {
            log.debug("Successful login for user " + userName);
        }
    } catch (LoginException ex) {
        // JAAS throws login exception due to various reasons.
        // We check if the login exception matches a case where the user
        // provided wrong authentication details, or
        // if there was another error - in case the user provided wrong
        // authentication details, we will abort the kdc search
        loginContext = null;
        KerberosReturnCodeParser parser = new KerberosReturnCodeParser();
        AuthenticationResult result = parser.parse(ex.getMessage());
        log.error("Kerberos error: " + ex.getMessage());
        if (log.isDebugEnabled()) {
            log.debug("Kerberos error stacktrace: ", ex);
        }
        if (result != AuthenticationResult.OTHER) {
            log.error(result.getDetailedMessage());
        }
        throw new AuthenticationResultException(result);
    }
}
#method_after
private void authenticateToKDC(GSSAPICallbackHandler callbackHandler) throws AuthenticationResultException {
    try {
        loginContext = new LoginContext(configuration.getProperty("config.JAASLoginContext"), callbackHandler);
        loginContext.login();
        if (log.isDebugEnabled()) {
            log.debug("Successful login for user " + userName);
        }
    } catch (LoginException ex) {
        // JAAS throws login exception due to various reasons.
        // We check if the login exception matches a case where the user
        // provided wrong authentication details, or
        // if there was another error - in case the user provided wrong
        // authentication details, we will abort the kdc search
        loginContext = null;
        KerberosReturnCodeParser parser = new KerberosReturnCodeParser();
        AuthenticationResult result = parser.parse(ex.getMessage());
        log.error("Kerberos error: " + ex.getMessage());
        if (log.isDebugEnabled()) {
            log.debug("Kerberos error stacktrace: ", ex);
        }
        if (result != AuthenticationResult.OTHER) {
            log.error(result.getDetailedMessage());
        }
        throw new AuthenticationResultException(result);
    }
}
#end_block

#method_before
@Override
public List<?> call() throws Exception {
    ContextMapperCallbackHandler cmCallback = new NotNullContextMapperCallbackHandler(queryExecution.getContextMapper());
    SearchControls controls = new SearchControls();
    if (queryExecution.getReturningAttributes() != null) {
        controls.setReturningAttributes(queryExecution.getReturningAttributes());
    }
    controls.setSearchScope(queryExecution.getSearchScope());
    controls.setCountLimit(resultcount);
    // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
    controls.setReturningObjFlag(true);
    controls.setTimeLimit(Integer.parseInt(Config.getProperty("LDAPQueryTimeout")) * 1000);
    ldapTemplate.search("", queryExecution.getFilter(), queryExecution.getDisplayFilter(), controls, cmCallback);
    return cmCallback.getList();
}
#method_after
@Override
public List<?> call() throws Exception {
    ContextMapperCallbackHandler cmCallback = new NotNullContextMapperCallbackHandler(queryExecution.getContextMapper());
    SearchControls controls = new SearchControls();
    if (queryExecution.getReturningAttributes() != null) {
        controls.setReturningAttributes(queryExecution.getReturningAttributes());
    }
    controls.setSearchScope(queryExecution.getSearchScope());
    controls.setCountLimit(resultcount);
    // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
    controls.setReturningObjFlag(true);
    controls.setTimeLimit(Integer.parseInt(configuration.getProperty("config.LDAPQueryTimeout")) * 1000);
    ldapTemplate.search("", queryExecution.getFilter(), queryExecution.getDisplayFilter(), controls, cmCallback);
    return cmCallback.getList();
}
#end_block

#method_before
protected GetRootDSE createRootDSE(URI uri) {
    return new GetRootDSE(uri);
}
#method_after
protected GetRootDSE createRootDSE(String uri) {
    return new GetRootDSE(configuration, uri);
}
#end_block

#method_before
public List<?> find(final LdapQueryData queryData, final long resultCount) {
    final String domainName = queryData.getDomain();
    final Domain domain = getDomainObject(domainName);
    if (domain == null) {
        log.errorFormat("Error in finding LDAP servers for domain {0} using user {1}", domainName, ldapCredentials.getUserName());
        return null;
    }
    List<URI> ldapServerURIs = domain.getLdapServers();
    List<URI> editableLdapServerURIs = new ArrayList<>(ldapServerURIs);
    if (log.isDebugEnabled()) {
        log.debug("Ldap server list: " + StringUtils.join(ldapServerURIs, ", "));
    }
    List<?> response = null;
    for (Iterator<URI> iterator = ldapServerURIs.iterator(); iterator.hasNext(); ) {
        URI ldapURI = iterator.next();
        try {
            response = findAndOrderServers(queryData, ldapURI, domainName, resultCount, editableLdapServerURIs);
            if (response != null) {
                break;
            }
        } catch (Exception ex) {
            return null;
        }
    }
    domain.setLdapServers(editableLdapServerURIs);
    return response;
}
#method_after
public List<?> find(final LdapQueryData queryData, final long resultCount) {
    final String domainName = queryData.getDomain();
    List<String> ldapServerURIs = Arrays.asList(configuration.getProperty("config.LDAPServers").split(","));
    List<String> editableLdapServerURIs = new ArrayList<>(ldapServerURIs);
    if (log.isDebugEnabled()) {
        log.debug("Ldap server list: " + StringUtils.join(ldapServerURIs, ", "));
    }
    List<?> response = null;
    for (Iterator<String> iterator = ldapServerURIs.iterator(); iterator.hasNext(); ) {
        String ldapURI = iterator.next();
        try {
            response = findAndOrderServers(queryData, ldapURI, domainName, resultCount, editableLdapServerURIs);
            if (response != null) {
                break;
            }
        } catch (Exception ex) {
            return null;
        }
    }
    configuration.setProperty("config.LdapServers", StringUtils.join(editableLdapServerURIs, ","));
    return response;
}
#end_block

#method_before
private List<?> findAndOrderServers(LdapQueryData queryData, URI ldapURI, String domainName, long resultCount, List<URI> modifiedLdapServersURIs) throws Exception {
    if (log.isDebugEnabled()) {
        log.debug("Using Ldap server " + ldapURI);
    }
    try {
        setException(null);
        GetRootDSETask getRootDSETask = new GetRootDSETask(this, domainName, ldapURI);
        PrepareLdapConnectionTask prepareLdapConnectionTask = new PrepareLdapConnectionTask(this, ldapCredentials, domainName, ldapURI);
        // TODO: Not really async Can throw exception
        getRootDSETask.call();
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(getDomainObject(domainName).getLdapProviderType(), queryData);
        if (queryExecution.getBaseDN() != null && !queryExecution.getBaseDN().isEmpty()) {
            setExplicitBaseDN(queryExecution.getBaseDN());
        }
        log.debug("find() : LDAP filter = " + queryExecution.getFilter() + ", baseDN = " + queryExecution.getBaseDN() + ", explicitBaseDN = " + explicitBaseDN + ", domain = " + queryExecution.getDomain());
        LDAPTemplateWrapper ldapTemplate = prepareLdapConnectionTask.call();
        if (ldapTemplate == null) {
            return Collections.emptyList();
        }
        return new DirectorySearchTask(ldapTemplate, queryExecution, resultCount).call();
    } catch (Exception exception) {
        LdapSearchExceptionHandlingResponse handlingResponse = handler.handle(exception, ldapCredentials);
        Exception translatedException = handlingResponse.getTranslatedException();
        setException(translatedException);
        LdapServersOrderingAlgorithmFactory.getInstance().getOrderingAlgorithm(handlingResponse.getOrderingAlgorithm()).reorder(ldapURI, modifiedLdapServersURIs);
        log.errorFormat("Failed ldap search server {0} using user {1} due to {2}. We {3} try the next server", ldapURI, ldapCredentials.getUserName(), LdapBrokerUtils.getFriendlyExceptionMessage(translatedException), handlingResponse.isTryNextServer() ? "should" : "should not");
        log.debugFormat("Failed ldap search server {0} using user {1} due to {2}. We {3} try the next server", ldapURI, ldapCredentials.getUserName(), translatedException, handlingResponse.isTryNextServer() ? "should" : "should not");
        if (!handlingResponse.isTryNextServer()) {
            throw new Exception();
        }
    }
    return null;
}
#method_after
private List<?> findAndOrderServers(LdapQueryData queryData, String ldapURI, String domainName, long resultCount, List<String> modifiedLdapServersURIs) throws Exception {
    if (log.isDebugEnabled()) {
        log.debug("Using Ldap server " + ldapURI);
    }
    try {
        setException(null);
        GetRootDSETask getRootDSETask = new GetRootDSETask(configuration, this, domainName, ldapURI);
        PrepareLdapConnectionTask prepareLdapConnectionTask = new PrepareLdapConnectionTask(configuration, this, ldapCredentials, domainName, ldapURI);
        // TODO: Not really async Can throw exception
        getRootDSETask.call();
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(LdapProviderType.valueOf(configuration.getProperty("config.LDAPProviderTypes")), queryData);
        if (queryExecution.getBaseDN() != null && !queryExecution.getBaseDN().isEmpty()) {
            setExplicitBaseDN(queryExecution.getBaseDN());
        }
        log.debug("find() : LDAP filter = " + queryExecution.getFilter() + ", baseDN = " + queryExecution.getBaseDN() + ", explicitBaseDN = " + explicitBaseDN + ", domain = " + queryExecution.getDomain());
        LDAPTemplateWrapper ldapTemplate = prepareLdapConnectionTask.call();
        if (ldapTemplate == null) {
            return Collections.emptyList();
        }
        return new DirectorySearchTask(configuration, ldapTemplate, queryExecution, resultCount).call();
    } catch (Exception exception) {
        LdapSearchExceptionHandlingResponse handlingResponse = handler.handle(exception, ldapCredentials);
        Exception translatedException = handlingResponse.getTranslatedException();
        setException(translatedException);
        LdapServersOrderingAlgorithmFactory.getInstance().getOrderingAlgorithm(handlingResponse.getOrderingAlgorithm()).reorder(ldapURI, modifiedLdapServersURIs);
        log.errorFormat("Failed ldap search server {0} using user {1} due to {2}. We {3} try the next server", ldapURI, ldapCredentials.getUserName(), LdapBrokerUtils.getFriendlyExceptionMessage(translatedException), handlingResponse.isTryNextServer() ? "should" : "should not");
        log.debugFormat("Failed ldap search server {0} using user {1} due to {2}. We {3} try the next server", ldapURI, ldapCredentials.getUserName(), translatedException, handlingResponse.isTryNextServer() ? "should" : "should not");
        if (!handlingResponse.isTryNextServer()) {
            throw new Exception();
        }
    }
    return null;
}
#end_block

#method_before
@Override
public ImageResource getValue(StorageDomain sp) {
    setEnumTitle(sp.getStatus());
    switch(sp.getStatus()) {
        case Unattached:
            if (sp.getStorageType() == StorageType.GLANCE) {
                return getApplicationResources().openstackImage();
            } else {
                return getApplicationResources().tornChainImage();
            }
        case Active:
            return getApplicationResources().upImage();
        case InActive:
            return getApplicationResources().downImage();
        case Uninitialized:
            return getApplicationResources().unconfiguredImage();
        case Locked:
        case MovingToMaintenance:
        case Detaching:
            return getApplicationResources().lockImage();
        default:
            return getApplicationResources().downImage();
    }
}
#method_after
@Override
public ImageResource getValue(StorageDomain sp) {
    setEnumTitle(sp.getStatus());
    switch(sp.getStatus()) {
        case Unattached:
            if (sp.getStorageType() == StorageType.GLANCE) {
                return getApplicationResources().openstackImage();
            } else {
                return getApplicationResources().tornChainImage();
            }
        case Active:
            return getApplicationResources().upImage();
        case InActive:
            return getApplicationResources().downImage();
        case Uninitialized:
            return getApplicationResources().unconfiguredImage();
        case Locked:
        case PreparingForMaintenance:
        case Detaching:
            return getApplicationResources().lockImage();
        case Maintenance:
            return getApplicationResources().maintenanceImage();
        default:
            return getApplicationResources().downImage();
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageDomainStatus.class, to = StorageDomainStatus.class)
public static StorageDomainStatus map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus status, StorageDomainStatus template) {
    switch(status) {
        case Unattached:
            return StorageDomainStatus.UNATTACHED;
        case Active:
            return StorageDomainStatus.ACTIVE;
        case InActive:
            return StorageDomainStatus.INACTIVE;
        case Locked:
            return StorageDomainStatus.LOCKED;
        case MovingToMaintenance:
            return StorageDomainStatus.MOVINGTOMAINTENANCE;
        case Detaching:
            return StorageDomainStatus.DETACHING;
        case Maintenance:
            return StorageDomainStatus.MAINTENANCE;
        case Unknown:
            return StorageDomainStatus.UNKNOWN;
        case Uninitialized:
            return null;
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageDomainStatus.class, to = StorageDomainStatus.class)
public static StorageDomainStatus map(org.ovirt.engine.core.common.businessentities.StorageDomainStatus status, StorageDomainStatus template) {
    switch(status) {
        case Unattached:
            return StorageDomainStatus.UNATTACHED;
        case Active:
            return StorageDomainStatus.ACTIVE;
        case InActive:
            return StorageDomainStatus.INACTIVE;
        case Locked:
            return StorageDomainStatus.LOCKED;
        case PreparingForMaintenance:
            return StorageDomainStatus.PREPARING_FOR_MAINTENANCE;
        case Detaching:
            return StorageDomainStatus.DETACHING;
        case Maintenance:
            return StorageDomainStatus.MAINTENANCE;
        case Unknown:
            return StorageDomainStatus.UNKNOWN;
        case Uninitialized:
            return null;
        default:
            return null;
    }
}
#end_block

#method_before
private void newDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDomainTitle());
    // $NON-NLS-1$
    model.setHashName("new_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    ArrayList<IStorageModel> items = new ArrayList<IStorageModel>();
    // putting all Data domains at the beginning on purpose (so when choosing the
    // first selectable storage type/function, it will be a Data one, if relevant).
    NfsStorageModel nfsDataModel = new NfsStorageModel();
    nfsDataModel.setRole(StorageDomainType.Data);
    items.add(nfsDataModel);
    IscsiStorageModel iscsiDataModel = new IscsiStorageModel();
    iscsiDataModel.setRole(StorageDomainType.Data);
    iscsiDataModel.setIsGrouppedByTarget(true);
    items.add(iscsiDataModel);
    FcpStorageModel fcpDataModel = new FcpStorageModel();
    fcpDataModel.setRole(StorageDomainType.Data);
    items.add(fcpDataModel);
    LocalStorageModel localDataModel = new LocalStorageModel();
    localDataModel.setRole(StorageDomainType.Data);
    items.add(localDataModel);
    LocalStorageModel localIsoModel = new LocalStorageModel();
    localIsoModel.setRole(StorageDomainType.ISO);
    items.add(localIsoModel);
    PosixStorageModel posixDataModel = new PosixStorageModel();
    posixDataModel.setRole(StorageDomainType.Data);
    items.add(posixDataModel);
    GlusterStorageModel GlusterDataModel = new GlusterStorageModel();
    GlusterDataModel.setRole(StorageDomainType.Data);
    items.add(GlusterDataModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    posixIsoModel.setRole(StorageDomainType.ISO);
    items.add(posixIsoModel);
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    nfsIsoModel.setRole(StorageDomainType.ISO);
    items.add(nfsIsoModel);
    NfsStorageModel nfsExportModel = new NfsStorageModel();
    nfsExportModel.setRole(StorageDomainType.ImportExport);
    items.add(nfsExportModel);
    model.setItems(items);
    model.initialize();
    // $NON-NLS-1$
    UICommand command = createOKCommand("OnSave");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#method_after
private void newDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDomainTitle());
    model.setHelpTag(HelpTag.new_domain);
    // $NON-NLS-1$
    model.setHashName("new_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    // putting all Data domains at the beginning on purpose (so when choosing the
    // first selectable storage type/function, it will be a Data one, if relevant).
    items = AsyncDataProvider.getDataStorageModels();
    items.addAll(AsyncDataProvider.getIsoStorageModels());
    NfsStorageModel nfsExportModel = new NfsStorageModel();
    nfsExportModel.setRole(StorageDomainType.ImportExport);
    items.add(nfsExportModel);
    model.setItems(items);
    model.initialize();
    // $NON-NLS-1$
    UICommand command = createOKCommand("OnSave");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
private void edit() {
    StorageDomain storage = (StorageDomain) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangable(false);
    model.getFormat().setIsChangable(false);
    boolean isStorageEditable = model.isStorageActive() || model.isNewStorage();
    model.getHost().setIsChangable(false);
    model.getName().setIsChangable(isStorageEditable);
    model.getDescription().setIsChangable(isStorageEditable);
    model.getComment().setIsChangable(isStorageEditable);
    // set the field domain type to non editable
    model.getAvailableStorageItems().setIsChangable(false);
    model.setIsChangable(isStorageEditable);
    boolean isPathEditable = isPathEditable(storage);
    isStorageEditable = isStorageEditable || isPathEditable;
    IStorageModel item = null;
    switch(storage.getStorageType()) {
        case NFS:
            item = prepareNfsStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case FCP:
            item = prepareFcpStorageForEdit(storage);
            break;
        case ISCSI:
            item = prepareIscsiStorageForEdit(storage);
            break;
        case LOCALFS:
            item = prepareLocalStorageForEdit(storage);
            model.getHost().setIsChangable(isPathEditable);
            break;
        case POSIXFS:
            item = preparePosixStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case GLUSTERFS:
            item = prepareGlusterStorageForEdit(storage);
            break;
    }
    model.setItems(new ArrayList<IStorageModel>(Arrays.asList(new IStorageModel[] { item })));
    model.setSelectedItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    UICommand command;
    if (isStorageEditable) {
        // $NON-NLS-1$
        command = createOKCommand("OnSave");
        model.getCommands().add(command);
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        model.getCommands().add(command);
    } else {
        // close is created the same as cancel, but with a different title
        // thus most of creation code can be reused.
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        command.setTitle(ConstantsManager.getInstance().getConstants().close());
        model.getCommands().add(command);
    }
}
#method_after
private void edit() {
    StorageDomain storage = (StorageDomain) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    model.setHelpTag(HelpTag.edit_domain);
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangable(false);
    model.getFormat().setIsChangable(false);
    boolean isStorageEditable = model.isStorageActive() || model.isNewStorage();
    model.getHost().setIsChangable(false);
    model.getName().setIsChangable(isStorageEditable);
    model.getDescription().setIsChangable(isStorageEditable);
    model.getComment().setIsChangable(isStorageEditable);
    // set the field domain type to non editable
    model.getAvailableStorageItems().setIsChangable(false);
    model.setIsChangable(isStorageEditable);
    boolean isPathEditable = isPathEditable(storage);
    isStorageEditable = isStorageEditable || isPathEditable;
    IStorageModel item = null;
    switch(storage.getStorageType()) {
        case NFS:
            item = prepareNfsStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case FCP:
            item = prepareFcpStorageForEdit(storage);
            break;
        case ISCSI:
            item = prepareIscsiStorageForEdit(storage);
            break;
        case LOCALFS:
            item = prepareLocalStorageForEdit(storage);
            model.getHost().setIsChangable(isPathEditable);
            break;
        case POSIXFS:
            item = preparePosixStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case GLUSTERFS:
            item = prepareGlusterStorageForEdit(storage);
            break;
    }
    model.setItems(new ArrayList<IStorageModel>(Arrays.asList(new IStorageModel[] { item })));
    model.setSelectedItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    UICommand command;
    if (isStorageEditable) {
        // $NON-NLS-1$
        command = createOKCommand("OnSave");
        model.getCommands().add(command);
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        model.getCommands().add(command);
    } else {
        // close is created the same as cancel, but with a different title
        // thus most of creation code can be reused.
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        command.setTitle(ConstantsManager.getInstance().getConstants().close());
        model.getCommands().add(command);
    }
}
#end_block

#method_before
private IStorageModel prepareNfsStorageForEdit(StorageDomain storage) {
    final NfsStorageModel model = new NfsStorageModel();
    model.setRole(storage.getStorageDomainType());
    boolean isNfsPathEditable = isPathEditable(storage);
    model.getPath().setIsChangable(isNfsPathEditable);
    model.getOverride().setIsChangable(isNfsPathEditable);
    AsyncDataProvider.getStorageConnectionById(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageServerConnections connection = (StorageServerConnections) returnValue;
            model.getPath().setEntity(connection.getconnection());
            model.getRetransmissions().setEntity(connection.getNfsRetrans());
            model.getTimeout().setEntity(connection.getNfsTimeo());
            for (Object item : model.getVersion().getItems()) {
                EntityModel itemModel = (EntityModel) item;
                boolean noNfsVersion = itemModel.getEntity() == null && connection.getNfsVersion() == null;
                boolean foundNfsVersion = itemModel.getEntity() != null && itemModel.getEntity().equals(connection.getNfsVersion());
                if (noNfsVersion || foundNfsVersion) {
                    model.getVersion().setSelectedItem(item);
                    break;
                }
            }
            // If any settings were overridden, reflect this in the override checkbox
            model.getOverride().setEntity(connection.getNfsVersion() != null || connection.getNfsRetrans() != null || connection.getNfsTimeo() != null);
        }
    }), storage.getStorage(), true);
    return model;
}
#method_after
private IStorageModel prepareNfsStorageForEdit(StorageDomain storage) {
    final NfsStorageModel model = new NfsStorageModel();
    model.setRole(storage.getStorageDomainType());
    boolean isNfsPathEditable = isPathEditable(storage);
    model.getPath().setIsChangable(isNfsPathEditable);
    model.getOverride().setIsChangable(isNfsPathEditable);
    AsyncDataProvider.getStorageConnectionById(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageServerConnections connection = (StorageServerConnections) returnValue;
            model.getPath().setEntity(connection.getconnection());
            model.getRetransmissions().setEntity(connection.getNfsRetrans());
            model.getTimeout().setEntity(connection.getNfsTimeo());
            for (EntityModel<NfsVersion> item : model.getVersion().getItems()) {
                EntityModel itemModel = (EntityModel) item;
                boolean noNfsVersion = itemModel.getEntity() == null && connection.getNfsVersion() == null;
                boolean foundNfsVersion = itemModel.getEntity() != null && itemModel.getEntity().equals(connection.getNfsVersion());
                if (noNfsVersion || foundNfsVersion) {
                    model.getVersion().setSelectedItem(item);
                    break;
                }
            }
            // If any settings were overridden, reflect this in the override checkbox
            model.getOverride().setEntity(connection.getNfsVersion() != null || connection.getNfsRetrans() != null || connection.getNfsTimeo() != null);
        }
    }), storage.getStorage(), true);
    return model;
}
#end_block

#method_before
private boolean isPathEditable(StorageDomain storage) {
    if (storage.getStorageType().isFileDomain() && !storage.getStorageType().equals(StorageType.GLUSTERFS)) {
        return ((storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master) && (storage.getStatus() == StorageDomainStatus.Maintenance || storage.getStatus() == StorageDomainStatus.MovingToMaintenance || storage.getStatus() == StorageDomainStatus.Detaching || storage.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached));
    }
    return false;
}
#method_after
private boolean isPathEditable(StorageDomain storage) {
    if (storage.getStorageType().isFileDomain() && !storage.getStorageType().equals(StorageType.GLUSTERFS)) {
        return ((storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master) && (storage.getStatus() == StorageDomainStatus.Maintenance || storage.getStatus() == StorageDomainStatus.PreparingForMaintenance || storage.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached));
    }
    return false;
}
#end_block

#method_before
private void importDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new ImportStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().importPreConfiguredDomainTitle());
    // $NON-NLS-1$
    model.setHashName("import_pre-configured_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.getName().setIsAvailable(false);
    model.getDescription().setIsAvailable(false);
    model.getComment().setIsAvailable(false);
    model.getFormat().setIsAvailable(false);
    ArrayList<IStorageModel> items = new ArrayList<IStorageModel>();
    NfsStorageModel tempVar = new NfsStorageModel();
    tempVar.setRole(StorageDomainType.ISO);
    items.add(tempVar);
    LocalStorageModel localIsoModel = new LocalStorageModel();
    localIsoModel.setRole(StorageDomainType.ISO);
    items.add(localIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    posixIsoModel.setRole(StorageDomainType.ISO);
    items.add(posixIsoModel);
    NfsStorageModel tempVar2 = new NfsStorageModel();
    tempVar2.setRole(StorageDomainType.ImportExport);
    items.add(tempVar2);
    model.setItems(items);
    model.initialize();
    UICommand command;
    // $NON-NLS-1$
    command = createOKCommand("OnImport");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#method_after
private void importDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new ImportStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().importPreConfiguredDomainTitle());
    model.setHelpTag(HelpTag.import_pre_configured_domain);
    // $NON-NLS-1$
    model.setHashName("import_pre-configured_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.getName().setIsAvailable(false);
    model.getDescription().setIsAvailable(false);
    model.getComment().setIsAvailable(false);
    model.getFormat().setIsAvailable(false);
    List<IStorageModel> items = AsyncDataProvider.getIsoStorageModels();
    NfsStorageModel tempVar2 = new NfsStorageModel();
    tempVar2.setRole(StorageDomainType.ImportExport);
    items.add(tempVar2);
    model.setItems(items);
    model.initialize();
    UICommand command;
    // $NON-NLS-1$
    command = createOKCommand("OnImport");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
public void storageNameValidation() {
    StorageModel model = (StorageModel) getWindow();
    String name = (String) model.getName().getEntity();
    model.getName().setIsValid(true);
    AsyncDataProvider.isStorageDomainNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageListModel storageListModel = (StorageListModel) target;
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            String name1 = (String) storageModel.getName().getEntity();
            String tempVar = storageModel.getOriginalName();
            // $NON-NLS-1$
            String originalName = (tempVar != null) ? tempVar : "";
            boolean isNameUnique = (Boolean) returnValue;
            if (!isNameUnique && name1.compareToIgnoreCase(originalName) != 0) {
                storageModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                storageModel.getName().setIsValid(false);
                storageListModel.postStorageNameValidation();
            } else {
                AsyncDataProvider.getStorageDomainMaxNameLength(new AsyncQuery(storageListModel, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target1, Object returnValue1) {
                        StorageListModel storageListModel1 = (StorageListModel) target1;
                        StorageModel storageModel1 = (StorageModel) storageListModel1.getWindow();
                        int nameMaxLength = (Integer) returnValue1;
                        RegexValidation tempVar2 = new RegexValidation();
                        // $NON-NLS-1$ //$NON-NLS-2$
                        tempVar2.setExpression("^[A-Za-z0-9_-]{1," + nameMaxLength + "}$");
                        tempVar2.setMessage(ConstantsManager.getInstance().getMessages().nameCanContainOnlyMsg(nameMaxLength));
                        storageModel1.getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar2 });
                        storageListModel1.postStorageNameValidation();
                    }
                }));
            }
        }
    }), name);
}
#method_after
public void storageNameValidation() {
    StorageModel model = (StorageModel) getWindow();
    String name = model.getName().getEntity();
    model.getName().setIsValid(true);
    AsyncDataProvider.isStorageDomainNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageListModel storageListModel = (StorageListModel) target;
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            String name1 = storageModel.getName().getEntity();
            String tempVar = storageModel.getOriginalName();
            // $NON-NLS-1$
            String originalName = (tempVar != null) ? tempVar : "";
            boolean isNameUnique = (Boolean) returnValue;
            if (!isNameUnique && name1.compareToIgnoreCase(originalName) != 0) {
                storageModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                storageModel.getName().setIsValid(false);
                storageListModel.postStorageNameValidation();
            } else {
                AsyncDataProvider.getStorageDomainMaxNameLength(new AsyncQuery(storageListModel, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target1, Object returnValue1) {
                        StorageListModel storageListModel1 = (StorageListModel) target1;
                        StorageModel storageModel1 = (StorageModel) storageListModel1.getWindow();
                        int nameMaxLength = (Integer) returnValue1;
                        RegexValidation tempVar2 = new RegexValidation();
                        // $NON-NLS-1$ //$NON-NLS-2$
                        tempVar2.setExpression("^[A-Za-z0-9_-]{1," + nameMaxLength + "}$");
                        tempVar2.setMessage(ConstantsManager.getInstance().getMessages().nameCanContainOnlyMsg(nameMaxLength));
                        storageModel1.getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar2 });
                        storageListModel1.postStorageNameValidation();
                    }
                }));
            }
        }
    }), name);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    model.getFormat().setIsAvailable(false);
    StorageDomain storage = (StorageDomain) getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setIsAvailable(storage.getStorageDomainType() == StorageDomainType.ISO || storage.getStorageDomainType() == StorageDomainType.ImportExport);
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    model.getFormat().setIsAvailable(false);
    StorageDomain storage = (StorageDomain) getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setIsAvailable(storage.getStorageDomainType().isIsoOrImportExportDomain());
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#end_block

#method_before
private void onRemove() {
    if (getSelectedItem() != null) {
        StorageDomain storage = (StorageDomain) getSelectedItem();
        RemoveStorageModel model = (RemoveStorageModel) getWindow();
        if (!model.validate()) {
            return;
        }
        VDS host = (VDS) model.getHostList().getSelectedItem();
        RemoveStorageDomainParameters tempVar = new RemoveStorageDomainParameters(storage.getId());
        tempVar.setVdsId(host.getId());
        tempVar.setDoFormat((storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master) ? true : (Boolean) model.getFormat().getEntity());
        Frontend.getInstance().runAction(VdcActionType.RemoveStorageDomain, tempVar, null, this);
    }
    cancel();
}
#method_after
private void onRemove() {
    if (getSelectedItem() != null) {
        StorageDomain storage = (StorageDomain) getSelectedItem();
        RemoveStorageModel model = (RemoveStorageModel) getWindow();
        if (!model.validate()) {
            return;
        }
        VDS host = (VDS) model.getHostList().getSelectedItem();
        RemoveStorageDomainParameters tempVar = new RemoveStorageDomainParameters(storage.getId());
        tempVar.setVdsId(host.getId());
        tempVar.setDoFormat(storage.getStorageDomainType().isDataDomain() ? true : (Boolean) model.getFormat().getEntity());
        Frontend.getInstance().runAction(VdcActionType.RemoveStorageDomain, tempVar, null, this);
    }
    cancel();
}
#end_block

#method_before
private void destroy() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().destroyStorageDomainTitle());
    // $NON-NLS-1$
    model.setHashName("destroy_storage_domain");
    ArrayList<String> items = new ArrayList<String>();
    items.add(((StorageDomain) getSelectedItem()).getStorageName());
    model.setItems(items);
    model.getLatch().setIsAvailable(true);
    model.getLatch().setIsChangable(true);
    UICommand command;
    // $NON-NLS-1$
    command = createOKCommand("OnDestroy");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#method_after
private void destroy() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().destroyStorageDomainTitle());
    model.setHelpTag(HelpTag.destroy_storage_domain);
    // $NON-NLS-1$
    model.setHashName("destroy_storage_domain");
    ArrayList<String> items = new ArrayList<String>();
    items.add(((StorageDomain) getSelectedItem()).getStorageName());
    model.setItems(items);
    model.getLatch().setIsAvailable(true);
    model.getLatch().setIsChangable(true);
    UICommand command;
    // $NON-NLS-1$
    command = createOKCommand("OnDestroy");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
private void forceCreationWarning(ArrayList<String> usedLunsMessages) {
    StorageModel storageModel = (StorageModel) getWindow();
    SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getSelectedItem();
    sanStorageModel.setForce(true);
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().forceStorageDomainCreation());
    model.setMessage(ConstantsManager.getInstance().getConstants().lunsAlreadyInUse());
    // $NON-NLS-1$
    model.setHashName("force_storage_domain_creation");
    model.setItems(usedLunsMessages);
    // $NON-NLS-1$
    UICommand command = createOKCommand("OnSaveSanStorage");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("CancelConfirm");
    model.getCommands().add(command);
}
#method_after
private void forceCreationWarning(ArrayList<String> usedLunsMessages) {
    StorageModel storageModel = (StorageModel) getWindow();
    SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getSelectedItem();
    sanStorageModel.setForce(true);
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().forceStorageDomainCreation());
    model.setMessage(ConstantsManager.getInstance().getConstants().lunsAlreadyInUse());
    model.setHelpTag(HelpTag.force_storage_domain_creation);
    // $NON-NLS-1$
    model.setHashName("force_storage_domain_creation");
    model.setItems(usedLunsMessages);
    // $NON-NLS-1$
    UICommand command = createOKCommand("OnSaveSanStorage");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("CancelConfirm");
    model.getCommands().add(command);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    if (getSelectedItem() != null) {
        StorageDomain storage = (StorageDomain) getSelectedItem();
        boolean isBackupStorage = storage.getStorageDomainType() == StorageDomainType.ImportExport;
        boolean isDataStorage = storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master;
        boolean isImageStorage = storage.getStorageDomainType() == StorageDomainType.Image || storage.getStorageDomainType() == StorageDomainType.ISO;
        boolean isDataCenterAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isGeneralAvailable = storage.getStorageType() != StorageType.GLANCE;
        generalModel.setIsAvailable(isGeneralAvailable);
        dcListModel.setIsAvailable(isDataCenterAvailable);
        vmBackupModel.setIsAvailable(isBackupStorage);
        templateBackupModel.setIsAvailable(isBackupStorage);
        vmListModel.setIsAvailable(isDataStorage);
        templateListModel.setIsAvailable(isDataStorage);
        diskListModel.setIsAvailable(isDataStorage);
        isoListModel.setIsAvailable(isImageStorage);
    }
}
#method_after
@Override
protected void updateDetailsAvailability() {
    if (getSelectedItem() != null) {
        StorageDomain storage = (StorageDomain) getSelectedItem();
        boolean isBackupStorage = storage.getStorageDomainType() == StorageDomainType.ImportExport;
        boolean isDataStorage = storage.getStorageDomainType().isDataDomain();
        boolean isImageStorage = storage.getStorageDomainType() == StorageDomainType.Image || storage.getStorageDomainType() == StorageDomainType.ISO;
        boolean isDataCenterAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isGeneralAvailable = storage.getStorageType() != StorageType.GLANCE;
        generalModel.setIsAvailable(isGeneralAvailable);
        dcListModel.setIsAvailable(isDataCenterAvailable);
        vmBackupModel.setIsAvailable(isBackupStorage);
        templateBackupModel.setIsAvailable(isBackupStorage);
        vmListModel.setIsAvailable(isDataStorage);
        templateListModel.setIsAvailable(isDataStorage);
        diskListModel.setIsAvailable(isDataStorage);
        isoListModel.setIsAvailable(isImageStorage);
    }
}
#end_block

#method_before
private boolean isEditAvailable(StorageDomain storageDomain) {
    if (storageDomain == null) {
        return false;
    }
    boolean isEditAvailable;
    boolean isActive = storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Active || storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Mixed;
    boolean isInMaintenance = (storageDomain.getStatus() == StorageDomainStatus.Maintenance || storageDomain.getStatus() == StorageDomainStatus.MovingToMaintenance);
    boolean isUnattached = (storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached || storageDomain.getStatus() == StorageDomainStatus.Detaching);
    boolean isDataDomain = (storageDomain.getStorageDomainType() == StorageDomainType.Data) || (storageDomain.getStorageDomainType() == StorageDomainType.Master);
    boolean isBlockStorage = storageDomain.getStorageType().isBlockDomain();
    isEditAvailable = isActive || isBlockStorage || ((isInMaintenance || isUnattached) && isDataDomain);
    return isEditAvailable;
}
#method_after
private boolean isEditAvailable(StorageDomain storageDomain) {
    if (storageDomain == null) {
        return false;
    }
    boolean isEditAvailable;
    boolean isActive = storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Active || storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Mixed;
    boolean isInMaintenance = (storageDomain.getStatus() == StorageDomainStatus.Maintenance || storageDomain.getStatus() == StorageDomainStatus.PreparingForMaintenance);
    boolean isUnattached = (storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached || storageDomain.getStatus() == StorageDomainStatus.Detaching);
    boolean isDataDomain = storageDomain.getStorageDomainType().isDataDomain();
    boolean isBlockStorage = storageDomain.getStorageType().isBlockDomain();
    isEditAvailable = isActive || isBlockStorage || ((isInMaintenance || isUnattached) && isDataDomain);
    return isEditAvailable;
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewDomainCommand()) {
        newDomain();
    } else if (command == getImportDomainCommand()) {
        importDomain();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getDestroyCommand()) {
        destroy();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        onSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirm")) {
        cancelConfirm();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnImport")) {
        onImport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnDestroy")) {
        onDestroy();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveSanStorage")) {
        onSaveSanStorage();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewDomainCommand()) {
        newDomain();
    } else if (command == getImportDomainCommand()) {
        importDomain();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getDestroyCommand()) {
        destroy();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "CancelConfirm".equals(command.getName())) {
        cancelConfirm();
    } else if (// $NON-NLS-1$
    "OnImport".equals(command.getName())) {
        onImport();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnDestroy".equals(command.getName())) {
        onDestroy();
    } else if (// $NON-NLS-1$
    "OnSaveSanStorage".equals(command.getName())) {
        onSaveSanStorage();
    }
}
#end_block

#method_before
private void savePosixStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    path = (String) posixModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName((String) model.getName().getEntity());
    storageDomain.setDescription((String) model.getDescription().getEntity());
    storageDomain.setComment((String) model.getComment().getEntity());
    storageDomain.setStorageFormat((StorageFormatType) model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewPosixStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#method_after
private void savePosixStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    path = (String) posixModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    storageDomain.setStorageFormat((StorageFormatType) model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewPosixStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#end_block

#method_before
public void saveNewPosixStorage() {
    StorageModel model = (StorageModel) getWindow();
    PosixStorageModel posixModel = (PosixStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections connection = new StorageServerConnections();
    connection.setconnection(path);
    connection.setstorage_type(posixModel.getType());
    connection.setVfsType((String) posixModel.getVfsType().getEntity());
    connection.setMountOptions((String) posixModel.getMountOptions().getEntity());
    this.connection = connection;
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddPosixFsStorageDomain);
    parameters.add(new StorageServerConnectionParametersBase(this.connection, host.getId()));
    StorageDomainManagementParameter parameter = new StorageDomainManagementParameter(storageDomain);
    parameter.setVdsId(host.getId());
    parameters.add(parameter);
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
            storageListModel.connection.setid((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageId = (Guid) vdcReturnValueBase.getActionReturnValue();
            // Attach storage to data center as necessary.
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            StoragePool dataCenter = (StoragePool) storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
        }
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<IFrontendActionAsyncCallback>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2 })), failureCallback, this);
}
#method_after
public void saveNewPosixStorage() {
    StorageModel model = (StorageModel) getWindow();
    PosixStorageModel posixModel = (PosixStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections connection = new StorageServerConnections();
    connection.setconnection(path);
    connection.setstorage_type(posixModel.getType());
    connection.setVfsType((String) posixModel.getVfsType().getEntity());
    connection.setMountOptions((String) posixModel.getMountOptions().getEntity());
    this.connection = connection;
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddPosixFsStorageDomain);
    parameters.add(new StorageServerConnectionParametersBase(this.connection, host.getId()));
    StorageDomainManagementParameter parameter = new StorageDomainManagementParameter(storageDomain);
    parameter.setVdsId(host.getId());
    parameters.add(parameter);
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
            storageListModel.connection.setid((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageId = (Guid) vdcReturnValueBase.getActionReturnValue();
            // Attach storage to data center as necessary.
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            StoragePool dataCenter = storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
        }
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<IFrontendActionAsyncCallback>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2 })), failureCallback, this);
}
#end_block

#method_before
private void saveGlusterStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    GlusterStorageModel glusterModel = (GlusterStorageModel) storageModel;
    path = (String) glusterModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName((String) model.getName().getEntity());
    storageDomain.setStorageFormat((StorageFormatType) model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewGlusterStorage();
                }
            }
        }), null, path);
    } else {
        updateStorageDomain();
    }
}
#method_after
private void saveGlusterStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    GlusterStorageModel glusterModel = (GlusterStorageModel) storageModel;
    path = (String) glusterModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setStorageFormat((StorageFormatType) model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewGlusterStorage();
                }
            }
        }), null, path);
    } else {
        updateStorageDomain();
    }
}
#end_block

#method_before
public void saveNewGlusterStorage() {
    StorageModel model = (StorageModel) getWindow();
    GlusterStorageModel glusterModel = (GlusterStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections connection = new StorageServerConnections();
    connection.setconnection(path);
    connection.setstorage_type(glusterModel.getType());
    connection.setVfsType((String) glusterModel.getVfsType().getEntity());
    connection.setMountOptions((String) glusterModel.getMountOptions().getEntity());
    this.connection = connection;
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddGlusterFsStorageDomain);
    parameters.add(new StorageServerConnectionParametersBase(this.connection, host.getId()));
    StorageDomainManagementParameter parameter = new StorageDomainManagementParameter(storageDomain);
    parameter.setVdsId(host.getId());
    parameters.add(parameter);
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
            storageListModel.connection.setid((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageId = (Guid) vdcReturnValueBase.getActionReturnValue();
            // Attach storage to data center as necessary.
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            StoragePool dataCenter = (StoragePool) storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
        }
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<IFrontendActionAsyncCallback>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2 })), failureCallback, this);
}
#method_after
public void saveNewGlusterStorage() {
    StorageModel model = (StorageModel) getWindow();
    GlusterStorageModel glusterModel = (GlusterStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections connection = new StorageServerConnections();
    connection.setconnection(path);
    connection.setstorage_type(glusterModel.getType());
    connection.setVfsType((String) glusterModel.getVfsType().getEntity());
    connection.setMountOptions((String) glusterModel.getMountOptions().getEntity());
    this.connection = connection;
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddGlusterFsStorageDomain);
    parameters.add(new StorageServerConnectionParametersBase(this.connection, host.getId()));
    StorageDomainManagementParameter parameter = new StorageDomainManagementParameter(storageDomain);
    parameter.setVdsId(host.getId());
    parameters.add(parameter);
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
            storageListModel.connection.setid((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageId = (Guid) vdcReturnValueBase.getActionReturnValue();
            // Attach storage to data center as necessary.
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            StoragePool dataCenter = storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
        }
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<IFrontendActionAsyncCallback>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2 })), failureCallback, this);
}
#end_block

#method_before
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = (String) nfsModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName((String) model.getName().getEntity());
    storageDomain.setDescription((String) model.getDescription().getEntity());
    storageDomain.setComment((String) model.getComment().getEntity());
    storageDomain.setStorageFormat((StorageFormatType) model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewNfsStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#method_after
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = (String) nfsModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    storageDomain.setStorageFormat((StorageFormatType) model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewNfsStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#end_block

#method_before
public void saveNewNfsStorage() {
    StorageModel model = (StorageModel) getWindow();
    NfsStorageModel nfsModel = (NfsStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections tempVar = new StorageServerConnections();
    tempVar.setconnection(path);
    tempVar.setstorage_type(nfsModel.getType());
    if ((Boolean) nfsModel.getOverride().getEntity()) {
        tempVar.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
        tempVar.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
        tempVar.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
    }
    connection = tempVar;
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddNFSStorageDomain);
    actionTypes.add(VdcActionType.DisconnectStorageServerConnection);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    StorageDomainManagementParameter tempVar2 = new StorageDomainManagementParameter(storageDomain);
    tempVar2.setVdsId(host.getId());
    parameters.add(tempVar2);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
            storageListModel.connection.setid((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageId = (Guid) vdcReturnValueBase.getActionReturnValue();
        }
    };
    IFrontendActionAsyncCallback callback3 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            // Attach storage to data center as necessary.
            StoragePool dataCenter = (StoragePool) storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
        }
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<IFrontendActionAsyncCallback>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2, callback3 })), failureCallback, this);
}
#method_after
public void saveNewNfsStorage() {
    StorageModel model = (StorageModel) getWindow();
    NfsStorageModel nfsModel = (NfsStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections tempVar = new StorageServerConnections();
    tempVar.setconnection(path);
    tempVar.setstorage_type(nfsModel.getType());
    if ((Boolean) nfsModel.getOverride().getEntity()) {
        tempVar.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
        tempVar.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
        tempVar.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
    }
    connection = tempVar;
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddNFSStorageDomain);
    actionTypes.add(VdcActionType.DisconnectStorageServerConnection);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    StorageDomainManagementParameter tempVar2 = new StorageDomainManagementParameter(storageDomain);
    tempVar2.setVdsId(host.getId());
    parameters.add(tempVar2);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
            storageListModel.connection.setid((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageId = (Guid) vdcReturnValueBase.getActionReturnValue();
        }
    };
    IFrontendActionAsyncCallback callback3 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            // Attach storage to data center as necessary.
            StoragePool dataCenter = storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
        }
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<IFrontendActionAsyncCallback>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2, callback3 })), failureCallback, this);
}
#end_block

#method_before
public void saveNewSanStorage() {
    StorageModel model = (StorageModel) getWindow();
    SanStorageModel sanModel = (SanStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    boolean force = sanModel.isForce();
    ArrayList<String> lunIds = new ArrayList<String>();
    for (LunModel lun : sanModel.getAddedLuns()) {
        lunIds.add(lun.getLunId());
    }
    AddSANStorageDomainParameters params = new AddSANStorageDomainParameters(storageDomain);
    params.setVdsId(host.getId());
    params.setLunIds(lunIds);
    params.setForce(force);
    Frontend.getInstance().runAction(VdcActionType.AddSANStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            storageListModel.storageModel = storageModel.getSelectedItem();
            if (!result.getReturnValue().getSucceeded()) {
                storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
                return;
            }
            StoragePool dataCenter = (StoragePool) storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                VdcReturnValueBase returnValue = result.getReturnValue();
                Guid storageId = (Guid) returnValue.getActionReturnValue();
                storageListModel.attachStorageToDataCenter(storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    }, this);
}
#method_after
public void saveNewSanStorage() {
    StorageModel model = (StorageModel) getWindow();
    SanStorageModel sanModel = (SanStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    boolean force = sanModel.isForce();
    ArrayList<String> lunIds = new ArrayList<String>();
    for (LunModel lun : sanModel.getAddedLuns()) {
        lunIds.add(lun.getLunId());
    }
    AddSANStorageDomainParameters params = new AddSANStorageDomainParameters(storageDomain);
    params.setVdsId(host.getId());
    params.setLunIds(lunIds);
    params.setForce(force);
    Frontend.getInstance().runAction(VdcActionType.AddSANStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            storageListModel.storageModel = storageModel.getSelectedItem();
            if (!result.getReturnValue().getSucceeded()) {
                storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
                return;
            }
            StoragePool dataCenter = storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                VdcReturnValueBase returnValue = result.getReturnValue();
                Guid storageId = (Guid) returnValue.getActionReturnValue();
                storageListModel.attachStorageToDataCenter(storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    }, this);
}
#end_block

#method_before
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    VDS host = (VDS) model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = (String) localModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName((String) model.getName().getEntity());
    storageDomain.setDescription((String) model.getDescription().getEntity());
    storageDomain.setComment((String) model.getComment().getEntity());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewLocalStorage();
                }
            }
        }), host.getStoragePoolId(), path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#method_after
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    VDS host = (VDS) model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = (String) localModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewLocalStorage();
                }
            }
        }), host.getStoragePoolId(), path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#end_block

#method_before
private void saveSanStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    SanStorageModel sanModel = (SanStorageModel) model.getSelectedItem();
    StorageDomain storage = (StorageDomain) getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(storage.getStorageStaticData());
    storageDomain.setStorageType(isNew ? sanModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? sanModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageFormat(isNew ? (StorageFormatType) sanModel.getContainer().getFormat().getSelectedItem() : storageDomain.getStorageFormat());
    storageDomain.setStorageName((String) model.getName().getEntity());
    storageDomain.setDescription((String) model.getDescription().getEntity());
    storageDomain.setComment((String) model.getComment().getEntity());
    if (isNew) {
        saveNewSanStorage();
    } else {
        Frontend.getInstance().runAction(VdcActionType.UpdateStorageDomain, new StorageDomainManagementParameter(storageDomain), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                StorageListModel storageListModel = (StorageListModel) result.getState();
                StorageModel storageModel = (StorageModel) getWindow();
                SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getSelectedItem();
                boolean force = sanStorageModel.isForce();
                StorageDomain storageDomain1 = (StorageDomain) storageListModel.getSelectedItem();
                ArrayList<String> lunIds = new ArrayList<String>();
                for (LunModel lun : sanStorageModel.getAddedLuns()) {
                    lunIds.add(lun.getLunId());
                }
                if (lunIds.size() > 0) {
                    Frontend.getInstance().runAction(VdcActionType.ExtendSANStorageDomain, new ExtendSANStorageDomainParameters(storageDomain1.getId(), lunIds, force), null, this);
                }
                storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
            }
        }, this);
    }
}
#method_after
private void saveSanStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    SanStorageModel sanModel = (SanStorageModel) model.getSelectedItem();
    StorageDomain storage = (StorageDomain) getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(storage.getStorageStaticData());
    storageDomain.setStorageType(isNew ? sanModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? sanModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageFormat(isNew ? (StorageFormatType) sanModel.getContainer().getFormat().getSelectedItem() : storageDomain.getStorageFormat());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    if (isNew) {
        saveNewSanStorage();
    } else {
        Frontend.getInstance().runAction(VdcActionType.UpdateStorageDomain, new StorageDomainManagementParameter(storageDomain), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                StorageListModel storageListModel = (StorageListModel) result.getState();
                StorageModel storageModel = (StorageModel) getWindow();
                SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getSelectedItem();
                boolean force = sanStorageModel.isForce();
                StorageDomain storageDomain1 = (StorageDomain) storageListModel.getSelectedItem();
                ArrayList<String> lunIds = new ArrayList<String>();
                for (LunModel lun : sanStorageModel.getAddedLuns()) {
                    lunIds.add(lun.getLunId());
                }
                if (lunIds.size() > 0) {
                    Frontend.getInstance().runAction(VdcActionType.ExtendSANStorageDomain, new ExtendSANStorageDomainParameters(storageDomain1.getId(), lunIds, force), null, this);
                }
                storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
            }
        }, this);
    }
}
#end_block

#method_before
public void importFileStorageAddDomain(ArrayList<StorageDomain> domains) {
    StorageDomain sdToAdd = Linq.firstOrDefault(domains);
    StorageDomainStatic sdsToAdd = sdToAdd.getStorageStaticData();
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sdsToAdd);
    params.setVdsId(hostId);
    Frontend.getInstance().runAction(VdcActionType.AddExistingFileStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            Object[] array = (Object[]) result.getState();
            StorageListModel storageListModel = (StorageListModel) array[0];
            StorageDomain sdToAdd1 = (StorageDomain) array[1];
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                StorageModel model = (StorageModel) storageListModel.getWindow();
                StoragePool dataCenter = (StoragePool) model.getDataCenter().getSelectedItem();
                if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                    storageListModel.attachStorageToDataCenter(sdToAdd1.getId(), dataCenter.getId());
                    onFinish(storageListModel.context, true, storageListModel.storageModel, null);
                } else {
                    postImportFileStorage(storageListModel.context, true, storageListModel.storageModel, null);
                }
            } else {
                // $NON-NLS-1$
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, "");
            }
        }
    }, new Object[] { this, sdToAdd });
}
#method_after
public void importFileStorageAddDomain(ArrayList<StorageDomain> domains) {
    StorageDomain sdToAdd = Linq.firstOrDefault(domains);
    StorageDomainStatic sdsToAdd = sdToAdd.getStorageStaticData();
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sdsToAdd);
    params.setVdsId(hostId);
    Frontend.getInstance().runAction(VdcActionType.AddExistingFileStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            Object[] array = (Object[]) result.getState();
            StorageListModel storageListModel = (StorageListModel) array[0];
            StorageDomain sdToAdd1 = (StorageDomain) array[1];
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                StorageModel model = (StorageModel) storageListModel.getWindow();
                StoragePool dataCenter = model.getDataCenter().getSelectedItem();
                if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                    storageListModel.attachStorageToDataCenter(sdToAdd1.getId(), dataCenter.getId());
                    onFinish(storageListModel.context, true, storageListModel.storageModel, null);
                } else {
                    postImportFileStorage(storageListModel.context, true, storageListModel.storageModel, null);
                }
            } else {
                // $NON-NLS-1$
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, "");
            }
        }
    }, new Object[] { this, sdToAdd });
}
#end_block

#method_before
@Override
public void run(TaskContext context) {
    ArrayList<Object> data = (ArrayList<Object>) context.getState();
    String key = (String) data.get(0);
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "SaveNfs")) {
        saveNfsStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "SaveLocal")) {
        saveLocalStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "SavePosix")) {
        savePosixStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "SaveGluster")) {
        saveGlusterStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "SaveSan")) {
        saveSanStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "ImportFile")) {
        importFileStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "Finish")) {
        getWindow().stopProgress();
        if ((Boolean) data.get(1)) {
            cancel();
        } else {
            ((Model) data.get(2)).setMessage((String) data.get(3));
        }
    }
}
#method_after
@Override
public void run(TaskContext context) {
    ArrayList<Object> data = (ArrayList<Object>) context.getState();
    String key = (String) data.get(0);
    if (// $NON-NLS-1$
    "SaveNfs".equals(key)) {
        saveNfsStorage(context);
    } else if (// $NON-NLS-1$
    "SaveLocal".equals(key)) {
        saveLocalStorage(context);
    } else if (// $NON-NLS-1$
    "SavePosix".equals(key)) {
        savePosixStorage(context);
    } else if (// $NON-NLS-1$
    "SaveGluster".equals(key)) {
        saveGlusterStorage(context);
    } else if (// $NON-NLS-1$
    "SaveSan".equals(key)) {
        saveSanStorage(context);
    } else if (// $NON-NLS-1$
    "ImportFile".equals(key)) {
        importFileStorage(context);
    } else if (// $NON-NLS-1$
    "Finish".equals(key)) {
        getWindow().stopProgress();
        if ((Boolean) data.get(1)) {
            cancel();
        } else {
            ((Model) data.get(2)).setMessage((String) data.get(3));
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    log.info("Start detach storage domain");
    changeStorageDomainStatusInTransaction(getStorageDomain().getStoragePoolIsoMapData(), StorageDomainStatus.Detaching);
    log.info(" Detach storage domain: before connect");
    connectAllHostsToPool();
    log.info(" Detach storage domain: after connect");
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, new DetachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, getStoragePool().getmaster_domain_version()));
    log.info(" Detach storage domain: after detach in vds");
    disconnectAllHostsInPool();
    if (returnValue.getSucceeded() && getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
        // reset iso for this pool in vdsBroker cache
        runVdsCommand(VDSCommandType.ResetISOPath, new IrsBaseVDSCommandParameters(getParameters().getStoragePoolId()));
    }
    log.info("End detach storage domain");
    setSucceeded(returnValue.getSucceeded());
}
#method_after
@Override
protected void executeCommand() {
    log.info("Start detach storage domain");
    changeStorageDomainStatusInTransaction(getStorageDomain().getStoragePoolIsoMapData(), StorageDomainStatus.Detaching);
    log.info(" Detach storage domain: before connect");
    connectAllHostsToPool();
    log.info(" Detach storage domain: after connect");
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, new DetachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, getStoragePool().getmaster_domain_version()));
    log.info(" Detach storage domain: after detach in vds");
    disconnectAllHostsInPool();
    log.info(" Detach storage domain: after disconnect storage");
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            StoragePoolIsoMap mapToRemove = getStorageDomain().getStoragePoolIsoMapData();
            getCompensationContext().snapshotEntity(mapToRemove);
            DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(mapToRemove.getstorage_id(), mapToRemove.getstorage_pool_id()));
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (returnValue.getSucceeded() && getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
        // reset iso for this pool in vdsBroker cache
        runVdsCommand(VDSCommandType.ResetISOPath, new IrsBaseVDSCommandParameters(getParameters().getStoragePoolId()));
    }
    log.info("End detach storage domain");
    setSucceeded(returnValue.getSucceeded());
}
#end_block

#method_before
protected void initCommand() {
    when(diskDao.get(diskId)).thenReturn(createDiskImage());
    AttachDettachVmDiskParameters parameters = createParameters();
    command = spy(new AttachDiskToVmCommand<AttachDettachVmDiskParameters>(parameters) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }
    });
}
#method_after
private void initCommand() {
    when(diskDao.get(diskId)).thenReturn(createDiskImage());
    AttachDettachVmDiskParameters parameters = createParameters();
    command = spy(new AttachDiskToVmCommand<AttachDettachVmDiskParameters>(parameters) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }
    });
}
#end_block

#method_before
@Test
public void testCanDoSucceed() {
    initCommand();
    initialSetup();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void testCanDoSucceed() {
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
@Test
public void testCanDoSucceedReadOnlyWithInterface() {
    initCommand();
    initialSetup();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
    verify(diskValidator).isReadOnlyPropertyCompatibleWithInterface();
}
#method_after
@Test
public void testCanDoSucceedReadOnlyWithInterface() {
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
    verify(diskValidator).isReadOnlyPropertyCompatibleWithInterface();
}
#end_block

#method_before
@Test
public void testCanDoFailReadOnlyOnInterface() {
    initCommand();
    initialSetup();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR);
    verify(diskValidator).isReadOnlyPropertyCompatibleWithInterface();
}
#method_after
@Test
public void testCanDoFailReadOnlyOnInterface() {
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR);
    verify(diskValidator).isReadOnlyPropertyCompatibleWithInterface();
}
#end_block

#method_before
private static AttachDettachVmDiskParameters createParameters() {
    AttachDettachVmDiskParameters parameters = new AttachDettachVmDiskParameters(vmId, diskId);
    parameters.setReadOnly(true);
    return parameters;
}
#method_after
private AttachDettachVmDiskParameters createParameters() {
    AttachDettachVmDiskParameters parameters = new AttachDettachVmDiskParameters(vmId, diskId);
    parameters.setReadOnly(true);
    return parameters;
}
#end_block

#method_before
private static DiskImage createDiskImage() {
    DiskImage disk = new DiskImage();
    disk.setId(diskId);
    disk.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageId)));
    return disk;
}
#method_after
private DiskImage createDiskImage() {
    DiskImage disk = new DiskImage();
    disk.setId(diskId);
    Collections.singletonList(storageId);
    disk.setStorageIds(new ArrayList<Guid>(Collections.singletonList(storageId)));
    return disk;
}
#end_block

#method_before
@Before
public void setUp() {
    initializeOsRepository(1, DiskInterface.VirtIO);
    disk = createDisk();
    disk.setDiskAlias("disk1");
    disk.setDiskInterface(DiskInterface.VirtIO);
    validator = spy(new DiskValidator(disk));
    doReturn(vmDAO).when(validator).getVmDAO();
}
#method_after
@Before
public void setUp() {
    initializeOsRepository(1, DiskInterface.VirtIO);
    disk = createDiskImage();
    disk.setDiskAlias("disk1");
    disk.setDiskInterface(DiskInterface.VirtIO);
    validator = spy(new DiskValidator(disk));
    doReturn(vmDAO).when(validator).getVmDAO();
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    mNewCreatedDiskImage = cloneDiskImage(getDestinationImageId());
    mNewCreatedDiskImage.setId(Guid.newGuid());
    Guid storagePoolID = mNewCreatedDiskImage.getStoragePoolId() != null ? mNewCreatedDiskImage.getStoragePoolId() : Guid.Empty;
    VDSReturnValue vdsReturnValue = null;
    Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.AddVmFromTemplate);
    try {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(storagePoolID, getDiskImage().getStorageIds().get(0), getVmTemplateId(), getDiskImage().getId(), getImage().getImageId(), mNewCreatedDiskImage.getId(), getDestinationImageId(), "", getDestinationStorageDomainId(), CopyVolumeType.LeafVol, mNewCreatedDiskImage.getVolumeFormat(), mNewCreatedDiskImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false));
    } catch (VdcBLLException e) {
        log.errorFormat("Failed creating snapshot from image id -'{0}'", getImage().getImageId());
        throw e;
    }
    if (vdsReturnValue.getSucceeded()) {
        getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmFromTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getDestinationStorageDomainId()));
    }
    return vdsReturnValue;
}
#method_after
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    mNewCreatedDiskImage = cloneDiskImage(getDestinationImageId());
    mNewCreatedDiskImage.setId(Guid.newGuid());
    Guid storagePoolID = mNewCreatedDiskImage.getStoragePoolId() != null ? mNewCreatedDiskImage.getStoragePoolId() : Guid.Empty;
    VDSReturnValue vdsReturnValue = null;
    Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.AddVmFromTemplate);
    try {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(storagePoolID, getParameters().getStorageDomainId(), getVmTemplateId(), getDiskImage().getId(), getImage().getImageId(), mNewCreatedDiskImage.getId(), getDestinationImageId(), "", getDestinationStorageDomainId(), CopyVolumeType.LeafVol, mNewCreatedDiskImage.getVolumeFormat(), mNewCreatedDiskImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false));
    } catch (VdcBLLException e) {
        log.errorFormat("Failed creating snapshot from image id -'{0}'", getImage().getImageId());
        throw e;
    }
    if (vdsReturnValue.getSucceeded()) {
        getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmFromTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getDestinationStorageDomainId()));
    }
    return vdsReturnValue;
}
#end_block

#method_before
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // Parses the custom properties field that was filled by frontend to
    // predefined and user defined fields
    VmPropertiesUtils.getInstance().separeteCustomPropertiesToUserAndPredefined(ClusterUtils.getCompatibilityVersion(getParameters().getVm()), vmStatic);
    updateOriginalTemplate(vmStatic);
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // Parses the custom properties field that was filled by frontend to
    // predefined and user defined fields
    VmPropertiesUtils.getInstance().separeteCustomPropertiesToUserAndPredefined(getVdsGroup().getcompatibility_version(), vmStatic);
    updateOriginalTemplate(vmStatic);
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
private Class<?> lookupService(Class<?> serviceInterface, String serviceClassName, String moduleName) {
    // Iterate over the service classes, and find the one that should
    // be instantiated and initialized.
    Module module = loadModule(moduleName);
    Class<?> serviceClass = null;
    for (Object service : ServiceLoader.load(serviceInterface, module.getClassLoader())) {
        if (service.getClass().getName().equals(serviceClassName)) {
            serviceClass = service.getClass();
            break;
        }
    }
    if (serviceClass == null) {
        throw new ConfigurationException(String.format("The module '%1$s' does not contain the service '%2$s'.", module.getIdentifier().getName(), serviceClassName));
    }
    return serviceClass;
}
#method_after
private Class<?> lookupService(Class<?> serviceInterface, String serviceClassName, String moduleName) {
    // Iterate over the service classes, and find the one that should
    // be instantiated and initialized.
    Module module = loadModule(moduleName);
    Class<?> serviceClass = null;
    for (Object service : module.loadService(serviceInterface)) {
        if (service.getClass().getName().equals(serviceClassName)) {
            serviceClass = service.getClass();
            break;
        }
    }
    if (serviceClass == null) {
        throw new ConfigurationException(String.format("The module '%1$s' does not contain the service '%2$s'.", module.getIdentifier().getName(), serviceClassName));
    }
    return serviceClass;
}
#end_block

#method_before
public void load(Properties configuration) {
    loadImpl(configuration, null);
}
#method_after
public String load(Properties configuration) {
    return loadImpl(configuration, null);
}
#end_block

#method_before
public void load(File file) {
    try (FileInputStream inputStream = new FileInputStream(file)) {
        Properties props = new Properties();
        props.load(inputStream);
        loadImpl(props, file);
    } catch (IOException exception) {
        throw new ConfigurationException(String.format("Can't load object configuration file '%1$s'", file.getAbsolutePath()));
    }
}
#method_after
public String load(File file) {
    try (FileInputStream inputStream = new FileInputStream(file)) {
        Properties props = new Properties();
        props.load(inputStream);
        return loadImpl(props, file);
    } catch (IOException exception) {
        throw new ConfigurationException(String.format("Can't load object configuration file '%1$s'", file.getAbsolutePath()));
    }
}
#end_block

#method_before
private void dumpConfig(ExtensionProxy extension) {
    Logger logger = extension.getContext().<Logger>get(TRACE_LOG_CONTEXT_KEY);
    if (logger.isDebugEnabled()) {
        List sensitive = extension.getContext().<List>get(Base.ContextKeys.CONFIGURATION_SENSITIVE_KEYS);
        logger.debug("Config BEGIN");
        for (Map.Entry<Object, Object> entry : extension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).entrySet()) {
            logger.debug(String.format("%s: %s", entry.getKey(), sensitive.contains(entry.getKey()) ? "***" : entry.getValue()));
        }
        logger.debug("Config END");
    }
}
#method_after
private void dumpConfig(ExtensionProxy extension) {
    Log logger = extension.getContext().<Log>get(TRACE_LOG_CONTEXT_KEY);
    if (logger.isDebugEnabled()) {
        List sensitive = extension.getContext().<List>get(Base.ContextKeys.CONFIGURATION_SENSITIVE_KEYS);
        logger.debug("Config BEGIN");
        for (Map.Entry<Object, Object> entry : extension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).entrySet()) {
            logger.debug(String.format("%s: %s", entry.getKey(), sensitive.contains(entry.getKey()) ? "***" : entry.getValue()));
        }
        logger.debug("Config END");
    }
}
#end_block

#method_before
private synchronized void loadImpl(Properties props, File confFile) {
    ExtensionEntry entry = new ExtensionEntry(props, confFile);
    ExtensionEntry alreadyLoadedEntry = loadedEntries.get(entry.name);
    if (alreadyLoadedEntry != null) {
        throw new ConfigurationException(String.format("Could not load the configuration '%1$s' from file %2$s. A configuration with the same name was already loaded from file %3$s", entry.name, entry.getFileName(), alreadyLoadedEntry.getFileName()));
    }
    loadedEntries.put(entry.name, entry);
    entry.enabled = Boolean.parseBoolean(configProperties.getProperty(ENGINE_EXTENSION_ENABLED + entry.name, Boolean.toString(entry.enabled)));
    // Activate the extension
    if (entry.enabled && entry.extension == null) {
        try {
            entry.extension = new ExtensionProxy(loadExtension(props), (new ExtMap().mput(Base.ContextKeys.GLOBAL_CONTEXT, globalContext).mput(TRACE_LOG_CONTEXT_KEY, traceLog).mput(Base.ContextKeys.INTERFACE_VERSION_MIN, 0).mput(Base.ContextKeys.INTERFACE_VERSION_MAX, Base.INTERFACE_VERSION_CURRENT).mput(Base.ContextKeys.LOCALE, Locale.getDefault().toString()).mput(Base.ContextKeys.CONFIGURATION, props).mput(Base.ContextKeys.CONFIGURATION_SENSITIVE_KEYS, splitString(props.getProperty(Base.ConfigKeys.SENSITIVE_KEYS, ""))).mput(Base.ContextKeys.INSTANCE_NAME, entry.name).mput(Base.ContextKeys.PROVIDES, splitString(props.getProperty(Base.ConfigKeys.PROVIDES, "")))));
            ExtMap output = entry.extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Base.InvokeCommands.INITIALIZE));
            entry.extension.getContext().put(TRACE_LOG_CONTEXT_KEY, LoggerFactory.getLogger(String.format("%1$s.%2$s.%3$s", traceLog.getName(), entry.extension.getContext().get(Base.ContextKeys.EXTENSION_NAME), entry.extension.getContext().get(Base.ContextKeys.INSTANCE_NAME))));
            globalContext.<List<ExtMap>>get(Base.GlobalContextKeys.EXTENSIONS).add(new ExtMap().mput(Base.ExtensionRecord.INSTANCE_NAME, entry.extension.getContext().get(Base.ContextKeys.INSTANCE_NAME)).mput(Base.ExtensionRecord.PROVIDES, entry.extension.getContext().get(Base.ContextKeys.PROVIDES)).mput(Base.ExtensionRecord.EXTENSION, entry.extension.getExtension()).mput(Base.ExtensionRecord.CONTEXT, entry.extension.getContext()));
            entry.activated = true;
            dumpConfig(entry.extension);
        } catch (Exception ex) {
            log.error(String.format("Error in activating extension %1$s. Exception message is %2$s", entry.name, ex.getMessage()));
            if (log.isDebugEnabled()) {
                log.error(ex.toString(), ex);
            }
        }
    }
    setChanged();
    notifyObservers();
}
#method_after
private synchronized String loadImpl(Properties props, File confFile) {
    ExtensionEntry entry = new ExtensionEntry(props, confFile);
    ExtensionEntry alreadyLoadedEntry = loadedEntries.get(entry.name);
    if (alreadyLoadedEntry != null) {
        throw new ConfigurationException(String.format("Could not load the configuration '%1$s' from file %2$s. A configuration with the same name was already loaded from file %3$s", entry.name, entry.getFileName(), alreadyLoadedEntry.getFileName()));
    }
    try {
        entry.extension = new ExtensionProxy(loadExtension(props), (new ExtMap().mput(Base.ContextKeys.GLOBAL_CONTEXT, globalContext).mput(TRACE_LOG_CONTEXT_KEY, traceLog).mput(Base.ContextKeys.INTERFACE_VERSION_MIN, 0).mput(Base.ContextKeys.INTERFACE_VERSION_MAX, Base.INTERFACE_VERSION_CURRENT).mput(Base.ContextKeys.LOCALE, Locale.getDefault().toString()).mput(Base.ContextKeys.CONFIGURATION, props).mput(Base.ContextKeys.CONFIGURATION_SENSITIVE_KEYS, splitString(props.getProperty(Base.ConfigKeys.SENSITIVE_KEYS, ""))).mput(Base.ContextKeys.INSTANCE_NAME, entry.name).mput(Base.ContextKeys.PROVIDES, splitString(props.getProperty(Base.ConfigKeys.PROVIDES, "")))));
        ExtMap output = entry.extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Base.InvokeCommands.LOAD));
        entry.extension.getContext().put(TRACE_LOG_CONTEXT_KEY, LogFactory.getLog(String.format("%1$s.%2$s.%3$s", getTraceLog(), entry.extension.getContext().get(Base.ContextKeys.EXTENSION_NAME), entry.extension.getContext().get(Base.ContextKeys.INSTANCE_NAME))));
        if (output.<Integer>get(Base.InvokeKeys.RESULT) != Base.InvokeResult.SUCCESS) {
            throw new RuntimeException(String.format("Invoke of LOAD returned with error code: %1$s", output.<Integer>get(Base.InvokeKeys.RESULT)));
        }
    } catch (Exception e) {
        throw new RuntimeException(String.format("Error loading extension %1$s", entry.name));
    }
    loadedEntries.put(entry.name, entry);
    dumpConfig(entry.extension);
    setChanged();
    notifyObservers();
    return entry.name;
}
#end_block

#method_before
public ExtensionProxy getExtensionByName(String name) throws ConfigurationException {
    ExtensionEntry entry = loadedEntries.get(name);
    ExtensionProxy result = null;
    if (entry != null && entry.activated) {
        result = entry.extension;
    }
    return result;
}
#method_after
public ExtensionProxy getExtensionByName(String name) throws ConfigurationException {
    ExtensionEntry entry = initializedEntries.get(name);
    if (entry == null) {
        throw new ConfigurationException(String.format("Extension %1$s could not be found", name));
    }
    return entry.extension;
}
#end_block

#method_before
private Extension loadExtension(Properties props) throws Exception {
    Extension extension;
    BindingsLoader loader = bindingsLoaders.get(props.getProperty(Base.ConfigKeys.BINDINGS_METHOD));
    if (loader == null) {
        throw new ConfigurationException(String.format("Invalid binding method '%1$s'.", props.getProperty(Base.ConfigKeys.BINDINGS_METHOD)));
    }
    return loader.load(props);
}
#method_after
private Extension loadExtension(Properties props) throws Exception {
    BindingsLoader loader = bindingsLoaders.get(props.getProperty(Base.ConfigKeys.BINDINGS_METHOD));
    if (loader == null) {
        throw new ConfigurationException(String.format("Invalid binding method '%1$s'.", props.getProperty(Base.ConfigKeys.BINDINGS_METHOD)));
    }
    return loader.load(props);
}
#end_block

#method_before
public void dump() {
    log.info("Start of enabled extensions list");
    for (ExtensionEntry entry : loadedEntries.values()) {
        if (entry.extension != null) {
            ExtMap context = entry.extension.getContext();
            log.info(String.format("Instance name: '%1$s', Extension name: '%2$s', Version: '%3$s', Build interface Version: '%4$s', License: '%5$s', Home: '%6$s', Author '%7$s',  File: '%8$s', Activated: '%9$s", emptyIfNull(context.get(Base.ContextKeys.INSTANCE_NAME)), emptyIfNull(context.get(Base.ContextKeys.EXTENSION_NAME)), emptyIfNull(context.get(Base.ContextKeys.VERSION)), emptyIfNull(context.get(Base.ContextKeys.BUILD_INTERFACE_VERSION)), emptyIfNull(context.get(Base.ContextKeys.LICENSE)), emptyIfNull(context.get(Base.ContextKeys.HOME_URL)), emptyIfNull(context.get(Base.ContextKeys.AUTHOR)), entry.getFileName(), entry.activated));
        }
    }
    log.info("End of enabled extensions list");
}
#method_after
public void dump() {
    log.info("Start of enabled extensions list");
    for (ExtensionEntry entry : loadedEntries.values()) {
        if (entry.extension != null) {
            ExtMap context = entry.extension.getContext();
            log.info(String.format("Instance name: '%1$s', Extension name: '%2$s', Version: '%3$s', Notes: '%4$s', License: '%5$s', Home: '%6$s', Author '%7$s', Build interface Version: '%8$s',  File: '%9$s', Initialized: '%10$s'", emptyIfNull(context.get(Base.ContextKeys.INSTANCE_NAME)), emptyIfNull(context.get(Base.ContextKeys.EXTENSION_NAME)), emptyIfNull(context.get(Base.ContextKeys.VERSION)), emptyIfNull(context.get(Base.ContextKeys.EXTENSION_NOTES)), emptyIfNull(context.get(Base.ContextKeys.LICENSE)), emptyIfNull(context.get(Base.ContextKeys.HOME_URL)), emptyIfNull(context.get(Base.ContextKeys.AUTHOR)), emptyIfNull(context.get(Base.ContextKeys.BUILD_INTERFACE_VERSION)), entry.getFileName(), entry.initialized));
        }
    }
    log.info("End of enabled extensions list");
}
#end_block

#method_before
private void createProfiles() throws ConfigurationException {
    for (ExtensionProxy authnExtension : EngineExtensionsManager.getInstance().getProvidedExtensions(AUTHN_SERVICE)) {
        registerProfile(new AuthenticationProfile(authnExtension, EngineExtensionsManager.getInstance().getExtensionByName(authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(AUTHN_AUTHZ_PLUGIN)), EngineExtensionsManager.getInstance().getExtensionByName(authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(AUTHN_MAPPING_PLUGIN))));
    }
}
#method_after
private void createProfiles() throws ConfigurationException {
    for (ExtensionProxy authnExtension : EngineExtensionsManager.getInstance().getExtensionsByService(AUTHN_SERVICE)) {
        String mapperName = authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(AUTHN_MAPPING_PLUGIN);
        String authzName = authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(AUTHN_AUTHZ_PLUGIN);
        if (authzName == null) {
            throw new ConfigurationException(String.format("Authz plugin for %1$s does not exist", authnExtension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME)));
        }
        registerProfile(new AuthenticationProfile(authnExtension, EngineExtensionsManager.getInstance().getExtensionByName(authzName), mapperName != null ? EngineExtensionsManager.getInstance().getExtensionByName(mapperName) : null));
    }
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    // Create authentication profiles for all the domains that exist in the database:
    // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
    createInternalAAAConfigurations();
    createKerberosLdapAAAConfigurations();
    EngineExtensionsManager.getInstance().dump();
    AuthenticationProfileRepository.getInstance();
    DbUserCacheManager.getInstance().init();
    AsyncTaskManager.getInstance().initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
    // Initialize Power Management Health Check
    PmHealthCheckManager.getInstance().initialize();
}
#method_after
@Override
@PostConstruct
public void create() {
    // Create authentication profiles for all the domains that exist in the database:
    // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    DbUserCacheManager.getInstance().init();
    AsyncTaskManager.getInstance().initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
    // Initialize Power Management Health Check
    PmHealthCheckManager.getInstance().initialize();
}
#end_block

#method_before
private void handleRadioButtonClick(ClickEvent event) {
    getDetailModel().setViewFilterType((viewRadioGroup.getSelectedValue()));
    boolean attached = viewRadioGroup.getSelectedValue() == NetworkHostFilter.attached;
    // $NON-NLS-1$
    getTable().ensureColumnPresent(hostStatus, constants.empty(), true, "30px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(nameColumn, constants.nameHost(), true, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(clusterColumn, constants.clusterHost(), true, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(dcColumn, constants.dcHost(), true, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(nicStatusColumn, constants.statusNetworkHost(), attached, "140px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(nicColumn, constants.nicNetworkHost(), attached, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(labelsColumn, constants.labelsNetworkHost(), true, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(speedColumn, constants.speedNetworkHost(), attached, "200px");
    getTable().ensureColumnPresent(nicRxColumn, templates.sub(constants.rxNetworkHost(), constants.mbps()).asString(), attached, // $NON-NLS-1$
    "200px");
    getTable().ensureColumnPresent(nicTxColumn, templates.sub(constants.txNetworkHost(), constants.mbps()).asString(), attached, // $NON-NLS-1$
    "200px");
}
#method_after
private void handleRadioButtonClick(ClickEvent event) {
    getDetailModel().setViewFilterType((viewRadioGroup.getSelectedValue()));
    boolean attached = viewRadioGroup.getSelectedValue() == NetworkHostFilter.attached;
    // $NON-NLS-1$
    getTable().ensureColumnPresent(hostStatus, constants.empty(), true, "30px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(nameColumn, constants.nameHost(), true, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(clusterColumn, constants.clusterHost(), true, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(dcColumn, constants.dcHost(), true, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(nicStatusColumn, constants.statusNetworkHost(), attached, "140px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(nicColumn, constants.nicNetworkHost(), attached, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(speedColumn, constants.speedNetworkHost(), attached, "200px");
    getTable().ensureColumnPresent(nicRxColumn, templates.sub(constants.rxNetworkHost(), constants.mbps()).asString(), attached, // $NON-NLS-1$
    "200px");
    getTable().ensureColumnPresent(nicTxColumn, templates.sub(constants.txNetworkHost(), constants.mbps()).asString(), attached, // $NON-NLS-1$
    "200px");
}
#end_block

#method_before
protected void updateReadOnlyChangeability() {
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    if (diskInterface == DiskInterface.IDE) {
        getIsReadOnly().setChangeProhibitionReason(CONSTANTS.cannotEnableIdeInterfaceForReadOnlyDisk());
        getIsReadOnly().setIsChangable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    boolean isVirtIoScsiLun = Boolean.FALSE.equals(getIsInternal().getEntity()) && diskInterface == DiskInterface.VirtIO_SCSI;
    if (isVirtIoScsiLun) {
        getIsReadOnly().setChangeProhibitionReason(CONSTANTS.cannotEnableVirtIoScsiInterfaceForLunReadOnlyDisk());
        getIsReadOnly().setIsChangable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    getIsReadOnly().setIsChangable(isEditEnabled());
}
#method_after
protected void updateReadOnlyChangeability() {
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    if (diskInterface == DiskInterface.IDE) {
        getIsReadOnly().setChangeProhibitionReason(CONSTANTS.cannotEnableIdeInterfaceForReadOnlyDisk());
        getIsReadOnly().setIsChangable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    boolean isDirectLUN = Boolean.FALSE.equals(getIsInternal().getEntity());
    if (diskInterface == DiskInterface.VirtIO_SCSI && isDirectLUN) {
        getIsReadOnly().setChangeProhibitionReason(CONSTANTS.cannotEnableVirtIoScsiInterfaceForLunReadOnlyDisk());
        getIsReadOnly().setIsChangable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    getIsReadOnly().setIsChangable(isEditEnabled());
}
#end_block

#method_before
private void updateProperties() {
    VDS vds = getEntity();
    setHardwareManufacturer(vds.getHardwareManufacturer());
    setHardwareVersion(vds.getHardwareVersion());
    setHardwareProductName(vds.getHardwareProductName());
    setHardwareUUID(vds.getHardwareUUID());
    setHardwareSerialNumber(vds.getHardwareSerialNumber());
    setHardwareFamily(vds.getHardwareFamily());
    setCpuType(vds.getCpuName() != null ? vds.getCpuName().getCpuName() : null);
    setCpuModel(vds.getCpuModel());
    setNumberOfSockets(vds.getCpuSockets());
    setCoresPerSocket((vds.getCpuCores() != null && vds.getCpuSockets() != null) ? vds.getCpuCores() / vds.getCpuSockets() : null);
    if (vds.getVdsGroupCompatibilityVersion() != null && Version.v3_2.compareTo(vds.getVdsGroupCompatibilityVersion()) > 0) {
        // Members of pre-3.2 clusters don't support SMT; here we act like a 3.1 engine
        setThreadsPerCore(constants.unsupported());
    } else if (vds.getCpuThreads() == null || vds.getCpuCores() == null) {
        setThreadsPerCore(constants.unknown());
    } else {
        Integer threads = vds.getCpuThreads() / vds.getCpuCores();
        setThreadsPerCore(messages.commonMessageWithBrackets(threads.toString(), threads > 1 ? constants.smtEnabled() : constants.smtDisabled()));
    }
    /* Go through the list of HBA devices and transfer the necessary info
           to the GWT host hardware model */
    List<EnumMap<HbaDeviceKeys, String>> hbaDevices = new ArrayList<EnumMap<HbaDeviceKeys, String>>();
    // $NON-NLS-1$
    List<Map<String, String>> fcDevices = vds.getHBAs().get("FC");
    if (fcDevices != null) {
        for (Map<String, String> device : fcDevices) {
            EnumMap<HbaDeviceKeys, String> deviceModel = new EnumMap<HbaDeviceKeys, String>(HbaDeviceKeys.class);
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.MODEL_NAME, device.get("model"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.WWNN, device.get("wwnn"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.WWNPS, device.get("wwpn"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.TYPE, "FC");
            hbaDevices.add(deviceModel);
        }
    }
    setHbaDevices(hbaDevices);
}
#method_after
private void updateProperties() {
    VDS vds = getEntity();
    setHardwareManufacturer(vds.getHardwareManufacturer());
    setHardwareVersion(vds.getHardwareVersion());
    setHardwareProductName(vds.getHardwareProductName());
    setHardwareUUID(vds.getHardwareUUID());
    setHardwareSerialNumber(vds.getHardwareSerialNumber());
    setHardwareFamily(vds.getHardwareFamily());
    setCpuType(vds.getCpuName() != null ? vds.getCpuName().getCpuName() : null);
    setCpuModel(vds.getCpuModel());
    setNumberOfSockets(vds.getCpuSockets());
    if (vds.getCpuCores() != null && vds.getCpuSockets() != null && vds.getCpuSockets() != 0) {
        setCoresPerSocket(vds.getCpuCores() / vds.getCpuSockets());
    } else {
        setCoresPerSocket(null);
    }
    if (vds.getVdsGroupCompatibilityVersion() != null && Version.v3_2.compareTo(vds.getVdsGroupCompatibilityVersion()) > 0) {
        // Members of pre-3.2 clusters don't support SMT; here we act like a 3.1 engine
        setThreadsPerCore(constants.unsupported());
    } else if (vds.getCpuThreads() == null || vds.getCpuCores() == null || vds.getCpuCores() == 0) {
        setThreadsPerCore(constants.unknown());
    } else {
        Integer threads = vds.getCpuThreads() / vds.getCpuCores();
        setThreadsPerCore(messages.commonMessageWithBrackets(threads.toString(), threads > 1 ? constants.smtEnabled() : constants.smtDisabled()));
    }
    /* Go through the list of HBA devices and transfer the necessary info
           to the GWT host hardware model */
    List<EnumMap<HbaDeviceKeys, String>> hbaDevices = new ArrayList<EnumMap<HbaDeviceKeys, String>>();
    // $NON-NLS-1$
    List<Map<String, String>> fcDevices = vds.getHBAs().get("FC");
    if (fcDevices != null) {
        for (Map<String, String> device : fcDevices) {
            EnumMap<HbaDeviceKeys, String> deviceModel = new EnumMap<HbaDeviceKeys, String>(HbaDeviceKeys.class);
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.MODEL_NAME, device.get("model"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.WWNN, device.get("wwnn"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.WWNPS, device.get("wwpn"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.TYPE, "FC");
            hbaDevices.add(deviceModel);
        }
    }
    setHbaDevices(hbaDevices);
}
#end_block

#method_before
@Override
protected Widget getContents() {
    VerticalPanel vPanel = new VerticalPanel();
    vPanel.setSpacing(5);
    // $NON-NLS-1$
    vPanel.setWidth("100%");
    Grid titleRow = new Grid(1, 3);
    titleRow.setCellSpacing(3);
    ColumnFormatter columnFormatter = titleRow.getColumnFormatter();
    // $NON-NLS-1$
    columnFormatter.setWidth(0, "30px");
    // $NON-NLS-1$
    columnFormatter.setWidth(1, "100%");
    // $NON-NLS-1$
    titleRow.setWidth("100%");
    // $NON-NLS-1$
    titleRow.setHeight("27px");
    Label titleLabel = new Label(item.getName());
    // $NON-NLS-1$
    titleLabel.setHeight("100%");
    Image bondImage = new Image(resources.bond());
    titleRow.setWidget(0, 0, bondImage);
    titleRow.setWidget(0, 1, titleLabel);
    titleRow.setWidget(0, 2, actionButton);
    titleRow.setCellSpacing(3);
    titleRow.setCellPadding(3);
    vPanel.add(titleRow);
    getElement().addClassName(style.bondPanel());
    List<NetworkInterfaceModel> bonded = ((BondNetworkInterfaceModel) item).getBonded();
    Collections.sort(bonded);
    for (NetworkInterfaceModel networkInterfaceModel : bonded) {
        NicPanel nicPanel = new NicPanel(networkInterfaceModel, style);
        nicPanel.parentPanel = this;
        vPanel.add(nicPanel);
    }
    return vPanel;
}
#method_after
@Override
protected Widget getContents() {
    VerticalPanel vPanel = new VerticalPanel();
    // $NON-NLS-1$
    vPanel.addStyleName("ts5");
    // $NON-NLS-1$
    vPanel.setWidth("100%");
    Grid titleRow = new Grid(1, 3);
    // $NON-NLS-1$
    titleRow.addStyleName("ts3");
    ColumnFormatter columnFormatter = titleRow.getColumnFormatter();
    // $NON-NLS-1$
    columnFormatter.setWidth(0, "30px");
    // $NON-NLS-1$
    columnFormatter.setWidth(1, "100%");
    // $NON-NLS-1$
    titleRow.setWidth("100%");
    // $NON-NLS-1$
    titleRow.setHeight("27px");
    Label titleLabel = new Label(item.getName());
    // $NON-NLS-1$
    titleLabel.setHeight("100%");
    Image bondImage = new Image(resources.bond());
    titleRow.setWidget(0, 0, bondImage);
    titleRow.setWidget(0, 1, titleLabel);
    titleRow.setWidget(0, 2, actionButton);
    // $NON-NLS-1$
    titleRow.addStyleName("ts3");
    titleRow.setCellPadding(3);
    vPanel.add(titleRow);
    getElement().addClassName(style.bondPanel());
    List<NetworkInterfaceModel> bonded = ((BondNetworkInterfaceModel) item).getBonded();
    Collections.sort(bonded);
    for (NetworkInterfaceModel networkInterfaceModel : bonded) {
        NicPanel nicPanel = new NicPanel(networkInterfaceModel, style);
        nicPanel.parentPanel = this;
        vPanel.add(nicPanel);
    }
    return vPanel;
}
#end_block

#method_before
public String getSelinuxEnforceMode() {
    if (selinuxEnforceMode == null) {
    // Nothing
    } else if (selinuxEnforceMode.equals(SELinuxMode.DISABLED)) {
        return constants.disabled();
    } else if (selinuxEnforceMode.equals(SELinuxMode.PERMISSIVE)) {
        return constants.permissive();
    } else if (selinuxEnforceMode.equals(SELinuxMode.ENFORCING)) {
        return constants.enforcing();
    }
    return constants.notAvailableLabel();
}
#method_after
public String getSelinuxEnforceMode() {
    return selinuxEnforceMode;
}
#end_block

#method_before
public void setSelinuxEnforceMode(SELinuxMode newMode) {
    if (!selinuxEnforceMode.equals(newMode)) {
        selinuxEnforceMode = newMode;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("selinuxEnforceMode"));
    }
}
#method_after
public void setSelinuxEnforceMode(String newMode) {
    if (!ObjectUtils.objectsEqual(selinuxEnforceMode, newMode)) {
        selinuxEnforceMode = newMode;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("selinuxEnforceMode"));
    }
}
#end_block

#method_before
private void updateProperties() {
    VDS vds = getEntity();
    setOS(vds.getHostOs());
    setKernelVersion(vds.getKernelVersion());
    setKvmVersion(vds.getKvmVersion());
    setLibvirtVersion(vds.getLibvirtVersion());
    setVdsmVersion(vds.getVersion());
    setSpiceVersion(vds.getSpiceVersion());
    setGlusterVersion(vds.getGlusterVersion());
    setIScsiInitiatorName(vds.getIScsiInitiatorName());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setActiveVms(vds.getVmActive());
    setPhysicalMemory(vds.getPhysicalMemMb());
    setSwapTotal(vds.getSwapTotal());
    setSwapFree(vds.getSwapFree());
    setSharedMemory(vds.getMemSharedPercent());
    setMemoryPageSharing(vds.getKsmState());
    setAutomaticLargePage(vds.getTransparentHugePagesState());
    setBootTime(vds.getBootTime());
    setSelinuxEnforceMode(vds.getSELinuxEnforceMode());
    setKdumpStatus(EnumTranslator.create(KdumpStatus.class).get(vds.getKdumpStatus()));
    if (!vds.getHighlyAvailableIsConfigured()) {
        setHostedEngineHaIsConfigured(false);
        setHostedEngineHa(constants.bracketedNotAvailableLabel());
    } else {
        setHostedEngineHaIsConfigured(true);
        if (!vds.getHighlyAvailableIsActive()) {
            setHostedEngineHa(constants.haNotActive());
        } else if (vds.getHighlyAvailableGlobalMaintenance()) {
            setHostedEngineHa(constants.haGlobalMaintenance());
        } else if (vds.getHighlyAvailableLocalMaintenance()) {
            setHostedEngineHa(constants.haLocalMaintenance());
        } else {
            setHostedEngineHa(messages.haActive(vds.getHighlyAvailableScore()));
        }
    }
    if (vds.getVdsGroupCompatibilityVersion() != null && Version.v3_2.compareTo(vds.getVdsGroupCompatibilityVersion()) > 0) {
        setLogicalCores(vds.getCpuCores());
    } else {
        setLogicalCores(vds.getCpuThreads());
    }
}
#method_after
private void updateProperties() {
    VDS vds = getEntity();
    setOS(vds.getHostOs());
    setKernelVersion(vds.getKernelVersion());
    setKvmVersion(vds.getKvmVersion());
    setLibvirtVersion(vds.getLibvirtVersion());
    setVdsmVersion(vds.getVersion());
    setSpiceVersion(vds.getSpiceVersion());
    setGlusterVersion(vds.getGlusterVersion());
    setIScsiInitiatorName(vds.getIScsiInitiatorName());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setActiveVms(vds.getVmActive());
    setPhysicalMemory(vds.getPhysicalMemMb());
    setSwapTotal(vds.getSwapTotal());
    setSwapFree(vds.getSwapFree());
    setSharedMemory(vds.getMemSharedPercent());
    setMemoryPageSharing(vds.getKsmState());
    setAutomaticLargePage(vds.getTransparentHugePagesState());
    setBootTime(vds.getBootTime());
    setKdumpStatus(EnumTranslator.create(KdumpStatus.class).get(vds.getKdumpStatus()));
    setSelinuxEnforceMode(EnumTranslator.create(SELinuxMode.class).get(vds.getSELinuxEnforceMode()));
    if (!vds.getHighlyAvailableIsConfigured()) {
        setHostedEngineHaIsConfigured(false);
        setHostedEngineHa(constants.bracketedNotAvailableLabel());
    } else {
        setHostedEngineHaIsConfigured(true);
        if (!vds.getHighlyAvailableIsActive()) {
            setHostedEngineHa(constants.haNotActive());
        } else if (vds.getHighlyAvailableGlobalMaintenance()) {
            setHostedEngineHa(constants.haGlobalMaintenance());
        } else if (vds.getHighlyAvailableLocalMaintenance()) {
            setHostedEngineHa(constants.haLocalMaintenance());
        } else {
            setHostedEngineHa(messages.haActive(vds.getHighlyAvailableScore()));
        }
    }
    if (vds.getVdsGroupCompatibilityVersion() != null && Version.v3_2.compareTo(vds.getVdsGroupCompatibilityVersion()) > 0) {
        setLogicalCores(vds.getCpuCores());
    } else {
        setLogicalCores(vds.getCpuThreads());
    }
}
#end_block

#method_before
private void edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            edittedVm = (VM) result;
            vmInitLoaded(edittedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
    }
}
#method_after
private void edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
    }
}
#end_block

#method_before
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        final VM selectedItem = (VM) getSelectedItem();
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        getcurrentVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.isNextRunConfigurationChanged(edittedVm, getcurrentVm(), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    if (((VdcQueryReturnValue) returnValue).<Boolean>getReturnValue()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(false);
                    }
                }
            }));
        } else {
            updateExistingVm(false);
        }
    }
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        final VM selectedItem = (VM) getSelectedItem();
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        getcurrentVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.isNextRunConfigurationChanged(editedVm, getcurrentVm(), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    if (((VdcQueryReturnValue) returnValue).<Boolean>getReturnValue()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(false);
                    }
                }
            }));
        } else {
            updateExistingVm(false);
        }
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VM srcVm = getParameters().getOriginal();
    VM dstVm = getParameters().getUpdated();
    VmStatic srcStatic = srcVm.getStaticData();
    VmStatic dstStatic = dstVm.getStaticData();
    VmPropertiesUtils vmPropertiesUtils = SimpleDependecyInjector.getInstance().get(VmPropertiesUtils.class);
    vmPropertiesUtils.separeteCustomPropertiesToUserAndPredefined(srcVm.getVdsGroupCompatibilityVersion(), srcStatic);
    vmPropertiesUtils.separeteCustomPropertiesToUserAndPredefined(dstVm.getVdsGroupCompatibilityVersion(), dstStatic);
    setReturnValue(!VmHandler.isUpdateValid(srcStatic, dstStatic, VMStatus.Up));
}
#method_after
@Override
protected void executeQueryCommand() {
    VM srcVm = getParameters().getOriginal();
    VM dstVm = getParameters().getUpdated();
    VmStatic srcStatic = srcVm.getStaticData();
    VmStatic dstStatic = dstVm.getStaticData();
    // copy fields which are not saved as part of the OVF
    dstStatic.setExportDate(srcStatic.getExportDate());
    dstStatic.setManagedDeviceMap(srcStatic.getManagedDeviceMap());
    dstStatic.setUnmanagedDeviceList(srcStatic.getUnmanagedDeviceList());
    dstStatic.setOvfVersion(srcStatic.getOvfVersion());
    VmPropertiesUtils vmPropertiesUtils = SimpleDependecyInjector.getInstance().get(VmPropertiesUtils.class);
    vmPropertiesUtils.separeteCustomPropertiesToUserAndPredefined(srcVm.getVdsGroupCompatibilityVersion(), srcStatic);
    vmPropertiesUtils.separeteCustomPropertiesToUserAndPredefined(dstVm.getVdsGroupCompatibilityVersion(), dstStatic);
    setReturnValue(!VmHandler.isUpdateValid(srcStatic, dstStatic, VMStatus.Up));
}
#end_block

#method_before
protected <P extends VdcActionParametersBase> P sessionize(P parameters) {
    return sessionHelper.sessionize(parameters);
}
#method_after
protected <P extends VdcQueryParametersBase> P sessionize(P parameters) {
    return sessionHelper.sessionize(parameters);
}
#end_block

#method_before
@Override
protected Host doPopulate(Host model, VDS entity) {
    return model;
}
#method_after
@Override
protected Host doPopulate(Host model, VDS entity) {
    Host host = addHostedEngineIfConfigured(model, entity);
    return host;
}
#end_block

#method_before
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addArchitectureCapabilities(version);
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#method_after
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addKdumpStates(version, KdumpStatus.values());
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addArchitectureCapabilities(version);
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    addSELinuxModes(version, SELinuxMode.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#end_block

#method_before
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(vds.getVmCount(), vds.getSpmStatus());
        log.warnFormat("Host {0} is not responding, Host will be in Connecting state for a grace period of {1} Sec and after that an attempt to fence the Host will be issued.", vds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(vds.getId());
        logable.addCustomValue("Seconds", new Long(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)).toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_HOST_IN_CONNECTING_STATE);
        if (mUnrespondedAttempts.get() < Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount) || (lastUpdate + timeoutToFence) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getStatus() != VDSStatus.Connecting && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        log.infoFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, vm_count = {2}, " + "spm_status = {3}, non-responsive_timeout (seconds) = {4}, error = {5}", vds.getId(), vds.getName(), vds.getVmCount(), vds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
        logable = new AuditLogableBase(vds.getId());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        boolean executeSshSoftFencing = false;
        if (!sshSoftFencingExecuted.getAndSet(true)) {
            executeSshSoftFencing = true;
        }
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds, executeSshSoftFencing);
    }
    return true;
}
#method_after
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(vds.getVmCount(), vds.getSpmStatus());
        log.warnFormat("Host {0} is not responding. It will stay in Connecting state for a grace period of ${1} seconds and after that an attempt to fence the host will be issued.", vds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(vds.getId());
        logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
        AuditLogDirector.log(logable, AuditLogType.VDS_HOST_IN_CONNECTING_STATE);
        if (mUnrespondedAttempts.get() < Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount) || (lastUpdate + timeoutToFence) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getStatus() != VDSStatus.Connecting && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        log.infoFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, vm_count = {2}, " + "spm_status = {3}, non-responsive_timeout (seconds) = {4}, error = {5}", vds.getId(), vds.getName(), vds.getVmCount(), vds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
        logable = new AuditLogableBase(vds.getId());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        boolean executeSshSoftFencing = false;
        if (!sshSoftFencingExecuted.getAndSet(true)) {
            executeSshSoftFencing = true;
        }
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds, executeSshSoftFencing);
    }
    return true;
}
#end_block

#method_before
private void addNumaSetting(final String compatibilityVersion) {
    if (Boolean.TRUE.equals(Config.<Boolean>getValue(ConfigValues.CpuPinningEnabled, compatibilityVersion))) {
        NumaTuneMode numaTune = vm.getNumaTuneMode() == null ? NumaTuneMode.PREFERRED : vm.getNumaTuneMode();
        List<VmNumaNode> vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(vm.getId());
        List<VdsNumaNode> totalVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vm.getRunOnVds());
        List<Integer> totalVdsNumaNodesIndexes = NumaUtils.getNodeIndexList(totalVdsNumaNodes);
        Map<String, Object> createNumaTune = new HashMap<>(2);
        createNumaTune.put(VdsProperties.NUMA_TUNE_MODE, numaTune.getValue());
        boolean useAllVdsNodesMem = false;
        Set<Integer> vmNumaNodePinInfo = new HashSet<>();
        if (!vmNumaNodes.isEmpty()) {
            List<Map<String, Object>> createVmNumaNodes = new ArrayList<>();
            for (VmNumaNode node : vmNumaNodes) {
                Map<String, Object> createVmNumaNode = new HashMap<>();
                createVmNumaNode.put(VdsProperties.NUMA_NODE_CPU_LIST, NumaUtils.buildStringFromListForNuma(node.getCpuIds()));
                createVmNumaNode.put(VdsProperties.VM_NUMA_NODE_MEM, String.valueOf(node.getMemTotal()));
                createVmNumaNodes.add(createVmNumaNode);
                if (node.getVdsNumaNodeList().isEmpty()) {
                    useAllVdsNodesMem = true;
                } else {
                    vmNumaNodePinInfo.addAll(NumaUtils.getPinnedNodeIndexList(node.getVdsNumaNodeList()));
                }
            }
            createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
        } else {
            useAllVdsNodesMem = true;
        }
        if (useAllVdsNodesMem && !totalVdsNumaNodesIndexes.isEmpty()) {
            createNumaTune.put(VdsProperties.NUMA_TUNE_NODESET, NumaUtils.buildStringFromListForNuma(totalVdsNumaNodesIndexes));
        } else if (!vmNumaNodePinInfo.isEmpty()) {
            createNumaTune.put(VdsProperties.NUMA_TUNE_NODESET, NumaUtils.buildStringFromListForNuma(vmNumaNodePinInfo));
        }
        createInfo.put(VdsProperties.NUMA_TUNE, createNumaTune);
        if (StringUtils.isEmpty(vm.getCpuPinning())) {
            Map<String, Object> cpuPinDict = addCpuPinningForNumaSetting(vmNumaNodes, totalVdsNumaNodes);
            if (!cpuPinDict.isEmpty()) {
                createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
            }
        }
    }
}
#method_after
private void addNumaSetting(final String compatibilityVersion) {
    if (Boolean.TRUE.equals(Config.<Boolean>getValue(ConfigValues.CpuPinningEnabled, compatibilityVersion))) {
        NumaTuneMode numaTune = vm.getNumaTuneMode() == null ? NumaTuneMode.PREFERRED : vm.getNumaTuneMode();
        List<VmNumaNode> vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(vm.getId());
        List<VdsNumaNode> totalVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vm.getRunOnVds());
        List<Integer> totalVdsNumaNodesIndexes = NumaUtils.getNodeIndexList(totalVdsNumaNodes);
        Map<String, Object> createNumaTune = new HashMap<>(2);
        createNumaTune.put(VdsProperties.NUMA_TUNE_MODE, numaTune.getValue());
        boolean useAllVdsNodesMem = false;
        Set<Integer> vmNumaNodePinInfo = new HashSet<>();
        if (!vmNumaNodes.isEmpty()) {
            List<Map<String, Object>> createVmNumaNodes = new ArrayList<>();
            for (VmNumaNode node : vmNumaNodes) {
                Map<String, Object> createVmNumaNode = new HashMap<>();
                createVmNumaNode.put(VdsProperties.NUMA_NODE_CPU_LIST, NumaUtils.buildStringFromListForNuma(node.getCpuIds()));
                createVmNumaNode.put(VdsProperties.VM_NUMA_NODE_MEM, String.valueOf(node.getMemTotal()));
                createVmNumaNodes.add(createVmNumaNode);
                if (node.getVdsNumaNodeList().isEmpty()) {
                    useAllVdsNodesMem = true;
                } else {
                    vmNumaNodePinInfo.addAll(NumaUtils.getPinnedNodeIndexList(node.getVdsNumaNodeList()));
                }
            }
            createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
        } else {
            useAllVdsNodesMem = true;
        }
        if (useAllVdsNodesMem) {
            if (!totalVdsNumaNodesIndexes.isEmpty()) {
                createNumaTune.put(VdsProperties.NUMA_TUNE_NODESET, NumaUtils.buildStringFromListForNuma(totalVdsNumaNodesIndexes));
            }
        } else {
            if (!vmNumaNodePinInfo.isEmpty()) {
                createNumaTune.put(VdsProperties.NUMA_TUNE_NODESET, NumaUtils.buildStringFromListForNuma(vmNumaNodePinInfo));
            }
        }
        createInfo.put(VdsProperties.NUMA_TUNE, createNumaTune);
        if (StringUtils.isEmpty(vm.getCpuPinning())) {
            Map<String, Object> cpuPinDict = addCpuPinningForNumaSetting(vmNumaNodes, totalVdsNumaNodes);
            if (!cpuPinDict.isEmpty()) {
                createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
            }
        }
    }
}
#end_block

#method_before
void handleActionResult(final VdcActionType actionType, final VdcActionParametersBase parameters, final VdcReturnValueBase result, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    // $NON-NLS-1$
    logger.log(Level.FINER, "Retrieved action result from RunAction.");
    FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, result, state);
    boolean failedOnCanDoAction = !result.getCanDoAction();
    if (failedOnCanDoAction) {
        result.setCanDoActionMessages((ArrayList<String>) translateError(result));
    } else if (showErrorDialog && result.getIsSyncronious() && !result.getSucceeded()) {
        runActionExecutionFailed(actionType, result.getFault());
    }
    callback.executed(f);
    // only needed for canDoAction failure
    if (failedOnCanDoAction && (getEventsHandler() != null) && (getEventsHandler().isRaiseErrorModalPanel(actionType, result.getFault()))) {
        if (result.getCanDoActionMessages().isEmpty()) {
            // TODO: Externalize to a better location, should support translation via
            // resource bundle file.
            // $NON-NLS-1$
            failureEventHandler(result.getDescription(), "No Message");
        } else {
            failureEventHandler(result.getDescription(), result.getCanDoActionMessages());
        }
    }
}
#method_after
void handleActionResult(final VdcActionType actionType, final VdcActionParametersBase parameters, final VdcReturnValueBase result, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    // $NON-NLS-1$
    logger.log(Level.FINER, "Retrieved action result from RunAction.");
    FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, result, state);
    boolean failedOnCanDoAction = !result.getCanDoAction();
    if (failedOnCanDoAction) {
        result.setCanDoActionMessages((ArrayList<String>) translateError(result));
    } else if (showErrorDialog && result.getIsSyncronious() && !result.getSucceeded()) {
        runActionExecutionFailed(actionType, result.getFault());
    }
    callback.executed(f);
    // only needed for canDoAction failure
    if (failedOnCanDoAction && (getEventsHandler() != null) && (getEventsHandler().isRaiseErrorModalPanel(actionType, result.getFault()))) {
        ArrayList<String> messages = result.getCanDoActionMessages();
        failureEventHandler(result.getDescription(), // $NON-NLS-1$
        messages.isEmpty() ? Collections.singletonList(getConstants().noCanDoActionMessage()) : messages);
    }
}
#end_block

#method_before
private void failureEventHandler(final Throwable caught) {
    String errorMessage;
    if (caught instanceof StatusCodeException) {
        errorMessage = // $NON-NLS-1$
        getConstants().requestToServerFailedWithCode() + ": " + ((StatusCodeException) caught).getStatusCode();
    } else {
        errorMessage = getConstants().requestToServerFailed() + ": " + // $NON-NLS-1$
        caught.getLocalizedMessage();
    }
    failureEventHandler(errorMessage);
}
#method_after
private void failureEventHandler(final Throwable caught) {
    String errorMessage;
    if (caught instanceof StatusCodeException) {
        errorMessage = // $NON-NLS-1$
        getConstants().requestToServerFailedWithCode() + ": " + ((StatusCodeException) caught).getStatusCode();
    } else {
        errorMessage = getConstants().requestToServerFailed() + ": " + // $NON-NLS-1$
        caught.getLocalizedMessage();
    }
    failureEventHandler(null, Collections.singletonList(errorMessage));
}
#end_block

#method_before
private void failureEventHandler(final String description, final ArrayList<String> errorMessages) {
    ArrayList<Message> messages = new ArrayList<Message>();
    for (String errorMessage : errorMessages) {
        messages.add(new Message(description, errorMessage));
    }
    frontendFailureEvent.raise(Frontend.class, new FrontendFailureEventArgs(messages));
}
#method_after
private void failureEventHandler(final String description, final List<String> errorMessages) {
    ArrayList<Message> messages = new ArrayList<Message>();
    for (String errorMessage : errorMessages) {
        handleNotLoggedInEvent(errorMessage);
        messages.add(new Message(description, errorMessage));
    }
    frontendFailureEvent.raise(Frontend.class, new FrontendFailureEventArgs(messages));
}
#end_block

#method_before
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().startProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.setHandleFailure(true);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            getWindow().stopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            } else if (!returnValue.getSucceeded()) {
                clusterModel.setMessage(Frontend.getInstance().getAppErrorsTranslator().translateErrorTextSingle(returnValue.getExceptionString()));
                return;
            }
            Map<String, String> hostMap = returnValue.getReturnValue();
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel> list = new ArrayList<EntityModel>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel entityModel = new EntityModel(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.getGlusterHosts(aQuery, clusterModel.getGlusterHostAddress().getEntity(), clusterModel.getGlusterHostPassword().getEntity(), clusterModel.getGlusterHostFingerprint().getEntity());
}
#method_after
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().startProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.setHandleFailure(true);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            getWindow().stopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            } else if (!returnValue.getSucceeded()) {
                clusterModel.setMessage(Frontend.getInstance().getAppErrorsTranslator().translateErrorTextSingle(returnValue.getExceptionString()));
                return;
            }
            Map<String, String> hostMap = returnValue.getReturnValue();
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel<HostDetailModel>> list = new ArrayList<EntityModel<HostDetailModel>>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel<HostDetailModel> entityModel = new EntityModel<HostDetailModel>(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.getGlusterHosts(aQuery, clusterModel.getGlusterHostAddress().getEntity(), clusterModel.getGlusterHostPassword().getEntity(), clusterModel.getGlusterHostFingerprint().getEntity());
}
#end_block

#method_before
private void importClusterHosts(ClusterModel clusterModel, ArrayList<EntityModel> hostList) {
    setWindow(null);
    getAddMultipleHostsCommand().execute();
    final MultipleHostsModel hostsModel = new MultipleHostsModel();
    setWindow(hostsModel);
    hostsModel.setTitle(ConstantsManager.getInstance().getConstants().addMultipleHostsTitle());
    hostsModel.setHelpTag(HelpTag.add_hosts);
    // $NON-NLS-1$
    hostsModel.setHashName("add_hosts");
    hostsModel.setClusterModel(clusterModel);
    hostsModel.getHosts().setItems(hostList);
    // $NON-NLS-1$
    UICommand command = new UICommand("OnSaveHosts", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    hostsModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    hostsModel.getCommands().add(command);
}
#method_after
private void importClusterHosts(ClusterModel clusterModel, ArrayList<EntityModel<HostDetailModel>> hostList) {
    setWindow(null);
    getAddMultipleHostsCommand().execute();
    final MultipleHostsModel hostsModel = new MultipleHostsModel();
    setWindow(hostsModel);
    hostsModel.setTitle(ConstantsManager.getInstance().getConstants().addMultipleHostsTitle());
    hostsModel.setHelpTag(HelpTag.add_hosts);
    // $NON-NLS-1$
    hostsModel.setHashName("add_hosts");
    hostsModel.setClusterModel(clusterModel);
    hostsModel.getHosts().setItems(hostList);
    // $NON-NLS-1$
    UICommand command = new UICommand("OnSaveHosts", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    hostsModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    hostsModel.getCommands().add(command);
}
#end_block

#method_before
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress(null);
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till then using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setVdsGroupId(hostsModel.getClusterModel().getClusterId());
        host.setpm_enabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(MultipleHostsModel.isEnableFirewall());
        parameters.setRebootAfterInstallation(hostsModel.getClusterModel().getEnableOvirtService().getIsSelected());
        parametersList.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllCanDoPassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllCanDoPassed = isAllCanDoPassed && returnValueBase.getCanDoAction();
                if (!isAllCanDoPassed) {
                    break;
                }
            }
            if (isAllCanDoPassed) {
                cancel();
            }
        }
    }, null);
}
#method_after
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress(null);
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till then using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setVdsGroupId(hostsModel.getClusterModel().getClusterId());
        host.setpm_enabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(hostsModel.isConfigureFirewall());
        parameters.setRebootAfterInstallation(hostsModel.getClusterModel().getEnableOvirtService().getIsSelected());
        parametersList.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllCanDoPassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllCanDoPassed = isAllCanDoPassed && returnValueBase.getCanDoAction();
                if (!isAllCanDoPassed) {
                    break;
                }
            }
            if (isAllCanDoPassed) {
                cancel();
            }
        }
    }, null);
}
#end_block

#method_before
private void updateConsoleAddressPartiallyOverridden(VDSGroup cluster) {
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            boolean isConsistent = (Boolean) ((VdcQueryReturnValue) returnValue).getReturnValue();
            setConsoleAddressPartiallyOverridden(!isConsistent);
        }
    });
    Frontend.getInstance().runQuery(VdcQueryType.IsDisplayAddressConsistentInCluster, new IdQueryParameters(cluster.getId()), query);
}
#method_after
private void updateConsoleAddressPartiallyOverridden(VDSGroup cluster) {
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            boolean isConsistent = ((VdcQueryReturnValue) returnValue).getReturnValue();
            setConsoleAddressPartiallyOverridden(!isConsistent);
        }
    });
    Frontend.getInstance().runQuery(VdcQueryType.IsDisplayAddressConsistentInCluster, new IdQueryParameters(cluster.getId()), query);
}
#end_block

#method_before
private void onManageGlusterSwiftServices() {
    if (getWindow() == null) {
        return;
    }
    ManageGlusterSwiftModel glusterSwiftModel = (ManageGlusterSwiftModel) getWindow();
    glusterSwiftModel.startProgress(null);
    if ((Boolean) glusterSwiftModel.getIsManageServerLevel().getEntity()) {
        ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
        for (Object model : glusterSwiftModel.getHostServicesList().getItems()) {
            GlusterSwiftServiceModel swiftServiceModel = (GlusterSwiftServiceModel) model;
            GlusterSwiftAction action = getGlusterSwiftAction(swiftServiceModel.getEntity().getStatus(), (Boolean) swiftServiceModel.getStartSwift().getEntity(), (Boolean) swiftServiceModel.getStopSwift().getEntity(), (Boolean) swiftServiceModel.getRestartSwift().getEntity());
            if (action != null) {
                GlusterServiceParameters parameters = new GlusterServiceParameters(getEntity().getId(), swiftServiceModel.getEntity().getServerId(), ServiceType.GLUSTER_SWIFT, action.name().toLowerCase());
                parametersList.add(parameters);
            }
        }
        if (!parametersList.isEmpty()) {
            Frontend.getInstance().runMultipleAction(VdcActionType.ManageGlusterService, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ManageGlusterSwiftModel innerGlusterSwiftModel = (ManageGlusterSwiftModel) result.getState();
                    innerGlusterSwiftModel.stopProgress();
                    for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                    }
                    cancel();
                    updateGlusterDetails();
                }
            }, glusterSwiftModel);
        } else {
            glusterSwiftModel.stopProgress();
            glusterSwiftModel.setMessage(ConstantsManager.getInstance().getConstants().noActionSelectedManageGlusterSwift());
        }
    } else {
        GlusterServiceStatus swiftStatus = (GlusterServiceStatus) glusterSwiftModel.getSwiftStatus().getEntity();
        GlusterSwiftAction action = getGlusterSwiftAction(swiftStatus, (Boolean) glusterSwiftModel.getStartSwift().getEntity(), (Boolean) glusterSwiftModel.getStopSwift().getEntity(), (Boolean) glusterSwiftModel.getRestartSwift().getEntity());
        if (action != null) {
            GlusterServiceParameters parameters = new GlusterServiceParameters(getEntity().getId(), null, ServiceType.GLUSTER_SWIFT, action.name().toLowerCase());
            Frontend.getInstance().runAction(VdcActionType.ManageGlusterService, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    ManageGlusterSwiftModel innerGlusterSwiftModel = (ManageGlusterSwiftModel) result.getState();
                    innerGlusterSwiftModel.stopProgress();
                    if (result.getReturnValue().getSucceeded()) {
                        cancel();
                        updateGlusterDetails();
                    }
                }
            }, glusterSwiftModel);
        } else {
            glusterSwiftModel.stopProgress();
            glusterSwiftModel.setMessage(ConstantsManager.getInstance().getConstants().noActionSelectedManageGlusterSwift());
        }
    }
}
#method_after
private void onManageGlusterSwiftServices() {
    if (getWindow() == null) {
        return;
    }
    ManageGlusterSwiftModel glusterSwiftModel = (ManageGlusterSwiftModel) getWindow();
    glusterSwiftModel.startProgress(null);
    if (glusterSwiftModel.getIsManageServerLevel().getEntity()) {
        ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
        for (Object model : glusterSwiftModel.getHostServicesList().getItems()) {
            GlusterSwiftServiceModel swiftServiceModel = (GlusterSwiftServiceModel) model;
            GlusterSwiftAction action = getGlusterSwiftAction(swiftServiceModel.getEntity().getStatus(), swiftServiceModel.getStartSwift().getEntity(), swiftServiceModel.getStopSwift().getEntity(), swiftServiceModel.getRestartSwift().getEntity());
            if (action != null) {
                GlusterServiceParameters parameters = new GlusterServiceParameters(getEntity().getId(), swiftServiceModel.getEntity().getServerId(), ServiceType.GLUSTER_SWIFT, action.name().toLowerCase());
                parametersList.add(parameters);
            }
        }
        if (!parametersList.isEmpty()) {
            Frontend.getInstance().runMultipleAction(VdcActionType.ManageGlusterService, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ManageGlusterSwiftModel innerGlusterSwiftModel = (ManageGlusterSwiftModel) result.getState();
                    innerGlusterSwiftModel.stopProgress();
                    for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                    }
                    cancel();
                    updateGlusterDetails();
                }
            }, glusterSwiftModel);
        } else {
            glusterSwiftModel.stopProgress();
            glusterSwiftModel.setMessage(ConstantsManager.getInstance().getConstants().noActionSelectedManageGlusterSwift());
        }
    } else {
        GlusterServiceStatus swiftStatus = glusterSwiftModel.getSwiftStatus().getEntity();
        GlusterSwiftAction action = getGlusterSwiftAction(swiftStatus, glusterSwiftModel.getStartSwift().getEntity(), glusterSwiftModel.getStopSwift().getEntity(), glusterSwiftModel.getRestartSwift().getEntity());
        if (action != null) {
            GlusterServiceParameters parameters = new GlusterServiceParameters(getEntity().getId(), null, ServiceType.GLUSTER_SWIFT, action.name().toLowerCase());
            Frontend.getInstance().runAction(VdcActionType.ManageGlusterService, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    ManageGlusterSwiftModel innerGlusterSwiftModel = (ManageGlusterSwiftModel) result.getState();
                    innerGlusterSwiftModel.stopProgress();
                    if (result.getReturnValue().getSucceeded()) {
                        cancel();
                        updateGlusterDetails();
                    }
                }
            }, glusterSwiftModel);
        } else {
            glusterSwiftModel.stopProgress();
            glusterSwiftModel.setMessage(ConstantsManager.getInstance().getConstants().noActionSelectedManageGlusterSwift());
        }
    }
}
#end_block

#method_before
public void fetchAndImportNewGlusterHosts() {
    if (getWindow() != null) {
        return;
    }
    final MultipleHostsModel hostsModel = new MultipleHostsModel();
    setWindow(hostsModel);
    hostsModel.setTitle(ConstantsManager.getInstance().getConstants().addMultipleHostsTitle());
    hostsModel.setHelpTag(HelpTag.add_hosts);
    // $NON-NLS-1$
    hostsModel.setHashName("add_hosts");
    // $NON-NLS-1$
    UICommand command = new UICommand("OnSaveHosts", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    hostsModel.getCommands().add(command);
    hostsModel.getHosts().setItems(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    hostsModel.getCommands().add(command);
    hostsModel.startProgress(null);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            Map<String, String> hostMap = (Map<String, String>) result;
            if (hostMap == null || hostMap.isEmpty()) {
                hostsModel.setMessage(ConstantsManager.getInstance().getConstants().emptyNewGlusterHosts());
            } else {
                ArrayList<EntityModel> list = new ArrayList<EntityModel>();
                for (Map.Entry<String, String> host : hostMap.entrySet()) {
                    HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                    hostModel.setName(host.getKey());
                    // $NON-NLS-1$
                    hostModel.setPassword("");
                    EntityModel entityModel = new EntityModel(hostModel);
                    list.add(entityModel);
                }
                hostsModel.getHosts().setItems(list);
            }
            hostsModel.stopProgress();
        }
    };
    AsyncDataProvider.getGlusterHostsNewlyAdded(_asyncQuery, getEntity().getId(), true);
}
#method_after
public void fetchAndImportNewGlusterHosts() {
    if (getWindow() != null) {
        return;
    }
    final MultipleHostsModel hostsModel = new MultipleHostsModel();
    setWindow(hostsModel);
    hostsModel.setTitle(ConstantsManager.getInstance().getConstants().addMultipleHostsTitle());
    hostsModel.setHelpTag(HelpTag.add_hosts);
    // $NON-NLS-1$
    hostsModel.setHashName("add_hosts");
    // $NON-NLS-1$
    UICommand command = new UICommand("OnSaveHosts", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    hostsModel.getCommands().add(command);
    hostsModel.getHosts().setItems(new ArrayList<EntityModel<HostDetailModel>>());
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    hostsModel.getCommands().add(command);
    hostsModel.startProgress(null);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            Map<String, String> hostMap = (Map<String, String>) result;
            if (hostMap == null || hostMap.isEmpty()) {
                hostsModel.setMessage(ConstantsManager.getInstance().getConstants().emptyNewGlusterHosts());
            } else {
                ArrayList<EntityModel<HostDetailModel>> list = new ArrayList<EntityModel<HostDetailModel>>();
                for (Map.Entry<String, String> host : hostMap.entrySet()) {
                    HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                    hostModel.setName(host.getKey());
                    // $NON-NLS-1$
                    hostModel.setPassword("");
                    EntityModel<HostDetailModel> entityModel = new EntityModel<HostDetailModel>(hostModel);
                    list.add(entityModel);
                }
                hostsModel.getHosts().setItems(list);
            }
            hostsModel.stopProgress();
        }
    };
    AsyncDataProvider.getGlusterHostsNewlyAdded(_asyncQuery, getEntity().getId(), true);
}
#end_block

#method_before
public void onSaveHosts() {
    final MultipleHostsModel hostsModel = (MultipleHostsModel) getWindow();
    if (hostsModel == null) {
        return;
    }
    if (!hostsModel.validate()) {
        return;
    }
    hostsModel.startProgress(null);
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till than using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setVdsGroupId(getEntity().getId());
        host.setpm_enabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(MultipleHostsModel.isEnableFirewall());
        parameters.setRebootAfterInstallation(getEntity().supportsVirtService());
        parametersList.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllCanDoPassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllCanDoPassed = isAllCanDoPassed && returnValueBase.getCanDoAction();
                if (!isAllCanDoPassed) {
                    break;
                }
            }
            if (isAllCanDoPassed) {
                updateAlerts();
                cancel();
            }
        }
    }, null);
}
#method_after
public void onSaveHosts() {
    final MultipleHostsModel hostsModel = (MultipleHostsModel) getWindow();
    if (hostsModel == null) {
        return;
    }
    if (!hostsModel.validate()) {
        return;
    }
    hostsModel.startProgress(null);
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till than using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setVdsGroupId(getEntity().getId());
        host.setpm_enabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(hostsModel.isConfigureFirewall());
        parameters.setRebootAfterInstallation(getEntity().supportsVirtService());
        parametersList.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllCanDoPassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllCanDoPassed = isAllCanDoPassed && returnValueBase.getCanDoAction();
                if (!isAllCanDoPassed) {
                    break;
                }
            }
            if (isAllCanDoPassed) {
                updateAlerts();
                cancel();
            }
        }
    }, null);
}
#end_block

#method_before
public void detachNewGlusterHosts() {
    if (getWindow() != null) {
        return;
    }
    final DetachGlusterHostsModel hostsModel = new DetachGlusterHostsModel();
    setWindow(hostsModel);
    hostsModel.setTitle(ConstantsManager.getInstance().getConstants().detachGlusterHostsTitle());
    hostsModel.setHelpTag(HelpTag.detach_gluster_hosts);
    // $NON-NLS-1$
    hostsModel.setHashName("detach_gluster_hosts");
    // $NON-NLS-1$
    UICommand command = new UICommand("OnDetachGlusterHosts", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    hostsModel.getCommands().add(command);
    hostsModel.getHosts().setItems(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    hostsModel.getCommands().add(command);
    hostsModel.startProgress(null);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            Map<String, String> hostMap = (Map<String, String>) result;
            if (hostMap == null || hostMap.isEmpty()) {
                hostsModel.setMessage(ConstantsManager.getInstance().getConstants().emptyNewGlusterHosts());
            } else {
                ArrayList<EntityModel> hostList = new ArrayList<EntityModel>();
                for (String host : hostMap.keySet()) {
                    hostList.add(new EntityModel(host));
                }
                hostsModel.getHosts().setItems(hostList);
            }
            hostsModel.stopProgress();
        }
    };
    AsyncDataProvider.getGlusterHostsNewlyAdded(_asyncQuery, getEntity().getId(), true);
}
#method_after
public void detachNewGlusterHosts() {
    if (getWindow() != null) {
        return;
    }
    final DetachGlusterHostsModel hostsModel = new DetachGlusterHostsModel();
    setWindow(hostsModel);
    hostsModel.setTitle(ConstantsManager.getInstance().getConstants().detachGlusterHostsTitle());
    hostsModel.setHelpTag(HelpTag.detach_gluster_hosts);
    // $NON-NLS-1$
    hostsModel.setHashName("detach_gluster_hosts");
    // $NON-NLS-1$
    UICommand command = new UICommand("OnDetachGlusterHosts", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    hostsModel.getCommands().add(command);
    hostsModel.getHosts().setItems(new ArrayList<EntityModel<String>>());
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    hostsModel.getCommands().add(command);
    hostsModel.startProgress(null);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            Map<String, String> hostMap = (Map<String, String>) result;
            if (hostMap == null || hostMap.isEmpty()) {
                hostsModel.setMessage(ConstantsManager.getInstance().getConstants().emptyNewGlusterHosts());
            } else {
                ArrayList<EntityModel<String>> hostList = new ArrayList<EntityModel<String>>();
                for (String host : hostMap.keySet()) {
                    hostList.add(new EntityModel<String>(host));
                }
                hostsModel.getHosts().setItems(hostList);
            }
            hostsModel.stopProgress();
        }
    };
    AsyncDataProvider.getGlusterHostsNewlyAdded(_asyncQuery, getEntity().getId(), true);
}
#end_block

#method_before
public void onDetachNewGlusterHosts() {
    if (getWindow() == null) {
        return;
    }
    final DetachGlusterHostsModel hostsModel = (DetachGlusterHostsModel) getWindow();
    if (!hostsModel.validate()) {
        return;
    }
    boolean force = (Boolean) hostsModel.getForce().getEntity();
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
    for (Object model : hostsModel.getHosts().getSelectedItems()) {
        String host = (String) ((EntityModel) model).getEntity();
        parametersList.add(new RemoveGlusterServerParameters(getEntity().getId(), host, force));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveGlusterServer, parametersList);
    cancel();
}
#method_after
public void onDetachNewGlusterHosts() {
    if (getWindow() == null) {
        return;
    }
    final DetachGlusterHostsModel hostsModel = (DetachGlusterHostsModel) getWindow();
    if (!hostsModel.validate()) {
        return;
    }
    boolean force = hostsModel.getForce().getEntity();
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
    for (Object model : hostsModel.getHosts().getSelectedItems()) {
        String host = (String) ((EntityModel) model).getEntity();
        parametersList.add(new RemoveGlusterServerParameters(getEntity().getId(), host, force));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveGlusterServer, parametersList);
    cancel();
}
#end_block

#method_before
public ListModel getHosts() {
    return hosts;
}
#method_after
public ListModel<EntityModel<HostDetailModel>> getHosts() {
    return hosts;
}
#end_block

#method_before
public void setHosts(ListModel hosts) {
    this.hosts = hosts;
}
#method_after
public void setHosts(ListModel<EntityModel<HostDetailModel>> hosts) {
    this.hosts = hosts;
}
#end_block

#method_before
public EntityModel getUseCommonPassword() {
    return useCommonPassword;
}
#method_after
public EntityModel<Boolean> getUseCommonPassword() {
    return useCommonPassword;
}
#end_block

#method_before
public void setUseCommonPassword(EntityModel useCommonPassword) {
    this.useCommonPassword = useCommonPassword;
}
#method_after
public void setUseCommonPassword(EntityModel<Boolean> useCommonPassword) {
    this.useCommonPassword = useCommonPassword;
}
#end_block

#method_before
public EntityModel getCommonPassword() {
    return commonPassword;
}
#method_after
public EntityModel<String> getCommonPassword() {
    return commonPassword;
}
#end_block

#method_before
public void setCommonPassword(EntityModel commonPassword) {
    this.commonPassword = commonPassword;
}
#method_after
public void setCommonPassword(EntityModel<String> commonPassword) {
    this.commonPassword = commonPassword;
}
#end_block

#method_before
private void applyPassword() {
    String password = (String) getCommonPassword().getEntity();
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    for (Object object : getHosts().getItems()) {
        HostDetailModel host = (HostDetailModel) ((EntityModel) object).getEntity();
        host.setPassword(password);
        EntityModel entityModel = new EntityModel();
        entityModel.setEntity(host);
        items.add(entityModel);
    }
    getHosts().setItems(items);
}
#method_after
private void applyPassword() {
    String password = getCommonPassword().getEntity();
    ArrayList<EntityModel<HostDetailModel>> items = new ArrayList<EntityModel<HostDetailModel>>();
    for (Object object : getHosts().getItems()) {
        HostDetailModel host = (HostDetailModel) ((EntityModel) object).getEntity();
        host.setPassword(password);
        EntityModel<HostDetailModel> entityModel = new EntityModel<HostDetailModel>();
        entityModel.setEntity(host);
        items.add(entityModel);
    }
    getHosts().setItems(items);
}
#end_block

#method_before
public boolean validate() {
    boolean isValid = true;
    setMessage(null);
    Iterable<EntityModel> items = getHosts().getItems();
    for (EntityModel model : items) {
        HostDetailModel host = (HostDetailModel) model.getEntity();
        if (host.getName().trim().length() == 0) {
            setMessage(ConstantsManager.getInstance().getMessages().importClusterHostNameEmpty(host.getAddress()));
            isValid = false;
            break;
        } else if (host.getPassword().trim().length() == 0) {
            setMessage(ConstantsManager.getInstance().getMessages().importClusterHostPasswordEmpty(host.getAddress()));
            isValid = false;
            break;
        } else if (host.getFingerprint().trim().length() == 0) {
            setMessage(ConstantsManager.getInstance().getMessages().importClusterHostFingerprintEmpty(host.getAddress()));
            isValid = false;
            break;
        }
    }
    return isValid;
}
#method_after
public boolean validate() {
    boolean isValid = true;
    setMessage(null);
    Iterable<EntityModel<HostDetailModel>> items = getHosts().getItems();
    for (EntityModel<HostDetailModel> model : items) {
        HostDetailModel host = model.getEntity();
        if (host.getName().trim().length() == 0) {
            setMessage(ConstantsManager.getInstance().getMessages().importClusterHostNameEmpty(host.getAddress()));
            isValid = false;
            break;
        } else if (host.getPassword().trim().length() == 0) {
            setMessage(ConstantsManager.getInstance().getMessages().importClusterHostPasswordEmpty(host.getAddress()));
            isValid = false;
            break;
        } else if (host.getFingerprint().trim().length() == 0) {
            setMessage(ConstantsManager.getInstance().getMessages().importClusterHostFingerprintEmpty(host.getAddress()));
            isValid = false;
            break;
        }
    }
    return isValid;
}
#end_block

#method_before
private void initEditors() {
    hostsTable = new EntityModelCellTable<ListModel>(SelectionMode.SINGLE, true);
    useCommonPasswordEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableFirewallEditor = new EntityModelCheckBoxEditor(Align.LEFT);
    enableFirewallEditor.setAccessible(true);
}
#method_after
private void initEditors() {
    hostsTable = new EntityModelCellTable<ListModel<EntityModel<HostDetailModel>>>(SelectionMode.SINGLE, true);
    useCommonPasswordEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    configureFirewallEditor = new EntityModelCheckBoxEditor(Align.LEFT);
    configureFirewallEditor.setAccessible(true);
}
#end_block

#method_before
private void localize(ApplicationConstants constants) {
    useCommonPasswordEditor.setLabel(constants.hostsPopupUseCommonPassword());
    commonPasswordEditor.setLabel(constants.hostsPopupRootPassword());
    applyPasswordButton.setLabel(constants.hostsPopupApply());
    enableFirewallEditor.setLabel(constants.configureFirewallForAllHostsOfThisCluster());
}
#method_after
private void localize(ApplicationConstants constants) {
    useCommonPasswordEditor.setLabel(constants.hostsPopupUseCommonPassword());
    commonPasswordEditor.setLabel(constants.hostsPopupRootPassword());
    applyPasswordButton.setLabel(constants.hostsPopupApply());
    configureFirewallEditor.setLabel(constants.configureFirewallForAllHostsOfThisCluster());
}
#end_block

#method_before
@Override
public void edit(final MultipleHostsModel object) {
    hostsTable.asEditor().edit(object.getHosts());
    driver.edit(object);
    applyPasswordButton.setCommand(object.getApplyPasswordCommand());
    enableFirewallEditor.asCheckBox().addClickListener(new ClickListener() {

        @Override
        public void onClick(Widget sender) {
            MultipleHostsModel.setEnableFirewall(enableFirewallEditor.asCheckBox().isChecked());
        }
    });
}
#method_after
@Override
public void edit(final MultipleHostsModel object) {
    hostsTable.asEditor().edit(object.getHosts());
    driver.edit(object);
    applyPasswordButton.setCommand(object.getApplyPasswordCommand());
    configureFirewallEditor.asCheckBox().setChecked(true);
    configureFirewallEditor.asCheckBox().addClickListener(new ClickListener() {

        @Override
        public void onClick(Widget sender) {
            object.setConfigureFirewall(configureFirewallEditor.asCheckBox().isChecked());
        }
    });
}
#end_block

#method_before
public ValidationResult networkNameNotUsed() {
    for (Network otherNetwork : getNetworks()) {
        if (otherNetwork.getName().equals(network.getName()) && !otherNetwork.getId().equals(network.getId())) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NAME_IN_USE, String.format("$NetworkName %s", network.getName()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult networkNameNotUsed() {
    for (Network otherNetwork : getNetworks()) {
        if (otherNetwork.getName().equals(network.getName()) && !otherNetwork.getId().equals(network.getId())) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NAME_IN_USE, getNetworkNameReplacement());
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult notManagementNetwork() {
    return NetworkUtils.isManagementNetwork(network) ? new ValidationResult(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, String.format("$NetworkName %s", network.getName())) : ValidationResult.VALID;
}
#method_after
public ValidationResult notManagementNetwork() {
    return NetworkUtils.isManagementNetwork(network) ? new ValidationResult(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, getNetworkNameReplacement()) : ValidationResult.VALID;
}
#end_block

#method_before
public static String getNewNicName(List<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#method_after
public static String getNewNicName(Collection<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeProfileInfo, new GlusterVolumeProfileInfoVDSParameters(getParameters().getClusterId(), getUpServerId(getParameters().getClusterId()), getGlusterVolumeName(getParameters().getVolumeId()), ((GlusterVolumeProfileParameters) getParameters()).isNfs()));
    getQueryReturnValue().setReturnValue((((GlusterVolumeProfileParameters) getParameters()).isNfs()) ? (GlusterVolumeProfileInfo) returnValue.getReturnValue() : setBrickNames((GlusterVolumeProfileInfo) returnValue.getReturnValue()));
}
#method_after
@Override
protected void executeQueryCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeProfileInfo, new GlusterVolumeProfileInfoVDSParameters(getParameters().getClusterId(), getUpServerId(getParameters().getClusterId()), getGlusterVolumeName(getParameters().getVolumeId()), getParameters().isNfs()));
    GlusterVolumeProfileInfo profileInfo = (GlusterVolumeProfileInfo) returnValue.getReturnValue();
    if (!getParameters().isNfs()) {
        populateBrickNames(profileInfo);
    }
    getQueryReturnValue().setReturnValue(profileInfo);
}
#end_block

#method_before
@Override
public void publish(LogRecord record) {
    if (getExtension() != null) {
        extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Logger.InvokeCommands.PUBLISH).mput(Logger.InvokeKeys.LOG_RECORD, record));
    }
}
#method_after
@Override
public void publish(LogRecord record) {
    ExtMap publishInputMap = new ExtMap().mput(Base.InvokeKeys.COMMAND, Logger.InvokeCommands.PUBLISH).mput(Logger.InvokeKeys.LOG_RECORD, record);
    ExtMap publishOutputMap = new ExtMap();
    for (ExtensionProxy extension : extensions) {
        try {
            extension.invoke(publishInputMap, publishOutputMap);
        } catch (Exception ex) {
        // ignore, logging this exception will result in infinite loop
        }
    }
}
#end_block

#method_before
@Override
public void flush() {
}
#method_after
@Override
public void flush() {
    for (ExtensionProxy extension : extensions) {
        try {
            extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Logger.InvokeCommands.FLUSH), true, true);
        } catch (Exception ex) {
        // ignore, logging this exception will result in infinite loop
        }
    }
}
#end_block

#method_before
@Override
public void close() throws SecurityException {
    if (getExtension() != null) {
        extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Logger.InvokeCommands.CLOSE));
    }
}
#method_after
@Override
public void close() throws SecurityException {
    for (ExtensionProxy extension : extensions) {
        try {
            extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Logger.InvokeCommands.CLOSE), true, true);
        } catch (Exception ex) {
        // ignore, logging this exception will result in infinite loop
        }
    }
}
#end_block

#method_before
private void copyDiskDevicesFromTemplate() {
    Guid templateId = getParameters().getVmStaticData().getVmtGuid();
    List<VmDevice> disks = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(templateId, VmDeviceGeneralType.DISK);
    VmDeviceUtils.copyVmDevices(templateId, getVmId(), getVm(), getVm().getStaticData(), true, disks, getSrcDeviceIdToTargetDeviceIdMapping(), false, false, false, false, false);
}
#method_after
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vmDisksSource.getId(), VmDeviceGeneralType.DISK);
    VmDeviceUtils.copyVmDevices(vmDisksSource.getId(), getVmId(), getVm(), getVm().getStaticData(), true, disks, getSrcDeviceIdToTargetDeviceIdMapping(), false, false, false, false, false);
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    // Create authentication profiles for all the domains that exist in the database:
    // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
    createInternalAAAConfigurations();
    createKerberosLdapAAAConfigurations();
    ExtensionsManager.getInstance().dump();
    ExtensionsManager.getInstance().getGlobalContext().put(Base.GlobalContextKeys.APPLICATION_NAME, Base.ApplicationName.ENGINE);
    AuthenticationProfileRepository.getInstance();
    DbUserCacheManager.getInstance().init();
    AsyncTaskManager.getInstance().initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
}
#method_after
@Override
@PostConstruct
public void create() {
    // Create authentication profiles for all the domains that exist in the database:
    // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
    createInternalAAAConfigurations();
    createKerberosLdapAAAConfigurations();
    ExtensionsManager.getInstance().dump();
    ExtensionsManager.getInstance().getGlobalContext().put(Base.GlobalContextKeys.APPLICATION_NAME, Base.ApplicationName.ENGINE);
    AuthenticationProfileRepository.getInstance();
    DbUserCacheManager.getInstance().init();
    AsyncTaskManager.getInstance().initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
    // Initialize Power Management Health Check
    PmHealthCheckManager.getInstance().initialize();
}
#end_block

#method_before
public void initialize() {
    log.info("Start initializing " + getClass().getSimpleName());
    if (Config.<Boolean>getValue(ConfigValues.PMHealthCheckEnabled)) {
        Integer pmHealthCheckInterval = Config.<Integer>getValue(ConfigValues.PMHealthCheckIntervalInSec);
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "pmHealthCheck", new Class[] {}, new Object[] {}, pmHealthCheckInterval, pmHealthCheckInterval, TimeUnit.SECONDS);
    }
    log.info("Finished initializing " + getClass().getSimpleName());
}
#method_after
public void initialize() {
    if (Config.<Boolean>getValue(ConfigValues.PMHealthCheckEnabled)) {
        log.info("Start initializing " + getClass().getSimpleName());
        Integer pmHealthCheckInterval = Config.<Integer>getValue(ConfigValues.PMHealthCheckIntervalInSec);
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "pmHealthCheck", new Class[] {}, new Object[] {}, pmHealthCheckInterval, pmHealthCheckInterval, TimeUnit.SECONDS);
        log.info("Finished initializing " + getClass().getSimpleName());
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("pmHealthCheck")
public void pmHealthCheck() {
    // skip PM health check if previous operation is not complete yet
    if (!inWork) {
        synchronized (instance) {
            List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
            for (VDS host : hosts) {
                if (host.getpm_enabled()) {
                    boolean hasSecondary = (host.getPmSecondaryIp() != null && !host.getPmSecondaryIp().isEmpty());
                    boolean isConcurrent = host.isPmSecondaryConcurrent();
                    FenceExecutor executor = new FenceExecutor(host, FenceActionType.Status);
                    if (executor.findProxyHost() && executor.fence(FenceAgentOrder.Primary).getSucceeded()) {
                        removeAlarm(host.getId(), isConcurrent, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_CON_PRIMARY_AGENT, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_SEQ_PRIMARY_AGENT);
                        if (hasSecondary) {
                            if (executor.findProxyHost() && executor.fence(FenceAgentOrder.Secondary).getSucceeded()) {
                                removeAlarm(host.getId(), isConcurrent, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_CON_SECONDARY_AGENT, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_SEQ_SECONDARY_AGENT);
                            } else {
                                addAlarm(host.getId(), isConcurrent, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_CON_SECONDARY_AGENT, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_SEQ_SECONDARY_AGENT);
                            }
                        }
                    } else {
                        addAlarm(host.getId(), isConcurrent, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_CON_PRIMARY_AGENT, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_SEQ_PRIMARY_AGENT);
                    }
                }
            }
            inWork = false;
        }
    }
}
#method_after
@OnTimerMethodAnnotation("pmHealthCheck")
public void pmHealthCheck() {
    // skip PM health check if previous operation is not completed yet
    if (!active) {
        try {
            synchronized (instance) {
                log.info("Power Management Health Check started.");
                active = true;
                List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
                for (VDS host : hosts) {
                    if (host.getpm_enabled()) {
                        boolean hasSecondary = (host.getPmSecondaryIp() != null && !host.getPmSecondaryIp().isEmpty());
                        boolean isConcurrent = host.isPmSecondaryConcurrent();
                        FenceExecutor executor = new FenceExecutor(host, FenceActionType.Status);
                        if (executor.findProxyHost() && executor.fence(FenceAgentOrder.Primary).getSucceeded()) {
                            removeAlarm(host.getId(), isConcurrent, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_CON_PRIMARY_AGENT, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_SEQ_PRIMARY_AGENT);
                            if (hasSecondary) {
                                if (executor.findProxyHost() && executor.fence(FenceAgentOrder.Secondary).getSucceeded()) {
                                    removeAlarm(host.getId(), isConcurrent, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_CON_SECONDARY_AGENT, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_SEQ_SECONDARY_AGENT);
                                } else {
                                    addAlarm(host.getId(), isConcurrent, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_CON_SECONDARY_AGENT, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_SEQ_SECONDARY_AGENT);
                                }
                            }
                        } else {
                            addAlarm(host.getId(), isConcurrent, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_CON_PRIMARY_AGENT, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FAILED_FOR_SEQ_PRIMARY_AGENT);
                        }
                    }
                }
                log.info("Power Management Health Check completed.");
            }
        } finally {
            active = false;
        }
    }
}
#end_block

#method_before
private String readPasswordFile(String passwordFile) throws FileNotFoundException, IOException {
    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(passwordFile))) {
        String readLine = bufferedReader.readLine();
        return readLine;
    }
}
#method_after
private String readPasswordFile(String passwordFile) throws FileNotFoundException, IOException {
    try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(passwordFile), "UTF-8"))) {
        String readLine = bufferedReader.readLine();
        return readLine;
    }
}
#end_block

#method_before
@Override
public void adjustUserName(LdapProviderType ldapProviderType) {
    StringBuilder userDNSb = new StringBuilder();
    if (ldapProviderType.equals(LdapProviderType.activeDirectory)) {
        userDNSb.append("CN=").append(userName).append(",CN=Users");
    } else if (ldapProviderType.equals(LdapProviderType.rhds) || ldapProviderType.equals(LdapProviderType.openLdap)) {
        userDNSb.append("uid=").append(userName).append(",ou=People");
    } else {
        userDNSb.append("uid=").append(userName).append(",cn=Users").append(",cn=Accounts");
    }
    if (baseDN != null && !baseDN.isEmpty()) {
        String dcDN = getDcDN(baseDN);
        if (!dcDN.isEmpty()) {
            userDNSb.append(",").append(dcDN);
        }
    }
    userName = userDNSb.toString();
}
#method_after
@Override
public void adjustUserName(LdapProviderType ldapProviderType) {
    StringBuilder userDNSb = new StringBuilder();
    if (ldapProviderType.equals(LdapProviderType.activeDirectory)) {
        userDNSb.append("CN=").append(userName).append(",CN=Users");
    } else if (ldapProviderType.equals(LdapProviderType.rhds) || ldapProviderType.equals(LdapProviderType.openLdap)) {
        userDNSb.append("uid=").append(userName).append(",ou=People");
    } else {
        userDNSb.append("uid=").append(userName).append(",cn=Users").append(",cn=Accounts");
    }
    if (StringUtils.isNotEmpty(baseDN)) {
        String dcDN = getDcDN(baseDN);
        if (!dcDN.isEmpty()) {
            userDNSb.append(",").append(dcDN);
        }
    }
    userName = userDNSb.toString();
}
#end_block

#method_before
@Override
public Object run() {
    Hashtable env = new Hashtable(11);
    env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    env.put("java.naming.ldap.attributes.binary", "objectGUID");
    env.put(Context.SECURITY_AUTHENTICATION, "GSSAPI");
    env.put("javax.security.sasl.qop", "auth-conf");
    // Send an SRV record DNS query to retrieve all the LDAP servers in the domain
    LdapSRVLocator locator = new LdapSRVLocator();
    if (ldapServers == null) {
        try {
            ldapServers = locator.getServersList(locator.getLdapServers(domainName));
        } catch (Exception ex) {
            return KerberosUtils.convertDNSException(ex);
        }
    }
    DirContext ctx = null;
    String currentLdapServer = null;
    if (ldapServers == null || ldapServers.size() == 0) {
        return AuthenticationResult.CANNOT_FIND_LDAP_SERVER_FOR_DOMAIN;
    }
    // Goes over all the retrieved LDAP servers
    for (String address : ldapServers) {
        try {
            // Constructs an LDAP url in a format of ldap://hostname:port (based on the data in the SRV record
            // This URL is not enough in order to query for user - as for querying users, we should also provide a
            // base dn, for example: ldap://hostname:389/DC=abc,DC=com . However, this URL (ldap:hostname:port)
            // suffices for
            // getting the rootDSE information, which includes the baseDN.
            URI uri = locator.constructURI("LDAP", address, defaultLdapServerPort);
            env.put(Context.PROVIDER_URL, uri.toString());
            try {
                ctx = new InitialDirContext(env);
                // Get the base DN from rootDSE
                String domainDN = getDomainDN(ctx);
                if (domainDN != null) {
                    // Append the base DN to the ldap URL in order to construct a full ldap URL (in form of
                    // ldap:hostname:port/baseDN ) to query for the user
                    StringBuilder ldapQueryPath = new StringBuilder(uri.toString());
                    ldapQueryPath.append("/").append(domainDN);
                    SearchControls controls = new SearchControls();
                    controls.setSearchScope(SearchControls.SUBTREE_SCOPE);
                    // Adding all the three attributes possible, as RHDS doesn't return the nsUniqueId by default
                    controls.setReturningAttributes(new String[] { "nsUniqueId", "ipaUniqueId", "objectGuid", "uniqueIdentifier", "entryuuid" });
                    // Added this in order to prevent a warning saying:
                    // "the returning obj flag wasn't set, setting it to true"
                    controls.setReturningObjFlag(true);
                    currentLdapServer = ldapQueryPath.toString();
                    env.put(Context.PROVIDER_URL, currentLdapServer);
                    // Run the LDAP query to get the user
                    ctx = new InitialDirContext(env);
                    NamingEnumeration<SearchResult> answer = executeQuery(ctx, controls, prepareQuery());
                    if (answer.hasMoreElements()) {
                        // Print the objectGUID for the user as well as URI and query path
                        String guid = guidFromResults(answer.next());
                        if (guid != null) {
                            userGuid.append(guid);
                            logQueryContext(userGuid.toString(), uri.toString(), currentLdapServer);
                            return AuthenticationResult.OK;
                        }
                    }
                    // Print user GUID and another logging info only if it was not printed previously already
                    logQueryContext(userGuid.toString(), uri.toString(), currentLdapServer);
                    System.out.println("No user in Directory was found for " + userName + ". Trying next LDAP server in list");
                } else {
                    System.out.println(InstallerConstants.ERROR_PREFIX + " Failed to query rootDSE in order to get the baseDN. Could not query for user " + userName + " in domain " + domainName);
                }
            } finally {
                if (ctx != null) {
                    ctx.close();
                }
            }
        } catch (CommunicationException ex) {
            handleCommunicationException(currentLdapServer, address);
        } catch (AuthenticationException ex) {
            handleAuthenticationException(ex);
        } catch (NegativeArraySizeException ex) {
            log.error("Internal Kerberos error.", ex);
            return AuthenticationResult.INTERNAL_KERBEROS_ERROR;
        } catch (Exception ex) {
            handleGeneralException(ex);
            break;
        } finally {
            if (ctx != null) {
                try {
                    ctx.close();
                } catch (Exception exception) {
                    log.warn("Unexpected exception while closing LDAP context.", exception);
                }
            }
        }
    }
    return AuthenticationResult.NO_USER_INFORMATION_WAS_FOUND_FOR_USER;
}
#method_after
@Override
public Object run() {
    Hashtable env = new Hashtable(11);
    env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    env.put("java.naming.ldap.attributes.binary", "objectGUID");
    env.put(Context.SECURITY_AUTHENTICATION, "GSSAPI");
    env.put("javax.security.sasl.qop", "auth-conf");
    // Send an SRV record DNS query to retrieve all the LDAP servers in the domain
    LdapSRVLocator locator = new LdapSRVLocator();
    if (ldapServers == null) {
        try {
            ldapServers = locator.getServersList(locator.getLdapServers(domainName));
        } catch (Exception ex) {
            return KerberosUtils.convertDNSException(ex);
        }
    }
    String currentLdapServer = null;
    if (ldapServers == null || ldapServers.size() == 0) {
        return AuthenticationResult.CANNOT_FIND_LDAP_SERVER_FOR_DOMAIN;
    }
    // Goes over all the retrieved LDAP servers
    for (String address : ldapServers) {
        DirContext ctx = null;
        try {
            // Constructs an LDAP url in a format of ldap://hostname:port (based on the data in the SRV record
            // This URL is not enough in order to query for user - as for querying users, we should also provide a
            // base dn, for example: ldap://hostname:389/DC=abc,DC=com . However, this URL (ldap:hostname:port)
            // suffices for
            // getting the rootDSE information, which includes the baseDN.
            URI uri = locator.constructURI("LDAP", address, defaultLdapServerPort);
            try {
                // Get the base DN from rootDSE
                env.put(Context.PROVIDER_URL, uri.toString());
                String domainDN = getDomainDN(uri.toString());
                if (domainDN != null) {
                    // Append the base DN to the ldap URL in order to construct a full ldap URL (in form of
                    // ldap:hostname:port/baseDN ) to query for the user
                    StringBuilder ldapQueryPath = new StringBuilder(uri.toString());
                    ldapQueryPath.append("/").append(domainDN);
                    SearchControls controls = new SearchControls();
                    controls.setSearchScope(SearchControls.SUBTREE_SCOPE);
                    // Adding all the three attributes possible, as RHDS doesn't return the nsUniqueId by default
                    controls.setReturningAttributes(new String[] { "nsUniqueId", "ipaUniqueId", "objectGuid", "uniqueIdentifier", "entryuuid" });
                    // Added this in order to prevent a warning saying:
                    // "the returning obj flag wasn't set, setting it to true"
                    controls.setReturningObjFlag(true);
                    currentLdapServer = ldapQueryPath.toString();
                    env.put(Context.PROVIDER_URL, currentLdapServer);
                    // Run the LDAP query to get the user
                    ctx = new InitialDirContext(env);
                    NamingEnumeration<SearchResult> answer = executeQuery(ctx, controls, prepareQuery());
                    if (answer.hasMoreElements()) {
                        // Print the objectGUID for the user as well as URI and query path
                        String guid = guidFromResults(answer.next());
                        if (guid != null) {
                            userGuid.append(guid);
                            logQueryContext(userGuid.toString(), uri.toString(), currentLdapServer);
                            return AuthenticationResult.OK;
                        }
                    }
                    // Print user GUID and another logging info only if it was not printed previously already
                    logQueryContext(userGuid.toString(), uri.toString(), currentLdapServer);
                    System.out.println("No user in Directory was found for " + userName + ". Trying next LDAP server in list");
                } else {
                    System.out.println(InstallerConstants.ERROR_PREFIX + " Failed to query rootDSE in order to get the baseDN. Could not query for user " + userName + " in domain " + domainName);
                }
            } finally {
                if (ctx != null) {
                    ctx.close();
                }
            }
        } catch (CommunicationException ex) {
            handleCommunicationException(currentLdapServer, address);
        } catch (AuthenticationException ex) {
            handleAuthenticationException(ex);
        } catch (NegativeArraySizeException ex) {
            log.error("Internal Kerberos error.", ex);
            return AuthenticationResult.INTERNAL_KERBEROS_ERROR;
        } catch (Exception ex) {
            handleGeneralException(ex);
            break;
        }
    }
    return AuthenticationResult.NO_USER_INFORMATION_WAS_FOUND_FOR_USER;
}
#end_block

#method_before
private String getDomainDN(DirContext ctx) throws NamingException {
    RootDSEData rootDSEData = new RootDSEData(ctx);
    return rootDSEData.getDomainDN();
}
#method_after
private String getDomainDN(String url) throws NamingException {
    RootDSEData rootDSEData = new RootDSEData(url);
    return rootDSEData.getDomainDN();
}
#end_block

#method_before
public <T> T get(ExtKey key, Class<T> type, T defaultValue) {
    if (!type.isAssignableFrom(key.getType())) {
        throw new IllegalArgumentException(String.format("Cannnot assign key '%s' into type '%s'", key, type));
    }
    if (defaultValue != null && !defaultValue.getClass().isAssignableFrom(key.getType())) {
        throw new IllegalArgumentException(String.format("Cannnot assign default value of '%s' into type '%s'", defaultValue.getClass(), key));
    }
    T value = type.cast(map.get(key));
    if (value == null) {
        value = defaultValue;
    }
    return value;
}
#method_after
public <T> T get(ExtKey key, Class<T> type, T defaultValue) {
    if (!key.getType().isAssignableFrom(type)) {
        throw new IllegalArgumentException(String.format("Cannnot assign key '%s' into type '%s'", key, type));
    }
    if (defaultValue != null && !key.getType().isAssignableFrom(defaultValue.getClass())) {
        throw new IllegalArgumentException(String.format("Cannnot assign default value of '%s' into type '%s'", defaultValue.getClass(), key));
    }
    T value = type.cast(map.get(key));
    if (value == null) {
        value = defaultValue;
    }
    return value;
}
#end_block

#method_before
@Override
public void initialize() {
    lockObj.writeLock().lock();
    try {
        log.infoFormat("{0}: Start initializing", instanceId());
        if (!"".equals(ranges)) {
            try {
                initRanges(ranges);
            } catch (MacPoolExceededMaxException e) {
                log.errorFormat("{0}: MAC Pool range exceeded maximum number of mac pool addresses ({1}). " + "Please check Mac Pool configuration.", instanceId(), maxMacsInPool);
            }
        }
        List<VmNic> interfaces = getVmNicInterfacesFromDB();
        for (VmNic iface : interfaces) {
            forceAddMac(iface.getMacAddress());
        }
        initialized = true;
        log.infoFormat("{0}: Finished initializing. Available MACs in pool: {1}", instanceId(), availableMacs.size());
    } catch (Exception ex) {
        log.errorFormat(INIT_ERROR_MSG, instanceId(), ex);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public void initialize() {
    lockObj.writeLock().lock();
    try {
        log.infoFormat("{0}: Start initializing", instanceId());
        if (!"".equals(ranges)) {
            try {
                initRanges(ranges);
            } catch (MacPoolExceededMaxException e) {
                log.errorFormat("{0}: MAC Pool range exceeded maximum number of mac pool addresses ({1}). " + "Please check Mac Pool configuration.", instanceId(), maxMacsInPool);
            }
        }
        List<VmNic> interfaces = getVmNicsFromDB();
        for (VmNic iface : interfaces) {
            forceAddMac(iface.getMacAddress());
        }
        initialized = true;
        log.infoFormat("{0}: Finished initializing. Available MACs in pool: {1}", instanceId(), availableMacs.size());
    } catch (Exception ex) {
        log.errorFormat(INIT_ERROR_MSG, instanceId(), ex);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
private void initRanges(String ranges) {
    String[] rangesArray = ranges.split("[,]", -1);
    for (String range : rangesArray) {
        String[] startendArray = range.split("[-]", -1);
        if (startendArray.length == 2) {
            if (!initRange(startendArray[0], startendArray[1])) {
                log.errorFormat("{0}: Failed to initialize Mac Pool range. Please fix Mac Pool range: {1}", instanceId(), range);
            }
        } else {
            log.errorFormat("{0}: Failed to initialize Mac Pool range. Please fix Mac Pool range: {1}", instanceId(), range);
        }
    }
    if (availableMacs.isEmpty()) {
        throw new VdcBLLException(VdcBllErrors.MAC_POOL_INITIALIZATION_FAILED);
    }
}
#method_after
private void initRanges(String ranges) {
    String[] rangesArray = ranges.split("[,]", -1);
    for (String range : rangesArray) {
        String[] startendArray = range.split("[-]", -1);
        if (startendArray.length == 2) {
            initRange(startendArray[0], startendArray[1]);
        } else {
            log.errorFormat("{0}: Failed to initialize Mac Pool range. Please fix Mac Pool range: {1}", instanceId(), range);
        }
    }
    if (availableMacs.isEmpty()) {
        throw new VdcBLLException(VdcBllErrors.MAC_POOL_INITIALIZATION_FAILED);
    }
}
#end_block

#method_before
private boolean initRange(String start, String end) {
    List<String> macAddresses = MacAddressRangeUtils.initRange(start, end, maxMacsInPool);
    if (macAddresses.size() + availableMacs.size() > maxMacsInPool) {
        availableMacs.addAll(macAddresses.subList(0, maxMacsInPool - availableMacs.size()));
        // TODO MM: what's this?  why returning boolean value then?
        throw new MacPoolExceededMaxException();
    } else {
        availableMacs.addAll(macAddresses);
        // System.out.println("!!"+availableMacs.size());
        return true;
    }
}
#method_after
private void initRange(String start, String end) {
    List<String> macAddresses = MacAddressRangeUtils.initRange(start, end, maxMacsInPool);
    if (macAddresses.size() + availableMacs.size() > maxMacsInPool) {
        availableMacs.addAll(macAddresses.subList(0, maxMacsInPool - availableMacs.size()));
        log.errorFormat("{0}: Failed to initialize Mac Pool range. Please fix Mac Pool range: <{1}, {2}>", instanceId(), start, end);
        throw new MacPoolExceededMaxException();
    } else {
        availableMacs.addAll(macAddresses);
    }
}
#end_block

#method_before
private boolean addMacToMap(Map<String, Integer> macMap, String mac) {
    if (!macMap.containsKey(mac)) {
        macMap.put(mac, 1);
        return true;
    } else if ((boolean) allowDuplicates) {
        incrementMacInMap(macMap, mac);
        return true;
    }
    return false;
}
#method_after
private boolean addMacToMap(Map<String, Integer> macMap, String mac) {
    if (!macMap.containsKey(mac)) {
        macMap.put(mac, 1);
        return true;
    } else if (allowDuplicates) {
        incrementMacInMap(macMap, mac);
        return true;
    }
    return false;
}
#end_block

#method_before
public boolean add(T key) {
    ModifiableInteger counter = map.get(key);
    if (counter == null) {
        map.put(key, new ModifiableInteger(1));
        return true;
    } else if (allowDuplicate) {
        counter.increment();
        return true;
    } else {
        return false;
    }
}
#method_after
public boolean add(T key) {
    Counter counter = map.get(key);
    if (counter == null) {
        map.put(key, new Counter());
        return true;
    } else if (allowDuplicate) {
        counter.increment();
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean remove(T key) {
    ModifiableInteger counter = map.get(key);
    if (counter == null) {
        // key was not there! So it was not removed.
        return false;
    }
    int count = counter.decrement();
    if (count == 0) {
        map.remove(key);
        // key was removed;
        return true;
    } else if (count < 0) {
        log.warn("count underflow.");
        map.remove(key);
        // key was removed.
        return true;
    }
    // key is still present with lessened count.
    return false;
}
#method_after
public void remove(T key) {
    Counter counter = map.get(key);
    if (counter == null) {
        return;
    }
    int count = counter.decrement();
    if (count == 0) {
        map.remove(key);
    } else if (count < 0) {
        throw new IllegalStateException("count underflow.");
    }
}
#end_block

#method_before
private static List<String> innerInitRange(int stopAfter, long startNum, long endNum) {
    if (startNum > endNum) {
        return Collections.emptyList();
    }
    // initialize ArrayList for all potential records. (ignore that there need not be that many records.
    List<String> macAddresses = new ArrayList<>(stopAfter);
    for (long i = startNum; i <= endNum; i++) {
        if ((MAC_ADDRESS_MULTICAST_BIT & i) != 0) {
            continue;
        }
        macAddresses.add(macAddressIntToString(i));
        if (stopAfter-- <= 0) {
            return macAddresses;
        }
    }
    // do a copy to reduce array length (array stored in ArrayList impl.)
    return new ArrayList<>(macAddresses);
}
#method_after
private static List<String> innerInitRange(int stopAfter, long startNum, long endNum) {
    if (startNum > endNum) {
        return Collections.emptyList();
    }
    // Initialize ArrayList for all potential records. (ignore that there need not be that many records.
    List<String> macAddresses = new ArrayList<>(Math.min(stopAfter, (int) (endNum - startNum)));
    for (long i = startNum; i <= endNum; i++) {
        if ((MAC_ADDRESS_MULTICAST_BIT & i) != 0) {
            continue;
        }
        macAddresses.add(macToString(i));
        if (stopAfter-- <= 0) {
            return macAddresses;
        }
    }
    return macAddresses;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = checkStoragePool();
    _oldStoragePool = getStoragePoolDAO().get(getStoragePool().getId());
    if (returnValue && !StringUtils.equals(_oldStoragePool.getName(), getStoragePool().getName()) && !isStoragePoolUnique(getStoragePool().getName())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    }
    if (returnValue && _oldStoragePool.isLocal() != getStoragePool().isLocal() && getStorageDomainStaticDAO().getAllForStoragePool(getStoragePool().getId()).size() > 0) {
        returnValue = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_POOL_TYPE_WITH_DOMAINS.toString());
    }
    returnValue = returnValue && checkStoragePoolNameLengthValid();
    if (returnValue && !_oldStoragePool.getcompatibility_version().equals(getStoragePool().getcompatibility_version())) {
        if (!isStoragePoolVersionSupported()) {
            addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
            returnValue = false;
        } else // decreasing of compatibility version is not allowed
        if (getStoragePool().getcompatibility_version().compareTo(_oldStoragePool.getcompatibility_version()) < 0) {
            if (!getVdsDAO().getAllForStoragePool(getStoragePoolId()).isEmpty()) {
                returnValue = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
            }
            if (returnValue) {
                List<Network> networks = getNetworkDAO().getAllForDataCenter(getStoragePoolId());
                if (networks != null && !networks.isEmpty()) {
                    Network network = networks.get(0);
                    NetworkValidator validator = getNetworkValidator(network);
                    if (networks.size() != 1 || !NetworkUtils.isManagementNetwork(networks.get(0)) || !validator.vmNetworkSetCorrectly().isValid() || !validator.mtuValid().isValid()) {
                        returnValue = false;
                        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
                    }
                }
            }
        } else {
            // Check all clusters has at least the same compatibility version.
            returnValue = checkAllClustersLevel();
        }
    }
    StoragePoolValidator validator = createStoragePoolValidator();
    if (returnValue) {
        returnValue = validate(validator.isNotLocalfsWithDefaultCluster());
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = checkStoragePool();
    _oldStoragePool = getStoragePoolDAO().get(getStoragePool().getId());
    if (returnValue && !StringUtils.equals(_oldStoragePool.getName(), getStoragePool().getName()) && !isStoragePoolUnique(getStoragePool().getName())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    }
    if (returnValue && _oldStoragePool.isLocal() != getStoragePool().isLocal() && getStorageDomainStaticDAO().getAllForStoragePool(getStoragePool().getId()).size() > 0) {
        returnValue = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_POOL_TYPE_WITH_DOMAINS.toString());
    }
    returnValue = returnValue && checkStoragePoolNameLengthValid();
    if (returnValue && !_oldStoragePool.getcompatibility_version().equals(getStoragePool().getcompatibility_version())) {
        if (!isStoragePoolVersionSupported()) {
            addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
            returnValue = false;
        } else // decreasing of compatibility version is allowed under conditions
        if (getStoragePool().getcompatibility_version().compareTo(_oldStoragePool.getcompatibility_version()) < 0) {
            List<Network> networks = getNetworkDAO().getAllForDataCenter(getStoragePoolId());
            if (networks.size() == 1) {
                Network network = networks.get(0);
                NetworkValidator validator = getNetworkValidator(network);
                validator.setDataCenter(getStoragePool());
                if (!NetworkUtils.isManagementNetwork(network) || !validator.canNetworkCompatabilityBeDecreased()) {
                    returnValue = false;
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
                }
            } else if (networks.size() > 1) {
                returnValue = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
            }
        } else {
            // Check all clusters has at least the same compatibility version.
            returnValue = checkAllClustersLevel();
        }
    }
    StoragePoolValidator validator = createStoragePoolValidator();
    if (returnValue) {
        returnValue = validate(validator.isNotLocalfsWithDefaultCluster());
    }
    return returnValue;
}
#end_block

#method_before
@Test
public void lowerVersionHostsNoNetwork() {
    storagePoolWithLowerVersion();
    addNonDefaultClusterToPool();
    addHostsToCluster();
    canDoActionFailed(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION.toString());
}
#method_after
@Test
public void lowerVersionHostsNoNetwork() {
    storagePoolWithLowerVersion();
    addNonDefaultClusterToPool();
    addHostsToCluster();
    assertTrue(cmd.canDoAction());
}
#end_block

#method_before
private void setupNetworkValidator(boolean valid) {
    NetworkValidator validator = Mockito.mock(NetworkValidator.class);
    if (valid) {
        when(validator.mtuValid()).thenReturn(ValidationResult.VALID);
        when(validator.vmNetworkSetCorrectly()).thenReturn(ValidationResult.VALID);
    } else {
        when(validator.mtuValid()).thenReturn(new ValidationResult(VdcBllMessages.NETWORK_BOND_NOT_EXISTS));
        when(validator.vmNetworkSetCorrectly()).thenReturn(new ValidationResult(VdcBllMessages.NETWORK_BOND_NOT_EXISTS));
    }
    when(cmd.getNetworkValidator(any(Network.class))).thenReturn(validator);
}
#method_after
private void setupNetworkValidator(boolean valid) {
    NetworkValidator validator = Mockito.mock(NetworkValidator.class);
    when(validator.canNetworkCompatabilityBeDecreased()).thenReturn(valid);
    when(cmd.getNetworkValidator(any(Network.class))).thenReturn(validator);
}
#end_block

#method_before
private void updateLatestStatus(GlusterVolumeTaskStatusEntity status) {
    GlusterAsyncTask asyncTask = volume.getAsyncTask();
    if (asyncTask != null && asyncTask.getTaskId() != null) {
        GlusterTaskParameters taskParameters = new GlusterTaskParameters();
        taskParameters.setVolumeName(volume.getName());
        asyncTask.setTaskParameters(taskParameters);
        List<Step> stepsList = getStepDao().getStepsByExternalId(asyncTask.getTaskId());
        if (stepsList != null && !stepsList.isEmpty() && stepsList.get(0).getEndTime() != null) {
            // if job has already ended, do not update status.
            asyncTask.setStatus(status.getStatusSummary().getStatus());
            asyncTask.setMessage(GlusterTaskUtils.getInstance().getSummaryMessage(status.getStatusSummary()));
            getGlusterTaskUtils().updateSteps(getClusterDao().get(clusterId), asyncTask, stepsList);
        }
        // release the volume lock if the task is completed
        if (getGlusterTaskUtils().hasTaskCompleted(asyncTask)) {
            getGlusterTaskUtils().releaseLock(volume.getId());
        }
    }
}
#method_after
private void updateLatestStatus(GlusterVolumeTaskStatusEntity status) {
    GlusterAsyncTask asyncTask = volume.getAsyncTask();
    if (asyncTask != null && asyncTask.getTaskId() != null) {
        GlusterTaskParameters taskParameters = new GlusterTaskParameters();
        taskParameters.setVolumeName(volume.getName());
        asyncTask.setTaskParameters(taskParameters);
        List<Step> stepsList = getStepDao().getStepsByExternalId(asyncTask.getTaskId());
        // if step has already ended, do not update status.
        if (stepsList != null && !stepsList.isEmpty() && stepsList.get(0).getEndTime() != null) {
            asyncTask.setStatus(status.getStatusSummary().getStatus());
            asyncTask.setMessage(GlusterTaskUtils.getInstance().getSummaryMessage(status.getStatusSummary()));
            getGlusterTaskUtils().updateSteps(getClusterDao().get(clusterId), asyncTask, stepsList);
            // release the volume lock if the task is completed
            if (getGlusterTaskUtils().hasTaskCompleted(asyncTask)) {
                getGlusterTaskUtils().releaseLock(volume.getId());
            }
        }
    }
}
#end_block

#method_before
private synchronized void loadImpl(Properties props, File confFile) {
    ExtensionEntry entry = new ExtensionEntry(props, confFile);
    ExtensionEntry alreadyLoadedEntry = loadedEntries.get(entry.name);
    if (alreadyLoadedEntry != null) {
        throw new ConfigurationException(String.format("Could not load the configuration '%1$s' from file %2$s. A configuration with the same name was already loaded from file %3$s", entry.name, entry.getFileName(), alreadyLoadedEntry.getFileName()));
    }
    loadedEntries.put(entry.name, entry);
    notifyObservers();
    entry.enabled = EngineLocalConfig.getInstance().getBoolean(ENGINE_EXTENSION_ENABLED + entry.name, entry.enabled);
    // Activate the extension
    if (entry.enabled && entry.extension == null) {
        try {
            entry.extension = new ExtensionProxy(loadExtension(props), (new ExtMap().mput(Base.ContextKeys.GLOBAL_CONTEXT, globalContext).mput(TRACE_LOG_CONTEXT_KEY, traceLog).mput(Base.ContextKeys.INTERFACE_VERSION_MIN, 0).mput(Base.ContextKeys.INTERFACE_VERSION_MAX, Base.INTERFACE_VERSION_CURRENT).mput(Base.ContextKeys.LOCALE, Locale.getDefault().toString()).mput(Base.ContextKeys.CONFIGURATION, props).mput(Base.ContextKeys.CONFIGURATION_SENSITIVE_KEYS, splitString(props.getProperty(Base.ConfigKeys.SENSITIVE_KEYS, ""))).mput(Base.ContextKeys.INSTANCE_NAME, entry.name).mput(Base.ContextKeys.PROVIDES, splitString(props.getProperty(Base.ConfigKeys.PROVIDES, "")))));
            ExtMap output = entry.extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Base.InvokeCommands.INITIALIZE));
            entry.extension.getContext().put(TRACE_LOG_CONTEXT_KEY, LoggerFactory.getLogger(String.format("%1$s.%2$s.%3$s", traceLog.getName(), entry.extension.getContext().get(Base.ContextKeys.EXTENSION_NAME), entry.extension.getContext().get(Base.ContextKeys.INSTANCE_NAME))));
            globalContext.<List<ExtMap>>get(Base.GlobalContextKeys.EXTENSIONS).add(new ExtMap().mput(Base.ExtensionRecord.INSTANCE_NAME, entry.extension.getContext().get(Base.ContextKeys.INSTANCE_NAME)).mput(Base.ExtensionRecord.PROVIDES, entry.extension.getContext().get(Base.ContextKeys.PROVIDES)).mput(Base.ExtensionRecord.EXTENSION, entry.extension.getExtension()).mput(Base.ExtensionRecord.CONTEXT, entry.extension.getContext()));
            entry.activated = true;
            dumpConfig(entry.extension);
        } catch (Exception ex) {
            log.error(String.format("Error in activating extension %1$s. Exception message is %2$s", entry.name, ex.getMessage()));
            if (log.isDebugEnabled()) {
                log.error(ex.toString(), ex);
            }
        }
    }
}
#method_after
private synchronized void loadImpl(Properties props, File confFile) {
    ExtensionEntry entry = new ExtensionEntry(props, confFile);
    ExtensionEntry alreadyLoadedEntry = loadedEntries.get(entry.name);
    if (alreadyLoadedEntry != null) {
        throw new ConfigurationException(String.format("Could not load the configuration '%1$s' from file %2$s. A configuration with the same name was already loaded from file %3$s", entry.name, entry.getFileName(), alreadyLoadedEntry.getFileName()));
    }
    loadedEntries.put(entry.name, entry);
    entry.enabled = EngineLocalConfig.getInstance().getBoolean(ENGINE_EXTENSION_ENABLED + entry.name, entry.enabled);
    // Activate the extension
    if (entry.enabled && entry.extension == null) {
        try {
            entry.extension = new ExtensionProxy(loadExtension(props), (new ExtMap().mput(Base.ContextKeys.GLOBAL_CONTEXT, globalContext).mput(TRACE_LOG_CONTEXT_KEY, traceLog).mput(Base.ContextKeys.INTERFACE_VERSION_MIN, 0).mput(Base.ContextKeys.INTERFACE_VERSION_MAX, Base.INTERFACE_VERSION_CURRENT).mput(Base.ContextKeys.LOCALE, Locale.getDefault().toString()).mput(Base.ContextKeys.CONFIGURATION, props).mput(Base.ContextKeys.CONFIGURATION_SENSITIVE_KEYS, splitString(props.getProperty(Base.ConfigKeys.SENSITIVE_KEYS, ""))).mput(Base.ContextKeys.INSTANCE_NAME, entry.name).mput(Base.ContextKeys.PROVIDES, splitString(props.getProperty(Base.ConfigKeys.PROVIDES, "")))));
            ExtMap output = entry.extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Base.InvokeCommands.INITIALIZE));
            entry.extension.getContext().put(TRACE_LOG_CONTEXT_KEY, LoggerFactory.getLogger(String.format("%1$s.%2$s.%3$s", traceLog.getName(), entry.extension.getContext().get(Base.ContextKeys.EXTENSION_NAME), entry.extension.getContext().get(Base.ContextKeys.INSTANCE_NAME))));
            globalContext.<List<ExtMap>>get(Base.GlobalContextKeys.EXTENSIONS).add(new ExtMap().mput(Base.ExtensionRecord.INSTANCE_NAME, entry.extension.getContext().get(Base.ContextKeys.INSTANCE_NAME)).mput(Base.ExtensionRecord.PROVIDES, entry.extension.getContext().get(Base.ContextKeys.PROVIDES)).mput(Base.ExtensionRecord.EXTENSION, entry.extension.getExtension()).mput(Base.ExtensionRecord.CONTEXT, entry.extension.getContext()));
            entry.activated = true;
            dumpConfig(entry.extension);
        } catch (Exception ex) {
            log.error(String.format("Error in activating extension %1$s. Exception message is %2$s", entry.name, ex.getMessage()));
            if (log.isDebugEnabled()) {
                log.error(ex.toString(), ex);
            }
        }
    }
    setChanged();
    notifyObservers();
}
#end_block

#method_before
@Override
public SafeHtml getValue() {
    return TEMPLATE.templatedValue(style.cellTableHeaderContent(), text);
}
#method_after
@Override
public SafeHtml getValue() {
    return TEMPLATE.templatedContent(style.cellTableHeaderContent(), text);
}
#end_block

#method_before
@Mapping(from = VDS.class, to = SELinux.class)
public static SELinux map(VDS entity, SELinux template) {
    SELinux model = template != null ? template : new SELinux();
    if (entity.getSELinuxEnforceMode() == null) {
        return model;
    }
    model.setMode(entity.getSELinuxEnforceMode().toString().toLowerCase());
    return model;
}
#method_after
@Mapping(from = VDS.class, to = SELinux.class)
public static SELinux map(VDS entity, SELinux template) {
    SELinux model = template != null ? template : new SELinux();
    if (entity.getSELinuxEnforceMode() == null) {
        return model;
    }
    String mode = null;
    switch(entity.getSELinuxEnforceMode()) {
        case DISABLED:
            mode = SELinuxMode.DISABLED.value();
            break;
        case PERMISSIVE:
            mode = SELinuxMode.PERMISSIVE.value();
            break;
        case ENFORCING:
            mode = SELinuxMode.ENFORCING.value();
    }
    model.setMode(mode);
    return model;
}
#end_block

#method_before
private void addSELinuxModes(VersionCaps version, SELinuxMode[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_5)) {
        version.setSelinuxModes(new SELinuxModes());
        for (SELinuxMode mode : values) {
            version.getSelinuxModes().getSELinuxModes().add(mode.toString().toLowerCase());
        }
    }
}
#method_after
private void addSELinuxModes(VersionCaps version, SELinuxMode[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_5)) {
        version.setSelinuxModes(new SELinuxModes());
        for (SELinuxMode mode : values) {
            version.getSelinuxModes().getSELinuxModes().add(mode.value());
        }
    }
}
#end_block

#method_before
public void makeSortable(String sortBy) {
    setSortable(true);
    this.sortBy = sortBy;
}
#method_after
public void makeSortable(String sortBy) {
    // $NON-NLS-1$
    assert sortBy != null : "sortBy cannot be null";
    this.sortBy = sortBy;
    this.comparator = null;
    setSortable(true);
}
#end_block

#method_before
public void makeSortable(String sortBy) {
    setSortable(true);
    this.sortBy = sortBy;
}
#method_after
public void makeSortable(Comparator<? super T> comparator) {
    // $NON-NLS-1$
    assert comparator != null : "comparator cannot be null";
    this.sortBy = null;
    this.comparator = comparator;
    setSortable(true);
}
#end_block

#method_before
protected void updateTableControls() {
    prevPageButton.setEnabled(getDataProvider().canGoBack());
    nextPageButton.setEnabled(getDataProvider().canGoForward());
}
#method_after
protected void updateTableControls() {
    prevPageButton.setEnabled(getDataProvider().canGoBack());
    nextPageButton.setEnabled(getDataProvider().canGoForward());
    // $NON-NLS-1$
    prevPageButton.addStyleName("prevPageButton_pfly_fix");
    // $NON-NLS-1$
    nextPageButton.addStyleName("nextPageButton_pfly_fix");
}
#end_block

#method_before
void initTable() {
    // Set up table data provider
    getDataProvider().addDataDisplay(table);
    // Set up sort handler
    initSortHandler();
    // Set up table selection model
    table.setSelectionModel(selectionModel);
    // Enable keyboard selection
    table.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.ENABLED);
    // Add arrow key handler
    table.addDomHandler(new KeyDownHandler() {

        @Override
        public void onKeyDown(KeyDownEvent event) {
            boolean shiftPageDown = event.isShiftKeyDown() && KeyCodes.KEY_PAGEDOWN == event.getNativeKeyCode();
            boolean shiftPageUp = event.isShiftKeyDown() && KeyCodes.KEY_PAGEUP == event.getNativeKeyCode();
            boolean ctrlA = event.isControlKeyDown() && ('a' == event.getNativeKeyCode() || 'A' == event.getNativeKeyCode());
            boolean arrow = KeyDownEvent.isArrow(event.getNativeKeyCode());
            if (shiftPageUp || shiftPageDown || ctrlA || arrow) {
                event.preventDefault();
                event.stopPropagation();
            } else {
                return;
            }
            if (shiftPageDown) {
                selectionModel.selectAllNext();
            } else if (shiftPageUp) {
                selectionModel.selectAllPrev();
            } else if (ctrlA) {
                selectionModel.selectAll();
            } else if (arrow) {
                selectionModel.setMultiSelectEnabled(event.isControlKeyDown() && !multiSelectionDisabled);
                selectionModel.setMultiRangeSelectEnabled(event.isShiftKeyDown() && !multiSelectionDisabled);
                if (event.isDownArrow()) {
                    selectionModel.selectNext();
                } else if (event.isUpArrow()) {
                    selectionModel.selectPrev();
                }
            }
        }
    }, KeyDownEvent.getType());
    // Add context menu handler for table widget
    addContextMenuHandler(tableContainer);
    // Use fixed table layout
    // $NON-NLS-1$
    setWidth("100%", true);
    // Attach table widget to the corresponding panel
    tableContainer.setWidget(table);
    tableHeaderContainer.setWidget(tableHeader);
    tableHeaderContainer.setVisible(isTableHeaderVisible());
    // Use relative positioning for tableHeader, in order to align it with main table
    tableHeader.getElement().getStyle().setPosition(Position.RELATIVE);
    // Attach scroll event handler to main table container, so that the tableHeader widget
    // can have its position aligned with main table container's current scroll position
    tableContainer.addDomHandler(new ScrollHandler() {

        @Override
        public void onScroll(ScrollEvent event) {
            tableContainerHorizontalScrollPosition = tableContainer.getElement().getScrollLeft();
            updateTableHeaderPosition();
        }
    }, ScrollEvent.getType());
    // Reset main table container's scroll position
    enforceScrollPosition();
}
#method_after
void initTable() {
    // Set up table data provider
    getDataProvider().addDataDisplay(table);
    // Set up sort handler
    initSortHandler();
    // Set up table selection model
    table.setSelectionModel(selectionModel);
    // Enable keyboard selection
    table.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.ENABLED);
    // Add arrow key handler
    table.addDomHandler(new KeyDownHandler() {

        @Override
        public void onKeyDown(KeyDownEvent event) {
            boolean shiftPageDown = event.isShiftKeyDown() && KeyCodes.KEY_PAGEDOWN == event.getNativeKeyCode();
            boolean shiftPageUp = event.isShiftKeyDown() && KeyCodes.KEY_PAGEUP == event.getNativeKeyCode();
            boolean ctrlA = event.isControlKeyDown() && ('a' == event.getNativeKeyCode() || 'A' == event.getNativeKeyCode());
            boolean arrow = KeyDownEvent.isArrow(event.getNativeKeyCode());
            if (shiftPageUp || shiftPageDown || ctrlA || arrow) {
                event.preventDefault();
                event.stopPropagation();
            } else {
                return;
            }
            if (shiftPageDown) {
                selectionModel.selectAllNext();
            } else if (shiftPageUp) {
                selectionModel.selectAllPrev();
            } else if (ctrlA) {
                selectionModel.selectAll();
            } else if (arrow) {
                selectionModel.setMultiSelectEnabled(event.isControlKeyDown() && !multiSelectionDisabled);
                selectionModel.setMultiRangeSelectEnabled(event.isShiftKeyDown() && !multiSelectionDisabled);
                if (event.isDownArrow()) {
                    selectionModel.selectNext();
                } else if (event.isUpArrow()) {
                    selectionModel.selectPrev();
                }
            }
        }
    }, KeyDownEvent.getType());
    // Add context menu handler for table widget
    addContextMenuHandler(tableContainer);
    // Use fixed table layout
    // $NON-NLS-1$
    setWidth("100%", true);
    // Attach table widget to the corresponding panel
    tableContainer.setWidget(table);
    tableHeaderContainer.setWidget(tableHeader);
    tableHeaderContainer.setVisible(isTableHeaderVisible());
    // Use relative positioning for tableHeader, in order to align it with main table
    tableHeader.getElement().getStyle().setPosition(Position.RELATIVE);
    // Attach scroll event handler to main table container, so that the tableHeader widget
    // can have its position aligned with main table container's current scroll position
    tableContainer.addDomHandler(new ScrollHandler() {

        @Override
        public void onScroll(ScrollEvent event) {
            tableContainerHorizontalScrollPosition = tableContainer.getElement().getScrollLeft();
            updateTableHeaderPosition();
        }
    }, ScrollEvent.getType());
    // Reset main table container's scroll position
    enforceScrollPosition();
    this.doAutoSelect = true;
}
#end_block

#method_before
void initSortHandler() {
    // Allow sorting by one column at a time
    tableHeader.getColumnSortList().setLimit(1);
    table.getColumnSortList().setLimit(1);
    // Attach column sort handler
    ActionCellTable<T> tableWithHeader = isTableHeaderVisible() ? tableHeader : table;
    tableWithHeader.addColumnSortHandler(new ColumnSortEvent.Handler() {

        @Override
        public void onColumnSort(ColumnSortEvent event) {
            Object model = getDataProvider().getModel();
            Column<?, ?> column = event.getColumn();
            if (model instanceof SearchableListModel) {
                SearchableListModel<?> searchableModel = (SearchableListModel<?>) model;
                String sortBy = null;
                // Explicit null check to make it clear that null column should reset sort
                if (column != null && column instanceof SortableColumn) {
                    SortableColumn<?, ?> sortableColumn = (SortableColumn<?, ?>) column;
                    sortBy = sortableColumn.getSortBy();
                }
                // Apply sort options to model
                searchableModel.setSortOptions(sortBy, event.isSortAscending());
                // Synchronize column sort info
                ColumnSortInfo columnSortInfo = event.getColumnSortList().get(0);
                tableHeader.getColumnSortList().push(columnSortInfo);
                table.getColumnSortList().push(columnSortInfo);
            }
        }
    });
}
#method_after
void initSortHandler() {
    // Allow sorting by one column at a time
    tableHeader.getColumnSortList().setLimit(1);
    table.getColumnSortList().setLimit(1);
    // Attach column sort handler
    ActionCellTable<T> tableWithHeader = isTableHeaderVisible() ? tableHeader : table;
    tableWithHeader.addColumnSortHandler(new ColumnSortEvent.Handler() {

        @SuppressWarnings("unchecked")
        @Override
        public void onColumnSort(ColumnSortEvent event) {
            Object model = getDataProvider().getModel();
            Column<?, ?> column = event.getColumn();
            if (model instanceof SearchableListModel) {
                SearchableListModel<T> searchableModel = (SearchableListModel<T>) model;
                SortableColumn<T, ?> sortedColumn = null;
                // Sorted column can be null (which indicates no sort)
                if (column instanceof SortableColumn) {
                    sortedColumn = (SortableColumn<T, ?>) column;
                }
                // Apply server-side sorting, if supported by the model
                if (searchableModel.supportsServerSideSorting()) {
                    String sortBy = (sortedColumn != null) ? sortedColumn.getSortBy() : null;
                    searchableModel.updateSortOptions(sortBy, event.isSortAscending());
                } else // Otherwise, fall back to client-side sorting
                {
                    Comparator<? super T> comparator = (sortedColumn != null) ? sortedColumn.getComparator() : null;
                    searchableModel.setComparator(comparator, event.isSortAscending());
                }
                // Synchronize column sort info
                ColumnSortInfo columnSortInfo = event.getColumnSortList().get(0);
                tableHeader.getColumnSortList().push(columnSortInfo);
                table.getColumnSortList().push(columnSortInfo);
            }
        }
    });
}
#end_block

#method_before
private void addTimerChangeHandler() {
    timerChangeHandler = timer.addGridTimerStateChangeEventHandler(new GridTimerStateChangeEventHandler() {

        @Override
        public void onGridTimerStateChange(GridTimerStateChangeEvent event) {
            int newInterval = event.getRefreshRate();
            if (timer.isActive()) {
                // Immediately adjust timer and restart if it was active.
                if (newInterval != timer.getRefreshRate()) {
                    timer.stop();
                    timer.setRefreshRate(newInterval);
                    timer.start();
                }
            } else {
                // Update the timer interval for inactive timers, so they are correct when they become active
                timer.setRefreshRate(newInterval);
            }
        }
    });
}
#method_after
private void addTimerChangeHandler() {
    timerChangeHandler = timer.addGridTimerStateChangeEventHandler(new GridTimerStateChangeEventHandler() {

        @Override
        public void onGridTimerStateChange(GridTimerStateChangeEvent event) {
            int newInterval = event.getRefreshRate();
            if (timer.isActive()) {
                // Immediately adjust timer and restart if it was active.
                if (newInterval != timer.getRefreshRate()) {
                    timer.stop();
                    timer.setRefreshRate(newInterval, false);
                    timer.start();
                }
            } else {
                // Update the timer interval for inactive timers, so they are correct when they become active
                timer.setRefreshRate(newInterval, false);
            }
        }
    });
}
#end_block

#method_before
protected void replaceTimerChangeHandler() {
    if (timerChangeHandler == null) {
        addTimerChangeHandler();
    } else {
        removeTimerChangeHandler();
        addTimerChangeHandler();
    }
}
#method_after
protected void replaceTimerChangeHandler() {
    if (timerChangeHandler != null) {
        removeTimerChangeHandler();
    }
    addTimerChangeHandler();
}
#end_block

#method_before
protected String applySortOptions(String searchQuery) {
    String result = searchQuery;
    if (sortBy != null) {
        // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
        result += " SORTBY " + sortBy + " " + (sortAscending ? "ASC" : "DESC");
    }
    return result;
}
#method_after
protected String applySortOptions(String searchQuery) {
    StringBuilder result = new StringBuilder(searchQuery);
    if (sortBy != null) {
        // $NON-NLS-1$
        result.append(" SORTBY ").append(sortBy).append(" ").append(// $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
        sortAscending ? "ASC" : "DESC");
    }
    return result.toString();
}
#end_block

#method_before
protected void setComparator(Comparator<T> comparator) {
    if (comparator == this.comparator) {
        return;
    }
    this.comparator = comparator;
    Iterable<T> items = getItems();
    if (items == null) {
        return;
    }
    Collection<T> identicalItems = (comparator == null) ? new ArrayList<T>() : new TreeSet<T>(comparator);
    for (T item : items) {
        identicalItems.add(item);
    }
    setItems(identicalItems);
}
#method_after
@Override
public void setComparator(Comparator<? super T> comparator, boolean sortAscending) {
    super.setComparator(comparator, sortAscending);
    Collection<T> items = getItems();
    if (items != null) {
        Collection<T> maybeSortedItems = (comparator != null) ? sortItems(items) : new ArrayList<T>(items);
        setItems(maybeSortedItems);
    }
}
#end_block

#method_before
@Override
public void setItems(Collection<T> value) {
    if (items != value) {
        T lastSelectedItem = getSelectedItem();
        List<T> lastSelectedItems = new ArrayList<T>();
        if (getSelectedItems() != null) {
            for (T item : getSelectedItems()) {
                lastSelectedItems.add(item);
            }
        }
        if (comparator == null || ((value instanceof SortedSet) && (((SortedSet) value).comparator() == comparator))) {
            itemsChanging(value, items);
            items = value;
        } else {
            TreeSet<T> sortedValue = null;
            if (value != null) {
                sortedValue = new TreeSet<T>(comparator);
                for (T item : value) {
                    sortedValue.add(item);
                }
            }
            itemsChanging(sortedValue, items);
            items = sortedValue;
        }
        updatePagingAvailability();
        getItemsChangedEvent().raise(this, EventArgs.EMPTY);
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Items"));
        selectedItem = null;
        if (getSelectedItems() != null) {
            getSelectedItems().clear();
        }
        if (lastSelectedItem != null && items != null) {
            T newSelectedItem = null;
            List<T> newItems = new ArrayList<T>();
            for (T item : items) {
                newItems.add(item);
            }
            if (newItems != null) {
                for (T newItem : newItems) {
                    // Search for selected item
                    if (((IVdcQueryable) newItem).getQueryableId().equals(((IVdcQueryable) lastSelectedItem).getQueryableId())) {
                        newSelectedItem = newItem;
                    } else {
                        // Search for selected items
                        for (T item : lastSelectedItems) {
                            if (((IVdcQueryable) newItem).getQueryableId().equals(((IVdcQueryable) item).getQueryableId())) {
                                selectedItems.add(newItem);
                            }
                        }
                    }
                }
            }
            if (newSelectedItem != null) {
                selectedItem = newSelectedItem;
                if (selectedItems != null) {
                    selectedItems.add(newSelectedItem);
                }
            }
        }
        onSelectedItemChanged();
    }
}
#method_after
@Override
public void setItems(Collection<T> value) {
    if (items != value) {
        T lastSelectedItem = getSelectedItem();
        List<T> lastSelectedItems = new ArrayList<T>();
        if (getSelectedItems() != null) {
            for (T item : getSelectedItems()) {
                lastSelectedItems.add(item);
            }
        }
        if (comparator == null || ((value instanceof SortedSet) && ObjectUtils.objectsEqual(((SortedSet<?>) value).comparator(), comparator))) {
            itemsChanging(value, items);
            items = value;
        } else {
            Collection<T> sortedItems = sortItems(value);
            itemsChanging(sortedItems, items);
            items = sortedItems;
        }
        updatePagingAvailability();
        getItemsChangedEvent().raise(this, EventArgs.EMPTY);
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Items"));
        selectedItem = null;
        if (getSelectedItems() != null) {
            getSelectedItems().clear();
        }
        if (lastSelectedItem != null && items != null) {
            T newSelectedItem = null;
            List<T> newItems = new ArrayList<T>();
            for (T item : items) {
                newItems.add(item);
            }
            if (newItems != null) {
                newSelectedItem = determineSelectedItems(newItems, lastSelectedItem, lastSelectedItems);
            }
            if (newSelectedItem != null) {
                selectedItem = newSelectedItem;
                if (selectedItems != null) {
                    selectedItems.add(newSelectedItem);
                }
            }
        }
        onSelectedItemChanged();
    }
}
#end_block

#method_before
@Override
protected void registerHandlers() {
    // Register to listen for operation complete events.
    registerHandler(getEventBus().addHandler(RefreshActiveModelEvent.getType(), new RefreshActiveModelHandler() {

        @Override
        public void onRefreshActiveModel(RefreshActiveModelEvent event) {
            if (getTimer().isActive()) {
                // Only if we are active should we refresh.
                if (handleRefreshActiveModel(event)) {
                    syncSearch();
                }
                if (event.isDoFastForward()) {
                    // Start the fast refresh.
                    getTimer().fastForward();
                }
            }
        }
    }));
}
#method_after
@Override
protected void registerHandlers() {
    // Register to listen for operation complete events.
    registerHandler(getEventBus().addHandler(RefreshActiveModelEvent.getType(), new RefreshActiveModelHandler() {

        @Override
        public void onRefreshActiveModel(RefreshActiveModelEvent event) {
            if (getTimer().isActive() || refreshOnInactiveTimer()) {
                // Only if we are active should we refresh.
                if (handleRefreshActiveModel(event)) {
                    syncSearch();
                }
                if (event.isDoFastForward()) {
                    // Start the fast refresh.
                    getTimer().fastForward();
                }
            }
        }
    }));
}
#end_block

