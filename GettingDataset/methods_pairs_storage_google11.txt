1501
#method_before
@Override
void apply(ChangeUpdate update) throws OrmException {
    checkUpdate(update);
    update.setChangeMessage(message.getMessage());
    setTopic(update);
    setStatus(update);
}
#method_after
@Override
void apply(ChangeUpdate update) throws OrmException {
    checkUpdate(update);
    update.setChangeMessage(message.getMessage());
    setTopic(update);
}
#end_block

#method_before
@Override
protected String getRefName() {
    return RefNames.refsDraftComments(getId(), effectiveAccountId);
}
#method_after
@Override
protected String getRefName() {
    return RefNames.refsDraftComments(getId(), accountId);
}
#end_block

#method_before
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    manager.setCheckExpectedState(false);
    Change change = new Change(bundle.getChange());
    if (bundle.getPatchSets().isEmpty()) {
        throw new NoPatchSetsException(change.getId());
    }
    PatchSet.Id currPsId = change.currentPatchSetId();
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = new ArrayList<>();
    Multimap<Account.Id, DraftCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteChangeMetaRef(change, manager.getChangeRepo().cmds);
    deleteDraftRefs(change, manager.getAllUsersRepo());
    Integer minPsNum = getMinPatchSetNum(bundle);
    Map<PatchSet.Id, PatchSetEvent> patchSetEvents = Maps.newHashMapWithExpectedSize(bundle.getPatchSets().size());
    for (PatchSet ps : bundle.getPatchSets()) {
        if (ps.getId().get() > currPsId.get()) {
            log.info("Skipping patch set {}, which is higher than current patch set {}", ps.getId(), currPsId);
            continue;
        }
        PatchSetEvent pse = new PatchSetEvent(change, ps, manager.getChangeRepo().rw);
        patchSetEvents.put(ps.getId(), pse);
        events.add(pse);
        for (Comment c : getComments(bundle, serverId, Status.PUBLISHED, ps)) {
            CommentEvent e = new CommentEvent(c, change, ps, patchListCache);
            events.add(e.addDep(pse));
        }
        for (Comment c : getComments(bundle, serverId, Status.DRAFT, ps)) {
            DraftCommentEvent e = new DraftCommentEvent(c, change, ps, patchListCache);
            draftCommentEvents.put(c.author.getId(), e);
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        PatchSetEvent pse = patchSetEvents.get(psa.getPatchSetId());
        if (pse != null) {
            events.add(new ApprovalEvent(psa, change.getCreatedOn()).addDep(pse));
        }
    }
    for (Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> r : bundle.getReviewers().asTable().cellSet()) {
        events.add(new ReviewerEvent(r, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        if (msg.getPatchSetId() == null) {
            // No dependency necessary; will get assigned to most recent patch set
            // in sortAndFillEvents.
            events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
            continue;
        }
        PatchSetEvent pse = patchSetEvents.get(msg.getPatchSetId());
        if (pse != null) {
            events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()).addDep(pse));
        }
    }
    sortAndFillEvents(change, noteDbChange, events, minPsNum);
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<DraftCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (DraftCommentEvent e : Ordering.natural().sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#method_after
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    manager.setCheckExpectedState(false);
    Change change = new Change(bundle.getChange());
    if (bundle.getPatchSets().isEmpty()) {
        throw new NoPatchSetsException(change.getId());
    }
    PatchSet.Id currPsId = change.currentPatchSetId();
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = new ArrayList<>();
    Multimap<Account.Id, DraftCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteChangeMetaRef(change, manager.getChangeRepo().cmds);
    deleteDraftRefs(change, manager.getAllUsersRepo());
    Integer minPsNum = getMinPatchSetNum(bundle);
    Map<PatchSet.Id, PatchSetEvent> patchSetEvents = Maps.newHashMapWithExpectedSize(bundle.getPatchSets().size());
    for (PatchSet ps : bundle.getPatchSets()) {
        if (ps.getId().get() > currPsId.get()) {
            log.info("Skipping patch set {}, which is higher than current patch set {}", ps.getId(), currPsId);
            continue;
        }
        PatchSetEvent pse = new PatchSetEvent(change, ps, manager.getChangeRepo().rw);
        patchSetEvents.put(ps.getId(), pse);
        events.add(pse);
        for (Comment c : getComments(bundle, serverId, Status.PUBLISHED, ps)) {
            CommentEvent e = new CommentEvent(c, change, ps, patchListCache);
            events.add(e.addDep(pse));
        }
        for (Comment c : getComments(bundle, serverId, Status.DRAFT, ps)) {
            DraftCommentEvent e = new DraftCommentEvent(c, change, ps, patchListCache);
            draftCommentEvents.put(c.author.getId(), e);
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        PatchSetEvent pse = patchSetEvents.get(psa.getPatchSetId());
        if (pse != null) {
            events.add(new ApprovalEvent(psa, change.getCreatedOn()).addDep(pse));
        }
    }
    for (Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> r : bundle.getReviewers().asTable().cellSet()) {
        events.add(new ReviewerEvent(r, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        List<Event> msgEvents = parseChangeMessage(msg, change, noteDbChange);
        if (msg.getPatchSetId() != null) {
            PatchSetEvent pse = patchSetEvents.get(msg.getPatchSetId());
            if (pse != null) {
                for (Event e : msgEvents) {
                    e.addDep(pse);
                }
            }
        }
        events.addAll(msgEvents);
    }
    sortAndFillEvents(change, noteDbChange, events, minPsNum);
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<DraftCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (DraftCommentEvent e : Ordering.natural().sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#end_block

#method_before
private void sortAndFillEvents(Change change, Change noteDbChange, List<Event> events, Integer minPsNum) {
    new EventSorter(events).sort();
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    // Ensure the first event in the list creates the change, setting the author
    // and any required footers.
    Event first = events.get(0);
    if (first instanceof PatchSetEvent && change.getOwner().equals(first.effectiveUser)) {
        ((PatchSetEvent) first).createChange = true;
    } else {
        events.add(0, new CreateChangeEvent(change, minPsNum));
    }
    // Final pass to correct some inconsistencies.
    // 
    // First, fill in any missing patch set IDs using the latest patch set of
    // the change at the time of the event, because NoteDb can't represent
    // actions with no associated patch set ID. This workaround is as if a user
    // added a ChangeMessage on the change by replying from the latest patch
    // set.
    // 
    // Start with the first patch set that actually exists. If there are no
    // patch sets at all, minPsNum will be null, so just bail and use 1 as the
    // patch set ID. The corresponding patch set won't exist, but this change is
    // probably corrupt anyway, as deleting the last draft patch set should have
    // deleted the whole change.
    // 
    // Second, ensure timestamps are nondecreasing, by copying the previous
    // timestamp if this happens. This assumes that the only way this can happen
    // is due to dependency constraints, and it is ok to give an event the same
    // timestamp as one of its dependencies.
    int ps = firstNonNull(minPsNum, 1);
    for (int i = 0; i < events.size(); i++) {
        Event e = events.get(i);
        if (e.psId == null) {
            e.psId = new PatchSet.Id(change.getId(), ps);
        } else {
            ps = Math.max(ps, e.psId.get());
        }
        if (i > 0) {
            Event p = events.get(i - 1);
            if (e.when.before(p.when)) {
                e.when = p.when;
            }
        }
    }
}
#method_after
private void sortAndFillEvents(Change change, Change noteDbChange, List<Event> events, Integer minPsNum) {
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    new EventSorter(events).sort();
    // Ensure the first event in the list creates the change, setting the author
    // and any required footers.
    Event first = events.get(0);
    if (first instanceof PatchSetEvent && change.getOwner().equals(first.user)) {
        ((PatchSetEvent) first).createChange = true;
    } else {
        events.add(0, new CreateChangeEvent(change, minPsNum));
    }
    // Final pass to correct some inconsistencies.
    // 
    // First, fill in any missing patch set IDs using the latest patch set of
    // the change at the time of the event, because NoteDb can't represent
    // actions with no associated patch set ID. This workaround is as if a user
    // added a ChangeMessage on the change by replying from the latest patch
    // set.
    // 
    // Start with the first patch set that actually exists. If there are no
    // patch sets at all, minPsNum will be null, so just bail and use 1 as the
    // patch set ID. The corresponding patch set won't exist, but this change is
    // probably corrupt anyway, as deleting the last draft patch set should have
    // deleted the whole change.
    // 
    // Second, ensure timestamps are nondecreasing, by copying the previous
    // timestamp if this happens. This assumes that the only way this can happen
    // is due to dependency constraints, and it is ok to give an event the same
    // timestamp as one of its dependencies.
    int ps = firstNonNull(minPsNum, 1);
    for (int i = 0; i < events.size(); i++) {
        Event e = events.get(i);
        if (e.psId == null) {
            e.psId = new PatchSet.Id(change.getId(), ps);
        } else {
            ps = Math.max(ps, e.psId.get());
        }
        if (i > 0) {
            Event p = events.get(i - 1);
            if (e.when.before(p.when)) {
                e.when = p.when;
            }
        }
    }
}
#end_block

#method_before
private void flushEventsToUpdate(NoteDbUpdateManager manager, EventList<Event> events, Change change) throws OrmException, IOException {
    if (events.isEmpty()) {
        return;
    }
    Comparator<String> labelNameComparator;
    if (projectCache != null) {
        labelNameComparator = projectCache.get(change.getProject()).getLabelTypes().nameComparator();
    } else {
        // No project cache available, bail and use natural ordering; there's no
        // semantic difference anyway difference.
        labelNameComparator = Ordering.natural();
    }
    ChangeUpdate update = updateFactory.create(change, events.getAccountId(), newAuthorIdent(events), events.getWhen(), labelNameComparator);
    update.setAllowWriteToNewRef(true);
    update.setPatchSetId(events.getPatchSetId());
    update.setTag(events.getTag());
    for (Event e : events) {
        e.apply(update);
    }
    manager.add(update);
    events.clear();
}
#method_after
private void flushEventsToUpdate(NoteDbUpdateManager manager, EventList<Event> events, Change change) throws OrmException, IOException {
    if (events.isEmpty()) {
        return;
    }
    Comparator<String> labelNameComparator;
    if (projectCache != null) {
        labelNameComparator = projectCache.get(change.getProject()).getLabelTypes().nameComparator();
    } else {
        // No project cache available, bail and use natural ordering; there's no
        // semantic difference anyway difference.
        labelNameComparator = Ordering.natural();
    }
    ChangeUpdate update = updateFactory.create(change, events.getAccountId(), events.getRealAccountId(), newAuthorIdent(events), events.getWhen(), labelNameComparator);
    update.setAllowWriteToNewRef(true);
    update.setPatchSetId(events.getPatchSetId());
    update.setTag(events.getTag());
    for (Event e : events) {
        e.apply(update);
    }
    manager.add(update);
    events.clear();
}
#end_block

#method_before
private void flushEventsToDraftUpdate(NoteDbUpdateManager manager, EventList<DraftCommentEvent> events, Change change) throws OrmException {
    if (events.isEmpty()) {
        return;
    }
    ChangeDraftUpdate update = draftUpdateFactory.create(change, events.getAccountId(), newAuthorIdent(events), events.getWhen());
    update.setPatchSetId(events.getPatchSetId());
    for (DraftCommentEvent e : events) {
        e.applyDraft(update);
    }
    manager.add(update);
    events.clear();
}
#method_after
private void flushEventsToDraftUpdate(NoteDbUpdateManager manager, EventList<DraftCommentEvent> events, Change change) throws OrmException {
    if (events.isEmpty()) {
        return;
    }
    ChangeDraftUpdate update = draftUpdateFactory.create(change, events.getAccountId(), events.getRealAccountId(), newAuthorIdent(events), events.getWhen());
    update.setPatchSetId(events.getPatchSetId());
    for (DraftCommentEvent e : events) {
        e.applyDraft(update);
    }
    manager.add(update);
    events.clear();
}
#end_block

#method_before
public static ChangeMessage newMessage(ReviewDb db, PatchSet.Id psId, CurrentUser user, Timestamp when, String body) throws OrmException {
    checkNotNull(psId);
    Account.Id accountId = user.isInternalUser() ? null : user.getAccountId();
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(db)), accountId, when, psId);
    m.setMessage(body);
    if (user.getRealUser().isIdentifiedUser()) {
        m.setRealAuthor(user.getRealUser().getAccountId());
    }
    return m;
}
#method_after
public static ChangeMessage newMessage(ReviewDb db, PatchSet.Id psId, CurrentUser user, Timestamp when, String body) throws OrmException {
    checkNotNull(psId);
    Account.Id accountId = user.isInternalUser() ? null : user.getAccountId();
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(db)), accountId, when, psId);
    m.setMessage(body);
    user.updateRealAccountId(m::setRealAuthor);
    return m;
}
#end_block

#method_before
public void putApproval(String label, short value) {
    putApprovalFor(getEffectiveAccountId(), label, value);
}
#method_after
public void putApproval(String label, short value) {
    putApprovalFor(getAccountId(), label, value);
}
#end_block

#method_before
public void removeApproval(String label) {
    removeApprovalFor(getEffectiveAccountId(), label);
}
#method_after
public void removeApproval(String label) {
    removeApprovalFor(getAccountId(), label);
}
#end_block

#method_before
public void putComment(PatchLineComment.Status status, Comment c) {
    checkRealAccount("update comments");
    verifyComment(c);
    createDraftUpdateIfNull();
    if (status == PatchLineComment.Status.DRAFT) {
        draftUpdate.putComment(c);
    } else {
        comments.add(c);
        // Always delete the corresponding comment from drafts. Published comments
        // are immutable, meaning in normal operation we only hit this path when
        // publishing a comment. It's exactly in that case that we have to delete
        // the draft.
        draftUpdate.deleteComment(c);
    }
}
#method_after
public void putComment(PatchLineComment.Status status, Comment c) {
    verifyComment(c);
    createDraftUpdateIfNull();
    if (status == PatchLineComment.Status.DRAFT) {
        draftUpdate.putComment(c);
    } else {
        comments.add(c);
        // Always delete the corresponding comment from drafts. Published comments
        // are immutable, meaning in normal operation we only hit this path when
        // publishing a comment. It's exactly in that case that we have to delete
        // the draft.
        draftUpdate.deleteComment(c);
    }
}
#end_block

#method_before
public void putRobotComment(RobotComment c) {
    checkRealAccount("update robot comments");
    verifyComment(c);
    createRobotCommentUpdateIfNull();
    robotCommentUpdate.putComment(c);
}
#method_after
public void putRobotComment(RobotComment c) {
    verifyComment(c);
    createRobotCommentUpdateIfNull();
    robotCommentUpdate.putComment(c);
}
#end_block

#method_before
public void deleteComment(Comment c) {
    checkRealAccount("update comments");
    verifyComment(c);
    createDraftUpdateIfNull().deleteComment(c);
}
#method_after
public void deleteComment(Comment c) {
    verifyComment(c);
    createDraftUpdateIfNull().deleteComment(c);
}
#end_block

#method_before
@VisibleForTesting
ChangeDraftUpdate createDraftUpdateIfNull() {
    if (draftUpdate == null) {
        checkRealAccount("update drafts");
        ChangeNotes notes = getNotes();
        if (notes != null) {
            draftUpdate = draftUpdateFactory.create(notes, effectiveAccountId, authorIdent, when);
        } else {
            draftUpdate = draftUpdateFactory.create(getChange(), effectiveAccountId, authorIdent, when);
        }
    }
    return draftUpdate;
}
#method_after
@VisibleForTesting
ChangeDraftUpdate createDraftUpdateIfNull() {
    if (draftUpdate == null) {
        ChangeNotes notes = getNotes();
        if (notes != null) {
            draftUpdate = draftUpdateFactory.create(notes, accountId, realAccountId, authorIdent, when);
        } else {
            draftUpdate = draftUpdateFactory.create(getChange(), accountId, realAccountId, authorIdent, when);
        }
    }
    return draftUpdate;
}
#end_block

#method_before
@VisibleForTesting
RobotCommentUpdate createRobotCommentUpdateIfNull() {
    if (robotCommentUpdate == null) {
        checkRealAccount("update robot comments");
        ChangeNotes notes = getNotes();
        if (notes != null) {
            robotCommentUpdate = robotCommentUpdateFactory.create(notes, effectiveAccountId, authorIdent, when);
        } else {
            robotCommentUpdate = robotCommentUpdateFactory.create(getChange(), effectiveAccountId, authorIdent, when);
        }
    }
    return robotCommentUpdate;
}
#method_after
@VisibleForTesting
RobotCommentUpdate createRobotCommentUpdateIfNull() {
    if (robotCommentUpdate == null) {
        ChangeNotes notes = getNotes();
        if (notes != null) {
            robotCommentUpdate = robotCommentUpdateFactory.create(notes, accountId, realAccountId, authorIdent, when);
        } else {
            robotCommentUpdate = robotCommentUpdateFactory.create(getChange(), accountId, realAccountId, authorIdent, when);
        }
    }
    return robotCommentUpdate;
}
#end_block

#method_before
@Override
protected CommitBuilder applyImpl(RevWalk rw, ObjectInserter ins, ObjectId curr) throws OrmException, IOException {
    CommitBuilder cb = new CommitBuilder();
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addPatchSetFooter(msg, ps);
    if (changeId != null) {
        addFooter(msg, FOOTER_CHANGE_ID, changeId);
    }
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit);
    }
    if (assignee != null) {
        if (assignee.isPresent()) {
            addFooter(msg, FOOTER_ASSIGNEE);
            addIdent(msg, assignee.get()).append('\n');
        } else {
            addFooter(msg, FOOTER_ASSIGNEE).append('\n');
        }
    }
    Joiner comma = Joiner.on(',');
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, comma.join(hashtags));
    }
    if (tag != null) {
        addFooter(msg, FOOTER_TAG, tag);
    }
    if (groups != null) {
        addFooter(msg, FOOTER_GROUPS, comma.join(groups));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(getEffectiveAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        PersonIdent ident = newIdent(accountCache.get(label.appliedBy).getAccount(), when);
                        msg.append(": ").append(ident.getName()).append(" <").append(ident.getEmailAddress()).append('>');
                    }
                    msg.append('\n');
                }
            }
        }
    }
    if (!Objects.equals(effectiveAccountId, realAccountId)) {
        addFooter(msg, FOOTER_REAL_USER);
        addIdent(msg, realAccountId).append('\n');
    }
    cb.setMessage(msg.toString());
    try {
        ObjectId treeId = storeRevisionNotes(rw, ins, curr);
        if (treeId != null) {
            cb.setTreeId(treeId);
        }
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    }
    return cb;
}
#method_after
@Override
protected CommitBuilder applyImpl(RevWalk rw, ObjectInserter ins, ObjectId curr) throws OrmException, IOException {
    CommitBuilder cb = new CommitBuilder();
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addPatchSetFooter(msg, ps);
    if (changeId != null) {
        addFooter(msg, FOOTER_CHANGE_ID, changeId);
    }
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit);
    }
    if (assignee != null) {
        if (assignee.isPresent()) {
            addFooter(msg, FOOTER_ASSIGNEE);
            addIdent(msg, assignee.get()).append('\n');
        } else {
            addFooter(msg, FOOTER_ASSIGNEE).append('\n');
        }
    }
    Joiner comma = Joiner.on(',');
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, comma.join(hashtags));
    }
    if (tag != null) {
        addFooter(msg, FOOTER_TAG, tag);
    }
    if (groups != null) {
        addFooter(msg, FOOTER_GROUPS, comma.join(groups));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(getAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        msg.append(": ");
                        addIdent(msg, label.appliedBy);
                    }
                    msg.append('\n');
                }
            }
        }
    }
    if (!Objects.equals(accountId, realAccountId)) {
        addFooter(msg, FOOTER_REAL_USER);
        addIdent(msg, realAccountId).append('\n');
    }
    cb.setMessage(msg.toString());
    try {
        ObjectId treeId = storeRevisionNotes(rw, ins, curr);
        if (treeId != null) {
            cb.setTreeId(treeId);
        }
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    }
    return cb;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Override
void apply(ChangeUpdate update) throws OrmException {
    if (!Objects.equals(change.getTopic(), noteDbChange.getTopic())) {
        update.setTopic(change.getTopic());
    }
    if (!Objects.equals(change.getStatus(), noteDbChange.getStatus())) {
        // TODO(dborowitz): Stamp approximate approvals at this time.
        update.fixStatus(change.getStatus());
    }
    if (change.getSubmissionId() != null) {
        update.setSubmissionId(change.getSubmissionId());
    }
    if (!update.isEmpty()) {
        update.setSubjectForCommit("Final NoteDb migration updates");
    }
}
#method_after
@SuppressWarnings("deprecation")
@Override
void apply(ChangeUpdate update) throws OrmException {
    if (!Objects.equals(change.getTopic(), noteDbChange.getTopic())) {
        update.setTopic(change.getTopic());
    }
    if (!Objects.equals(change.getStatus(), noteDbChange.getStatus())) {
        // TODO(dborowitz): Stamp approximate approvals at this time.
        update.fixStatus(change.getStatus());
    }
    if (change.getSubmissionId() != null && noteDbChange.getSubmissionId() == null) {
        update.setSubmissionId(change.getSubmissionId());
    }
    if (!Objects.equals(change.getAssignee(), noteDbChange.getAssignee())) {
        // TODO(dborowitz): Parse intermediate values out from messages.
        update.setAssignee(change.getAssignee());
    }
    if (!update.isEmpty()) {
        update.setSubjectForCommit("Final NoteDb migration updates");
    }
}
#end_block

#method_before
boolean canAdd(E e) {
    if (isEmpty()) {
        return true;
    }
    if (e instanceof FinalUpdatesEvent) {
        // FinalUpdatesEvent always gets its own update.
        return false;
    }
    Event last = getLast();
    if (!Objects.equals(e.effectiveUser, last.effectiveUser) || !Objects.equals(e.realUser, last.realUser) || !e.psId.equals(last.psId) || !Objects.equals(e.tag, last.tag)) {
        // Different patch set, author, or tag.
        return false;
    }
    long t = e.when.getTime();
    long tFirst = getFirstTime();
    long tLast = getLastTime();
    checkArgument(t >= tLast, "event %s is before previous event in list %s", e, last);
    if (t - tLast > ChangeRebuilderImpl.MAX_DELTA_MS || t - tFirst > ChangeRebuilderImpl.MAX_WINDOW_MS) {
        // Too much time elapsed.
        return false;
    }
    if (!e.uniquePerUpdate()) {
        return true;
    }
    for (Event o : this) {
        if (e.getClass() == o.getClass()) {
            // Only one event of this type allowed per update.
            return false;
        }
    }
    return true;
}
#method_after
boolean canAdd(E e) {
    if (isEmpty()) {
        return true;
    }
    if (e instanceof FinalUpdatesEvent) {
        // FinalUpdatesEvent always gets its own update.
        return false;
    }
    Event last = getLast();
    if (!Objects.equals(e.user, last.user) || !Objects.equals(e.realUser, last.realUser) || !e.psId.equals(last.psId) || !Objects.equals(e.tag, last.tag)) {
        // Different patch set, author, or tag.
        return false;
    }
    long t = e.when.getTime();
    long tFirst = getFirstTime();
    long tLast = getLastTime();
    checkArgument(t >= tLast, "event %s is before previous event in list %s", e, last);
    if (t - tLast > ChangeRebuilderImpl.MAX_DELTA_MS || t - tFirst > ChangeRebuilderImpl.MAX_WINDOW_MS) {
        // Too much time elapsed.
        return false;
    }
    if (!e.uniquePerUpdate()) {
        return true;
    }
    for (Event o : this) {
        if (e.getClass() == o.getClass()) {
            // Only one event of this type allowed per update.
            return false;
        }
    }
    return true;
}
#end_block

#method_before
Account.Id getAccountId() {
    Account.Id id = get(0).effectiveUser;
    for (int i = 1; i < size(); i++) {
        checkState(Objects.equals(id, get(i).effectiveUser), "mismatched users in EventList: %s != %s", id, get(i).effectiveUser);
    }
    return id;
}
#method_after
Account.Id getAccountId() {
    Account.Id id = get(0).user;
    for (int i = 1; i < size(); i++) {
        checkState(Objects.equals(id, get(i).user), "mismatched users in EventList: %s != %s", id, get(i).user);
    }
    return id;
}
#end_block

#method_before
protected void checkUpdate(AbstractChangeUpdate update) {
    checkState(Objects.equals(update.getPatchSetId(), psId), "cannot apply event for %s to update for %s", update.getPatchSetId(), psId);
    checkState(when.getTime() - update.getWhen().getTime() <= MAX_WINDOW_MS, "event at %s outside update window starting at %s", when, update.getWhen());
    checkState(Objects.equals(update.getNullableAccountId(), effectiveUser), "cannot apply event by %s to update by %s", effectiveUser, update.getNullableAccountId());
}
#method_after
protected void checkUpdate(AbstractChangeUpdate update) {
    checkState(Objects.equals(update.getPatchSetId(), psId), "cannot apply event for %s to update for %s", update.getPatchSetId(), psId);
    checkState(when.getTime() - update.getWhen().getTime() <= MAX_WINDOW_MS, "event at %s outside update window starting at %s", when, update.getWhen());
    checkState(Objects.equals(update.getNullableAccountId(), user), "cannot apply event by %s to update by %s", user, update.getNullableAccountId());
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("psId", psId).add("effectiveUser", effectiveUser).add("realUser", realUser).add("when", when).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("psId", psId).add("effectiveUser", user).add("realUser", realUser).add("when", when).toString();
}
#end_block

#method_before
@Override
public int compareTo(Event other) {
    return ComparisonChain.start().compare(this.when, other.when).compareTrueFirst(isPatchSet(), isPatchSet()).compareTrueFirst(this.predatesChange, other.predatesChange).compare(this.effectiveUser, other.effectiveUser, ReviewDbUtil.intKeyOrdering()).compare(this.realUser, other.realUser, ReviewDbUtil.intKeyOrdering()).compare(this.psId, other.psId, ReviewDbUtil.intKeyOrdering().nullsLast()).result();
}
#method_after
@Override
public int compareTo(Event other) {
    return ComparisonChain.start().compareFalseFirst(this.isFinalUpdates(), other.isFinalUpdates()).compare(this.when, other.when).compareTrueFirst(isPatchSet(), isPatchSet()).compareTrueFirst(this.predatesChange, other.predatesChange).compare(this.user, other.user, ReviewDbUtil.intKeyOrdering()).compare(this.realUser, other.realUser, ReviewDbUtil.intKeyOrdering()).compare(this.psId, other.psId, ReviewDbUtil.intKeyOrdering().nullsLast()).result();
}
#end_block

#method_before
protected boolean isPatchSet() {
    return false;
}
#method_after
private boolean isPatchSet() {
    return this instanceof PatchSetEvent;
}
#end_block

#method_before
public static PatchSetApproval newApproval(PatchSet.Id psId, CurrentUser user, LabelId labelId, int value, Date when) {
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), labelId), Shorts.checkedCast(value), when);
    if (user.getRealUser().isIdentifiedUser()) {
        psa.setRealAccountId(user.getRealUser().getAccountId());
    }
    return psa;
}
#method_after
public static PatchSetApproval newApproval(PatchSet.Id psId, CurrentUser user, LabelId labelId, int value, Date when) {
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), labelId), Shorts.checkedCast(value), when);
    user.updateRealAccountId(psa::setRealAccountId);
    return psa;
}
#end_block

#method_before
private Comment parseComment(byte[] note, MutableInteger curr, String currentFileName, PatchSet.Id psId, RevId revId, boolean isForBase, Integer parentNumber) throws ConfigInvalidException {
    Change.Id changeId = psId.getParentKey();
    // Check if there is a new file.
    boolean newFile = (RawParseUtils.match(note, curr.value, FILE.getBytes(UTF_8))) != -1;
    if (newFile) {
        // If so, parse the new file name.
        currentFileName = parseFilename(note, curr, changeId);
    } else if (currentFileName == null) {
        throw parseException(changeId, "could not parse %s", FILE);
    }
    CommentRange range = parseCommentRange(note, curr);
    if (range == null) {
        throw parseException(changeId, "could not parse %s", COMMENT_RANGE);
    }
    Timestamp commentTime = parseTimestamp(note, curr, changeId);
    Account.Id aId = parseAuthor(note, curr, changeId);
    boolean hasParent = (RawParseUtils.match(note, curr.value, PARENT.getBytes(UTF_8))) != -1;
    String parentUUID = null;
    if (hasParent) {
        parentUUID = parseStringField(note, curr, changeId, PARENT);
    }
    String uuid = parseStringField(note, curr, changeId, UUID);
    boolean hasTag = (RawParseUtils.match(note, curr.value, TAG.getBytes(UTF_8))) != -1;
    String tag = null;
    if (hasTag) {
        tag = parseStringField(note, curr, changeId, TAG);
    }
    int commentLength = parseCommentLength(note, curr, changeId);
    String message = RawParseUtils.decode(UTF_8, note, curr.value, curr.value + commentLength);
    checkResult(message, "message contents", changeId);
    Comment c = new Comment(new Comment.Key(uuid, currentFileName, psId.get()), aId, commentTime, isForBase ? (short) (parentNumber == null ? 0 : -parentNumber) : (short) 1, message, serverId);
    c.lineNbr = range.getEndLine();
    c.parentUuid = parentUUID;
    c.tag = tag;
    c.setRevId(revId);
    if (range.getStartCharacter() != -1) {
        c.setRange(range);
    }
    curr.value = RawParseUtils.nextLF(note, curr.value + commentLength);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return c;
}
#method_after
private Comment parseComment(byte[] note, MutableInteger curr, String currentFileName, PatchSet.Id psId, RevId revId, boolean isForBase, Integer parentNumber) throws ConfigInvalidException {
    Change.Id changeId = psId.getParentKey();
    // Check if there is a new file.
    boolean newFile = (RawParseUtils.match(note, curr.value, FILE.getBytes(UTF_8))) != -1;
    if (newFile) {
        // If so, parse the new file name.
        currentFileName = parseFilename(note, curr, changeId);
    } else if (currentFileName == null) {
        throw parseException(changeId, "could not parse %s", FILE);
    }
    CommentRange range = parseCommentRange(note, curr);
    if (range == null) {
        throw parseException(changeId, "could not parse %s", COMMENT_RANGE);
    }
    Timestamp commentTime = parseTimestamp(note, curr, changeId);
    Account.Id aId = parseAuthor(note, curr, changeId, AUTHOR);
    boolean hasRealAuthor = (RawParseUtils.match(note, curr.value, REAL_AUTHOR.getBytes(UTF_8))) != -1;
    Account.Id raId = null;
    if (hasRealAuthor) {
        raId = parseAuthor(note, curr, changeId, REAL_AUTHOR);
    }
    boolean hasParent = (RawParseUtils.match(note, curr.value, PARENT.getBytes(UTF_8))) != -1;
    String parentUUID = null;
    if (hasParent) {
        parentUUID = parseStringField(note, curr, changeId, PARENT);
    }
    String uuid = parseStringField(note, curr, changeId, UUID);
    boolean hasTag = (RawParseUtils.match(note, curr.value, TAG.getBytes(UTF_8))) != -1;
    String tag = null;
    if (hasTag) {
        tag = parseStringField(note, curr, changeId, TAG);
    }
    int commentLength = parseCommentLength(note, curr, changeId);
    String message = RawParseUtils.decode(UTF_8, note, curr.value, curr.value + commentLength);
    checkResult(message, "message contents", changeId);
    Comment c = new Comment(new Comment.Key(uuid, currentFileName, psId.get()), aId, commentTime, isForBase ? (short) (parentNumber == null ? 0 : -parentNumber) : (short) 1, message, serverId);
    c.lineNbr = range.getEndLine();
    c.parentUuid = parentUUID;
    c.tag = tag;
    c.setRevId(revId);
    if (raId != null) {
        c.setRealAuthor(raId);
    }
    if (range.getStartCharacter() != -1) {
        c.setRange(range);
    }
    curr.value = RawParseUtils.nextLF(note, curr.value + commentLength);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return c;
}
#end_block

#method_before
private Account.Id parseAuthor(byte[] note, MutableInteger curr, Change.Id changeId) throws ConfigInvalidException {
    checkHeaderLineFormat(note, curr, AUTHOR, changeId);
    int startOfAccountId = RawParseUtils.endOfFooterLineKey(note, curr.value) + 2;
    PersonIdent ident = RawParseUtils.parsePersonIdent(note, startOfAccountId);
    Account.Id aId = parseIdent(ident, changeId);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return checkResult(aId, "comment author", changeId);
}
#method_after
private Account.Id parseAuthor(byte[] note, MutableInteger curr, Change.Id changeId, String fieldName) throws ConfigInvalidException {
    checkHeaderLineFormat(note, curr, fieldName, changeId);
    int startOfAccountId = RawParseUtils.endOfFooterLineKey(note, curr.value) + 2;
    PersonIdent ident = RawParseUtils.parsePersonIdent(note, startOfAccountId);
    Account.Id aId = parseIdent(ident, changeId);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return checkResult(aId, fieldName, changeId);
}
#end_block

#method_before
private void appendOneComment(PrintWriter writer, Comment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    Comment.Range range = c.range;
    if (range != null) {
        writer.print(range.startLine);
        writer.print(':');
        writer.print(range.startChar);
        writer.print('-');
        writer.print(range.endLine);
        writer.print(':');
        writer.print(range.endChar);
    } else {
        writer.print(c.lineNbr);
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.writtenOn));
    writer.print("\n");
    PersonIdent ident = newIdent(accountCache.get(c.author.getId()).getAccount(), c.writtenOn, serverIdent, anonymousCowardName);
    StringBuilder name = new StringBuilder();
    PersonIdent.appendSanitized(name, ident.getName());
    name.append(" <");
    PersonIdent.appendSanitized(name, ident.getEmailAddress());
    name.append('>');
    appendHeaderField(writer, AUTHOR, name.toString());
    String parent = c.parentUuid;
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.key.uuid);
    if (c.tag != null) {
        appendHeaderField(writer, TAG, c.tag);
    }
    byte[] messageBytes = c.message.getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.message);
    writer.print("\n\n");
}
#method_after
private void appendOneComment(PrintWriter writer, Comment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    Comment.Range range = c.range;
    if (range != null) {
        writer.print(range.startLine);
        writer.print(':');
        writer.print(range.startChar);
        writer.print('-');
        writer.print(range.endLine);
        writer.print(':');
        writer.print(range.endChar);
    } else {
        writer.print(c.lineNbr);
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.writtenOn));
    writer.print("\n");
    appendIdent(writer, AUTHOR, c.author.getId(), c.writtenOn);
    if (!c.getRealAuthor().equals(c.author)) {
        appendIdent(writer, REAL_AUTHOR, c.getRealAuthor().getId(), c.writtenOn);
    }
    String parent = c.parentUuid;
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.key.uuid);
    if (c.tag != null) {
        appendHeaderField(writer, TAG, c.tag);
    }
    byte[] messageBytes = c.message.getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.message);
    writer.print("\n\n");
}
#end_block

#method_before
private void parseChangeMessage(PatchSet.Id psId, Account.Id effectiveAccountId, Account.Id realAccountId, ChangeNotesCommit commit, Timestamp ts) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), effectiveAccountId, ts, psId);
    changeMessage.setMessage(changeMsgString);
    changeMessage.setTag(tag);
    changeMessage.setRealAuthor(realAccountId);
    changeMessagesByPatchSet.put(psId, changeMessage);
    allChangeMessages.add(changeMessage);
}
#method_after
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, Account.Id realAccountId, ChangeNotesCommit commit, Timestamp ts) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, ts, psId);
    changeMessage.setMessage(changeMsgString);
    changeMessage.setTag(tag);
    changeMessage.setRealAuthor(realAccountId);
    changeMessagesByPatchSet.put(psId, changeMessage);
    allChangeMessages.add(changeMessage);
}
#end_block

#method_before
public Account.Id getNullableAccountId() {
    return effectiveAccountId;
}
#method_after
public Account.Id getNullableAccountId() {
    return accountId;
}
#end_block

#method_before
private void assertRobotComment(RobotCommentInfo c, RobotCommentInput expected, boolean expectPath) {
    assertThat(c.robotId).isEqualTo(expected.robotId);
    assertThat(c.robotRunId).isEqualTo(expected.robotRunId);
    assertThat(c.url).isEqualTo(expected.url);
    if (expected.properties != null) {
        assertThat(c.properties).containsExactlyEntriesIn(expected.properties).inOrder();
    } else {
        assertThat(c.properties).isNull();
    }
    assertThat(c.line).isEqualTo(expected.line);
    assertThat(c.message).isEqualTo(expected.message);
    assertThat(c.author.email).isEqualTo(admin.email);
    if (expectPath) {
        assertThat(c.path).isEqualTo(expected.path);
    } else {
        assertThat(c.path).isNull();
    }
}
#method_after
private void assertRobotComment(RobotCommentInfo c, RobotCommentInput expected, boolean expectPath) {
    assertThat(c.robotId).isEqualTo(expected.robotId);
    assertThat(c.robotRunId).isEqualTo(expected.robotRunId);
    assertThat(c.url).isEqualTo(expected.url);
    assertThat(c.properties).isEqualTo(expected.properties);
    assertThat(c.line).isEqualTo(expected.line);
    assertThat(c.message).isEqualTo(expected.message);
    assertThat(c.author.email).isEqualTo(admin.email);
    if (expectPath) {
        assertThat(c.path).isEqualTo(expected.path);
    } else {
        assertThat(c.path).isNull();
    }
}
#end_block

#method_before
@Override
public String toString() {
    return new StringBuilder().append("RobotComment{").append("key=").append(key).append(',').append("robotId=").append(robotId).append(',').append("robotRunId=").append(robotRunId).append(',').append("lineNbr=").append(lineNbr).append(',').append("author=").append(author.getId().get()).append(',').append("writtenOn=").append(writtenOn.toString()).append(',').append("side=").append(side).append(',').append("message=").append(Objects.toString(message, "")).append(',').append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',').append("range=").append(Objects.toString(range, "")).append(',').append("revId=").append(revId != null ? revId : "").append(',').append("tag=").append(Objects.toString(tag, "")).append(',').append("url=").append(url).append(',').append("properties={").append(join(properties.entrySet().stream().map(e -> e.getKey() + "=" + e.getValue()).collect(toList()))).append('}').append('}').toString();
}
#method_after
@Override
public String toString() {
    return new StringBuilder().append("RobotComment{").append("key=").append(key).append(',').append("robotId=").append(robotId).append(',').append("robotRunId=").append(robotRunId).append(',').append("lineNbr=").append(lineNbr).append(',').append("author=").append(author.getId().get()).append(',').append("writtenOn=").append(writtenOn.toString()).append(',').append("side=").append(side).append(',').append("message=").append(Objects.toString(message, "")).append(',').append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',').append("range=").append(Objects.toString(range, "")).append(',').append("revId=").append(revId != null ? revId : "").append(',').append("tag=").append(Objects.toString(tag, "")).append(',').append("url=").append(url).append(',').append("properties=").append(properties != null ? properties : "").append('}').toString();
}
#end_block

#method_before
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    assigneeLink.setText(info.assignee() != null ? info.assignee().name() : "");
    assigneeSuggestOracle.setChange(changeId);
    editAssigneeIcon.setVisible(Gerrit.isSignedIn());
}
#method_after
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    this.canEdit = info.hasActions() && info.actions().containsKey("assignee");
    setAssignee(info.assignee());
    assigneeSuggestOracle.setChange(changeId);
    editAssigneeIcon.setVisible(canEdit);
    if (!canEdit) {
        show.setTitle(null);
    }
}
#end_block

#method_before
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(false);
    suggestBox.setFocus(true);
    suggestBox.setText("");
}
#method_after
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(show, false);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(false);
    suggestBox.setFocus(true);
    suggestBox.setText(FormatUtil.nameEmail(currentAssignee));
    suggestBox.selectAll();
}
#end_block

#method_before
void onCloseForm() {
    UIObject.setVisible(form, false);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(true);
    suggestBox.setFocus(false);
}
#method_after
void onCloseForm() {
    UIObject.setVisible(form, false);
    UIObject.setVisible(show, true);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(true);
    suggestBox.setFocus(false);
}
#end_block

#method_before
@UiHandler("assign")
void onEditAssignee(@SuppressWarnings("unused") ClickEvent e) {
    editAssignee(suggestBox.getText());
}
#method_after
@UiHandler("assign")
void onEditAssignee(@SuppressWarnings("unused") ClickEvent e) {
    if (canEdit) {
        editAssignee(suggestBox.getText());
    }
}
#end_block

#method_before
private void editAssignee(final String assignee) {
    if (assignee.isEmpty()) {
        ChangeApi.deleteAssignee(changeId.get(), new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                assigneeLink.setText("");
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    } else {
        ChangeApi.setAssignee(changeId.get(), assignee, new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                assigneeLink.setText(getName(result));
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    }
}
#method_after
private void editAssignee(final String assignee) {
    if (assignee.isEmpty()) {
        ChangeApi.deleteAssignee(changeId.get(), new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                setAssignee(null);
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    } else {
        ChangeApi.setAssignee(changeId.get(), assignee, new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                setAssignee(result);
                Reviewers reviewers = getReviewers();
                if (reviewers != null) {
                    reviewers.updateReviewerList();
                }
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    }
}
#end_block

#method_before
private String getName(AccountInfo info) {
    if (info.name() != null) {
        return info.name();
    }
    return info.username();
}
#method_after
private String getName(AccountInfo info) {
    if (info.name() != null) {
        return info.name();
    }
    if (info.email() != null) {
        return info.email();
    }
    return Gerrit.info().user().anonymousCowardName();
}
#end_block

#method_before
void format(StringBuilder s) {
    if (!Strings.isNullOrEmpty(name)) {
        s.append(name).append(": ");
    }
    synchronized (this) {
        if (total == UNKNOWN) {
            s.append(count);
        } else {
            s.append(String.format("%d%% (%d/%d)", count * 100 / total, count, total));
        }
    }
}
#method_after
synchronized void format(StringBuilder s, boolean first) {
    if (count == 0) {
        return;
    }
    if (!first) {
        s.append(',');
    }
    s.append(' ');
    if (!Strings.isNullOrEmpty(name)) {
        s.append(name).append(": ");
    }
    if (total == UNKNOWN) {
        s.append(count);
    } else {
        s.append(String.format("%d%% (%d/%d)", count * 100 / total, count, total));
    }
}
#end_block

#method_before
private StringBuilder format() {
    StringBuilder s = new StringBuilder().append("\r").append(taskName).append(':');
    if (!tasks.isEmpty()) {
        boolean first = true;
        for (Task t : tasks) {
            int count = t.count;
            if (count == 0) {
                continue;
            }
            if (!first) {
                s.append(',');
            } else {
                first = false;
            }
            s.append(' ');
            t.format(s);
        }
    }
    if (spinnerState != NO_SPINNER) {
        // Don't output a spinner until the alarm fires for the first time.
        s.append(" (").append(spinnerState).append(')');
    }
    return s;
}
#method_after
private StringBuilder format() {
    StringBuilder s = new StringBuilder().append("\r").append(taskName).append(':');
    int firstLength = s.length();
    for (Task t : tasks) {
        t.format(s, s.length() == firstLength);
    }
    if (spinnerState != NO_SPINNER) {
        // Don't output a spinner until the alarm fires for the first time.
        s.append(" (").append(spinnerState).append(')');
    }
    return s;
}
#end_block

#method_before
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
        checkState(input.drafts == DraftHandling.KEEP);
    }
    if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
    }
    return Response.ok(output);
}
#end_block

#method_before
private RevisionResource onBehalfOf(RevisionResource rev, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP || !isEmpty(in.comments) || !isEmpty(in.robotComments)) {
        // well for simplicity and consistency.
        throw new AuthException("not allowed to modify other user's comments");
    }
    ChangeControl caller = rev.getControl();
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = caller.getLabelTypes().byLabel(ent.getKey());
        if (type == null && in.strictLabels) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        } else if (type == null) {
            itr.remove();
            continue;
        }
        PermissionRange r = caller.getRange(Permission.forLabelAs(type.getName()));
        if (r == null || r.isEmpty() || !r.contains(ent.getValue())) {
            throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", ent.getKey(), in.onBehalfOf));
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    ChangeControl target = caller.forUser(accounts.parse(in.onBehalfOf));
    if (!target.getRefControl().isVisible()) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see destination ref", target.getUser().getAccountId()));
    }
    return new RevisionResource(changes.parse(target), rev.getPatchSet());
}
#method_after
private RevisionResource onBehalfOf(RevisionResource rev, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP) {
        throw new AuthException("not allowed to modify other user's drafts");
    }
    ChangeControl caller = rev.getControl();
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = caller.getLabelTypes().byLabel(ent.getKey());
        if (type == null && in.strictLabels) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        } else if (type == null) {
            itr.remove();
            continue;
        }
        PermissionRange r = caller.getRange(Permission.forLabelAs(type.getName()));
        if (r == null || r.isEmpty() || !r.contains(ent.getValue())) {
            throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", ent.getKey(), in.onBehalfOf));
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    ChangeControl target = caller.forUser(accounts.parse(in.onBehalfOf));
    if (!target.getRefControl().isVisible()) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see destination ref", target.getUser().getAccountId()));
    }
    return new RevisionResource(changes.parse(target), rev.getPatchSet());
}
#end_block

#method_before
@Override
public void run() {
    String path = cache.get("directory");
    if (path != null && path.isEmpty()) {
        // 
        return;
    }
    if (path == null) {
        path = "cache";
        cache.set("directory", path);
    }
    Path loc = site.resolve(path);
    FileUtil.mkdirsOrDie(loc, "cannot create cache.directory");
    List<Path> result = new ArrayList<>();
    try (DirectoryStream<Path> stream = Files.newDirectoryStream(loc, "*.{loc,h2}.db")) {
        for (Path entry : stream) {
            result.add(entry);
        }
    } catch (IOException e) {
        ui.message("IO error during cache directory scan");
        return;
    }
    if (!result.isEmpty() && ui.yesno(true, "Clear persistent caches")) {
        for (Path entry : result) {
            try {
                Files.deleteIfExists(entry);
            } catch (IOException e) {
                ui.message("Could not delete " + entry);
            }
        }
    }
}
#method_after
@Override
public void run() {
    ui.header("Cache");
    String path = cache.get("directory");
    if (path != null && path.isEmpty()) {
        // 
        return;
    }
    if (path == null) {
        path = "cache";
        cache.set("directory", path);
    }
    Path loc = site.resolve(path);
    FileUtil.mkdirsOrDie(loc, "cannot create cache.directory");
    List<Path> cacheFiles = new ArrayList<>();
    try (DirectoryStream<Path> stream = Files.newDirectoryStream(loc, "*.{lock,h2,trace}.db")) {
        for (Path entry : stream) {
            cacheFiles.add(entry);
        }
    } catch (IOException e) {
        ui.message("IO error during cache directory scan");
        return;
    }
    if (!cacheFiles.isEmpty()) {
        for (Path entry : cacheFiles) {
            if (ui.yesno(false, "Delete cache file %s", entry)) {
                try {
                    Files.deleteIfExists(entry);
                } catch (IOException e) {
                    ui.message("Could not delete " + entry);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public BinaryResult apply(RevisionResource rsrc) throws RestApiException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (allowedFormats.getAllowed().isEmpty() && format.equals("tar")) {
        // When no formats are allowed, this is because the server admin wants
        // to disallow downloading patchsets/changes as archives, this
        // is not applicable to the preview_submit call. Allow tar as a
        // fall back.
        f = ArchiveFormat.TAR;
    }
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new PreconditionFailedException("change is " + Submit.status(change));
    }
    ChangeControl control = rsrc.getControl();
    if (!control.getUser().isIdentifiedUser()) {
        throw new MethodNotAllowedException("Anonymous users cannot submit");
    }
    try (BinaryResult b = getBundles(rsrc, f)) {
        b.disableGzip().setContentType(f.getMimeType()).setAttachmentName("submit-preview-" + change.getChangeId() + "." + format);
        return b;
    } catch (OrmException | IOException e) {
        throw new RestApiException("Error generating submit preview");
    }
}
#method_after
@Override
public BinaryResult apply(RevisionResource rsrc) throws RestApiException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (f == null && format.equals("tgz")) {
        // Always allow tgz, even when the allowedFormats doesn't contain it.
        // Then we allow at least one format even if the list of allowed
        // formats is empty.
        f = ArchiveFormat.TGZ;
    }
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new PreconditionFailedException("change is " + Submit.status(change));
    }
    ChangeControl control = rsrc.getControl();
    if (!control.getUser().isIdentifiedUser()) {
        throw new MethodNotAllowedException("Anonymous users cannot submit");
    }
    try (BinaryResult b = getBundles(rsrc, f)) {
        b.disableGzip().setContentType(f.getMimeType()).setAttachmentName("submit-preview-" + change.getChangeId() + "." + format);
        return b;
    } catch (OrmException | IOException e) {
        throw new RestApiException("Error generating submit preview");
    }
}
#end_block

#method_before
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().hasAvatarInfo()) {
        AvatarImage avatar;
        if (change.owner().email() != null && person != null && person.email() != null && change.owner().email().equals(person.email())) {
            avatar = new AvatarImage(change.owner());
        } else {
            avatar = new AvatarImage(AccountInfo.create(0, person.name(), person.email(), null));
        }
        p.insert(avatar, 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#method_after
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().hasAvatarInfo()) {
        AvatarImage avatar;
        if (sameEmail(change.owner(), person)) {
            avatar = new AvatarImage(change.owner());
        } else {
            avatar = new AvatarImage(AccountInfo.create(0, person.name(), person.email(), null));
        }
        p.insert(avatar, 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#end_block

#method_before
@Override
public Set<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#method_after
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(ChangeResource rsrc, AssigneeInput input) throws RestApiException, UpdateException, OrmException, IOException {
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getControl().getUser(), TimeUtil.nowTs())) {
        SetAssigneeOp op = assigneeFactory.create(input);
        bu.addOp(rsrc.getId(), op);
        PostReviewers.Addition reviewersAddition = addAssigneAsCC(rsrc, input.assignee);
        bu.addOp(rsrc.getId(), reviewersAddition.op);
        bu.execute();
        reviewersAddition.gatherResults();
        return Response.ok(AccountJson.toAccountInfo(op.getNewAssignee()));
    }
}
#method_after
@Override
public Response<AccountInfo> apply(ChangeResource rsrc, AssigneeInput input) throws RestApiException, UpdateException, OrmException, IOException {
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getControl().getUser(), TimeUtil.nowTs())) {
        SetAssigneeOp op = assigneeFactory.create(input);
        bu.addOp(rsrc.getId(), op);
        PostReviewers.Addition reviewersAddition = addAssigneeAsCC(rsrc, input.assignee);
        bu.addOp(rsrc.getId(), reviewersAddition.op);
        bu.execute();
        reviewersAddition.gatherResults();
        return Response.ok(AccountJson.toAccountInfo(op.getNewAssignee()));
    }
}
#end_block

#method_before
@Test
public void approvalsTombstone() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId().get()).isEqualTo(1);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApproval("Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).isEmpty();
}
#method_after
@Test
public void approvalsTombstone() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId().get()).isEqualTo(1);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApproval("Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).containsExactlyEntriesIn(ImmutableMultimap.of(psa.getPatchSetId(), new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen())));
}
#end_block

#method_before
@Test
public void removeOtherUsersApprovals() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApprovalFor(otherUserId, "Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).isEmpty();
    // Add back approval on same label.
    update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 2);
    update.commit();
    notes = newNotes(c);
    psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 2);
}
#method_after
@Test
public void removeOtherUsersApprovals() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApprovalFor(otherUserId, "Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).containsExactlyEntriesIn(ImmutableMultimap.of(psa.getPatchSetId(), new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen())));
    // Add back approval on same label.
    update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 2);
    update.commit();
    notes = newNotes(c);
    psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 2);
}
#end_block

#method_before
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    assertThat(note).isEqualTo(pushCert);
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(newPublishedComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    // TODO(hanwen): test fails. What do we really want to check here?
    assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
}
#method_after
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    if (!testJson()) {
        assertThat(note).isEqualTo(pushCert);
    }
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(newPublishedComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
    if (!testJson()) {
        assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    PatchLineComment comment3 = newPublishedComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    PatchLineComment comment3 = newPublishedComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    PatchLineComment comment1 = newPublishedComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    PatchLineComment comment2 = newPublishedComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    PatchLineComment comment3 = newPublishedComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(comment3);
    update.putComment(comment2);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#method_after
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    PatchLineComment comment1 = newPublishedComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    PatchLineComment comment2 = newPublishedComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    PatchLineComment comment3 = newPublishedComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(comment3);
    update.putComment(comment2);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(comment.getRevId(), comment));
}
#method_after
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(comment.getRevId(), comment));
}
#end_block

#method_before
@Test
public void patchLineCommentsDeleteAllDrafts() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ObjectId objId = ObjectId.fromString(rev);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment = newComment(psId, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    assertThat(notes.getDraftCommentNotes().getNoteMap().contains(objId)).isTrue();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(psId);
    update.deleteComment(comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    // TODO
    assertThat(notes.getDraftCommentNotes().getNoteMap()).isNull();
}
#method_after
@Test
public void patchLineCommentsDeleteAllDrafts() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ObjectId objId = ObjectId.fromString(rev);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment = newComment(psId, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    assertThat(notes.getDraftCommentNotes().getNoteMap().contains(objId)).isTrue();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(psId);
    update.deleteComment(comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getDraftCommentNotes().getNoteMap()).isNull();
}
#end_block

#method_before
public List<PatchLineComment> parseNote(byte[] note, MutableInteger p, Change.Id changeId, Status status) throws ConfigInvalidException {
    if (p.value >= note.length) {
        return ImmutableList.of();
    }
    Set<PatchLineComment.Key> seen = new HashSet<>();
    List<PatchLineComment> result = new ArrayList<>();
    int sizeOfNote = note.length;
    byte[] psb = PATCH_SET.getBytes(UTF_8);
    byte[] bpsb = BASE_PATCH_SET.getBytes(UTF_8);
    byte[] bpn = PARENT_NUMBER.getBytes(UTF_8);
    if (note[p.value] == '{' || note[p.value] == '[') {
        return parseNoteJSON(note, p);
    }
    RevId revId = new RevId(parseStringField(note, p, changeId, REVISION));
    String fileName = null;
    PatchSet.Id psId = null;
    boolean isForBase = false;
    Integer parentNumber = null;
    while (p.value < sizeOfNote) {
        boolean matchPs = match(note, p, psb);
        boolean matchBase = match(note, p, bpsb);
        if (matchPs) {
            fileName = null;
            psId = parsePsId(note, p, changeId, PATCH_SET);
            isForBase = false;
        } else if (matchBase) {
            fileName = null;
            psId = parsePsId(note, p, changeId, BASE_PATCH_SET);
            isForBase = true;
            if (match(note, p, bpn)) {
                parentNumber = parseParentNumber(note, p, changeId);
            }
        } else if (psId == null) {
            throw parseException(changeId, "missing %s or %s header", PATCH_SET, BASE_PATCH_SET);
        }
        PatchLineComment c = parseComment(note, p, fileName, psId, revId, isForBase, parentNumber, status);
        fileName = c.getKey().getParentKey().getFileName();
        if (!seen.add(c.getKey())) {
            throw parseException(changeId, "multiple comments for %s in note", c.getKey());
        }
        result.add(c);
    }
    return result;
}
#method_after
public List<PatchLineComment> parseNote(byte[] note, MutableInteger p, Change.Id changeId, Status status) throws ConfigInvalidException {
    if (p.value >= note.length) {
        return ImmutableList.of();
    }
    Set<PatchLineComment.Key> seen = new HashSet<>();
    List<PatchLineComment> result = new ArrayList<>();
    int sizeOfNote = note.length;
    byte[] psb = PATCH_SET.getBytes(UTF_8);
    byte[] bpsb = BASE_PATCH_SET.getBytes(UTF_8);
    byte[] bpn = PARENT_NUMBER.getBytes(UTF_8);
    RevId revId = new RevId(parseStringField(note, p, changeId, REVISION));
    String fileName = null;
    PatchSet.Id psId = null;
    boolean isForBase = false;
    Integer parentNumber = null;
    while (p.value < sizeOfNote) {
        boolean matchPs = match(note, p, psb);
        boolean matchBase = match(note, p, bpsb);
        if (matchPs) {
            fileName = null;
            psId = parsePsId(note, p, changeId, PATCH_SET);
            isForBase = false;
        } else if (matchBase) {
            fileName = null;
            psId = parsePsId(note, p, changeId, BASE_PATCH_SET);
            isForBase = true;
            if (match(note, p, bpn)) {
                parentNumber = parseParentNumber(note, p, changeId);
            }
        } else if (psId == null) {
            throw parseException(changeId, "missing %s or %s header", PATCH_SET, BASE_PATCH_SET);
        }
        PatchLineComment c = parseComment(note, p, fileName, psId, revId, isForBase, parentNumber, status);
        fileName = c.getKey().getParentKey().getFileName();
        if (!seen.add(c.getKey())) {
            throw parseException(changeId, "multiple comments for %s in note", c.getKey());
        }
        result.add(c);
    }
    return result;
}
#end_block

#method_before
void buildNote(Multimap<PatchSet.Id, PatchLineComment> comments, OutputStream out) {
    if (gson != null) {
        buildNoteJSON(comments, out);
        return;
    }
    if (comments.isEmpty()) {
        return;
    }
    List<PatchSet.Id> psIds = ReviewDbUtil.intKeyOrdering().sortedCopy(comments.keySet());
    OutputStreamWriter streamWriter = new OutputStreamWriter(out, UTF_8);
    try (PrintWriter writer = new PrintWriter(streamWriter)) {
        RevId revId = comments.values().iterator().next().getRevId();
        appendHeaderField(writer, REVISION, revId.get());
        for (PatchSet.Id psId : psIds) {
            List<PatchLineComment> psComments = PLC_ORDER.sortedCopy(comments.get(psId));
            PatchLineComment first = psComments.get(0);
            short side = first.getSide();
            appendHeaderField(writer, side <= 0 ? BASE_PATCH_SET : PATCH_SET, Integer.toString(psId.get()));
            if (side < 0) {
                appendHeaderField(writer, PARENT_NUMBER, Integer.toString(-side));
            }
            String currentFilename = null;
            for (PatchLineComment c : psComments) {
                checkArgument(revId.equals(c.getRevId()), "All comments being added must have all the same RevId. The " + "comment below does not have the same RevId as the others " + "(%s).\n%s", revId, c);
                checkArgument(side == c.getSide(), "All comments being added must all have the same side. The " + "comment below does not have the same side as the others " + "(%s).\n%s", side, c);
                String commentFilename = QuotedString.GIT_PATH.quote(c.getKey().getParentKey().getFileName());
                if (!commentFilename.equals(currentFilename)) {
                    currentFilename = commentFilename;
                    writer.print("File: ");
                    writer.print(commentFilename);
                    writer.print("\n\n");
                }
                appendOneComment(writer, c);
            }
        }
    }
}
#method_after
void buildNote(Multimap<PatchSet.Id, PatchLineComment> comments, OutputStream out) {
    if (comments.isEmpty()) {
        return;
    }
    List<PatchSet.Id> psIds = ReviewDbUtil.intKeyOrdering().sortedCopy(comments.keySet());
    OutputStreamWriter streamWriter = new OutputStreamWriter(out, UTF_8);
    try (PrintWriter writer = new PrintWriter(streamWriter)) {
        RevId revId = comments.values().iterator().next().getRevId();
        appendHeaderField(writer, REVISION, revId.get());
        for (PatchSet.Id psId : psIds) {
            List<PatchLineComment> psComments = PLC_ORDER.sortedCopy(comments.get(psId));
            PatchLineComment first = psComments.get(0);
            short side = first.getSide();
            appendHeaderField(writer, side <= 0 ? BASE_PATCH_SET : PATCH_SET, Integer.toString(psId.get()));
            if (side < 0) {
                appendHeaderField(writer, PARENT_NUMBER, Integer.toString(-side));
            }
            String currentFilename = null;
            for (PatchLineComment c : psComments) {
                checkArgument(revId.equals(c.getRevId()), "All comments being added must have all the same RevId. The " + "comment below does not have the same RevId as the others " + "(%s).\n%s", revId, c);
                checkArgument(side == c.getSide(), "All comments being added must all have the same side. The " + "comment below does not have the same side as the others " + "(%s).\n%s", side, c);
                String commentFilename = QuotedString.GIT_PATH.quote(c.getKey().getParentKey().getFileName());
                if (!commentFilename.equals(currentFilename)) {
                    currentFilename = commentFilename;
                    writer.print("File: ");
                    writer.print(commentFilename);
                    writer.print("\n\n");
                }
                appendOneComment(writer, c);
            }
        }
    }
}
#end_block

#method_before
public static Set<String> fields(Schema<ChangeData> schema, QueryOptions opts) {
    // Ensure we request enough fields to construct a ChangeData.
    Set<String> fs = opts.fields();
    if (fs.contains(CHANGE.getName())) {
        // A Change is always sufficient.
        return fs;
    }
    if (!schema.hasField(PROJECT)) {
        // field, and call createOnlyWhenNoteDbDisabled from toChangeData below.
        if (fs.contains(LEGACY_ID.getName())) {
            return fs;
        }
        return Sets.union(fs, ImmutableSet.of(LEGACY_ID.getName()));
    }
    // New enough schema to have project field, so ensure that is requested.
    if (fs.contains(PROJECT.getName()) && fs.contains(LEGACY_ID.getName())) {
        return fs;
    }
    return Sets.union(fs, ImmutableSet.of(LEGACY_ID.getName(), PROJECT.getName()));
}
#method_after
public static Set<String> fields(QueryOptions opts) {
    // Ensure we request enough fields to construct a ChangeData. We need both
    // change ID and project, which can either come via the Change field or
    // separate fields.
    Set<String> fs = opts.fields();
    if (fs.contains(CHANGE.getName())) {
        // A Change is always sufficient.
        return fs;
    }
    if (fs.contains(PROJECT.getName()) && fs.contains(LEGACY_ID.getName())) {
        return fs;
    }
    return Sets.union(fs, ImmutableSet.of(LEGACY_ID.getName(), PROJECT.getName()));
}
#end_block

#method_before
@Override
protected String getMappings() {
    return "{\"mappings\" : " + getMappingProperties("open_changes") + "," + getMappingProperties("closed_changes") + "}";
}
#method_after
@Override
protected String getMappings() {
    return gson.toJson(ImmutableMap.of("mappings", mapping));
}
#end_block

#method_before
@Override
public void close() {
    MoreExecutors.shutdownAndAwaitTermination(executor, Long.MAX_VALUE, TimeUnit.SECONDS);
    try {
        openIndex.close();
    } finally {
        closedIndex.close();
    }
}
#method_after
@Override
public void close() {
    List<ListenableFuture<?>> closeFutures = Lists.newArrayListWithCapacity(2);
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            openIndex.close();
        }
    }));
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            closedIndex.close();
        }
    }));
    Futures.getUnchecked(Futures.allAsList(closeFutures));
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interrupted");
    }
    final Set<String> fields = IndexUtils.fields(schema, opts);
    return new ChangeDataResults(executor.submit(new Callable<List<Document>>() {

        @Override
        public List<Document> call() throws IOException {
            return doRead(fields);
        }

        @Override
        public String toString() {
            return predicate.toString();
        }
    }), fields);
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interrupted");
    }
    final Set<String> fields = IndexUtils.fields(opts);
    return new ChangeDataResults(executor.submit(new Callable<List<Document>>() {

        @Override
        public List<Document> call() throws IOException {
            return doRead(fields);
        }

        @Override
        public String toString() {
            return predicate.toString();
        }
    }), fields);
}
#end_block

#method_before
private ChangeData toChangeData(Multimap<String, IndexableField> doc, Set<String> fields, String idFieldName) {
    ChangeData cd;
    // Either change or the ID field was guaranteed to be included in the call
    // to fields() above.
    IndexableField cb = Iterables.getFirst(doc.get(CHANGE_FIELD), null);
    if (cb != null) {
        BytesRef proto = cb.binaryValue();
        cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(proto.bytes, proto.offset, proto.length));
    } else {
        IndexableField f = Iterables.getFirst(doc.get(idFieldName), null);
        Change.Id id = new Change.Id(f.numericValue().intValue());
        IndexableField project = Iterables.getFirst(doc.get(PROJECT.getName()), null);
        if (project == null) {
            // Old schema without project field: we can safely assume NoteDb is
            // disabled.
            cd = changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), id);
        } else {
            cd = changeDataFactory.create(db.get(), new Project.NameKey(project.stringValue()), id);
        }
    }
    if (fields.contains(PATCH_SET_FIELD)) {
        decodePatchSets(doc, cd);
    }
    if (fields.contains(APPROVAL_FIELD)) {
        decodeApprovals(doc, cd);
    }
    if (fields.contains(ADDED_FIELD) && fields.contains(DELETED_FIELD)) {
        decodeChangedLines(doc, cd);
    }
    if (fields.contains(MERGEABLE_FIELD)) {
        decodeMergeable(doc, cd);
    }
    if (fields.contains(REVIEWEDBY_FIELD)) {
        decodeReviewedBy(doc, cd);
    }
    if (fields.contains(HASHTAG_FIELD)) {
        decodeHashtags(doc, cd);
    }
    if (fields.contains(STARREDBY_FIELD)) {
        decodeStarredBy(doc, cd);
    }
    if (fields.contains(STAR_FIELD)) {
        decodeStar(doc, cd);
    }
    if (fields.contains(REVIEWER_FIELD)) {
        decodeReviewers(doc, cd);
    }
    return cd;
}
#method_after
private ChangeData toChangeData(Multimap<String, IndexableField> doc, Set<String> fields, String idFieldName) {
    ChangeData cd;
    // Either change or the ID field was guaranteed to be included in the call
    // to fields() above.
    IndexableField cb = Iterables.getFirst(doc.get(CHANGE_FIELD), null);
    if (cb != null) {
        BytesRef proto = cb.binaryValue();
        cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(proto.bytes, proto.offset, proto.length));
    } else {
        IndexableField f = Iterables.getFirst(doc.get(idFieldName), null);
        Change.Id id = new Change.Id(f.numericValue().intValue());
        IndexableField project = Iterables.getFirst(doc.get(PROJECT.getName()), null);
        if (project == null) {
            // Old schema without project field: we can safely assume NoteDb is
            // disabled.
            cd = changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), id);
        } else {
            cd = changeDataFactory.create(db.get(), new Project.NameKey(project.stringValue()), id);
        }
    }
    if (fields.contains(PATCH_SET_FIELD)) {
        decodePatchSets(doc, cd);
    }
    if (fields.contains(APPROVAL_FIELD)) {
        decodeApprovals(doc, cd);
    }
    if (fields.contains(ADDED_FIELD) && fields.contains(DELETED_FIELD)) {
        decodeChangedLines(doc, cd);
    }
    if (fields.contains(MERGEABLE_FIELD)) {
        decodeMergeable(doc, cd);
    }
    if (fields.contains(REVIEWEDBY_FIELD)) {
        decodeReviewedBy(doc, cd);
    }
    if (fields.contains(HASHTAG_FIELD)) {
        decodeHashtags(doc, cd);
    }
    if (fields.contains(STAR_FIELD)) {
        decodeStar(doc, cd);
    }
    if (fields.contains(REVIEWER_FIELD)) {
        decodeReviewers(doc, cd);
    }
    return cd;
}
#end_block

#method_before
private void readObject(ObjectInputStream input) throws IOException {
    String[] paths = new String[readVarInt32(input)];
    int i = 0;
    try (InflaterInputStream in = new InflaterInputStream(input)) {
        if (i >= paths.length) {
            throw new IOException("too many paths, expected " + paths.length);
        }
        paths[i++] = readString(in);
    }
    if (i != paths.length) {
        throw new IOException("expected " + paths.length + "paths, got " + i);
    }
}
#method_after
private void readObject(ObjectInputStream input) throws IOException {
    paths = new String[readVarInt32(input)];
    try (InflaterInputStream in = new InflaterInputStream(input)) {
        for (int i = 0; i < paths.length; i++) {
            paths[i] = readString(in);
        }
    }
}
#end_block

#method_before
public final boolean canEdit(Account.FieldName f) {
    return editableAccountFields().contains(f);
}
#method_after
public final boolean canEdit(AccountFieldName f) {
    return editableAccountFields().contains(f);
}
#end_block

#method_before
public final List<Account.FieldName> editableAccountFields() {
    List<Account.FieldName> fields = new ArrayList<>();
    for (String f : Natives.asList(_editableAccountFields())) {
        fields.add(Account.FieldName.valueOf(f));
    }
    return fields;
}
#method_after
public final List<AccountFieldName> editableAccountFields() {
    List<AccountFieldName> fields = new ArrayList<>();
    for (String f : Natives.asList(_editableAccountFields())) {
        fields.add(AccountFieldName.valueOf(f));
    }
    return fields;
}
#end_block

#method_before
public final boolean siteHasUsernames() {
    if (isCustomExtension() && httpPasswordUrl() != null && !canEdit(FieldName.USER_NAME)) {
        return false;
    }
    return true;
}
#method_after
public final boolean siteHasUsernames() {
    if (isCustomExtension() && httpPasswordUrl() != null && !canEdit(AccountFieldName.USER_NAME)) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (passwordMatchesTheUserGeneratedOne(who, username, password)) {
        setUserIdentified(who.getAccount().getId());
        return true;
    } else if (!authConfig.isLdapAuthType()) {
        log.warn("Authentication failed for {}: password does not match the one" + " stored in Gerrit", username);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        setUserIdentified(whoAuthResult.getAccountId());
        return true;
    } catch (NoSuchUserException e) {
        if (password.equals(who.getPassword(who.getUserName()))) {
            setUserIdentified(who.getAccount().getId());
            return true;
        }
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AuthenticationFailedException e) {
        log.warn("Authentication failed for " + username + ": " + e.getMessage());
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#method_after
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    GitBasicAuthPolicy gitBasicAuthPolicy = authConfig.getGitBasicAuthPolicy();
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP || gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP_LDAP) {
        if (passwordMatchesTheUserGeneratedOne(who, username, password)) {
            return succeedAuthentication(who);
        }
    }
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP) {
        return failAuthentication(rsp, username);
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        setUserIdentified(whoAuthResult.getAccountId());
        return true;
    } catch (NoSuchUserException e) {
        if (password.equals(who.getPassword(who.getUserName()))) {
            return succeedAuthentication(who);
        }
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AuthenticationFailedException e) {
        log.warn("Authentication failed for " + username + ": " + e.getMessage());
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#end_block

#method_before
private void setUserIdentified(final Account.Id id) {
    WebSession ws = session.get();
    ws.setUserAccountId(id);
    ws.setAccessPathOk(AccessPath.GIT, true);
    ws.setAccessPathOk(AccessPath.REST_API, true);
}
#method_after
private void setUserIdentified(Account.Id id) {
    WebSession ws = session.get();
    ws.setUserAccountId(id);
    ws.setAccessPathOk(AccessPath.GIT, true);
    ws.setAccessPathOk(AccessPath.REST_API, true);
}
#end_block

#method_before
public static int mainImpl(final String[] argv) throws Exception {
    if (argv.length == 0) {
        File me;
        try {
            me = getDistributionArchive();
        } catch (FileNotFoundException e) {
            me = null;
        }
        String jar = me != null ? me.getName() : "gerrit.war";
        System.err.println("Gerrit Code Review " + getVersion(me));
        System.err.println("usage: java -jar " + jar + " command [ARG ...]");
        System.err.println();
        System.err.println("The most commonly used commands are:");
        System.err.println("  init            Initialize a Gerrit installation");
        System.err.println("  rebuild-notedb  Rebuild the review notes database");
        System.err.println("  reindex         Rebuild the secondary index");
        System.err.println("  daemon          Run the Gerrit network daemons");
        System.err.println("  gsql            Run the interactive query console");
        System.err.println("  version         Display the build version number");
        System.err.println();
        System.err.println("  ls              List files available for cat");
        System.err.println("  cat FILE        Display a file from the archive");
        System.err.println();
        return 1;
    }
    // 
    if ("-v".equals(argv[0]) || "--version".equals(argv[0])) {
        argv[0] = "version";
    } else if ("-p".equals(argv[0]) || "--cat".equals(argv[0])) {
        argv[0] = "cat";
    } else if ("-l".equals(argv[0]) || "--ls".equals(argv[0])) {
        argv[0] = "ls";
    }
    // Run the application class
    // 
    final ClassLoader cl = libClassLoader(isProlog(programClassName(argv[0])));
    Thread.currentThread().setContextClassLoader(cl);
    return invokeProgram(cl, argv);
}
#method_after
public static int mainImpl(final String[] argv) throws Exception {
    if (argv.length == 0) {
        File me;
        try {
            me = getDistributionArchive();
        } catch (FileNotFoundException e) {
            me = null;
        }
        String jar = me != null ? me.getName() : "gerrit.war";
        System.err.println("Gerrit Code Review " + getVersion(me));
        System.err.println("usage: java -jar " + jar + " command [ARG ...]");
        System.err.println();
        System.err.println("The most commonly used commands are:");
        System.err.println("  init            Initialize a Gerrit installation");
        System.err.println("  reindex         Rebuild the secondary index");
        System.err.println("  daemon          Run the Gerrit network daemons");
        System.err.println("  gsql            Run the interactive query console");
        System.err.println("  version         Display the build version number");
        System.err.println();
        System.err.println("  ls              List files available for cat");
        System.err.println("  cat FILE        Display a file from the archive");
        System.err.println();
        return 1;
    }
    // 
    if ("-v".equals(argv[0]) || "--version".equals(argv[0])) {
        argv[0] = "version";
    } else if ("-p".equals(argv[0]) || "--cat".equals(argv[0])) {
        argv[0] = "cat";
    } else if ("-l".equals(argv[0]) || "--ls".equals(argv[0])) {
        argv[0] = "ls";
    }
    // Run the application class
    // 
    final ClassLoader cl = libClassLoader(isProlog(programClassName(argv[0])));
    Thread.currentThread().setContextClassLoader(cl);
    return invokeProgram(cl, argv);
}
#end_block

#method_before
private static FileSystem newZipFileSystem(Path zip) throws IOException {
    return FileSystems.newFileSystem(URI.create("jar:" + zip.toUri()), Collections.<String, String>emptyMap());
}
#method_after
public static FileSystem newZipFileSystem(Path zip) throws IOException {
    return FileSystems.newFileSystem(URI.create("jar:" + zip.toUri()), Collections.<String, String>emptyMap());
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new EventBroker.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private AbstractModule createIndexModule() {
    if (slave) {
        return new DummyIndexModule();
    }
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : new LuceneIndexModule();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#method_after
private AbstractModule createIndexModule() {
    if (slave) {
        return new DummyIndexModule();
    }
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : LuceneIndexModule.latestVersionWithOnlineUpgrade();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(StaticModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    // StaticModule contains a "/*" wildcard, place it last.
    modules.add(sysInjector.getInstance(StaticModule.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                accounts = parseAccount(pair.getValue());
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                accounts = parseAccount(value);
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.listMembers.get().setRecursive(true).apply(group).stream().map(a -> new Account.Id(a._accountId)).collect(toSet());
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    return new LabelPredicate(args.projectCache, args.changeControlGenericFactory, args.userFactory, args.db, name, accounts, group);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",owner":
    // label:Code-Review+2,owner
    // label:Code-Review+2,user=owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                if (pair.getValue().equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(pair.getValue());
                }
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                if (value.equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(value);
                }
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.listMembers.get().setRecursive(true).apply(group).stream().map(a -> new Account.Id(a._accountId)).collect(toSet());
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    return new LabelPredicate(args, name, accounts, group);
}
#end_block

#method_before
private Predicate<ChangeData> starredby(Set<Account.Id> who) throws QueryParseException {
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(who.size());
    for (Account.Id id : who) {
        p.add(starredby(id));
    }
    return Predicate.or(p);
}
#method_after
private Predicate<ChangeData> starredby(Set<Account.Id> who) {
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(who.size());
    for (Account.Id id : who) {
        p.add(starredby(id));
    }
    return Predicate.or(p);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private Predicate<ChangeData> starredby(Account.Id who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.STAR)) {
        return new StarPredicate(who, StarredChangesUtil.DEFAULT_LABEL);
    }
    try {
        // git
        return new IsStarredByLegacyPredicate(who, args.starredChangesUtil.byAccount(who, StarredChangesUtil.DEFAULT_LABEL));
    } catch (OrmException e) {
        throw new QueryParseException("Failed to query starred changes.", e);
    }
}
#method_after
private Predicate<ChangeData> starredby(Account.Id who) {
    return new StarPredicate(who, StarredChangesUtil.DEFAULT_LABEL);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private Predicate<ChangeData> draftby(Account.Id who) {
    return args.getSchema().hasField(ChangeField.DRAFTBY) ? new HasDraftByPredicate(who) : new HasDraftByLegacyPredicate(args, who);
}
#method_after
private Predicate<ChangeData> draftby(Account.Id who) {
    return new HasDraftByPredicate(who);
}
#end_block

#method_before
public List<ChangeData> bySubmissionId(String cs) throws OrmException {
    if (Strings.isNullOrEmpty(cs) || !schema().hasField(SUBMISSIONID)) {
        return Collections.emptyList();
    }
    return query(new SubmissionIdPredicate(cs));
}
#method_after
public List<ChangeData> bySubmissionId(String cs) throws OrmException {
    if (Strings.isNullOrEmpty(cs)) {
        return Collections.emptyList();
    }
    return query(new SubmissionIdPredicate(cs));
}
#end_block

#method_before
public static String formatLabel(String label, int value, Account.Id accountId) {
    return label.toLowerCase() + (value >= 0 ? "+" : "") + value + (accountId != null ? "," + accountId.get() : "");
}
#method_after
public static String formatLabel(String label, int value, Account.Id accountId) {
    return label.toLowerCase() + (value >= 0 ? "+" : "") + value + (accountId != null ? "," + formatAccount(accountId) : "");
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, RestApiException {
    if (!notesMigration.readChanges()) {
        throw new BadRequestException("Cannot add Assignee; NoteDb is disabled");
    }
    if (!ctx.getControl().canEditAssignee()) {
        throw new AuthException("Changing Assignee not permitted");
    }
    ChangeUpdate update = ctx.getUpdate(ctx.getChange().currentPatchSetId());
    Optional<Account.Id> oldAssigneeId = update.getNotes().getAssignee();
    if (input.assignee == null) {
        if (oldAssigneeId != null && oldAssigneeId.isPresent()) {
            throw new AuthException("Cannot set Assignee to empty");
        }
        return false;
    }
    Account oldAssignee = null;
    if (oldAssigneeId != null && oldAssigneeId.isPresent()) {
        oldAssignee = accountInfosFactory.create().get(oldAssigneeId.get());
    }
    IdentifiedUser newAssigneeUser = accounts.parse(input.assignee);
    if (oldAssigneeId != null && oldAssigneeId.equals(newAssigneeUser.getAccountId())) {
        newAssignee = oldAssignee;
        return false;
    }
    if (!newAssigneeUser.getAccount().isActive()) {
        throw new UnprocessableEntityException(String.format("Account of %s is not active", newAssigneeUser.getUserName()));
    }
    if (!ctx.getControl().forUser(newAssigneeUser).isRefVisible()) {
        throw new AuthException(String.format("Change %s is not visible to %s.", ctx.getChange().getChangeId(), newAssigneeUser.getUserName()));
    }
    try {
        for (AssigneeValidationListener validator : validationListeners) {
            validator.validateAssignee(change, newAssigneeUser.getAccount());
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    update.setAssignee(Optional.fromNullable(newAssigneeUser.getAccountId()));
    this.newAssignee = newAssigneeUser.getAccount();
    addMessage(ctx, update, oldAssignee);
    return true;
}
#method_after
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, RestApiException {
    if (!notesMigration.readChanges()) {
        throw new BadRequestException("Cannot add Assignee; NoteDb is disabled");
    }
    if (!ctx.getControl().canEditAssignee()) {
        throw new AuthException("Changing Assignee not permitted");
    }
    ChangeUpdate update = ctx.getUpdate(ctx.getChange().currentPatchSetId());
    Optional<Account.Id> oldAssigneeId = update.getNotes().getAssignee();
    if (input.assignee == null) {
        if (oldAssigneeId != null && oldAssigneeId.isPresent()) {
            throw new AuthException("Cannot set Assignee to empty");
        }
        return false;
    }
    Account oldAssignee = null;
    if (oldAssigneeId != null && oldAssigneeId.isPresent()) {
        oldAssignee = accountInfosFactory.create().get(oldAssigneeId.get());
    }
    IdentifiedUser newAssigneeUser = accounts.parse(input.assignee);
    if (oldAssigneeId != null && oldAssigneeId.equals(newAssigneeUser.getAccountId())) {
        newAssignee = oldAssignee;
        return false;
    }
    if (!newAssigneeUser.getAccount().isActive()) {
        throw new UnprocessableEntityException(String.format("Account of %s is not active", newAssigneeUser.getUserName()));
    }
    if (!ctx.getControl().forUser(newAssigneeUser).isRefVisible()) {
        throw new AuthException(String.format("Change %s is not visible to %s.", ctx.getChange().getChangeId(), newAssigneeUser.getUserName()));
    }
    try {
        for (AssigneeValidationListener validator : validationListeners) {
            validator.validateAssignee(change, newAssigneeUser.getAccount());
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    update.setAssignee(newAssigneeUser.getAccountId());
    this.newAssignee = newAssigneeUser.getAccount();
    addMessage(ctx, update, oldAssignee);
    return true;
}
#end_block

#method_before
@Override
public void validateAssignee(Change change, Account assignee) throws ValidationException {
    try {
        if (queryProcessor.query(queryBuilder.assignee(assignee.getPreferredEmail())).entities().size() > MAX_ASSIGNED_CHANGES) {
            throw new ValidationException("Cannot assign user to more than " + MAX_ASSIGNED_CHANGES + " changes");
        }
    } catch (OrmException e1) {
    } catch (QueryParseException e2) {
    }
}
#method_after
@Override
public void validateAssignee(Change change, Account assignee) throws ValidationException {
    try {
        if (queryProcessor.query(queryBuilder.assignee(assignee.getPreferredEmail())).entities().size() > MAX_ASSIGNED_CHANGES) {
            throw new ValidationException("Cannot assign user to more than " + MAX_ASSIGNED_CHANGES + " changes");
        }
    } catch (OrmException | QueryParseException e) {
        log.error("Failed to validate assignee for change " + change.getId(), e);
    // Allow assignee.
    }
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    if (!showLegacyId) {
        fmt.addStyleName(row, C_ID, Gerrit.RESOURCES.css().dataCellHidden());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().cSTATUS());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_ASSIGNEE, Gerrit.info().change().showAssignee() ? Gerrit.RESOURCES.css().cASSIGNEE() : Gerrit.RESOURCES.css().dataCellHidden());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    fmt.addStyleName(row, C_SIZE, Gerrit.RESOURCES.css().cSIZE());
    for (int i = C_SIZE + 1; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    if (!showLegacyId) {
        fmt.addStyleName(row, C_ID, Gerrit.RESOURCES.css().dataCellHidden());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().cSTATUS());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_ASSIGNEE, showAssignee ? Gerrit.RESOURCES.css().cASSIGNEE() : Gerrit.RESOURCES.css().dataCellHidden());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    fmt.addStyleName(row, C_SIZE, Gerrit.RESOURCES.css().cSIZE());
    for (int i = C_SIZE + 1; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    if (Gerrit.info().change().showAssignee()) {
        if (c.assignee() != null) {
            table.setWidget(row, C_ASSIGNEE, new AssigneeLinkPanel(c.assignee()));
            if (Gerrit.getUserPreferences().highlightAssigneeInChangeTable() && c.assignee().getId().get() == Gerrit.getUserAccount().getId().get()) {
                table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME());
            }
        } else {
            table.setText(row, C_ASSIGNEE, "");
        }
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.getUserPreferences().relativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (!Gerrit.getUserPreferences().sizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserPreferences().reviewCategoryStrategy();
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, AccountLinkPanel.withStatus(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    if (showAssignee) {
        if (c.assignee() != null) {
            table.setWidget(row, C_ASSIGNEE, AccountLinkPanel.forAssignee(c.assignee()));
            if (Gerrit.getUserPreferences().highlightAssigneeInChangeTable() && Objects.equals(c.assignee().getId(), Gerrit.getUserAccount().getId())) {
                table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME());
            }
        } else {
            table.setText(row, C_ASSIGNEE, "");
        }
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.getUserPreferences().relativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (!Gerrit.getUserPreferences().sizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserPreferences().reviewCategoryStrategy();
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input).value();
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set assigne", e);
    }
}
#method_after
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input).value();
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set assignee", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo getAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = getAssignee.apply(change);
        if (r.isNone()) {
            return null;
        }
        return r.value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get assigne", e);
    }
}
#method_after
@Override
public AccountInfo getAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = getAssignee.apply(change);
        return r.isNone() ? null : r.value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get assignee", e);
    }
}
#end_block

#method_before
@Override
public Set<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees assigne", e);
    }
}
#method_after
@Override
public Set<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = (Response<AccountInfo>) deleteAssignee.apply(change, null);
        if (r.isNone()) {
            return null;
        }
        return r.value();
    } catch (UpdateException e) {
        throw new RestApiException("Cannot delete assigne", e);
    }
}
#method_after
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (UpdateException e) {
        throw new RestApiException("Cannot delete assignee", e);
    }
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    if (!showLegacyId) {
        fmt.addStyleName(row, C_ID, Gerrit.RESOURCES.css().dataCellHidden());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().cSTATUS());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_ASSIGNEE, Gerrit.info().change().showAssignee() ? Gerrit.RESOURCES.css().cASSIGNEE() : Gerrit.RESOURCES.css().dataCellHidden());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    fmt.addStyleName(row, C_SIZE, Gerrit.RESOURCES.css().cSIZE());
    for (int i = C_SIZE + 1; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    if (!showLegacyId) {
        fmt.addStyleName(row, C_ID, Gerrit.RESOURCES.css().dataCellHidden());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().cSTATUS());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_ASSIGNEE, showAssignee ? Gerrit.RESOURCES.css().cASSIGNEE() : Gerrit.RESOURCES.css().dataCellHidden());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    fmt.addStyleName(row, C_SIZE, Gerrit.RESOURCES.css().cSIZE());
    for (int i = C_SIZE + 1; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    if (Gerrit.info().change().showAssignee()) {
        if (c.assignee() != null) {
            table.setWidget(row, C_ASSIGNEE, new AssigneeLinkPanel(c.assignee()));
            if (c.assignee().getId().get() == Gerrit.getUserAccount().getId().get()) {
                table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME());
            }
        } else {
            table.setText(row, C_ASSIGNEE, "");
        }
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.getUserPreferences().relativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (!Gerrit.getUserPreferences().sizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserPreferences().reviewCategoryStrategy();
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, AccountLinkPanel.withStatus(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    if (showAssignee) {
        if (c.assignee() != null) {
            table.setWidget(row, C_ASSIGNEE, AccountLinkPanel.forAssignee(c.assignee()));
            if (Objects.equals(c.assignee().getId(), Gerrit.getUserAccount().getId())) {
                table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME());
            }
        } else {
            table.setText(row, C_ASSIGNEE, "");
        }
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.getUserPreferences().relativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (!Gerrit.getUserPreferences().sizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserPreferences().reviewCategoryStrategy();
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    if (c.assignee() != null) {
        table.setWidget(row, C_ASSIGNEE, new AssigneeLinkPanel(c.assignee()));
        if (c.assignee().getId().get() == Gerrit.getUserAccount().getId().get()) {
            table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME());
        }
    } else {
        table.setText(row, C_ASSIGNEE, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.getUserPreferences().relativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (!Gerrit.getUserPreferences().sizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserPreferences().reviewCategoryStrategy();
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    if (c.assignee() != null) {
        table.setWidget(row, C_ASSIGNEE, new AssigneeLinkPanel(c.assignee()));
        if (Objects.equals(c.assignee().getId(), Gerrit.getUserAccount().getId())) {
            table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME());
        }
    } else {
        table.setText(row, C_ASSIGNEE, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.getUserPreferences().relativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (!Gerrit.getUserPreferences().sizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserPreferences().reviewCategoryStrategy();
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
public static String assignedTo(AccountInfo ai) {
    if (ai.email() != null) {
        return ai.email();
    } else if (ai.name() != null) {
        return ai.name();
    } else if (ai._accountId() != 0) {
        return "" + ai._accountId();
    } else {
        return "";
    }
}
#method_after
public static String assignedTo(AccountInfo ai) {
    if (ai.email() != null) {
        return ai.email();
    } else if (ai.name() != null) {
        return ai.name();
    } else {
        return "";
    }
}
#end_block

#method_before
static Description forTestClass(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(configName, // @UseLocalDisk is only valid on methods.
    true, !has(NoHttpd.class, testDesc.getTestClass()), !has(Hermetic.class, testDesc.getTestClass()), // @GerritConfig is only valid on methods.
    null, // @GerritConfigs is only valid on methods.
    null);
}
#method_after
static Description forTestClass(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(configName, // @UseLocalDisk is only valid on methods.
    true, !has(NoHttpd.class, testDesc.getTestClass()), has(Sandboxed.class, testDesc.getTestClass()), // @GerritConfig is only valid on methods.
    null, // @GerritConfigs is only valid on methods.
    null);
}
#end_block

#method_before
static Description forTestMethod(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(configName, testDesc.getAnnotation(UseLocalDisk.class) == null, testDesc.getAnnotation(NoHttpd.class) == null && !has(NoHttpd.class, testDesc.getTestClass()), testDesc.getAnnotation(Hermetic.class) == null && !has(Hermetic.class, testDesc.getTestClass()), testDesc.getAnnotation(GerritConfig.class), testDesc.getAnnotation(GerritConfigs.class));
}
#method_after
static Description forTestMethod(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(configName, testDesc.getAnnotation(UseLocalDisk.class) == null, testDesc.getAnnotation(NoHttpd.class) == null && !has(NoHttpd.class, testDesc.getTestClass()), testDesc.getAnnotation(Sandboxed.class) != null || has(Sandboxed.class, testDesc.getTestClass()), testDesc.getAnnotation(GerritConfig.class), testDesc.getAnnotation(GerritConfigs.class));
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) || classDesc.hermethic()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    notesMigration.setFromEnv();
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(user);
    atrScope.set(ctx);
    userSshSession = ctx.getSession();
    userSshSession.open();
    ctx = newRequestContext(admin);
    atrScope.set(ctx);
    adminSshSession = ctx.getSession();
    adminSshSession.open();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    notesMigration.setFromEnv();
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(user);
    atrScope.set(ctx);
    userSshSession = ctx.getSession();
    userSshSession.open();
    ctx = newRequestContext(admin);
    atrScope.set(ctx);
    adminSshSession = ctx.getSession();
    adminSshSession.open();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, allowsDrafts);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",change_owner":
    // label:Code-Review+2,user=0
    // label:Code-Review+2,change_owner
    // label:Code-Review+2,user=change_owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                accounts = parseAccount(pair.getValue());
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                accounts = parseAccount(value);
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = new HashSet<>(Lists.transform(args.listMembers.get().setRecursive(true).apply(group), new Function<AccountInfo, Account.Id>() {

            @Override
            public Account.Id apply(AccountInfo accountInfo) {
                return new Account.Id(accountInfo._accountId);
            }
        }));
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    return new LabelPredicate(args.projectCache, args.changeControlGenericFactory, args.userFactory, args.db, name, accounts, group);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",owner":
    // label:Code-Review+2,owner
    // label:Code-Review+2,user=owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                if (pair.getValue().equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(pair.getValue());
                }
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                if (value.equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(value);
                }
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.listMembers.get().setRecursive(true).apply(group).stream().map(a -> new Account.Id(a._accountId)).collect(toSet());
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    return new LabelPredicate(args, name, accounts, group);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    if (who.equals(ARG_ID_CHANGE_OWNER) || who.equals(CHANGE_OWNER_ACCOUNT_ID.toString())) {
        return Collections.singleton(CHANGE_OWNER_ACCOUNT_ID);
    }
    Set<Account.Id> matches = args.accountResolver.findAll(who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#method_after
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#end_block

#method_before
private static String formatAccount(Account.Id accountId) {
    if (ChangeQueryBuilder.CHANGE_OWNER_ACCOUNT_ID.equals(accountId)) {
        return ChangeQueryBuilder.ARG_ID_CHANGE_OWNER;
    }
    return Integer.toString(accountId.get());
}
#method_after
private static String formatAccount(Account.Id accountId) {
    if (ChangeQueryBuilder.OWNER_ACCOUNT_ID.equals(accountId)) {
        return ChangeQueryBuilder.ARG_ID_OWNER;
    }
    return Integer.toString(accountId.get());
}
#end_block

#method_before
public List<ChangeNotes> create(ReviewDb db, Project.NameKey project, Collection<Change.Id> changeIds, Predicate<ChangeNotes> predicate) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.enabled()) {
        for (Change.Id cid : changeIds) {
            ChangeNotes cn = create(db, project, cid);
            if (cn.getChange() != null && predicate.apply(cn)) {
                notes.add(cn);
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        if (c != null && project.equals(c.getDest().getParentKey())) {
            ChangeNotes cn = createFromChangeOnlyWhenNoteDbDisabled(c);
            if (predicate.apply(cn)) {
                notes.add(cn);
            }
        }
    }
    return notes;
}
#method_after
public List<ChangeNotes> create(ReviewDb db, Project.NameKey project, Collection<Change.Id> changeIds, Predicate<ChangeNotes> predicate) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.enabled()) {
        for (Change.Id cid : changeIds) {
            ChangeNotes cn = create(db, project, cid);
            if (cn.getChange() != null && predicate.test(cn)) {
                notes.add(cn);
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        if (c != null && project.equals(c.getDest().getParentKey())) {
            ChangeNotes cn = createFromChangeOnlyWhenNoteDbDisabled(c);
            if (predicate.test(cn)) {
                notes.add(cn);
            }
        }
    }
    return notes;
}
#end_block

#method_before
public ListMultimap<Project.NameKey, ChangeNotes> create(ReviewDb db, Predicate<ChangeNotes> predicate) throws IOException, OrmException {
    ListMultimap<Project.NameKey, ChangeNotes> m = ArrayListMultimap.create();
    if (args.migration.readChanges()) {
        for (Project.NameKey project : projectCache.all()) {
            try (Repository repo = args.repoManager.openRepository(project)) {
                List<ChangeNotes> changes = scanNoteDb(repo, db, project);
                for (ChangeNotes cn : changes) {
                    if (predicate.apply(cn)) {
                        m.put(project, cn);
                    }
                }
            }
        }
    } else {
        for (Change change : ReviewDbUtil.unwrapDb(db).changes().all()) {
            ChangeNotes notes = createFromChangeOnlyWhenNoteDbDisabled(change);
            if (predicate.apply(notes)) {
                m.put(change.getProject(), notes);
            }
        }
    }
    return ImmutableListMultimap.copyOf(m);
}
#method_after
public ListMultimap<Project.NameKey, ChangeNotes> create(ReviewDb db, Predicate<ChangeNotes> predicate) throws IOException, OrmException {
    ListMultimap<Project.NameKey, ChangeNotes> m = ArrayListMultimap.create();
    if (args.migration.readChanges()) {
        for (Project.NameKey project : projectCache.all()) {
            try (Repository repo = args.repoManager.openRepository(project)) {
                List<ChangeNotes> changes = scanNoteDb(repo, db, project);
                for (ChangeNotes cn : changes) {
                    if (predicate.test(cn)) {
                        m.put(project, cn);
                    }
                }
            }
        }
    } else {
        for (Change change : ReviewDbUtil.unwrapDb(db).changes().all()) {
            ChangeNotes notes = createFromChangeOnlyWhenNoteDbDisabled(change);
            if (predicate.test(notes)) {
                m.put(change.getProject(), notes);
            }
        }
    }
    return ImmutableListMultimap.copyOf(m);
}
#end_block

#method_before
public ImmutableListMultimap<RevId, PatchLineComment> getComments() {
    return state.publishedComments();
}
#method_after
public ImmutableListMultimap<RevId, Comment> getComments() {
    return state.publishedComments();
}
#end_block

#method_before
public ImmutableListMultimap<RevId, PatchLineComment> getDraftComments(Account.Id author) throws OrmException {
    loadDraftComments(author);
    final Multimap<RevId, PatchLineComment> published = state.publishedComments();
    // Filter out any draft comments that also exist in the published map, in
    // case the update to All-Users to delete them during the publish operation
    // failed.
    Multimap<RevId, PatchLineComment> filtered = Multimaps.filterEntries(draftCommentNotes.getComments(), new Predicate<Map.Entry<RevId, PatchLineComment>>() {

        @Override
        public boolean apply(Map.Entry<RevId, PatchLineComment> in) {
            for (PatchLineComment c : published.get(in.getKey())) {
                if (c.getKey().equals(in.getValue().getKey())) {
                    return false;
                }
            }
            return true;
        }
    });
    return ImmutableListMultimap.copyOf(filtered);
}
#method_after
public ImmutableListMultimap<RevId, Comment> getDraftComments(Account.Id author) throws OrmException {
    loadDraftComments(author);
    final Multimap<RevId, Comment> published = state.publishedComments();
    // Filter out any draft comments that also exist in the published map, in
    // case the update to All-Users to delete them during the publish operation
    // failed.
    Multimap<RevId, Comment> filtered = Multimaps.filterEntries(draftCommentNotes.getComments(), (Map.Entry<RevId, Comment> e) -> {
        for (Comment c : published.get(e.getKey())) {
            if (c.key.equals(e.getValue().key)) {
                return false;
            }
        }
        return true;
    });
    return ImmutableListMultimap.copyOf(filtered);
}
#end_block

#method_before
public boolean containsComment(PatchLineComment c) throws OrmException {
    if (containsCommentPublished(c)) {
        return true;
    }
    loadDraftComments(c.getAuthor());
    return draftCommentNotes.containsComment(c);
}
#method_after
public boolean containsComment(Comment c) throws OrmException {
    if (containsCommentPublished(c)) {
        return true;
    }
    loadDraftComments(c.author.getId());
    return draftCommentNotes.containsComment(c);
}
#end_block

#method_before
public boolean containsCommentPublished(PatchLineComment c) {
    for (PatchLineComment l : getComments().values()) {
        if (c.getKey().equals(l.getKey())) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean containsCommentPublished(Comment c) {
    for (Comment l : getComments().values()) {
        if (c.key.equals(l.key)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private ChangeNotesState buildState() {
    return ChangeNotesState.create(id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, status, assignee, historicalAssignees, hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments);
}
#method_after
private ChangeNotesState buildState() {
    return ChangeNotesState.create(id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, status, assignee != null ? assignee.orNull() : null, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments);
}
#end_block

#method_before
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    if (currentPatchSetId == null || psId.get() > currentPatchSetId.get()) {
        currentPatchSetId = psId;
    }
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    parseHistoricalAssignees(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
}
#method_after
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    if (currentPatchSetId == null || psId.get() > currentPatchSetId.get()) {
        currentPatchSetId = psId;
    }
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
}
#end_block

#method_before
private void parseAssignee(ChangeNotesCommit commit) throws ConfigInvalidException {
    if (isAssigneeParsed) {
        return;
    }
    String assigneeValue = parseOneFooter(commit, FOOTER_ASSIGNEE);
    if (assigneeValue == null) {
    // footer not found
    } else if (assigneeValue.equals("")) {
        // empty footer found, assignee deleted
        assignee = null;
        isAssigneeParsed = true;
    } else {
        PersonIdent ident = RawParseUtils.parsePersonIdent(assigneeValue);
        assignee = noteUtil.parseIdent(ident, id);
        isAssigneeParsed = true;
    }
}
#method_after
private void parseAssignee(ChangeNotesCommit commit) throws ConfigInvalidException {
    if (pastAssignees == null) {
        pastAssignees = Lists.newArrayList();
    }
    String assigneeValue = parseOneFooter(commit, FOOTER_ASSIGNEE);
    if (assigneeValue != null) {
        Optional<Account.Id> parsedAssignee;
        if (assigneeValue.equals("")) {
            // Empty footer found, assignee deleted
            parsedAssignee = Optional.absent();
        } else {
            PersonIdent ident = RawParseUtils.parsePersonIdent(assigneeValue);
            parsedAssignee = Optional.fromNullable(noteUtil.parseIdent(ident, id));
        }
        if (assignee == null) {
            assignee = parsedAssignee;
        }
        if (parsedAssignee.isPresent()) {
            pastAssignees.add(parsedAssignee.get());
        }
    }
}
#end_block

#method_before
private void parseNotes() throws IOException, ConfigInvalidException {
    ObjectReader reader = walk.getObjectReader();
    ChangeNotesCommit tipCommit = walk.parseCommit(tip);
    revisionNoteMap = RevisionNoteMap.parse(noteUtil, id, reader, NoteMap.read(reader, tipCommit), PatchLineComment.Status.PUBLISHED);
    Map<RevId, RevisionNote> rns = revisionNoteMap.revisionNotes;
    for (Map.Entry<RevId, RevisionNote> e : rns.entrySet()) {
        for (PatchLineComment plc : e.getValue().comments) {
            comments.put(e.getKey(), plc);
        }
    }
    for (PatchSet ps : patchSets.values()) {
        RevisionNote rn = rns.get(ps.getRevision());
        if (rn != null && rn.pushCert != null) {
            ps.setPushCertificate(rn.pushCert);
        }
    }
}
#method_after
private void parseNotes() throws IOException, ConfigInvalidException {
    ObjectReader reader = walk.getObjectReader();
    ChangeNotesCommit tipCommit = walk.parseCommit(tip);
    revisionNoteMap = RevisionNoteMap.parse(noteUtil, id, reader, NoteMap.read(reader, tipCommit), PatchLineComment.Status.PUBLISHED);
    Map<RevId, RevisionNote> rns = revisionNoteMap.revisionNotes;
    for (Map.Entry<RevId, RevisionNote> e : rns.entrySet()) {
        for (Comment c : e.getValue().comments) {
            comments.put(e.getKey(), c);
        }
    }
    for (PatchSet ps : patchSets.values()) {
        RevisionNote rn = rns.get(ps.getRevision());
        if (rn != null && rn.pushCert != null) {
            ps.setPushCertificate(rn.pushCert);
        }
    }
}
#end_block

#method_before
private void updatePatchSetStates() throws ConfigInvalidException {
    for (PatchSet ps : patchSets.values()) {
        if (ps.getRevision().equals(PARTIAL_PATCH_SET)) {
            throw parseException("No %s found for patch set %s", FOOTER_COMMIT, ps.getPatchSetId());
        }
    }
    if (patchSetStates.isEmpty()) {
        return;
    }
    boolean deleted = false;
    for (Map.Entry<PatchSet.Id, PatchSetState> e : patchSetStates.entrySet()) {
        switch(e.getValue()) {
            case PUBLISHED:
            default:
                break;
            case DELETED:
                deleted = true;
                patchSets.remove(e.getKey());
                break;
            case DRAFT:
                PatchSet ps = patchSets.get(e.getKey());
                if (ps != null) {
                    ps.setDraft(true);
                }
                break;
        }
    }
    if (!deleted) {
        return;
    }
    // Post-process other collections to remove items corresponding to deleted
    // patch sets. This is safer than trying to prevent insertion, as it will
    // also filter out items racily added after the patch set was deleted.
    // 
    // Approvals are filtered in buildApprovals().
    NavigableSet<PatchSet.Id> all = patchSets.navigableKeySet();
    if (!all.isEmpty()) {
        currentPatchSetId = all.last();
    } else {
        currentPatchSetId = null;
    }
    changeMessagesByPatchSet.keys().retainAll(all);
    for (Iterator<ChangeMessage> it = allChangeMessages.iterator(); it.hasNext(); ) {
        if (!all.contains(it.next().getPatchSetId())) {
            it.remove();
        }
    }
    for (Iterator<PatchLineComment> it = comments.values().iterator(); it.hasNext(); ) {
        PatchSet.Id psId = it.next().getKey().getParentKey().getParentKey();
        if (!all.contains(psId)) {
            it.remove();
        }
    }
}
#method_after
private void updatePatchSetStates() throws ConfigInvalidException {
    for (PatchSet ps : patchSets.values()) {
        if (ps.getRevision().equals(PARTIAL_PATCH_SET)) {
            throw parseException("No %s found for patch set %s", FOOTER_COMMIT, ps.getPatchSetId());
        }
    }
    if (patchSetStates.isEmpty()) {
        return;
    }
    boolean deleted = false;
    for (Map.Entry<PatchSet.Id, PatchSetState> e : patchSetStates.entrySet()) {
        switch(e.getValue()) {
            case PUBLISHED:
            default:
                break;
            case DELETED:
                deleted = true;
                patchSets.remove(e.getKey());
                break;
            case DRAFT:
                PatchSet ps = patchSets.get(e.getKey());
                if (ps != null) {
                    ps.setDraft(true);
                }
                break;
        }
    }
    if (!deleted) {
        return;
    }
    // Post-process other collections to remove items corresponding to deleted
    // patch sets. This is safer than trying to prevent insertion, as it will
    // also filter out items racily added after the patch set was deleted.
    // 
    // Approvals are filtered in buildApprovals().
    NavigableSet<PatchSet.Id> all = patchSets.navigableKeySet();
    if (!all.isEmpty()) {
        currentPatchSetId = all.last();
    } else {
        currentPatchSetId = null;
    }
    changeMessagesByPatchSet.keys().retainAll(all);
    for (Iterator<ChangeMessage> it = allChangeMessages.iterator(); it.hasNext(); ) {
        if (!all.contains(it.next().getPatchSetId())) {
            it.remove();
        }
    }
    for (Iterator<Comment> it = comments.values().iterator(); it.hasNext(); ) {
        PatchSet.Id psId = new PatchSet.Id(id, it.next().key.patchSetId);
        if (!all.contains(psId)) {
            it.remove();
        }
    }
}
#end_block

#method_before
private void checkMandatoryFooters() throws ConfigInvalidException {
    List<FooterKey> missing = new ArrayList<>();
    if (branch == null) {
        missing.add(FOOTER_BRANCH);
    }
    if (changeId == null) {
        missing.add(FOOTER_CHANGE_ID);
    }
    if (originalSubject == null || subject == null) {
        missing.add(FOOTER_SUBJECT);
    }
    if (!missing.isEmpty()) {
        throw parseException("Missing footers: " + Joiner.on(", ").join(Lists.transform(missing, new Function<FooterKey, String>() {

            @Override
            public String apply(FooterKey input) {
                return input.getName();
            }
        })));
    }
}
#method_after
private void checkMandatoryFooters() throws ConfigInvalidException {
    List<FooterKey> missing = new ArrayList<>();
    if (branch == null) {
        missing.add(FOOTER_BRANCH);
    }
    if (changeId == null) {
        missing.add(FOOTER_CHANGE_ID);
    }
    if (originalSubject == null || subject == null) {
        missing.add(FOOTER_SUBJECT);
    }
    if (!missing.isEmpty()) {
        throw parseException("Missing footers: " + missing.stream().map(FooterKey::getName).collect(joining(", ")));
    }
}
#end_block

#method_before
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(change.getId(), null, null, ImmutableSet.<Account.Id>of(), ImmutableSet.<String>of(), ImmutableSortedMap.<PatchSet.Id, PatchSet>of(), ImmutableListMultimap.<PatchSet.Id, PatchSetApproval>of(), ReviewerSet.empty(), ImmutableList.<Account.Id>of(), ImmutableList.<ReviewerStatusUpdate>of(), ImmutableList.<SubmitRecord>of(), ImmutableList.<ChangeMessage>of(), ImmutableListMultimap.<PatchSet.Id, ChangeMessage>of(), ImmutableListMultimap.<RevId, PatchLineComment>of());
}
#method_after
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(change.getId(), null, null, ImmutableSet.<Account.Id>of(), ImmutableSet.<String>of(), ImmutableSortedMap.<PatchSet.Id, PatchSet>of(), ImmutableListMultimap.<PatchSet.Id, PatchSetApproval>of(), ReviewerSet.empty(), ImmutableList.<Account.Id>of(), ImmutableList.<ReviewerStatusUpdate>of(), ImmutableList.<SubmitRecord>of(), ImmutableList.<ChangeMessage>of(), ImmutableListMultimap.<PatchSet.Id, ChangeMessage>of(), ImmutableListMultimap.<RevId, Comment>of());
}
#end_block

#method_before
static ChangeNotesState create(Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Change.Status status, @Nullable Account.Id assignee, @Nullable Set<Account.Id> historicalAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, Multimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, Multimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, Multimap<RevId, PatchLineComment> publishedComments) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, status), assignee, ImmutableSet.copyOf(historicalAssignees), ImmutableSet.copyOf(hashtags), ImmutableSortedMap.copyOf(patchSets, ReviewDbUtil.intKeyOrdering()), ImmutableListMultimap.copyOf(approvals), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments));
}
#method_after
static ChangeNotesState create(Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Change.Status status, @Nullable Account.Id assignee, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, Multimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, Multimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, Multimap<RevId, Comment> publishedComments) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, status), assignee, ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableSortedMap.copyOf(patchSets, comparing(PatchSet.Id::get)), ImmutableListMultimap.copyOf(approvals), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments));
}
#end_block

#method_before
@Test
public void tagInlineCommenrts() throws Exception {
    String tag = "jenkins";
    Change c = newChange();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putComment(newPublishedComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.setTag(tag);
    update.commit();
    ChangeNotes notes = newNotes(c);
    ImmutableListMultimap<RevId, PatchLineComment> comments = notes.getComments();
    assertThat(comments).hasSize(1);
    assertThat(comments.entries().asList().get(0).getValue().getTag()).isEqualTo(tag);
}
#method_after
@Test
public void tagInlineCommenrts() throws Exception {
    String tag = "jenkins";
    Change c = newChange();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.setTag(tag);
    update.commit();
    ChangeNotes notes = newNotes(c);
    ImmutableListMultimap<RevId, Comment> comments = notes.getComments();
    assertThat(comments).hasSize(1);
    assertThat(comments.entries().asList().get(0).getValue().tag).isEqualTo(tag);
}
#end_block

#method_before
@Test
public void multipleTags() throws Exception {
    String ipTag = "ip";
    String coverageTag = "coverage";
    String integrationTag = "integration";
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Verified", (short) -1);
    update.setChangeMessage("integration verification");
    update.setTag(integrationTag);
    update.commit();
    RevCommit commit = tr.commit().message("PS2").create();
    update = newUpdate(c, changeOwner);
    update.putComment(newPublishedComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.setChangeMessage("coverage verification");
    update.setTag(coverageTag);
    update.commit();
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("ip clear");
    update.setTag(ipTag);
    update.commit();
    ChangeNotes notes = newNotes(c);
    ImmutableListMultimap<PatchSet.Id, PatchSetApproval> approvals = notes.getApprovals();
    assertThat(approvals).hasSize(1);
    PatchSetApproval approval = approvals.entries().asList().get(0).getValue();
    assertThat(approval.getTag()).isEqualTo(integrationTag);
    assertThat(approval.getValue()).isEqualTo(-1);
    ImmutableListMultimap<RevId, PatchLineComment> comments = notes.getComments();
    assertThat(comments).hasSize(1);
    assertThat(comments.entries().asList().get(0).getValue().getTag()).isEqualTo(coverageTag);
    ImmutableList<ChangeMessage> messages = notes.getChangeMessages();
    assertThat(messages).hasSize(3);
    assertThat(messages.get(0).getTag()).isEqualTo(integrationTag);
    assertThat(messages.get(1).getTag()).isEqualTo(coverageTag);
    assertThat(messages.get(2).getTag()).isEqualTo(ipTag);
}
#method_after
@Test
public void multipleTags() throws Exception {
    String ipTag = "ip";
    String coverageTag = "coverage";
    String integrationTag = "integration";
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Verified", (short) -1);
    update.setChangeMessage("integration verification");
    update.setTag(integrationTag);
    update.commit();
    RevCommit commit = tr.commit().message("PS2").create();
    update = newUpdate(c, changeOwner);
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.setChangeMessage("coverage verification");
    update.setTag(coverageTag);
    update.commit();
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("ip clear");
    update.setTag(ipTag);
    update.commit();
    ChangeNotes notes = newNotes(c);
    ImmutableListMultimap<PatchSet.Id, PatchSetApproval> approvals = notes.getApprovals();
    assertThat(approvals).hasSize(1);
    PatchSetApproval approval = approvals.entries().asList().get(0).getValue();
    assertThat(approval.getTag()).isEqualTo(integrationTag);
    assertThat(approval.getValue()).isEqualTo(-1);
    ImmutableListMultimap<RevId, Comment> comments = notes.getComments();
    assertThat(comments).hasSize(1);
    assertThat(comments.entries().asList().get(0).getValue().tag).isEqualTo(coverageTag);
    ImmutableList<ChangeMessage> messages = notes.getChangeMessages();
    assertThat(messages).hasSize(3);
    assertThat(messages.get(0).getTag()).isEqualTo(integrationTag);
    assertThat(messages.get(1).getTag()).isEqualTo(coverageTag);
    assertThat(messages.get(2).getTag()).isEqualTo(ipTag);
}
#end_block

#method_before
@Test
public void putOtherUsersApprovals() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Code-Review", (short) 1);
    update.putApprovalFor(otherUser.getAccountId(), "Code-Review", (short) -1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    List<PatchSetApproval> approvals = Ordering.natural().onResultOf(new Function<PatchSetApproval, Integer>() {

        @Override
        public Integer apply(PatchSetApproval in) {
            return in.getAccountId().get();
        }
    }).sortedCopy(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(approvals).hasSize(2);
    assertThat(approvals.get(0).getAccountId()).isEqualTo(changeOwner.getAccountId());
    assertThat(approvals.get(0).getLabel()).isEqualTo("Code-Review");
    assertThat(approvals.get(0).getValue()).isEqualTo((short) 1);
    assertThat(approvals.get(1).getAccountId()).isEqualTo(otherUser.getAccountId());
    assertThat(approvals.get(1).getLabel()).isEqualTo("Code-Review");
    assertThat(approvals.get(1).getValue()).isEqualTo((short) -1);
}
#method_after
@Test
public void putOtherUsersApprovals() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Code-Review", (short) 1);
    update.putApprovalFor(otherUser.getAccountId(), "Code-Review", (short) -1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    List<PatchSetApproval> approvals = ReviewDbUtil.intKeyOrdering().onResultOf(PatchSetApproval::getAccountId).sortedCopy(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(approvals).hasSize(2);
    assertThat(approvals.get(0).getAccountId()).isEqualTo(changeOwner.getAccountId());
    assertThat(approvals.get(0).getLabel()).isEqualTo("Code-Review");
    assertThat(approvals.get(0).getValue()).isEqualTo((short) 1);
    assertThat(approvals.get(1).getAccountId()).isEqualTo(otherUser.getAccountId());
    assertThat(approvals.get(1).getLabel()).isEqualTo("Code-Review");
    assertThat(approvals.get(1).getValue()).isEqualTo((short) -1);
}
#end_block

#method_before
@Test
public void assigneeCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(otherUserId);
    ObjectId result = update.commit();
    assertThat(result).isNotNull();
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(update.getResult());
        rw.parseBody(commit);
        String strIdent = otherUser.getName() + " <" + otherUserId + "@" + serverId + ">";
        assertThat(commit.getFullMessage()).contains("Assignee: " + strIdent);
    }
}
#method_after
@Test
public void assigneeCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(Optional.fromNullable(otherUserId));
    ObjectId result = update.commit();
    assertThat(result).isNotNull();
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(update.getResult());
        rw.parseBody(commit);
        String strIdent = otherUser.getName() + " <" + otherUserId + "@" + serverId + ">";
        assertThat(commit.getFullMessage()).contains("Assignee: " + strIdent);
    }
}
#end_block

#method_before
@Test
public void assigneeChangeNotes() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(otherUserId);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getAssignee()).isEqualTo(otherUserId);
    update = newUpdate(c, changeOwner);
    update.setAssignee(changeOwner.getAccountId());
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getAssignee()).isEqualTo(changeOwner.getAccountId());
}
#method_after
@Test
public void assigneeChangeNotes() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(Optional.fromNullable(otherUserId));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getAssignee().get()).isEqualTo(otherUserId);
    update = newUpdate(c, changeOwner);
    update.setAssignee(Optional.fromNullable(changeOwner.getAccountId()));
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getAssignee().get()).isEqualTo(changeOwner.getAccountId());
}
#end_block

#method_before
@Test
public void patchSetStates() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    // ps2
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.setPatchSetState(PatchSetState.DRAFT);
    update.putApproval("Code-Review", (short) 1);
    update.setChangeMessage("This is a message");
    update.putComment(newPublishedComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isTrue();
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getApprovals()).isNotEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isNotEmpty();
    assertThat(notes.getChangeMessages()).isNotEmpty();
    assertThat(notes.getComments()).isNotEmpty();
    // publish ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.PUBLISHED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isFalse();
    // delete ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.DELETED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1);
    assertThat(notes.getApprovals()).isEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isEmpty();
    assertThat(notes.getChangeMessages()).isEmpty();
    assertThat(notes.getComments()).isEmpty();
}
#method_after
@Test
public void patchSetStates() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    // ps2
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.setPatchSetState(PatchSetState.DRAFT);
    update.putApproval("Code-Review", (short) 1);
    update.setChangeMessage("This is a message");
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isTrue();
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getApprovals()).isNotEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isNotEmpty();
    assertThat(notes.getChangeMessages()).isNotEmpty();
    assertThat(notes.getComments()).isNotEmpty();
    // publish ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.PUBLISHED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isFalse();
    // delete ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.DELETED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1);
    assertThat(notes.getApprovals()).isEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isEmpty();
    assertThat(notes.getChangeMessages()).isEmpty();
    assertThat(notes.getComments()).isEmpty();
}
#end_block

#method_before
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    if (!testJson()) {
        assertThat(note).isEqualTo(pushCert);
    }
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(newPublishedComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
    if (!testJson()) {
        assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    }
}
#method_after
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    if (!testJson()) {
        assertThat(note).isEqualTo(pushCert);
    }
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(Status.PUBLISHED, newComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
    if (!testJson()) {
        assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    }
}
#end_block

#method_before
@Test
public void multipleUpdatesIncludingComments() throws Exception {
    Change c = newChange();
    ChangeUpdate update1 = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String message1 = "comment 1";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    RevCommit tipCommit;
    try (NoteDbUpdateManager updateManager = updateManagerFactory.create(project)) {
        PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
        update1.setPatchSetId(psId);
        update1.putComment(comment1);
        updateManager.add(update1);
        ChangeUpdate update2 = newUpdate(c, otherUser);
        update2.putApproval("Code-Review", (short) 2);
        updateManager.add(update2);
        updateManager.execute();
    }
    ChangeNotes notes = newNotes(c);
    ObjectId tip = notes.getRevision();
    tipCommit = rw.parseCommit(tip);
    RevCommit commitWithApprovals = tipCommit;
    assertThat(commitWithApprovals).isNotNull();
    RevCommit commitWithComments = commitWithApprovals.getParent(0);
    assertThat(commitWithComments).isNotNull();
    try (ChangeNotesRevWalk rw = ChangeNotesCommit.newRevWalk(repo)) {
        ChangeNotesParser notesWithComments = new ChangeNotesParser(c.getId(), commitWithComments.copy(), rw, noteUtil, args.metrics);
        ChangeNotesState state = notesWithComments.parseAll();
        assertThat(state.approvals()).isEmpty();
        assertThat(state.publishedComments()).hasSize(1);
    }
    try (ChangeNotesRevWalk rw = ChangeNotesCommit.newRevWalk(repo)) {
        ChangeNotesParser notesWithApprovals = new ChangeNotesParser(c.getId(), commitWithApprovals.copy(), rw, noteUtil, args.metrics);
        ChangeNotesState state = notesWithApprovals.parseAll();
        assertThat(state.approvals()).hasSize(1);
        assertThat(state.publishedComments()).hasSize(1);
    }
}
#method_after
@Test
public void multipleUpdatesIncludingComments() throws Exception {
    Change c = newChange();
    ChangeUpdate update1 = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String message1 = "comment 1";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    RevCommit tipCommit;
    try (NoteDbUpdateManager updateManager = updateManagerFactory.create(project)) {
        Comment comment1 = newComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
        update1.setPatchSetId(psId);
        update1.putComment(Status.PUBLISHED, comment1);
        updateManager.add(update1);
        ChangeUpdate update2 = newUpdate(c, otherUser);
        update2.putApproval("Code-Review", (short) 2);
        updateManager.add(update2);
        updateManager.execute();
    }
    ChangeNotes notes = newNotes(c);
    ObjectId tip = notes.getRevision();
    tipCommit = rw.parseCommit(tip);
    RevCommit commitWithApprovals = tipCommit;
    assertThat(commitWithApprovals).isNotNull();
    RevCommit commitWithComments = commitWithApprovals.getParent(0);
    assertThat(commitWithComments).isNotNull();
    try (ChangeNotesRevWalk rw = ChangeNotesCommit.newRevWalk(repo)) {
        ChangeNotesParser notesWithComments = new ChangeNotesParser(c.getId(), commitWithComments.copy(), rw, noteUtil, args.metrics);
        ChangeNotesState state = notesWithComments.parseAll();
        assertThat(state.approvals()).isEmpty();
        assertThat(state.publishedComments()).hasSize(1);
    }
    try (ChangeNotesRevWalk rw = ChangeNotesCommit.newRevWalk(repo)) {
        ChangeNotesParser notesWithApprovals = new ChangeNotesParser(c.getId(), commitWithApprovals.copy(), rw, noteUtil, args.metrics);
        ChangeNotesState state = notesWithApprovals.parseAll();
        assertThat(state.approvals()).hasSize(1);
        assertThat(state.publishedComments()).hasSize(1);
    }
}
#end_block

#method_before
@Test
public void patchLineCommentsFileComment() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchLineComment comment = newPublishedComment(psId, "file1", "uuid", null, 0, otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#method_after
@Test
public void patchLineCommentsFileComment() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    Comment comment = newComment(psId, "file1", "uuid", null, 0, otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#end_block

#method_before
@Test
public void patchLineCommentsZeroColumns() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 0, 2, 0);
    PatchLineComment comment = newPublishedComment(psId, "file1", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#method_after
@Test
public void patchLineCommentsZeroColumns() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 0, 2, 0);
    Comment comment = newComment(psId, "file1", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#end_block

#method_before
@Test
public void patchLineCommentZeroRange() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(0, 0, 0, 0);
    PatchLineComment comment = newPublishedComment(psId, "file", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#method_after
@Test
public void patchLineCommentZeroRange() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(0, 0, 0, 0);
    Comment comment = newComment(psId, "file", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#end_block

#method_before
@Test
public void patchLineCommentEmptyFilename() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 2, 3, 4);
    PatchLineComment comment = newPublishedComment(psId, "", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#method_after
@Test
public void patchLineCommentEmptyFilename() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 2, 3, 4);
    Comment comment = newComment(psId, "", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    PatchLineComment comment3 = newPublishedComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment1 = newComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Comment comment2 = newComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    Comment comment3 = newComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
        }
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment1 = newComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Comment comment2 = newComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    PatchLineComment comment1 = newPublishedComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    PatchLineComment comment2 = newPublishedComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    PatchLineComment comment3 = newPublishedComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(comment3);
    update.putComment(comment2);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#method_after
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    Comment comment1 = newComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    Comment comment2 = newComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    Comment comment3 = newComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(Status.PUBLISHED, comment3);
    update.putComment(Status.PUBLISHED, comment2);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(comment.getRevId(), comment));
}
#method_after
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment = newComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(new RevId(comment.revId), comment));
}
#end_block

#method_before
@Test
public void patchLineCommentMultipleOnePatchsetOneFileBothSides() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    String messageForBase = "comment for base";
    String messageForPS = "comment for ps";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment commentForBase = newPublishedComment(psId, "filename", uuid1, range, range.getEndLine(), otherUser, null, now, messageForBase, (short) 0, rev1);
    update.setPatchSetId(psId);
    update.putComment(commentForBase);
    update.commit();
    update = newUpdate(c, otherUser);
    PatchLineComment commentForPS = newPublishedComment(psId, "filename", uuid2, range, range.getEndLine(), otherUser, null, now, messageForPS, (short) 1, rev2);
    update.setPatchSetId(psId);
    update.putComment(commentForPS);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), commentForBase, new RevId(rev2), commentForPS));
}
#method_after
@Test
public void patchLineCommentMultipleOnePatchsetOneFileBothSides() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    String messageForBase = "comment for base";
    String messageForPS = "comment for ps";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment commentForBase = newComment(psId, "filename", uuid1, range, range.getEndLine(), otherUser, null, now, messageForBase, (short) 0, rev1);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, commentForBase);
    update.commit();
    update = newUpdate(c, otherUser);
    Comment commentForPS = newComment(psId, "filename", uuid2, range, range.getEndLine(), otherUser, null, now, messageForPS, (short) 1, rev2);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, commentForPS);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), commentForBase, new RevId(rev2), commentForPS));
}
#end_block

#method_before
@Test
public void patchLineCommentMultipleOnePatchsetOneFile() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp timeForComment1 = TimeUtil.nowTs();
    Timestamp timeForComment2 = TimeUtil.nowTs();
    PatchLineComment comment1 = newPublishedComment(psId, filename, uuid1, range, range.getEndLine(), otherUser, null, timeForComment1, "comment 1", side, rev);
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    PatchLineComment comment2 = newPublishedComment(psId, filename, uuid2, range, range.getEndLine(), otherUser, null, timeForComment2, "comment 2", side, rev);
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
}
#method_after
@Test
public void patchLineCommentMultipleOnePatchsetOneFile() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp timeForComment1 = TimeUtil.nowTs();
    Timestamp timeForComment2 = TimeUtil.nowTs();
    Comment comment1 = newComment(psId, filename, uuid1, range, range.getEndLine(), otherUser, null, timeForComment1, "comment 1", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    Comment comment2 = newComment(psId, filename, uuid2, range, range.getEndLine(), otherUser, null, timeForComment2, "comment 2", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
}
#end_block

#method_before
@Test
public void patchLineCommentMultipleOnePatchsetMultipleFiles() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename1 = "filename1";
    String filename2 = "filename2";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment1 = newPublishedComment(psId, filename1, uuid, range, range.getEndLine(), otherUser, null, now, "comment 1", side, rev);
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    PatchLineComment comment2 = newPublishedComment(psId, filename2, uuid, range, range.getEndLine(), otherUser, null, now, "comment 2", side, rev);
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
}
#method_after
@Test
public void patchLineCommentMultipleOnePatchsetMultipleFiles() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename1 = "filename1";
    String filename2 = "filename2";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(psId, filename1, uuid, range, range.getEndLine(), otherUser, null, now, "comment 1", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    Comment comment2 = newComment(psId, filename2, uuid, range, range.getEndLine(), otherUser, null, now, "comment 2", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
}
#end_block

#method_before
@Test
public void patchLineCommentMultiplePatchsets() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment1 = newPublishedComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1);
    update.setPatchSetId(ps1);
    update.putComment(comment1);
    update.commit();
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    PatchLineComment comment2 = newPublishedComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2);
    update.setPatchSetId(ps2);
    update.putComment(comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), comment1, new RevId(rev2), comment2));
}
#method_after
@Test
public void patchLineCommentMultiplePatchsets() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    Comment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2);
    update.setPatchSetId(ps2);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), comment1, new RevId(rev2), comment2));
}
#end_block

#method_before
@Test
public void patchLineCommentSingleDraftToPublished() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    update.setPatchSetId(ps1);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
    assertThat(notes.getComments()).isEmpty();
    comment1.setStatus(Status.PUBLISHED);
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(comment1);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
}
#method_after
@Test
public void patchLineCommentSingleDraftToPublished() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    update.setPatchSetId(ps1);
    update.putComment(Status.DRAFT, comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
}
#end_block

#method_before
@Test
public void patchLineCommentMultipleDraftsSameSidePublishOne() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    short side = (short) 1;
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts on the same side of one patch set.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    PatchLineComment comment1 = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    PatchLineComment comment2 = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "other on ps1", side, rev, Status.DRAFT);
    update.putComment(comment1);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
    assertThat(notes.getComments()).isEmpty();
    // Publish first draft.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    comment1.setStatus(Status.PUBLISHED);
    update.putComment(comment1);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment2));
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
}
#method_after
@Test
public void patchLineCommentMultipleDraftsSameSidePublishOne() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    short side = (short) 1;
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts on the same side of one patch set.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    Comment comment1 = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    Comment comment2 = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "other on ps1", side, rev);
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
    assertThat(notes.getComments()).isEmpty();
    // Publish first draft.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment2));
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
}
#end_block

#method_before
@Test
public void patchLineCommentsMultipleDraftsBothSidesPublishAll() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts, one on each side of the patchset.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    PatchLineComment baseComment = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on base", (short) 0, rev1, Status.DRAFT);
    PatchLineComment psComment = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "comment on ps", (short) 1, rev2, Status.DRAFT);
    update.putComment(baseComment);
    update.putComment(psComment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
    assertThat(notes.getComments()).isEmpty();
    // Publish both comments.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    baseComment.setStatus(Status.PUBLISHED);
    psComment.setStatus(Status.PUBLISHED);
    update.putComment(baseComment);
    update.putComment(psComment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
}
#method_after
@Test
public void patchLineCommentsMultipleDraftsBothSidesPublishAll() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts, one on each side of the patchset.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    Comment baseComment = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on base", (short) 0, rev1);
    Comment psComment = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "comment on ps", (short) 1, rev2);
    update.putComment(Status.DRAFT, baseComment);
    update.putComment(Status.DRAFT, psComment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
    assertThat(notes.getComments()).isEmpty();
    // Publish both comments.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, baseComment);
    update.putComment(Status.PUBLISHED, psComment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
}
#end_block

#method_before
@Test
public void patchLineCommentsDeleteAllDrafts() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ObjectId objId = ObjectId.fromString(rev);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment = newComment(psId, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    assertThat(notes.getDraftCommentNotes().getNoteMap().contains(objId)).isTrue();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(psId);
    update.deleteComment(comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getDraftCommentNotes().getNoteMap()).isNull();
}
#method_after
@Test
public void patchLineCommentsDeleteAllDrafts() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ObjectId objId = ObjectId.fromString(rev);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment = newComment(psId, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.DRAFT, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    assertThat(notes.getDraftCommentNotes().getNoteMap().contains(objId)).isTrue();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(psId);
    update.deleteComment(comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getDraftCommentNotes().getNoteMap()).isNull();
}
#end_block

#method_before
@Test
public void patchLineCommentsDeleteAllDraftsForOneRevision() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    ObjectId objId1 = ObjectId.fromString(rev1);
    ObjectId objId2 = ObjectId.fromString(rev2);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1, Status.DRAFT);
    update.setPatchSetId(ps1);
    update.putComment(comment1);
    update.commit();
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    PatchLineComment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2, Status.DRAFT);
    update.setPatchSetId(ps2);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(2);
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(ps2);
    update.deleteComment(comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    NoteMap noteMap = notes.getDraftCommentNotes().getNoteMap();
    assertThat(noteMap.contains(objId1)).isTrue();
    assertThat(noteMap.contains(objId2)).isFalse();
}
#method_after
@Test
public void patchLineCommentsDeleteAllDraftsForOneRevision() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    ObjectId objId1 = ObjectId.fromString(rev1);
    ObjectId objId2 = ObjectId.fromString(rev2);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1);
    update.setPatchSetId(ps1);
    update.putComment(Status.DRAFT, comment1);
    update.commit();
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    Comment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2);
    update.setPatchSetId(ps2);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(2);
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(ps2);
    update.deleteComment(comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    NoteMap noteMap = notes.getDraftCommentNotes().getNoteMap();
    assertThat(noteMap.contains(objId1)).isTrue();
    assertThat(noteMap.contains(objId2)).isFalse();
}
#end_block

#method_before
@Test
public void addingPublishedCommentDoesNotCreateNoOpCommitOnEmptyDraftRef() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.PUBLISHED);
    update.putComment(comment);
    update.commit();
    assertThat(repo.exactRef(changeMetaRef(c.getId()))).isNotNull();
    String draftRef = refsDraftComments(c.getId(), otherUser.getAccountId());
    assertThat(exactRefAllUsers(draftRef)).isNull();
}
#method_after
@Test
public void addingPublishedCommentDoesNotCreateNoOpCommitOnEmptyDraftRef() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    assertThat(repo.exactRef(changeMetaRef(c.getId()))).isNotNull();
    String draftRef = refsDraftComments(c.getId(), otherUser.getAccountId());
    assertThat(exactRefAllUsers(draftRef)).isNull();
}
#end_block

#method_before
@Test
public void addingPublishedCommentDoesNotCreateNoOpCommitOnNonEmptyDraftRef() throws Exception {
    Change c = newChange();
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment draft = newComment(ps1, filename, "uuid1", range, range.getEndLine(), otherUser, null, now, "draft comment on ps1", side, rev, Status.DRAFT);
    update.putComment(draft);
    update.commit();
    String draftRef = refsDraftComments(c.getId(), otherUser.getAccountId());
    ObjectId old = exactRefAllUsers(draftRef);
    assertThat(old).isNotNull();
    update = newUpdate(c, otherUser);
    PatchLineComment pub = newComment(ps1, filename, "uuid2", range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.PUBLISHED);
    update.putComment(pub);
    update.commit();
    assertThat(exactRefAllUsers(draftRef)).isEqualTo(old);
}
#method_after
@Test
public void addingPublishedCommentDoesNotCreateNoOpCommitOnNonEmptyDraftRef() throws Exception {
    Change c = newChange();
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment draft = newComment(ps1, filename, "uuid1", range, range.getEndLine(), otherUser, null, now, "draft comment on ps1", side, rev);
    update.putComment(Status.DRAFT, draft);
    update.commit();
    String draftRef = refsDraftComments(c.getId(), otherUser.getAccountId());
    ObjectId old = exactRefAllUsers(draftRef);
    assertThat(old).isNotNull();
    update = newUpdate(c, otherUser);
    Comment pub = newComment(ps1, filename, "uuid2", range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    update.putComment(Status.PUBLISHED, pub);
    update.commit();
    assertThat(exactRefAllUsers(draftRef)).isEqualTo(old);
}
#end_block

#method_before
@Test
public void fileComment() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String messageForBase = "comment for base";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "filename", uuid, null, 0, otherUser, null, now, messageForBase, (short) 0, rev);
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment));
}
#method_after
@Test
public void fileComment() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String messageForBase = "comment for base";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment = newComment(psId, "filename", uuid, null, 0, otherUser, null, now, messageForBase, (short) 0, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment));
}
#end_block

#method_before
@Test
public void patchLineCommentNoRange() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String messageForBase = "comment for base";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "filename", uuid, null, 1, otherUser, null, now, messageForBase, (short) 0, rev);
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment));
}
#method_after
@Test
public void patchLineCommentNoRange() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String messageForBase = "comment for base";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment = newComment(psId, "filename", uuid, null, 1, otherUser, null, now, messageForBase, (short) 0, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment));
}
#end_block

#method_before
@Test
public void putCommentsForMultipleRevisions() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(ps2);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1, Status.DRAFT);
    PatchLineComment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2, Status.DRAFT);
    update.putComment(comment1);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(2);
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps2);
    comment1.setStatus(Status.PUBLISHED);
    comment2.setStatus(Status.PUBLISHED);
    update.putComment(comment1);
    update.putComment(comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).hasSize(2);
}
#method_after
@Test
public void putCommentsForMultipleRevisions() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(ps2);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1);
    Comment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2);
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(2);
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps2);
    update.putComment(Status.PUBLISHED, comment1);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).hasSize(2);
}
#end_block

#method_before
@Test
public void publishSubsetOfCommentsOnRevision() throws Exception {
    Change c = newChange();
    RevId rev1 = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment1 = newComment(ps1, "file1", "uuid1", range, range.getEndLine(), otherUser, null, now, "comment1", side, rev1.get(), Status.DRAFT);
    PatchLineComment comment2 = newComment(ps1, "file2", "uuid2", range, range.getEndLine(), otherUser, null, now, "comment2", side, rev1.get(), Status.DRAFT);
    update.putComment(comment1);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1, comment2);
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    comment2.setStatus(Status.PUBLISHED);
    update.putComment(comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1);
    assertThat(notes.getComments().get(rev1)).containsExactly(comment2);
}
#method_after
@Test
public void publishSubsetOfCommentsOnRevision() throws Exception {
    Change c = newChange();
    RevId rev1 = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, "file1", "uuid1", range, range.getEndLine(), otherUser, null, now, "comment1", side, rev1.get());
    Comment comment2 = newComment(ps1, "file2", "uuid2", range, range.getEndLine(), otherUser, null, now, "comment2", side, rev1.get());
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1, comment2);
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1);
    assertThat(notes.getComments().get(rev1)).containsExactly(comment2);
}
#end_block

#method_before
@Test
public void filterOutAndFixUpZombieDraftComments() throws Exception {
    Change c = newChange();
    RevId rev1 = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment1 = newComment(ps1, "file1", "uuid1", range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1.get(), Status.DRAFT);
    PatchLineComment comment2 = newComment(ps1, "file2", "uuid2", range, range.getEndLine(), otherUser, null, now, "another comment", side, rev1.get(), Status.DRAFT);
    update.putComment(comment1);
    update.putComment(comment2);
    update.commit();
    String refName = refsDraftComments(c.getId(), otherUserId);
    ObjectId oldDraftId = exactRefAllUsers(refName);
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    comment2.setStatus(Status.PUBLISHED);
    update.putComment(comment2);
    update.commit();
    assertThat(exactRefAllUsers(refName)).isNotNull();
    assertThat(exactRefAllUsers(refName)).isNotEqualTo(oldDraftId);
    // Re-add draft version of comment2 back to draft ref without updating
    // change ref. Simulates the case where deleting the draft failed
    // non-atomically after adding the published comment succeeded.
    ChangeDraftUpdate draftUpdate = newUpdate(c, otherUser).createDraftUpdateIfNull();
    comment2.setStatus(Status.DRAFT);
    draftUpdate.putComment(comment2);
    try (NoteDbUpdateManager manager = updateManagerFactory.create(c.getProject())) {
        manager.add(draftUpdate);
        manager.execute();
    }
    // Looking at drafts directly shows the zombie comment.
    DraftCommentNotes draftNotes = draftNotesFactory.create(c, otherUserId);
    assertThat(draftNotes.load().getComments().get(rev1)).containsExactly(comment1, comment2);
    // Reset for later assertions.
    comment2.setStatus(Status.PUBLISHED);
    // Zombie comment is filtered out of drafts via ChangeNotes.
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1);
    assertThat(notes.getComments().get(rev1)).containsExactly(comment2);
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    comment1.setStatus(Status.PUBLISHED);
    update.putComment(comment1);
    update.commit();
    // Updating an unrelated comment causes the zombie comment to get fixed up.
    assertThat(exactRefAllUsers(refName)).isNull();
}
#method_after
@Test
public void filterOutAndFixUpZombieDraftComments() throws Exception {
    Change c = newChange();
    RevId rev1 = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, "file1", "uuid1", range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1.get());
    Comment comment2 = newComment(ps1, "file2", "uuid2", range, range.getEndLine(), otherUser, null, now, "another comment", side, rev1.get());
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    String refName = refsDraftComments(c.getId(), otherUserId);
    ObjectId oldDraftId = exactRefAllUsers(refName);
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(exactRefAllUsers(refName)).isNotNull();
    assertThat(exactRefAllUsers(refName)).isNotEqualTo(oldDraftId);
    // Re-add draft version of comment2 back to draft ref without updating
    // change ref. Simulates the case where deleting the draft failed
    // non-atomically after adding the published comment succeeded.
    ChangeDraftUpdate draftUpdate = newUpdate(c, otherUser).createDraftUpdateIfNull();
    draftUpdate.putComment(comment2);
    try (NoteDbUpdateManager manager = updateManagerFactory.create(c.getProject())) {
        manager.add(draftUpdate);
        manager.execute();
    }
    // Looking at drafts directly shows the zombie comment.
    DraftCommentNotes draftNotes = draftNotesFactory.create(c, otherUserId);
    assertThat(draftNotes.load().getComments().get(rev1)).containsExactly(comment1, comment2);
    // Zombie comment is filtered out of drafts via ChangeNotes.
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1);
    assertThat(notes.getComments().get(rev1)).containsExactly(comment2);
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    // Updating an unrelated comment causes the zombie comment to get fixed up.
    assertThat(exactRefAllUsers(refName)).isNull();
}
#end_block

#method_before
@Test
public void updateCommentsInSequentialUpdates() throws Exception {
    Change c = newChange();
    CommentRange range = new CommentRange(1, 1, 2, 1);
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ChangeUpdate update1 = newUpdate(c, otherUser);
    PatchLineComment comment1 = newComment(c.currentPatchSetId(), "filename", "uuid1", range, range.getEndLine(), otherUser, null, new Timestamp(update1.getWhen().getTime()), "comment 1", (short) 1, rev, Status.PUBLISHED);
    update1.putComment(comment1);
    ChangeUpdate update2 = newUpdate(c, otherUser);
    PatchLineComment comment2 = newComment(c.currentPatchSetId(), "filename", "uuid2", range, range.getEndLine(), otherUser, null, new Timestamp(update2.getWhen().getTime()), "comment 2", (short) 1, rev, Status.PUBLISHED);
    update2.putComment(comment2);
    try (NoteDbUpdateManager manager = updateManagerFactory.create(project)) {
        manager.add(update1);
        manager.add(update2);
        manager.execute();
    }
    ChangeNotes notes = newNotes(c);
    List<PatchLineComment> comments = notes.getComments().get(new RevId(rev));
    assertThat(comments).hasSize(2);
    assertThat(comments.get(0).getMessage()).isEqualTo("comment 1");
    assertThat(comments.get(1).getMessage()).isEqualTo("comment 2");
}
#method_after
@Test
public void updateCommentsInSequentialUpdates() throws Exception {
    Change c = newChange();
    CommentRange range = new CommentRange(1, 1, 2, 1);
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ChangeUpdate update1 = newUpdate(c, otherUser);
    Comment comment1 = newComment(c.currentPatchSetId(), "filename", "uuid1", range, range.getEndLine(), otherUser, null, new Timestamp(update1.getWhen().getTime()), "comment 1", (short) 1, rev);
    update1.putComment(Status.PUBLISHED, comment1);
    ChangeUpdate update2 = newUpdate(c, otherUser);
    Comment comment2 = newComment(c.currentPatchSetId(), "filename", "uuid2", range, range.getEndLine(), otherUser, null, new Timestamp(update2.getWhen().getTime()), "comment 2", (short) 1, rev);
    update2.putComment(Status.PUBLISHED, comment2);
    try (NoteDbUpdateManager manager = updateManagerFactory.create(project)) {
        manager.add(update1);
        manager.add(update2);
        manager.execute();
    }
    ChangeNotes notes = newNotes(c);
    List<Comment> comments = notes.getComments().get(new RevId(rev));
    assertThat(comments).hasSize(2);
    assertThat(comments.get(0).message).isEqualTo("comment 1");
    assertThat(comments.get(1).message).isEqualTo("comment 2");
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "all_assignees").to(GetAllAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#end_block

#method_before
public List<String> filePaths(PatchSet ps) throws OrmException {
    Integer psId = ps.getPatchSetId();
    List<String> r = initFiles().get(psId);
    if (r == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        Optional<PatchList> p = getPatchList(c, ps);
        if (!p.isPresent()) {
            List<String> emptyFileList = Collections.emptyList();
            if (lazyLoad) {
                files.put(ps.getPatchSetId(), emptyFileList);
            }
            return emptyFileList;
        }
        r = new ArrayList<>(p.get().getPatches().size());
        for (PatchListEntry e : p.get().getPatches()) {
            if (Patch.COMMIT_MSG.equals(e.getNewName())) {
                continue;
            }
            switch(e.getChangeType()) {
                case ADDED:
                case MODIFIED:
                case DELETED:
                case COPIED:
                case REWRITE:
                    r.add(e.getNewName());
                    break;
                case RENAMED:
                    r.add(e.getOldName());
                    r.add(e.getNewName());
                    break;
            }
        }
        Collections.sort(r);
        r = Collections.unmodifiableList(r);
        files.put(psId, r);
    }
    return r;
}
#method_after
public List<String> filePaths(PatchSet ps) throws OrmException {
    Integer psId = ps.getPatchSetId();
    List<String> r = initFiles().get(psId);
    if (r == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        Optional<PatchList> p = getPatchList(c, ps);
        if (!p.isPresent()) {
            List<String> emptyFileList = Collections.emptyList();
            if (lazyLoad) {
                files.put(ps.getPatchSetId(), emptyFileList);
            }
            return emptyFileList;
        }
        r = new ArrayList<>(p.get().getPatches().size());
        for (PatchListEntry e : p.get().getPatches()) {
            if (Patch.isMagic(e.getNewName())) {
                continue;
            }
            switch(e.getChangeType()) {
                case ADDED:
                case MODIFIED:
                case DELETED:
                case COPIED:
                case REWRITE:
                    r.add(e.getNewName());
                    break;
                case RENAMED:
                    r.add(e.getOldName());
                    r.add(e.getNewName());
                    break;
            }
        }
        Collections.sort(r);
        r = Collections.unmodifiableList(r);
        files.put(psId, r);
    }
    return r;
}
#end_block

#method_before
public Collection<PatchSet> visiblePatchSets() throws OrmException {
    Predicate<PatchSet> predicate = new Predicate<PatchSet>() {

        @Override
        public boolean apply(PatchSet input) {
            try {
                return changeControl().isPatchVisible(input, db);
            } catch (OrmException e) {
                return false;
            }
        }
    };
    return FluentIterable.from(patchSets()).filter(predicate).toList();
}
#method_after
public Collection<PatchSet> visiblePatchSets() throws OrmException {
    Predicate<PatchSet> predicate = ps -> {
        try {
            return changeControl().isPatchVisible(ps, db);
        } catch (OrmException e) {
            return false;
        }
    };
    return FluentIterable.from(patchSets()).filter(predicate).toList();
}
#end_block

#method_before
public Account.Id assignee() throws OrmException {
    if (assignee == null) {
        if (!lazyLoad) {
            return null;
        }
        assignee = notes().getAssignee();
    }
    return assignee;
}
#method_after
public Optional<Account.Id> assignee() throws OrmException {
    if (assignee == null) {
        if (!lazyLoad) {
            return Optional.absent();
        }
        assignee = notes().getAssignee();
    }
    return assignee;
}
#end_block

#method_before
public void setAssignee(Account.Id assignee) {
    this.assignee = assignee;
}
#method_after
public void setAssignee(Optional<Account.Id> assignee) {
    this.assignee = assignee;
}
#end_block

#method_before
private void decodeAssignee(Multimap<String, IndexableField> doc, ChangeData cd) {
    Collection<IndexableField> ac = doc.get(ASSIGNEE_FIELD);
    Account.Id assignee = null;
    for (IndexableField a : ac) {
        int id = a.numericValue().intValue();
        assignee = new Account.Id(id);
    }
    cd.setAssignee(assignee);
}
#method_after
private void decodeAssignee(Multimap<String, IndexableField> doc, ChangeData cd) {
    IndexableField af = Iterables.getFirst(doc.get(ASSIGNEE_FIELD), null);
    Account.Id assignee = null;
    if (af != null) {
        int id = af.numericValue().intValue();
        if (id > 0) {
            assignee = new Account.Id(id);
        }
    }
    cd.setAssignee(Optional.fromNullable(assignee));
}
#end_block

#method_before
private void decodeReviewers(Multimap<String, IndexableField> doc, ChangeData cd) {
    cd.setReviewers(ChangeField.parseReviewerFieldValues(FluentIterable.from(doc.get(REVIEWER_FIELD)).transform(new Function<IndexableField, String>() {

        @Override
        public String apply(IndexableField in) {
            return in.stringValue();
        }
    })));
}
#method_after
private void decodeReviewers(Multimap<String, IndexableField> doc, ChangeData cd) {
    cd.setReviewers(ChangeField.parseReviewerFieldValues(FluentIterable.from(doc.get(REVIEWER_FIELD)).transform(IndexableField::stringValue)));
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(final ChangeInfo info) {
            info.init();
            addExtensionPoints(info, initCurrentRevision(info));
            final RevisionInfo rev = info.revision(revision);
            CallbackGroup group = new CallbackGroup();
            loadCommit(rev, group);
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    if (base == null && rev.commit().parents().length() > 1) {
                        base = Gerrit.getUserPreferences().defaultBaseForMerges().getBase();
                    }
                    loadConfigInfo(info, base);
                }
            });
            group.done();
        }
    }));
}
#end_block

#method_before
private void addExtensionPoints(ChangeInfo change, RevisionInfo rev) {
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER, headerExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS, headerExtensionMiddle, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, headerExtensionRight, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, changeExtension, change, rev);
}
#method_after
private void addExtensionPoints(ChangeInfo change, RevisionInfo rev) {
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER, headerExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS, headerExtensionMiddle, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, headerExtensionRight, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, changeExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_RELATED_INFO_BLOCK, relatedExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_COMMIT_INFO_BLOCK, commitExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HISTORY_RIGHT_OF_BUTTONS, historyExtensionRight, change, rev);
}
#end_block

#method_before
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#method_after
private void gotoSibling(int offset) {
    if (offset > 0 && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#end_block

#method_before
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile, files);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.isEdit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn()) {
        RevisionInfo rev = info.revision(revision);
        if (info.status().isOpen()) {
            if (isEditModeEnabled(info, rev)) {
                editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
                addFile.setVisible(!editMode.isVisible());
                deleteFile.setVisible(!editMode.isVisible());
                renameFile.setVisible(!editMode.isVisible());
                reviewMode.setVisible(!editMode.isVisible());
                addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile, files);
                deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
                renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
            } else {
                editMode.setVisible(false);
                addFile.setVisible(false);
                reviewMode.setVisible(false);
            }
            if (rev.isEdit()) {
                if (info.hasEditBasedOnCurrentPatchSet()) {
                    publishEdit.setVisible(true);
                } else {
                    rebaseEdit.setVisible(true);
                }
                deleteEdit.setVisible(true);
            }
        } else if (rev.isEdit()) {
            deleteEdit.setStyleName(style.highlight());
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
@UiHandler("publishEdit")
void onPublishEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.publishEdit(changeId);
}
#method_after
@UiHandler("publishEdit")
void onPublishEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.publishEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
}
#end_block

#method_before
@UiHandler("rebaseEdit")
void onRebaseEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.rebaseEdit(changeId);
}
#method_after
@UiHandler("rebaseEdit")
void onRebaseEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.rebaseEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
}
#end_block

#method_before
@UiHandler("deleteEdit")
void onDeleteEdit(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteChangeEdit())) {
        EditActions.deleteEdit(changeId);
    }
}
#method_after
@UiHandler("deleteEdit")
void onDeleteEdit(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteChangeEdit())) {
        EditActions.deleteEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
    }
}
#end_block

#method_before
@UiHandler("publish")
void onPublish(@SuppressWarnings("unused") ClickEvent e) {
    DraftActions.publish(changeId, revision);
}
#method_after
@UiHandler("publish")
void onPublish(@SuppressWarnings("unused") ClickEvent e) {
    DraftActions.publish(changeId, revision, publish, deleteRevision, deleteChange);
}
#end_block

#method_before
@UiHandler("deleteRevision")
void onDeleteRevision(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteDraftRevision())) {
        DraftActions.delete(changeId, revision);
    }
}
#method_after
@UiHandler("deleteRevision")
void onDeleteRevision(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteDraftRevision())) {
        DraftActions.delete(changeId, revision, publish, deleteRevision, deleteChange);
    }
}
#end_block

#method_before
@UiHandler("deleteChange")
void onDeleteChange(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteDraftChange())) {
        DraftActions.delete(changeId);
    }
}
#method_after
@UiHandler("deleteChange")
void onDeleteChange(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteDraftChange())) {
        DraftActions.delete(changeId, publish, deleteRevision, deleteChange);
    }
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    KeyCommandSet keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    handlers.add(GlobalKey.add(this, keysNavigation));
    KeyCommandSet keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                star.setValue(!star.getValue(), true);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                reviewers.onOpenForm();
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                // differentiate F5 from 't' by checking the charCode(F5=0, t=116).
                if (event.getNativeEvent().getCharCode() == 0) {
                    Window.Location.reload();
                    return;
                }
                if (topic.canEdit()) {
                    topic.onEdit();
                }
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    KeyCommandSet keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    handlers.add(GlobalKey.add(this, keysNavigation));
    KeyCommandSet keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                star.setValue(!star.getValue(), true);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                reviewers.onOpenForm();
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                // differentiate F5 from 't' by checking the charCode(F5=0, t=116).
                if (event.getNativeEvent().getCharCode() == 0) {
                    Window.Location.reload();
                    return;
                }
                if (topic.canEdit()) {
                    topic.onEdit();
                }
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.setName(edit.commit().commit());
        info.setEdit(edit);
        if (edit.hasFiles()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.isEdit()) {
                info.setCurrentRevision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.isEdit()) {
                    info.setCurrentRevision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    addExtensionPoints(info, rev);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(b, rev, lastReply, group, comments, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, String base) {
    final RevisionInfo rev = info.revision(revision);
    RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(b, rev, lastReply, group, comments, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    group.addListener(new AsyncCallback<Void>() {

        @Override
        public void onSuccess(Void result) {
            loadConfigInfo(info, rev);
        }

        @Override
        public void onFailure(Throwable caught) {
            logger.log(Level.SEVERE, "Loading file list and inline comments failed: " + caught.getMessage());
            loadConfigInfo(info, rev);
        }
    });
    group.done();
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.setName(edit.commit().commit());
        info.setEdit(edit);
        if (edit.hasFiles()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.isEdit()) {
                info.setCurrentRevision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.isEdit()) {
                    info.setCurrentRevision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    addExtensionPoints(info, rev);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(b, rev, lastReply, group, comments, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, RevisionInfo rev) {
    if (loaded) {
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    });
}
#end_block

#method_before
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(RevisionInfo base, RevisionInfo rev, Timestamp myLastReply, CallbackGroup group) {
    List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void loadFileList(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group, final List<NativeMap<JsArray<CommentInfo>>> comments, final List<NativeMap<JsArray<CommentInfo>>> drafts) {
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments != null ? comments.get(0) : null, drafts != null ? drafts.get(0) : null);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadFileList(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group, final List<NativeMap<JsArray<CommentInfo>>> comments, final List<NativeMap<JsArray<CommentInfo>>> drafts) {
    DiffApi.list(changeId.get(), rev.name(), base, group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments != null ? comments.get(0) : null, drafts != null ? drafts.get(0) : null);
        }

        @Override
        public void onFailure(Throwable caught) {
            files.showError(caught);
        }
    }));
}
#end_block

#method_before
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.isEdit()) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.setCommit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.isEdit() || rev.commit() != null) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.setCommit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.currentRevision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacyId().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.currentRevision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    }
    new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacyId().get())).center();
    throw new IllegalStateException("no revision, cannot proceed");
}
#end_block

#method_before
private RevisionInfo resolveRevisionOrPatchSetId(ChangeInfo info, String revOrId, String defaultValue) {
    if (revOrId == null) {
        revOrId = defaultValue;
    } else if (!info.revisions().containsKey(revOrId)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revOrId.equals(String.valueOf(r._number()))) {
                revOrId = r.name();
                break;
            }
        }
    }
    return revOrId != null ? info.revision(revOrId) : null;
}
#method_after
private RevisionInfo resolveRevisionOrPatchSetId(ChangeInfo info, String revOrId, String defaultValue) {
    int parentNum;
    if (revOrId == null) {
        revOrId = defaultValue;
    } else if ((parentNum = toParentNum(revOrId)) > 0) {
        CommitInfo commitInfo = info.revision(revision).commit();
        JsArray<CommitInfo> parents = commitInfo.parents();
        if (parents.length() >= parentNum) {
            return RevisionInfo.forParent(-parentNum, parents.get(parentNum - 1));
        }
    } else if (!info.revisions().containsKey(revOrId)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revOrId.equals(String.valueOf(r._number()))) {
                revOrId = r.name();
                break;
            }
        }
    }
    return revOrId != null ? info.revision(revOrId) : null;
}
#end_block

#method_before
private boolean isSubmittable(ChangeInfo info) {
    boolean canSubmit = info.status().isOpen() && revision.equals(info.currentRevision()) && !info.revision(revision).draft();
    if (canSubmit && info.status() == Change.Status.NEW) {
        for (String name : info.labels()) {
            LabelInfo label = info.label(name);
            switch(label.status()) {
                case NEED:
                    statusText.setInnerText("Needs " + name);
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (label.blocking()) {
                        statusText.setInnerText("Not " + name);
                        canSubmit = false;
                    }
                    break;
                case MAY:
                case OK:
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#method_after
private boolean isSubmittable(ChangeInfo info) {
    boolean canSubmit = info.status().isOpen() && revision.equals(info.currentRevision()) && !info.revision(revision).draft();
    if (canSubmit && info.status() == Change.Status.NEW) {
        for (String name : info.labels()) {
            LabelInfo label = info.label(name);
            switch(label.status()) {
                case NEED:
                    statusText.setInnerText(Util.M.needs(name));
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (label.blocking()) {
                        statusText.setInnerText(Util.M.blockedOn(name));
                        canSubmit = false;
                    }
                    break;
                case MAY:
                case OK:
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#end_block

#method_before
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r.id() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#method_after
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r.id() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    if (parents.length() > 1) {
        diffBase.addItem(Util.C.autoMerge(), "");
        for (int i = 0; i < parents.length(); i++) {
            int parentNum = i + 1;
            diffBase.addItem(Util.M.diffBaseParent(parentNum), String.valueOf(-parentNum));
        }
        int parentNum = toParentNum(base);
        if (parentNum > 0) {
            selectedIdx = list.length() + parentNum;
        }
    } else {
        diffBase.addItem(Util.C.baseDiffItem(), "");
    }
    diffBase.setSelectedIndex(selectedIdx);
}
#end_block

#method_before
public final int getMissingLabelIndex() {
    int i = -1;
    int ret = -1;
    List<LabelInfo> labels = Natives.asList(allLabels().values());
    for (LabelInfo label : labels) {
        i++;
        if (!permittedLabels().containsKey(label.name())) {
            continue;
        }
        JsArrayString values = permittedValues(label.name());
        if (values.length() == 0) {
            continue;
        }
        switch(label.status()) {
            case // Label is required for submit.
            NEED:
                if (ret != -1) {
                    // approve, return -1
                    return -1;
                } else {
                    ret = i;
                }
                continue;
            // Label already applied.
            case OK:
            case // Label is not required.
            MAY:
                continue;
            // Submit cannot happen, do not quick approve.
            case REJECT:
            case IMPOSSIBLE:
                return -1;
        }
    }
    return ret;
}
#method_after
public final int getMissingLabelIndex() {
    int i = -1;
    int ret = -1;
    List<LabelInfo> labels = Natives.asList(allLabels().values());
    for (LabelInfo label : labels) {
        i++;
        if (!permittedLabels().containsKey(label.name())) {
            continue;
        }
        JsArrayString values = permittedValues(label.name());
        if (values.length() == 0) {
            continue;
        }
        switch(label.status()) {
            case // Label is required for submit.
            NEED:
                if (ret != -1) {
                    // approve, return -1
                    return -1;
                }
                ret = i;
                continue;
            // Label already applied.
            case OK:
            case // Label is not required.
            MAY:
                continue;
            // Submit cannot happen, do not quick approve.
            case REJECT:
            case IMPOSSIBLE:
                return -1;
        }
    }
    return ret;
}
#end_block

#method_before
@Override
public boolean match(final ChangeData object) throws OrmException {
    return id.equals(object.notes().load().getAssignee());
}
#method_after
@Override
public boolean match(final ChangeData object) throws OrmException {
    if (id.get() == ChangeField.NO_ASSIGNEE) {
        return object.notes().load().getAssignee() == null;
    }
    return id.equals(object.notes().load().getAssignee());
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) {
    List<CodeReviewCommit> sorted = CodeReviewCommit.ORDER.sortedCopy(toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            ops.add(new CherryPickUnbornRootOp(n));
        } else if (n.getParentCount() == 0) {
            ops.add(new CherryPickRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new CherryPickOneOp(n));
        } else {
            ops.add(new CherryPickMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#method_after
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = CodeReviewCommit.ORDER.sortedCopy(toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            ops.add(new FastForwardOp(args, n));
        } else if (n.getParentCount() == 0) {
            ops.add(new CherryPickRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new CherryPickOneOp(n));
        } else {
            ops.add(new CherryPickMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    if (args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge)) {
        // on the commit so we have nothing further to perform at this time.
        return;
    }
    // There are multiple parents, so this is a merge commit. We don't want
    // to cherry-pick the merge as clients can't easily rebase their history
    // with that merge present and replaced by an equivalent merge with a
    // different first parent. So instead behave as though MERGE_IF_NECESSARY
    // was configured.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge)) {
        mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
        toMerge.setStatusCode(CLEAN_MERGE);
    } else {
        PersonIdent myIdent = new PersonIdent(args.serverIdent, ctx.getWhen());
        CodeReviewCommit result = args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        result = amendGitlink(result);
        mergeTip.moveTipTo(result, toMerge);
        args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    }
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    if (args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge)) {
        // on the commit so we have nothing further to perform at this time.
        return;
    }
    // There are multiple parents, so this is a merge commit. We don't want
    // to cherry-pick the merge as clients can't easily rebase their history
    // with that merge present and replaced by an equivalent merge with a
    // different first parent. So instead behave as though MERGE_IF_NECESSARY
    // was configured.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge) && !args.submoduleOp.hasSubscription(args.destBranch)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        PersonIdent myIdent = new PersonIdent(args.serverIdent, ctx.getWhen());
        CodeReviewCommit result = args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        result = amendGitlink(result);
        mergeTip.moveTipTo(result, toMerge);
        args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    }
}
#end_block

#method_before
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = sort(toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    for (CodeReviewCommit c : sorted) {
        if (c.getParentCount() > 1) {
            // Since there is a merge commit, sort and prune again using
            // MERGE_IF_NECESSARY semantics to avoid creating duplicate
            // commits.
            // 
            sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, sorted);
            break;
        }
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            ops.add(new RebaseUnbornRootOp(n));
        } else if (n.getParentCount() == 0) {
            ops.add(new RebaseRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new RebaseOneOp(n));
        } else {
            ops.add(new RebaseMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#method_after
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = sort(toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    for (CodeReviewCommit c : sorted) {
        if (c.getParentCount() > 1) {
            // Since there is a merge commit, sort and prune again using
            // MERGE_IF_NECESSARY semantics to avoid creating duplicate
            // commits.
            // 
            sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, sorted);
            break;
        }
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            ops.add(new FastForwardOp(args, n));
        } else if (n.getParentCount() == 0) {
            ops.add(new RebaseRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new RebaseOneOp(n));
        } else {
            ops.add(new RebaseMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // There are multiple parents, so this is a merge commit. We don't want
    // to rebase the merge as clients can't easily rebase their history with
    // that merge present and replaced by an equivalent merge with a different
    // first parent. So instead behave as though MERGE_IF_NECESSARY was
    // configured.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge)) {
        mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
        toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
    } else {
        CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(args.serverIdent, args.serverIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        mergeTip.moveTipTo(amendGitlink(newTip), toMerge);
        args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    }
    acceptMergeTip(mergeTip);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // There are multiple parents, so this is a merge commit. We don't want
    // to rebase the merge as clients can't easily rebase their history with
    // that merge present and replaced by an equivalent merge with a different
    // first parent. So instead behave as though MERGE_IF_NECESSARY was
    // configured.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge) && !args.submoduleOp.hasSubscription(args.destBranch)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(args.serverIdent, args.serverIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        mergeTip.moveTipTo(amendGitlink(newTip), toMerge);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    acceptMergeTip(mergeTip);
}
#end_block

#method_before
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null) {
        args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()).getAccount(), args.mergeTip.getCurrentTip().name(), ctx.getWhen());
    }
}
#method_after
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null && !args.dryrun) {
        args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()).getAccount(), args.mergeTip.getCurrentTip().name(), ctx.getWhen());
    }
}
#end_block

#method_before
protected CodeReviewCommit amendGitlink(CodeReviewCommit commit) throws IntegrationException {
    if (!args.submoduleOp.hasSubscription(args.destBranch)) {
        return commit;
    }
    // Modify the commit with gitlink update
    try {
        CodeReviewCommit newCommit = args.submoduleOp.composeGitlinksCommit(args.destBranch, commit);
        newCommit.copyFrom(commit);
        return newCommit;
    } catch (SubmoduleException | IOException e) {
        throw new IntegrationException("cannot update gitlink for the commit at branch: " + args.destBranch);
    }
}
#method_after
protected CodeReviewCommit amendGitlink(CodeReviewCommit commit) throws IntegrationException {
    if (!args.submoduleOp.hasSubscription(args.destBranch)) {
        return commit;
    }
    // Modify the commit with gitlink update
    try {
        return args.submoduleOp.composeGitlinksCommit(args.destBranch, commit);
    } catch (SubmoduleException | IOException e) {
        throw new IntegrationException("cannot update gitlink for the commit at branch: " + args.destBranch);
    }
}
#end_block

#method_before
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    if (!args.submoduleOp.hasSubscription(args.destBranch)) {
        CodeReviewCommit firstFastForward = args.mergeUtil.getFirstFastForward(args.mergeTip.getInitialTip(), args.rw, sorted);
        if (firstFastForward != null && !firstFastForward.equals(args.mergeTip.getInitialTip())) {
            ops.add(new FastForwardOp(args, firstFastForward));
        }
    }
    // For every other commit do a pair-wise merge.
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        ops.add(new MergeOneOp(args, n));
    }
    return ops;
}
#method_after
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    if (args.mergeTip.getInitialTip() == null || !args.submoduleOp.hasSubscription(args.destBranch)) {
        CodeReviewCommit firstFastForward = args.mergeUtil.getFirstFastForward(args.mergeTip.getInitialTip(), args.rw, sorted);
        if (firstFastForward != null && !firstFastForward.equals(args.mergeTip.getInitialTip())) {
            ops.add(new FastForwardOp(args, firstFastForward));
        }
    }
    // For every other commit do a pair-wise merge.
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        ops.add(new MergeOneOp(args, n));
    }
    return ops;
}
#end_block

#method_before
void process(Event e) {
    if (sorted.contains(e)) {
        return;
    }
    if (deps.get(e).isEmpty()) {
        sorted.add(e);
        for (Event w : waiting.get(e)) {
            deps.get(w).remove(e);
            process(w);
        }
    }
}
#method_after
void process(Event e) {
    if (sorted.contains(e)) {
        return;
    }
    // re-process those events in case they can now be emitted.
    if (deps.get(e).isEmpty()) {
        sorted.add(e);
        for (Event w : waiting.get(e)) {
            deps.get(w).remove(e);
            process(w);
        }
    }
}
#end_block

#method_before
@Override
public Result rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    try (NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject())) {
        buildUpdates(manager, ChangeBundle.fromReviewDb(db, changeId));
        return execute(db, changeId, manager);
    }
}
#method_after
@Override
public Result rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    try (NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject())) {
        buildUpdates(manager, bundleReader.fromReviewDb(db, changeId));
        return execute(db, changeId, manager);
    }
}
#end_block

#method_before
@Override
public NoteDbUpdateManager stage(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject());
    buildUpdates(manager, ChangeBundle.fromReviewDb(db, changeId));
    manager.stage();
    return manager;
}
#method_after
@Override
public NoteDbUpdateManager stage(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject());
    buildUpdates(manager, bundleReader.fromReviewDb(db, changeId));
    manager.stage();
    return manager;
}
#end_block

#method_before
@Override
public boolean rebuildProject(ReviewDb db, ImmutableMultimap<Project.NameKey, Change.Id> allChanges, Project.NameKey project, Repository allUsersRepo) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    checkArgument(allChanges.containsKey(project));
    boolean ok = true;
    ProgressMonitor pm = new TextProgressMonitor(new PrintWriter(System.out));
    pm.beginTask(FormatUtil.elide(project.get(), 50), allChanges.get(project).size());
    try (NoteDbUpdateManager manager = updateManagerFactory.create(project);
        ObjectInserter allUsersInserter = allUsersRepo.newObjectInserter();
        RevWalk allUsersRw = new RevWalk(allUsersInserter.newReader())) {
        manager.setAllUsersRepo(allUsersRepo, allUsersRw, allUsersInserter, new ChainedReceiveCommands(allUsersRepo));
        for (Change.Id changeId : allChanges.get(project)) {
            try {
                buildUpdates(manager, ChangeBundle.fromReviewDb(db, changeId));
            } catch (NoPatchSetsException e) {
                log.warn(e.getMessage());
            } catch (Throwable t) {
                log.error("Failed to rebuild change " + changeId, t);
                ok = false;
            }
            pm.update(1);
        }
        manager.execute();
    } finally {
        pm.endTask();
    }
    return ok;
}
#method_after
@Override
public boolean rebuildProject(ReviewDb db, ImmutableMultimap<Project.NameKey, Change.Id> allChanges, Project.NameKey project, Repository allUsersRepo) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    checkArgument(allChanges.containsKey(project));
    boolean ok = true;
    ProgressMonitor pm = new TextProgressMonitor(new PrintWriter(System.out));
    pm.beginTask(FormatUtil.elide(project.get(), 50), allChanges.get(project).size());
    try (NoteDbUpdateManager manager = updateManagerFactory.create(project);
        ObjectInserter allUsersInserter = allUsersRepo.newObjectInserter();
        RevWalk allUsersRw = new RevWalk(allUsersInserter.newReader())) {
        manager.setAllUsersRepo(allUsersRepo, allUsersRw, allUsersInserter, new ChainedReceiveCommands(allUsersRepo));
        for (Change.Id changeId : allChanges.get(project)) {
            try {
                buildUpdates(manager, bundleReader.fromReviewDb(db, changeId));
            } catch (NoPatchSetsException e) {
                log.warn(e.getMessage());
            } catch (Throwable t) {
                log.error("Failed to rebuild change " + changeId, t);
                ok = false;
            }
            pm.update(1);
        }
        manager.execute();
    } finally {
        pm.endTask();
    }
    return ok;
}
#end_block

#method_before
@Override
protected void configure() {
    install(new RestApiModule() {

        @Override
        protected void configure() {
            get(PROJECT_KIND, "lfs:config").to(GetLfsConfig.class);
            get(PROJECT_KIND, "lfs:settings").to(GetLfsSettings.class);
            put(PROJECT_KIND, "lfs:settings").to(PutLfsSettings.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    install(new RestApiModule() {

        @Override
        protected void configure() {
            get(PROJECT_KIND, "lfs:config-project").to(GetLfsProjectConfig.class);
            get(PROJECT_KIND, "lfs:config-global").to(GetLfsGlobalConfig.class);
            put(PROJECT_KIND, "lfs:config-global").to(PutLfsGlobalConfig.class);
        }
    });
}
#end_block

#method_before
public boolean isAssignee() {
    Account.Id current_assignee = notes.getAssignee();
    if (current_assignee != null && getUser().isIdentifiedUser()) {
        Account.Id id = getUser().asIdentifiedUser().getAccountId();
        return id.equals(current_assignee);
    }
    return false;
}
#method_after
public boolean isAssignee() {
    Account.Id currentAssignee = notes.getAssignee();
    if (currentAssignee != null && getUser().isIdentifiedUser()) {
        Account.Id id = getUser().getAccountId();
        return id.equals(currentAssignee);
    }
    return false;
}
#end_block

#method_before
public boolean canEditAssignee() {
    return isOwner() || getProjectControl().isOwner() || getUser().getCapabilities().canAdministrateServer() || getRefControl().canEditAssignee() || isAssignee();
}
#method_after
public boolean canEditAssignee() {
    return isOwner() || getProjectControl().isOwner() || getRefControl().canEditAssignee() || isAssignee();
}
#end_block

#method_before
private RevisionNoteMap getRevisionNoteMap(RevWalk rw, ObjectId curr) throws ConfigInvalidException, OrmException, IOException {
    if (curr.equals(ObjectId.zeroId())) {
        return RevisionNoteMap.emptyMap();
    }
    if (migration.readChanges()) {
        // If reading from changes is enabled, then the old ChangeNotes may have
        // already parsed the revision notes. We can reuse them as long as the ref
        // hasn't advanced.
        ChangeNotes notes = getNotes();
        if (notes != null && notes.revisionNoteMap != null) {
            ObjectId idFromNotes = firstNonNull(notes.load().getRevision(), ObjectId.zeroId());
            if (idFromNotes.equals(curr)) {
                return notes.revisionNoteMap;
            }
        }
    }
    NoteMap noteMap = NoteMap.read(rw.getObjectReader(), rw.parseCommit(curr));
    // parse any existing revision notes so we can merge them.
    return RevisionNoteMap.parse(noteUtil, getId(), rw.getObjectReader(), noteMap, false);
}
#method_after
private RevisionNoteMap getRevisionNoteMap(RevWalk rw, ObjectId curr) throws ConfigInvalidException, OrmException, IOException {
    if (curr.equals(ObjectId.zeroId())) {
        return RevisionNoteMap.emptyMap();
    }
    if (migration.readChanges()) {
        // If reading from changes is enabled, then the old ChangeNotes may have
        // already parsed the revision notes. We can reuse them as long as the ref
        // hasn't advanced.
        ChangeNotes notes = getNotes();
        if (notes != null && notes.revisionNoteMap != null) {
            ObjectId idFromNotes = firstNonNull(notes.load().getRevision(), ObjectId.zeroId());
            if (idFromNotes.equals(curr)) {
                return notes.revisionNoteMap;
            }
        }
    }
    NoteMap noteMap = NoteMap.read(rw.getObjectReader(), rw.parseCommit(curr));
    // parse any existing revision notes so we can merge them.
    return RevisionNoteMap.parse(noteUtil, getId(), rw.getObjectReader(), noteMap, PatchLineComment.Status.PUBLISHED);
}
#end_block

#method_before
private void parseAssignee(ChangeNotesCommit commit) throws ConfigInvalidException {
    // Only last assignee
    if (assignee != null) {
        return;
    }
    String assigneeValue = parseOneFooter(commit, FOOTER_ASSIGNEE);
    if (assigneeValue != null) {
        PersonIdent ident = RawParseUtils.parsePersonIdent(assigneeValue);
        assignee = noteUtil.parseIdent(ident, id);
    }
}
#method_after
private void parseAssignee(ChangeNotesCommit commit) throws ConfigInvalidException {
    if (assignee != null) {
        return;
    }
    String assigneeValue = parseOneFooter(commit, FOOTER_ASSIGNEE);
    if (assigneeValue != null) {
        PersonIdent ident = RawParseUtils.parsePersonIdent(assigneeValue);
        assignee = noteUtil.parseIdent(ident, id);
    }
}
#end_block

#method_before
private void parseNotes() throws IOException, ConfigInvalidException {
    ObjectReader reader = walk.getObjectReader();
    ChangeNotesCommit tipCommit = walk.parseCommit(tip);
    revisionNoteMap = RevisionNoteMap.parse(noteUtil, id, reader, NoteMap.read(reader, tipCommit), false);
    Map<RevId, RevisionNote> rns = revisionNoteMap.revisionNotes;
    for (Map.Entry<RevId, RevisionNote> e : rns.entrySet()) {
        for (PatchLineComment plc : e.getValue().comments) {
            comments.put(e.getKey(), plc);
        }
    }
    for (PatchSet ps : patchSets.values()) {
        RevisionNote rn = rns.get(ps.getRevision());
        if (rn != null && rn.pushCert != null) {
            ps.setPushCertificate(rn.pushCert);
        }
    }
}
#method_after
private void parseNotes() throws IOException, ConfigInvalidException {
    ObjectReader reader = walk.getObjectReader();
    ChangeNotesCommit tipCommit = walk.parseCommit(tip);
    revisionNoteMap = RevisionNoteMap.parse(noteUtil, id, reader, NoteMap.read(reader, tipCommit), PatchLineComment.Status.PUBLISHED);
    Map<RevId, RevisionNote> rns = revisionNoteMap.revisionNotes;
    for (Map.Entry<RevId, RevisionNote> e : rns.entrySet()) {
        for (PatchLineComment plc : e.getValue().comments) {
            comments.put(e.getKey(), plc);
        }
    }
    for (PatchSet ps : patchSets.values()) {
        RevisionNote rn = rns.get(ps.getRevision());
        if (rn != null && rn.pushCert != null) {
            ps.setPushCertificate(rn.pushCert);
        }
    }
}
#end_block

#method_before
@Test
public void assigneeCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(otherUserId);
    ObjectId result = update.commit();
    assertThat(result).isNotNull();
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(update.getResult());
        rw.parseBody(commit);
        assertThat(commit.getFullMessage()).endsWith("Assignee: " + otherUser.getNameEmail());
    }
}
#method_after
@Test
public void assigneeCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(otherUserId);
    ObjectId result = update.commit();
    assertThat(result).isNotNull();
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(update.getResult());
        rw.parseBody(commit);
        String strIdent = otherUser.getName() + " <" + otherUserId + "@" + serverId + ">";
        assertThat(commit.getFullMessage()).contains("Assignee: " + strIdent);
    }
}
#end_block

#method_before
@Test
public void assigneeChangeNotes() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(otherUserId);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getAssignee()).isEqualTo(otherUserId);
}
#method_after
@Test
public void assigneeChangeNotes() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(otherUserId);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getAssignee()).isEqualTo(otherUserId);
    update = newUpdate(c, changeOwner);
    update.setAssignee(changeOwner.getAccountId());
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getAssignee()).isEqualTo(changeOwner.getAccountId());
}
#end_block

#method_before
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(readNote(notes, commit)).isEqualTo(pushCert);
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(newPublishedComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
}
#method_after
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    if (!testJson()) {
        assertThat(note).isEqualTo(pushCert);
    }
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(newPublishedComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
    if (!testJson()) {
        assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    PatchLineComment comment3 = newPublishedComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    PatchLineComment comment3 = newPublishedComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    PatchLineComment comment1 = newPublishedComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    PatchLineComment comment2 = newPublishedComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    PatchLineComment comment3 = newPublishedComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(comment3);
    update.putComment(comment2);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#method_after
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    PatchLineComment comment1 = newPublishedComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    PatchLineComment comment2 = newPublishedComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    PatchLineComment comment3 = newPublishedComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(comment3);
    update.putComment(comment2);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(comment.getRevId(), comment));
}
#method_after
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(comment.getRevId(), comment));
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus() != Change.Status.MERGED) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
    }
    out.submittable = Submit.submittable(cd);
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (includeSubmittable) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private Paths getPaths() {
    if (paths == null) {
        paths = new Paths();
    }
    return paths;
}
#method_after
@Provides
@Singleton
private Paths getPaths() {
    if (paths == null) {
        paths = new Paths(options);
    }
    return paths;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serveRegex("^/Documentation/(.+)$").with(named(DOC_SERVLET));
    serve("/static/*").with(SiteStaticDirectoryServlet.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE, Path.class, Resource.class).maximumWeight(1 << 20).weigher(ResourceServlet.Weigher.class);
        }
    });
    install(new CoreStaticModule());
    if (options.enablePolyGWT()) {
        filter("/*").through(PolyGWTFilter.class);
        install(new GwtUiModule());
        install(new PolyGerritUiModule(true));
    } else if (options.enablePolyGerrit()) {
        install(new PolyGerritUiModule(false));
    } else if (options.enableDefaultUi()) {
        install(new GwtUiModule());
    }
}
#method_after
@Override
protected void configureServlets() {
    serveRegex("^/Documentation/(.+)$").with(named(DOC_SERVLET));
    serve("/static/*").with(SiteStaticDirectoryServlet.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE, Path.class, Resource.class).maximumWeight(1 << 20).weigher(ResourceServlet.Weigher.class);
        }
    });
    if (!options.headless()) {
        install(new CoreStaticModule());
    }
    if (options.enablePolyGerrit()) {
        install(new PolyGerritModule());
    }
    if (options.enableGwtUi()) {
        install(new GwtUiModule());
    }
}
#end_block

#method_before
@Provides
@Singleton
@Named(ROBOTS_TXT_SERVLET)
HttpServlet getRobotsTxtServlet(@GerritServerConfig Config cfg, SitePaths sitePaths, @Named(CACHE) Cache<Path, Resource> cache) {
    Path configPath = sitePaths.resolve(cfg.getString("httpd", null, "robotsFile"));
    if (configPath != null) {
        if (exists(configPath) && isReadable(configPath)) {
            return new SingleFileServlet(cache, configPath, true);
        } else {
            log.warn("Cannot read httpd.robotsFile, using default");
        }
    }
    Paths p = getPaths();
    if (p.warFs != null) {
        return new SingleFileServlet(cache, p.warFs.getPath("/robots.txt"), false);
    } else {
        return new SingleFileServlet(cache, webappSourcePath("robots.txt"), true);
    }
}
#method_after
@Provides
@Singleton
@Named(ROBOTS_TXT_SERVLET)
HttpServlet getRobotsTxtServlet(@GerritServerConfig Config cfg, SitePaths sitePaths, @Named(CACHE) Cache<Path, Resource> cache) {
    Path configPath = sitePaths.resolve(cfg.getString("httpd", null, "robotsFile"));
    if (configPath != null) {
        if (exists(configPath) && isReadable(configPath)) {
            return new SingleFileServlet(cache, configPath, true);
        }
        log.warn("Cannot read httpd.robotsFile, using default");
    }
    Paths p = getPaths();
    if (p.warFs != null) {
        return new SingleFileServlet(cache, p.warFs.getPath("/robots.txt"), false);
    }
    return new SingleFileServlet(cache, webappSourcePath("robots.txt"), true);
}
#end_block

#method_before
@Provides
@Singleton
@Named(FAVICON_SERVLET)
HttpServlet getFaviconServlet(@Named(CACHE) Cache<Path, Resource> cache) {
    Paths p = getPaths();
    if (p.warFs != null) {
        return new SingleFileServlet(cache, p.warFs.getPath("/favicon.ico"), false);
    } else {
        return new SingleFileServlet(cache, webappSourcePath("favicon.ico"), true);
    }
}
#method_after
@Provides
@Singleton
@Named(FAVICON_SERVLET)
HttpServlet getFaviconServlet(@Named(CACHE) Cache<Path, Resource> cache) {
    Paths p = getPaths();
    if (p.warFs != null) {
        return new SingleFileServlet(cache, p.warFs.getPath("/favicon.ico"), false);
    }
    return new SingleFileServlet(cache, webappSourcePath("favicon.ico"), true);
}
#end_block

#method_before
@Provides
@Singleton
@Named(GWT_UI_SERVLET)
HttpServlet getGwtUiServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    Paths p = getPaths();
    if (p.warFs != null) {
        return new WarGwtUiServlet(cache, p.warFs);
    } else {
        return new DirectoryGwtUiServlet(cache, p.unpackedWar, p.isDev());
    }
}
#method_after
@Provides
@Singleton
@Named(GWT_UI_SERVLET)
HttpServlet getGwtUiServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    Paths p = getPaths();
    if (p.warFs != null) {
        return new WarGwtUiServlet(cache, p.warFs);
    }
    return new DirectoryGwtUiServlet(cache, p.unpackedWar, p.isDev());
}
#end_block

#method_before
private File getLauncherLoadedFrom() {
    File war;
    try {
        war = GerritLauncher.getDistributionArchive();
    } catch (IOException e) {
        if ((e instanceof FileNotFoundException) && GerritLauncher.NOT_ARCHIVED.equals(e.getMessage())) {
            return null;
        } else {
            ProvisionException pe = new ProvisionException("Error reading gerrit.war");
            pe.initCause(e);
            throw pe;
        }
    }
    return war;
}
#method_after
private File getLauncherLoadedFrom() {
    File war;
    try {
        war = GerritLauncher.getDistributionArchive();
    } catch (IOException e) {
        if ((e instanceof FileNotFoundException) && GerritLauncher.NOT_ARCHIVED.equals(e.getMessage())) {
            return null;
        }
        ProvisionException pe = new ProvisionException("Error reading gerrit.war");
        pe.initCause(e);
        throw pe;
    }
    return war;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (options.enableDefaultUi() || options.enablePolyGWT()) {
        filter("/").through(XsrfCookieFilter.class);
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    if (authConfig.getAuthType() != AuthType.OAUTH && authConfig.getAuthType() != AuthType.OPENID) {
        serve("/logout").with(HttpLogoutServlet.class);
        serve("/signout").with(HttpLogoutServlet.class);
    }
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    filter("/Documentation/").through(QueryDocumentationFilter.class);
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (options.enableGwtUi()) {
        filter("/").through(XsrfCookieFilter.class);
        filter("/accounts/self/detail").through(XsrfCookieFilter.class);
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
        // Forward PolyGerrit URLs to their respective GWT equivalents.
        serveRegex("^/(c|q|x|admin|dashboard|settings)/(.*)").with(gerritUrl());
    }
    serve("/cat/*").with(CatServlet.class);
    if (authConfig.getAuthType() != AuthType.OAUTH && authConfig.getAuthType() != AuthType.OPENID) {
        serve("/logout").with(HttpLogoutServlet.class);
        serve("/signout").with(HttpLogoutServlet.class);
    }
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    // Bind servlets for REST root collections.
    // The '/plugins/' root collection is already handled by HttpPluginServlet
    // which is bound in HttpPluginModule. We cannot bind it here again although
    // this means that plugins can't add REST views on PLUGIN_KIND.
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    filter("/Documentation/").through(QueryDocumentationFilter.class);
}
#end_block

#method_before
@Override
protected Path getResourcePath(String pathInfo) throws IOException {
    if (bowerComponents == null) {
        throw new IOException("No polymer components found: " + zip + ". Run `buck build //polygerrit-ui:polygerrit_components`?");
    }
    // Why we need to remove here bower_components suffix?
    if (pathInfo.startsWith("bower_components")) {
        int offset = "bower_components".length() + 1;
        pathInfo = pathInfo.substring(offset, pathInfo.length());
    }
    return bowerComponents.resolve(pathInfo);
}
#method_after
@Override
protected Path getResourcePath(String pathInfo) throws IOException {
    if (bowerComponents == null) {
        throw new IOException("No polymer components found: " + zip + ". Run `buck build //polygerrit-ui:polygerrit_components`?");
    }
    return bowerComponents.resolve(pathInfo);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    get(REVISION_KIND, "submit_prediction").to(SubmitPrediction.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#end_block

#method_before
BatchUpdate getUpdate() {
    checkState(db != null, "call setContext before getUpdate");
    if (update == null) {
        update = batchUpdateFactory.create(db, getProjectName(), caller, ts).setRepository(repo, rw, ins).setRequestId(submissionId);
    }
    return update;
}
#method_after
public BatchUpdate getUpdate() {
    checkState(db != null, "call setContext before getUpdate");
    if (update == null) {
        update = batchUpdateFactory.create(db, getProjectName(), caller, ts).setRepository(repo, rw, ins).setRequestId(submissionId);
    }
    return update;
}
#end_block

#method_before
public OpenRepo openRepo(Project.NameKey project, boolean abortIfOpen) throws NoSuchProjectException, IOException {
    if (abortIfOpen) {
        checkState(!openRepos.containsKey(project), "repo already opened: %s", project);
    }
    if (openRepos.containsKey(project)) {
        return openRepos.get(project);
    }
    ProjectState projectState = projectCache.get(project);
    if (projectState == null) {
        throw new NoSuchProjectException(project);
    }
    try {
        OpenRepo or = new OpenRepo(repoManager.openRepository(project), projectState);
        openRepos.put(project, or);
        return or;
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchProjectException(project);
    }
}
#method_after
public OpenRepo openRepo(Project.NameKey project) throws NoSuchProjectException, IOException {
    if (openRepos.containsKey(project)) {
        return openRepos.get(project);
    }
    ProjectState projectState = projectCache.get(project);
    if (projectState == null) {
        throw new NoSuchProjectException(project);
    }
    try {
        OpenRepo or = new OpenRepo(repoManager.openRepository(project), projectState);
        openRepos.put(project, or);
        return or;
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchProjectException(project);
    }
}
#end_block

#method_before
public void execute(Listener listener) throws UpdateException, RestApiException {
    execute(ImmutableList.of(this), listener, requestId);
}
#method_after
static void execute(Collection<BatchUpdate> updates, Listener listener, @Nullable RequestId requestId, boolean dryrun) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    if (requestId != null) {
        for (BatchUpdate u : updates) {
            checkArgument(u.requestId == null || u.requestId == requestId, "refusing to overwrite RequestId %s in update with %s", u.requestId, requestId);
            u.setRequestId(requestId);
        }
    }
    try {
        Order order = getOrder(updates);
        boolean updateChangesInParallel = getUpdateChangesInParallel(updates);
        switch(order) {
            case REPO_BEFORE_DB:
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterRefUpdates();
                for (BatchUpdate u : updates) {
                    u.executeChangeOps(updateChangesInParallel, dryrun);
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (BatchUpdate u : updates) {
                    u.executeChangeOps(updateChangesInParallel, dryrun);
                }
                listener.afterUpdateChanges();
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates(dryrun);
                }
                listener.afterRefUpdates();
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        List<CheckedFuture<?, IOException>> indexFutures = new ArrayList<>();
        for (BatchUpdate u : updates) {
            indexFutures.addAll(u.indexFutures);
        }
        ChangeIndexer.allAsList(indexFutures).get();
        for (BatchUpdate u : updates) {
            if (u.batchRefUpdate != null) {
                // Fire ref update events only after all mutations are finished, since
                // callers may assume a patch set ref being created means the change
                // was created, or a branch advancing meaning some changes were
                // closed.
                u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getUser().isIdentifiedUser() ? u.getUser().getAccountId() : null);
            }
        }
        if (!dryrun) {
            for (BatchUpdate u : updates) {
                u.executePostOps();
            }
        }
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    // Convert other common non-REST exception types with user-visible
    // messages to corresponding REST exception types
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    } catch (NoSuchChangeException | NoSuchRefException | NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
public Collection<ReceiveCommand> getRefUpdates() throws UpdateException, RestApiException {
    executeUpdateRepo();
    return commands.getCommands().values();
}
#method_after
public Collection<ReceiveCommand> getRefUpdates() {
    return commands.getCommands().values();
}
#end_block

#method_before
public void execute(Listener listener) throws UpdateException, RestApiException {
    execute(ImmutableList.of(this), listener, requestId);
}
#method_after
public void execute(Listener listener) throws UpdateException, RestApiException {
    execute(ImmutableList.of(this), listener, requestId, false);
}
#end_block

#method_before
private void executeUpdateRepo() throws UpdateException, RestApiException {
    try {
        logDebug("Executing updateRepo on {} ops", ops.size());
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
        if (!repoOnlyOps.isEmpty()) {
            logDebug("Executing updateRepo on {} RepoOnlyOps", ops.size());
            for (RepoOnlyOp op : repoOnlyOps) {
                op.updateRepo(ctx);
            }
        }
        if (inserter != null) {
            // todo should be optional
            logDebug("Flushing inserter");
            inserter.flush();
        } else {
            logDebug("No objects to flush");
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void executeUpdateRepo() throws UpdateException, RestApiException {
    try {
        logDebug("Executing updateRepo on {} ops", ops.size());
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
        if (!repoOnlyOps.isEmpty()) {
            logDebug("Executing updateRepo on {} RepoOnlyOps", ops.size());
            for (RepoOnlyOp op : repoOnlyOps) {
                op.updateRepo(ctx);
            }
        }
        if (inserter != null) {
            logDebug("Flushing inserter");
            inserter.flush();
        } else {
            logDebug("No objects to flush");
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
private void executeRefUpdates() throws IOException, UpdateException {
    if (commands == null || commands.isEmpty()) {
        logDebug("No ref updates to execute");
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    logDebug("Executing batch of {} ref updates", batchRefUpdate.getCommands().size());
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#method_after
private void executeRefUpdates(boolean dryrun) throws IOException, UpdateException {
    if (commands == null || commands.isEmpty()) {
        logDebug("No ref updates to execute");
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    logDebug("Executing batch of {} ref updates", batchRefUpdate.getCommands().size());
    if (dryrun) {
        return;
    }
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#end_block

#method_before
private void executeChangeOps(boolean parallel) throws UpdateException, RestApiException {
    logDebug("Executing change ops (parallel? {})", parallel);
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        if (notesMigration.commitChangeWrites() && repo != null) {
            // A NoteDb change may have been rebuilt since the repo was originally
            // opened, so make sure we see that.
            logDebug("Preemptively scanning for repo changes");
            repo.scanForRepoChanges();
        }
        if (!ops.isEmpty() && notesMigration.failChangeWrites()) {
            // Fail fast before attempting any writes if changes are read-only, as
            // this is a programmer error.
            logDebug("Failing early due to read-only Changes table");
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread());
            tasks.add(task);
            if (!parallel) {
                logDebug("Direct execution of task for ops: {}", ops);
            }
            futures.add(executor.submit(task));
        }
        if (parallel) {
            logDebug("Waiting on futures for {} ops spanning {} changes", ops.size(), ops.keySet().size());
        }
        // TODO(dborowitz): Timing is wrong for non-parallel updates.
        long startNanos = System.nanoTime();
        Futures.allAsList(futures).get();
        maybeLogSlowUpdate(startNanos, "change");
        if (notesMigration.commitChangeWrites()) {
            startNanos = System.nanoTime();
            executeNoteDbUpdates(tasks);
            maybeLogSlowUpdate(startNanos, "NoteDb");
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    } catch (OrmException | IOException e) {
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else if (task.dirty) {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#method_after
private void executeChangeOps(boolean parallel, boolean dryrun) throws UpdateException, RestApiException {
    logDebug("Executing change ops (parallel? {})", parallel);
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        if (notesMigration.commitChangeWrites() && repo != null) {
            // A NoteDb change may have been rebuilt since the repo was originally
            // opened, so make sure we see that.
            logDebug("Preemptively scanning for repo changes");
            repo.scanForRepoChanges();
        }
        if (!ops.isEmpty() && notesMigration.failChangeWrites()) {
            // Fail fast before attempting any writes if changes are read-only, as
            // this is a programmer error.
            logDebug("Failing early due to read-only Changes table");
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread(), dryrun);
            tasks.add(task);
            if (!parallel) {
                logDebug("Direct execution of task for ops: {}", ops);
            }
            futures.add(executor.submit(task));
        }
        if (parallel) {
            logDebug("Waiting on futures for {} ops spanning {} changes", ops.size(), ops.keySet().size());
        }
        // TODO(dborowitz): Timing is wrong for non-parallel updates.
        long startNanos = System.nanoTime();
        Futures.allAsList(futures).get();
        maybeLogSlowUpdate(startNanos, "change");
        if (notesMigration.commitChangeWrites()) {
            startNanos = System.nanoTime();
            if (!dryrun) {
                executeNoteDbUpdates(tasks);
            }
            maybeLogSlowUpdate(startNanos, "NoteDb");
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    } catch (OrmException | IOException e) {
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else if (task.dirty) {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#end_block

#method_before
private void call(ReviewDb db, Repository repo, RevWalk rw) throws Exception {
    // Not always opened.
    @SuppressWarnings("resource")
    NoteDbUpdateManager updateManager = null;
    try {
        ChangeContext ctx;
        db.changes().beginTransaction(id);
        try {
            ctx = newChangeContext(db, repo, rw, id);
            // Call updateChange on each op.
            logDebug("Calling updateChange on {} ops", changeOps.size());
            for (Op op : changeOps) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                logDebug("No ops reported dirty, short-circuiting");
                return;
            }
            deleted = ctx.deleted;
            if (deleted) {
                logDebug("Change was deleted");
            }
            // Stage the NoteDb update and store its state in the Change.
            if (notesMigration.commitChangeWrites()) {
                updateManager = stageNoteDbUpdate(ctx, deleted);
            }
            // Bump lastUpdatedOn or rowVersion and commit.
            Iterable<Change> cs = changesToUpdate(ctx);
            if (newChanges.containsKey(id)) {
                // Insert rather than upsert in case of a race on change IDs.
                logDebug("Inserting change");
                db.changes().insert(cs);
            } else if (deleted) {
                logDebug("Deleting change");
                db.changes().delete(cs);
            } else {
                logDebug("Updating change");
                db.changes().update(cs);
            }
            db.commit();
        } finally {
            db.rollback();
        }
        if (notesMigration.commitChangeWrites()) {
            try {
                // Do not execute the NoteDbUpdateManager, as we don't want too much
                // contention on the underlying repo, and we would rather use a
                // single ObjectInserter/BatchRefUpdate later.
                // 
                // TODO(dborowitz): May or may not be worth trying to batch
                // together flushed inserters as well.
                noteDbResult = updateManager.stage().get(id);
            } catch (IOException ex) {
                // Ignore all errors trying to update NoteDb at this point. We've
                // already written the NoteDbChangeState to ReviewDb, which means
                // if the state is out of date it will be rebuilt the next time it
                // is needed.
                log.debug("Ignoring NoteDb update error after ReviewDb write", ex);
            }
        }
    } catch (Exception e) {
        logDebug("Error updating change (should be rethrown)", e);
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    } finally {
        if (updateManager != null) {
            updateManager.close();
        }
    }
}
#method_after
private void call(ReviewDb db, Repository repo, RevWalk rw) throws Exception {
    // Not always opened.
    @SuppressWarnings("resource")
    NoteDbUpdateManager updateManager = null;
    try {
        ChangeContext ctx;
        db.changes().beginTransaction(id);
        try {
            ctx = newChangeContext(db, repo, rw, id);
            // Call updateChange on each op.
            logDebug("Calling updateChange on {} ops", changeOps.size());
            for (Op op : changeOps) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                logDebug("No ops reported dirty, short-circuiting");
                return;
            }
            deleted = ctx.deleted;
            if (deleted) {
                logDebug("Change was deleted");
            }
            // Stage the NoteDb update and store its state in the Change.
            if (notesMigration.commitChangeWrites()) {
                updateManager = stageNoteDbUpdate(ctx, deleted);
            }
            // Bump lastUpdatedOn or rowVersion and commit.
            Iterable<Change> cs = changesToUpdate(ctx);
            if (newChanges.containsKey(id)) {
                // Insert rather than upsert in case of a race on change IDs.
                logDebug("Inserting change");
                db.changes().insert(cs);
            } else if (deleted) {
                logDebug("Deleting change");
                db.changes().delete(cs);
            } else {
                logDebug("Updating change");
                db.changes().update(cs);
            }
            if (!dryrun) {
                db.commit();
            }
        } finally {
            db.rollback();
        }
        if (notesMigration.commitChangeWrites()) {
            try {
                // Do not execute the NoteDbUpdateManager, as we don't want too much
                // contention on the underlying repo, and we would rather use a
                // single ObjectInserter/BatchRefUpdate later.
                // 
                // TODO(dborowitz): May or may not be worth trying to batch
                // together flushed inserters as well.
                noteDbResult = updateManager.stage().get(id);
            } catch (IOException ex) {
                // Ignore all errors trying to update NoteDb at this point. We've
                // already written the NoteDbChangeState to ReviewDb, which means
                // if the state is out of date it will be rebuilt the next time it
                // is needed.
                log.debug("Ignoring NoteDb update error after ReviewDb write", ex);
            }
        }
    } catch (Exception e) {
        logDebug("Error updating change (should be rethrown)", e);
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    } finally {
        if (updateManager != null) {
            updateManager.close();
        }
    }
}
#end_block

#method_before
void sendMessages() {
    for (CommitValidationMessage m : messages) {
        if (m.isError()) {
            messageSender.sendError(m.getMessage());
        } else {
            messageSender.sendMessage(m.getMessage());
        }
    }
}
#method_after
void sendMessages() {
    for (ValidationMessage m : messages) {
        if (m.isError()) {
            messageSender.sendError(m.getMessage());
        } else {
            messageSender.sendMessage(m.getMessage());
        }
    }
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), c.change.getStatus() == Change.Status.DRAFT, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, u.replaceOp != null && u.replaceOp.getPatchSet().isDraft(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean draft, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (draft) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) {
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(ReceiveCommand cmd) {
    logDebug("Deleting {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    logDebug("Deleting {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
String parse(CmdLineParser clp, Repository repo, Set<String> refs) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        clp.parseOptionMap(options);
        ref = ref.substring(0, optionStart);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#method_after
String parse(CmdLineParser clp, Repository repo, Set<String> refs, ListMultimap<String, String> pushOptions) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    ListMultimap<String, String> options = LinkedListMultimap.create(pushOptions);
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        ref = ref.substring(0, optionStart);
    }
    if (!options.isEmpty()) {
        clp.parseOptionMap(options);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        logDebug("Forcing newChangeForAllNotInTarget = false");
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        logDebug("Handling %base: {}", magicBranch.base);
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        logDebug("Handling newChangeForAllNotInTarget");
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        } catch (IOException ex) {
            logWarn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            logDebug("Marking {} base commits uninteresting", magicBranch.baseCommit.size());
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                logDebug("Marking target ref {} ({}) uninteresting", magicBranch.ctl.getRefName(), targetRef.getObjectId().name());
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setDraft(magicBranch.draft).setTopic(magicBranch.topic).setValidatePolicy(CommitValidators.Policy.NONE);
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    ins.setUpdateRefCommand(cmd);
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#method_after
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setValidatePolicy(CommitValidators.Policy.NONE);
    if (magicBranch.draft) {
        ins.setDraft(magicBranch.draft);
    } else if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    ins.setUpdateRefCommand(cmd);
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators.Policy policy;
    if (magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged) {
        policy = CommitValidators.Policy.MERGED;
    } else {
        policy = CommitValidators.Policy.RECEIVE_COMMITS;
    }
    try {
        messages.addAll(commitValidatorsFactory.create(policy, ctl, sshInfo, repo).validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.completeChangeSet(db, cd.change(), resource.getControl().getUser());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.get().completeChangeSet(db, cd.change(), resource.getControl().getUser());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput, boolean dryrun) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    this.ts = TimeUtil.nowTs();
    submissionId = RequestId.forChange(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs, dryrun);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput, boolean dryrun) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.dryrun = dryrun;
    this.caller = caller;
    this.ts = TimeUtil.nowTs();
    submissionId = RequestId.forChange(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.setMergeOpRepoManager(orm).completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs, boolean dryrun) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Set<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
    try {
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp);
        Set<Project.NameKey> allProjects = submoduleOp.getProjectsInOrder();
        // in case superproject subscription is disabled, allProjects would be null
        if (allProjects == null) {
            allProjects = projects;
        }
        this.allProjects = allProjects;
        if (!dryrun) {
            BatchUpdate.execute(orm.batchUpdates(allProjects), new SubmitStrategyListener(submitInput, strategies, commits), submissionId);
        }
    } catch (UpdateException | SubmoduleException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "") + ": \n" + e.getMessage();
        }
        throw new IntegrationException(msg, e);
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Set<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
    try {
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp, dryrun);
        Set<Project.NameKey> allProjects = submoduleOp.getProjectsInOrder();
        // in case superproject subscription is disabled, allProjects would be null
        if (allProjects == null) {
            allProjects = projects;
        }
        this.allProjects = allProjects;
        BatchUpdate.execute(orm.batchUpdates(allProjects), new SubmitStrategyListener(submitInput, strategies, commits), submissionId, dryrun);
    } catch (UpdateException | SubmoduleException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "") + ": \n" + e.getMessage();
        }
        throw new IntegrationException(msg, e);
    }
}
#end_block

#method_before
private List<SubmitStrategy> getSubmitStrategies(Map<Branch.NameKey, BranchBatch> toSubmit, SubmoduleOp submoduleOp) throws IntegrationException {
    List<SubmitStrategy> strategies = new ArrayList<>();
    Set<Branch.NameKey> allBranches = submoduleOp.getBranchesInOrder();
    // in case superproject subscription is disabled, allBranches would be null
    if (allBranches == null) {
        allBranches = toSubmit.keySet();
    }
    for (Branch.NameKey branch : allBranches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        if (toSubmit.containsKey(branch)) {
            BranchBatch submitting = toSubmit.get(branch);
            OpenBranch ob = or.getBranch(branch);
            checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
            Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
            ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
            SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip, submoduleOp);
            strategies.add(strategy);
            strategy.addOps(or.getUpdate(), commitsToSubmit);
        } else {
            // no open change for this branch
            // add submodule triggered op into BatchUpdate
            submoduleOp.addOp(or.getUpdate(), branch);
        }
    }
    return strategies;
}
#method_after
private List<SubmitStrategy> getSubmitStrategies(Map<Branch.NameKey, BranchBatch> toSubmit, SubmoduleOp submoduleOp, boolean dryrun) throws IntegrationException {
    List<SubmitStrategy> strategies = new ArrayList<>();
    Set<Branch.NameKey> allBranches = submoduleOp.getBranchesInOrder();
    // in case superproject subscription is disabled, allBranches would be null
    if (allBranches == null) {
        allBranches = toSubmit.keySet();
    }
    for (Branch.NameKey branch : allBranches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        if (toSubmit.containsKey(branch)) {
            BranchBatch submitting = toSubmit.get(branch);
            OpenBranch ob = or.getBranch(branch);
            checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
            Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
            ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
            SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip, submoduleOp, dryrun);
            strategies.add(strategy);
            strategy.addOps(or.getUpdate(), commitsToSubmit);
        } else {
            // no open change for this branch
            // add submodule triggered op into BatchUpdate
            submoduleOp.addOp(or.getUpdate(), branch);
        }
    }
    return strategies;
}
#end_block

#method_before
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip, SubmoduleOp submoduleOp) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify, submoduleOp);
}
#method_after
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip, SubmoduleOp submoduleOp, boolean dryrun) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify, submoduleOp, dryrun);
}
#end_block

#method_before
private void openRepos(Collection<Project.NameKey> projects) throws IntegrationException {
    for (Project.NameKey project : projects) {
        try {
            orm.openRepo(project, true);
        } catch (NoSuchProjectException noProject) {
            logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
            abandonAllOpenChangeForDeletedProject(noProject.project());
        } catch (IOException e) {
            throw new IntegrationException("Error opening project " + project, e);
        }
    }
}
#method_after
private void openRepos(Collection<Project.NameKey> projects) throws IntegrationException {
    for (Project.NameKey project : projects) {
        try {
            orm.openRepo(project);
        } catch (NoSuchProjectException noProject) {
            logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
            abandonAllOpenChangeForDeletedProject(noProject.project());
        } catch (IOException e) {
            throw new IntegrationException("Error opening project " + project, e);
        }
    }
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    if (magicBranch.merged) {
        if (magicBranch.draft) {
            reject(cmd, "cannot be draft & merged");
            return;
        }
        if (magicBranch.base != null) {
            reject(cmd, "cannot use merged with base");
            return;
        }
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
    if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
        logDebug("Forcing newChangeForAllNotInTarget = false");
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        logDebug("Handling %base: {}", magicBranch.base);
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        logDebug("Handling newChangeForAllNotInTarget");
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        } catch (IOException ex) {
            logWarn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private RevCommit setUpWalkForSelectingChanges() throws IOException {
    RevWalk rw = rp.getRevWalk();
    rw.reset();
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.REVERSE, true);
    RevCommit start = rw.parseCommit(magicBranch.cmd.getNewId());
    rp.getRevWalk().markStart(start);
    if (magicBranch.baseCommit != null) {
        markExplicitBasesUninteresting();
    } else if (magicBranch.merged) {
        logDebug("Marking parents of merged commit {} uninteresting", start.name());
        for (RevCommit c : start.getParents()) {
            rw.markUninteresting(c);
        }
    } else {
        markHeadsAsUninteresting(rw, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
    }
    return start;
}
#method_after
private RevCommit setUpWalkForSelectingChanges() throws IOException {
    RevWalk rw = rp.getRevWalk();
    RevCommit start = rw.parseCommit(magicBranch.cmd.getNewId());
    rw.reset();
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.REVERSE, true);
    rp.getRevWalk().markStart(start);
    if (magicBranch.baseCommit != null) {
        markExplicitBasesUninteresting();
    } else if (magicBranch.merged) {
        logDebug("Marking parents of merged commit {} uninteresting", start.name());
        for (RevCommit c : start.getParents()) {
            rw.markUninteresting(c);
        }
    } else {
        markHeadsAsUninteresting(rw, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
    }
    return start;
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    if (magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged) {
        // When a commit is already merged, the user can't go back and add a
        // Change-Id line if missing. However, we still want perform the rest of
        // the validation for things like Forge Committer.
        // TODO(dborowitz): Do we want to use all other validation checks? If we
        // need some defined subset, then we probably need a new validateFor*
        // method on CommitValidators.
        commitValidators.setValidateChangeId(false);
    }
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators.Policy policy;
    if (magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged) {
        policy = CommitValidators.Policy.MERGED;
    } else {
        policy = CommitValidators.Policy.RECEIVE_COMMITS;
    }
    try {
        messages.addAll(commitValidatorsFactory.create(policy, ctl, sshInfo, repo).validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
@Test
public void createChangeForMergedCommit() throws Exception {
    String master = "refs/heads/master";
    grant(Permission.PUSH, project, master, true);
    // Update master with a direct push.
    RevCommit c1;
    RevCommit c2;
    String changeId;
    c1 = testRepo.commit().message("Non-change 1").create();
    c2 = testRepo.parseBody(testRepo.commit().parent(c1).message("Non-change 2").insertChangeId().create());
    changeId = Iterables.getOnlyElement(c2.getFooterLines(CHANGE_ID));
    testRepo.reset(c2);
    assertPushOk(pushHead(testRepo, master, false, true), master);
    String q = "commit:" + c1.name() + " OR commit:" + c2.name() + " OR change:" + changeId;
    assertThat(gApi.changes().query(q).get()).isEmpty();
    // Push c2 as a merged change.
    String r = "refs/for/master%merged";
    assertPushOk(pushHead(testRepo, r, false), r);
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.CURRENT_REVISION);
    ChangeInfo info = gApi.changes().id(changeId).get(opts);
    assertThat(info.currentRevision).isEqualTo(c2.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
    // Only c2 was created as a change.
    String q1 = "commit: " + c1.name();
    assertThat(gApi.changes().query(q1).get()).isEmpty();
    // Push c1 as a merged change.
    testRepo.reset(c1);
    assertPushOk(pushHead(testRepo, r, false), r);
    List<ChangeInfo> infos = gApi.changes().query(q1).withOptions(opts).get();
    assertThat(infos).hasSize(1);
    info = infos.get(0);
    assertThat(info.currentRevision).isEqualTo(c1.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
}
#method_after
@Test
public void createChangeForMergedCommit() throws Exception {
    String master = "refs/heads/master";
    grant(Permission.PUSH, project, master, true);
    // Update master with a direct push.
    RevCommit c1 = testRepo.commit().message("Non-change 1").create();
    RevCommit c2 = testRepo.parseBody(testRepo.commit().parent(c1).message("Non-change 2").insertChangeId().create());
    String changeId = Iterables.getOnlyElement(c2.getFooterLines(CHANGE_ID));
    testRepo.reset(c2);
    assertPushOk(pushHead(testRepo, master, false, true), master);
    String q = "commit:" + c1.name() + " OR commit:" + c2.name() + " OR change:" + changeId;
    assertThat(gApi.changes().query(q).get()).isEmpty();
    // Push c2 as a merged change.
    String r = "refs/for/master%merged";
    assertPushOk(pushHead(testRepo, r, false), r);
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.CURRENT_REVISION);
    ChangeInfo info = gApi.changes().id(changeId).get(opts);
    assertThat(info.currentRevision).isEqualTo(c2.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
    // Only c2 was created as a change.
    String q1 = "commit: " + c1.name();
    assertThat(gApi.changes().query(q1).get()).isEmpty();
    // Push c1 as a merged change.
    testRepo.reset(c1);
    assertPushOk(pushHead(testRepo, r, false), r);
    List<ChangeInfo> infos = gApi.changes().query(q1).withOptions(opts).get();
    assertThat(infos).hasSize(1);
    info = infos.get(0);
    assertThat(info.currentRevision).isEqualTo(c1.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new LinkedList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        if (!CHANGE_ID.matcher(v).matches()) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (!shouldValidateChangeId(receiveEvent)) {
        return Collections.emptyList();
    }
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new LinkedList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        if (!CHANGE_ID.matcher(v).matches()) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
public MergeSuperSet setMergeOpRepoManager(MergeOpRepoManager orm) {
    checkState(this.orm == null);
    this.orm = checkNotNull(orm);
    return this;
}
#method_after
public MergeSuperSet setMergeOpRepoManager(MergeOpRepoManager orm) {
    checkState(this.orm == null);
    this.orm = checkNotNull(orm);
    closeOrm = false;
    return this;
}
#end_block

#method_before
public ChangeSet completeChangeSet(ReviewDb db, Change change, CurrentUser user) throws IOException, OrmException {
    try {
        ChangeData cd = changeDataFactory.create(db, change.getProject(), change.getId());
        cd.changeControl(user);
        ChangeSet cs = new ChangeSet(cd, cd.changeControl().isVisible(db, cd));
        if (Submit.wholeTopicEnabled(cfg)) {
            return completeChangeSetIncludingTopics(db, cs, user);
        }
        return completeChangeSetWithoutTopic(db, cs, user);
    } finally {
        closeRepos();
    }
}
#method_after
public ChangeSet completeChangeSet(ReviewDb db, Change change, CurrentUser user) throws IOException, OrmException {
    try {
        ChangeData cd = changeDataFactory.create(db, change.getProject(), change.getId());
        cd.changeControl(user);
        ChangeSet cs = new ChangeSet(cd, cd.changeControl().isVisible(db, cd));
        if (Submit.wholeTopicEnabled(cfg)) {
            return completeChangeSetIncludingTopics(db, cs, user);
        }
        return completeChangeSetWithoutTopic(db, cs, user);
    } finally {
        if (closeOrm && orm != null) {
            orm.close();
            orm = null;
        }
    }
}
#end_block

#method_before
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws IOException, OrmException {
    Collection<ChangeData> visibleChanges = new ArrayList<>();
    Collection<ChangeData> nonVisibleChanges = new ArrayList<>();
    // For each target branch we run a separate rev walk to find open changes
    // reachable from changes already in the merge super set.
    ImmutableListMultimap<Branch.NameKey, ChangeData> bc = byBranch(Iterables.concat(changes.changes(), changes.nonVisibleChanges()));
    for (Branch.NameKey b : bc.keySet()) {
        OpenRepo or = getRepo(b.getParentKey());
        List<RevCommit> visibleCommits = new ArrayList<>();
        List<RevCommit> nonVisibleCommits = new ArrayList<>();
        for (ChangeData cd : bc.get(b)) {
            checkState(cd.hasChangeControl(), "completeChangeSet forgot to set changeControl for current user" + " at ChangeData creation time");
            boolean visible = changes.ids().contains(cd.getId());
            if (visible && !cd.changeControl().isVisible(db, cd)) {
                // We thought the change was visible, but it isn't.
                // This can happen if the ACL changes during the
                // completeChangeSet computation, for example.
                visible = false;
            }
            Collection<ChangeData> dest = visible ? visibleChanges : nonVisibleChanges;
            Collection<RevCommit> toWalk = visible ? visibleCommits : nonVisibleCommits;
            // Pick a revision to use for traversal.  If any of the patch sets
            // is visible, we use the most recent one.  Otherwise, use the current
            // patch set.
            PatchSet ps = cd.currentPatchSet();
            boolean visiblePatchSet = visible;
            if (!cd.changeControl().isPatchVisible(ps, cd)) {
                Iterable<PatchSet> visiblePatchSets = cd.visiblePatchSets();
                if (Iterables.isEmpty(visiblePatchSets)) {
                    visiblePatchSet = false;
                } else {
                    ps = Iterables.getLast(visiblePatchSets);
                }
            }
            if (submitType(cd, ps, visiblePatchSet) == SubmitType.CHERRY_PICK) {
                dest.add(cd);
                continue;
            }
            // Get the underlying git commit object
            String objIdStr = ps.getRevision().get();
            RevCommit commit = or.rw.parseCommit(ObjectId.fromString(objIdStr));
            // Always include the input, even if merged. This allows
            // SubmitStrategyOp to correct the situation later, assuming it gets
            // returned by byCommitsOnBranchNotMerged below.
            toWalk.add(commit);
        }
        Ref ref = or.repo.getRefDatabase().getRef(b.get());
        Optional<RevCommit> head = ref != null ? Optional.<RevCommit>of(or.rw.parseCommit(ref.getObjectId())) : Optional.<RevCommit>absent();
        Set<String> visibleHashes = new HashSet<>();
        or.rw.reset();
        if (head.isPresent()) {
            or.rw.markUninteresting(head.get());
        }
        for (RevCommit c : visibleCommits) {
            visibleHashes.add(c.name());
            or.rw.markStart(c);
        }
        for (RevCommit c : or.rw) {
            visibleHashes.add(c.name());
        }
        Iterable<ChangeData> cds = query().byCommitsOnBranchNotMerged(or.repo, db, b, visibleHashes);
        for (ChangeData chd : cds) {
            chd.changeControl(user);
            visibleChanges.add(chd);
        }
        Set<String> nonVisibleHashes = new HashSet<>();
        or.rw.reset();
        if (head.isPresent()) {
            or.rw.markUninteresting(head.get());
        }
        for (RevCommit c : nonVisibleCommits) {
            if (visibleHashes.contains(c.name())) {
                continue;
            }
            nonVisibleHashes.add(c.name());
            or.rw.markStart(c);
        }
        for (RevCommit c : or.rw) {
            if (visibleHashes.contains(c.name())) {
                continue;
            }
            nonVisibleHashes.add(c.name());
        }
        Iterables.addAll(nonVisibleChanges, query().byCommitsOnBranchNotMerged(or.repo, db, b, nonVisibleHashes));
    }
    return new ChangeSet(visibleChanges, nonVisibleChanges);
}
#method_after
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws IOException, OrmException {
    Collection<ChangeData> visibleChanges = new ArrayList<>();
    Collection<ChangeData> nonVisibleChanges = new ArrayList<>();
    // For each target branch we run a separate rev walk to find open changes
    // reachable from changes already in the merge super set.
    ImmutableListMultimap<Branch.NameKey, ChangeData> bc = byBranch(Iterables.concat(changes.changes(), changes.nonVisibleChanges()));
    for (Branch.NameKey b : bc.keySet()) {
        OpenRepo or = getRepo(b.getParentKey());
        List<RevCommit> visibleCommits = new ArrayList<>();
        List<RevCommit> nonVisibleCommits = new ArrayList<>();
        for (ChangeData cd : bc.get(b)) {
            checkState(cd.hasChangeControl(), "completeChangeSet forgot to set changeControl for current user" + " at ChangeData creation time");
            boolean visible = changes.ids().contains(cd.getId());
            if (visible && !cd.changeControl().isVisible(db, cd)) {
                // We thought the change was visible, but it isn't.
                // This can happen if the ACL changes during the
                // completeChangeSet computation, for example.
                visible = false;
            }
            Collection<RevCommit> toWalk = visible ? visibleCommits : nonVisibleCommits;
            // Pick a revision to use for traversal.  If any of the patch sets
            // is visible, we use the most recent one.  Otherwise, use the current
            // patch set.
            PatchSet ps = cd.currentPatchSet();
            boolean visiblePatchSet = visible;
            if (!cd.changeControl().isPatchVisible(ps, cd)) {
                Iterable<PatchSet> visiblePatchSets = cd.visiblePatchSets();
                if (Iterables.isEmpty(visiblePatchSets)) {
                    visiblePatchSet = false;
                } else {
                    ps = Iterables.getLast(visiblePatchSets);
                }
            }
            if (submitType(cd, ps, visiblePatchSet) == SubmitType.CHERRY_PICK) {
                if (visible) {
                    visibleChanges.add(cd);
                } else {
                    nonVisibleChanges.add(cd);
                }
                continue;
            }
            // Get the underlying git commit object
            String objIdStr = ps.getRevision().get();
            RevCommit commit = or.rw.parseCommit(ObjectId.fromString(objIdStr));
            // Always include the input, even if merged. This allows
            // SubmitStrategyOp to correct the situation later, assuming it gets
            // returned by byCommitsOnBranchNotMerged below.
            toWalk.add(commit);
        }
        Ref ref = or.repo.getRefDatabase().getRef(b.get());
        Optional<RevCommit> head = ref != null ? Optional.<RevCommit>of(or.rw.parseCommit(ref.getObjectId())) : Optional.<RevCommit>absent();
        Set<String> emptySet = Collections.emptySet();
        Set<String> visibleHashes = walkChangesByHashes(visibleCommits, emptySet, or, head);
        Iterable<ChangeData> cds = query().byCommitsOnBranchNotMerged(or.repo, db, b, visibleHashes);
        for (ChangeData chd : cds) {
            chd.changeControl(user);
            visibleChanges.add(chd);
        }
        Set<String> nonVisibleHashes = walkChangesByHashes(nonVisibleCommits, visibleHashes, or, head);
        Iterables.addAll(nonVisibleChanges, query().byCommitsOnBranchNotMerged(or.repo, db, b, nonVisibleHashes));
    }
    return new ChangeSet(visibleChanges, nonVisibleChanges);
}
#end_block

#method_before
private OpenRepo getRepo(Project.NameKey project) throws IOException {
    if (orm == null) {
        orm = repoManagerProvider.get();
    }
    try {
        OpenRepo or = orm.openRepo(project);
        checkState(or.rw.hasRevSort(RevSort.TOPO));
        return or;
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
}
#method_after
private OpenRepo getRepo(Project.NameKey project) throws IOException {
    if (orm == null) {
        orm = repoManagerProvider.get();
        closeOrm = true;
    }
    try {
        OpenRepo or = orm.openRepo(project);
        checkState(or.rw.hasRevSort(RevSort.TOPO));
        return or;
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p, QueryOptions opts) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriter.getPossibleStatus(p);
    List<SubIndex> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, queryBuilder.toQuery(p), opts, getSort());
}
#method_after
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p, QueryOptions opts) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriter.getPossibleStatus(p);
    List<SubIndex> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, p, opts, getSort());
}
#end_block

#method_before
@Override
public String toString() {
    return query.toString();
}
#method_after
@Override
public String toString() {
    return predicate.toString();
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interupted");
    }
    return new ChangeDataResults(executor.submit(new Callable<List<Document>>() {

        @Override
        public List<Document> call() throws OrmException {
            return doRead();
        }

        @Override
        public String toString() {
            return query.toString();
        }
    }));
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interupted");
    }
    return new ChangeDataResults(executor.submit(new Callable<List<Document>>() {

        @Override
        public List<Document> call() throws OrmException {
            return doRead();
        }

        @Override
        public String toString() {
            return predicate.toString();
        }
    }));
}
#end_block

#method_before
@Test
@TestProjectInput(createEmptyCommit = false)
public void pushInitialCommitForMasterBranch() throws Exception {
    RevCommit c = testRepo.commit().message("Initial commit").insertChangeId().create();
    String id = GitUtil.getChangeId(testRepo, c).get();
    testRepo.reset(c);
    String r = "refs/for/master";
    PushResult pr = pushHead(testRepo, r, false);
    assertPushOk(pr, r);
    assertThat(gApi.changes().id(id).info().branch).isEqualTo("master");
    try (Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.resolve("master")).isNull();
    }
}
#method_after
@Test
@TestProjectInput(createEmptyCommit = false)
public void pushInitialCommitForMasterBranch() throws Exception {
    RevCommit c = testRepo.commit().message("Initial commit").insertChangeId().create();
    String id = GitUtil.getChangeId(testRepo, c).get();
    testRepo.reset(c);
    String r = "refs/for/master";
    PushResult pr = pushHead(testRepo, r, false);
    assertPushOk(pr, r);
    ChangeInfo change = gApi.changes().id(id).info();
    assertThat(change.branch).isEqualTo("master");
    assertThat(change.status).isEqualTo(ChangeStatus.NEW);
    try (Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.resolve("master")).isNull();
    }
}
#end_block

#method_before
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify)) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = textBody.toString();
        va.htmlBody = htmlBody.toString();
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body, useHtml() ? va.htmlBody : null);
    }
}
#method_after
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify)) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        String textPart = textBody.toString();
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        if (useHtml()) {
            String htmlPart = htmlBody.toString();
            String boundary = generateMultipartBoundary(textPart, htmlPart);
            va.body = buildMultipartBody(boundary, textPart, htmlPart);
            va.textBody = textPart;
            va.htmlBody = htmlPart;
            va.headers.put("Content-Type", new EmailHeader.String("multipart/alternative; " + "boundary=\"" + boundary + "\"; " + "charset=UTF-8"));
        } else {
            va.body = textPart;
            va.textBody = textPart;
        }
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body);
    }
}
#end_block

#method_before
protected void appendHtml(final String html) {
    if (html != null) {
        htmlBody.append(html);
    }
}
#method_after
protected void appendHtml(String html) {
    if (html != null) {
        htmlBody.append(html);
    }
}
#end_block

#method_before
protected String soyTextTemplate(String name) {
    return args.soyTofu.newRenderer("com.google.gerrit.server.mail.template." + name).setContentKind(SanitizedContent.ContentKind.TEXT).setData(soyContext).render();
}
#method_after
protected String soyTextTemplate(String name) {
    return soyTemplate(name, SanitizedContent.ContentKind.TEXT);
}
#end_block

#method_before
protected String soyHtmlTemplate(String name) {
    return args.soyTofu.newRenderer("com.google.gerrit.server.mail.template." + name).setContentKind(SanitizedContent.ContentKind.HTML).setData(soyContext).render();
}
#method_after
protected String soyHtmlTemplate(String name) {
    return soyTemplate(name, SanitizedContent.ContentKind.HTML);
}
#end_block

#method_before
protected String textTemplate(String name) throws EmailException {
    String velocityName = name + ".vm";
    Path filePath = args.site.mail_dir.resolve(velocityName);
    if (Files.isRegularFile(filePath)) {
        return velocifyFile(velocityName);
    } else {
        return soyTextTemplate(name);
    }
}
#method_after
protected String textTemplate(String name) throws EmailException {
    String velocityName = name + ".vm";
    Path filePath = args.site.mail_dir.resolve(velocityName);
    if (Files.isRegularFile(filePath)) {
        return velocifyFile(velocityName);
    }
    return soyTextTemplate(name);
}
#end_block

#method_before
private void pushTag(TagType tagType, boolean newCommit, Status expectedStatus) throws Exception {
    commit(user.getIdent(), "subject");
    String tagName = "v1" + "_" + System.nanoTime();
    switch(tagType) {
        case LIGHTWEIGHT:
            break;
        case ANNOTATED:
            createAnnotatedTag(testRepo, tagName, user.getIdent());
            break;
        default:
            throw new IllegalStateException("unexpected tag type: " + tagType);
    }
    if (!newCommit) {
        grant(Permission.SUBMIT, project, "refs/for/refs/heads/master", false, REGISTERED_USERS);
        pushHead(testRepo, "refs/for/master%submit");
    }
    PushResult r = tagType == TagType.LIGHTWEIGHT ? pushHead(testRepo, "refs/tags/" + tagName) : GitUtil.pushTag(testRepo, tagName);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate("refs/tags/" + tagName);
    assertThat(refUpdate.getStatus()).named(tagType.name()).isEqualTo(expectedStatus);
}
#method_after
private void pushTag(TagType tagType, boolean newCommit, Status expectedStatus) throws Exception {
    commit(user.getIdent(), "subject");
    String tagName = "v1" + "_" + System.nanoTime();
    switch(tagType) {
        case LIGHTWEIGHT:
            break;
        case ANNOTATED:
            createAnnotatedTag(testRepo, tagName, user.getIdent());
            break;
        default:
            throw new IllegalStateException("unexpected tag type: " + tagType);
    }
    if (!newCommit) {
        grant(Permission.SUBMIT, project, "refs/for/refs/heads/master", false, REGISTERED_USERS);
        pushHead(testRepo, "refs/for/master%submit");
    }
    PushResult r = tagType == LIGHTWEIGHT ? pushHead(testRepo, "refs/tags/" + tagName) : GitUtil.pushTag(testRepo, tagName);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate("refs/tags/" + tagName);
    assertThat(refUpdate.getStatus()).named(tagType.name()).isEqualTo(expectedStatus);
}
#end_block

#method_before
public void abandonInactiveOpenChanges() {
    if (cfg.getAbandonAfter() <= 0) {
        return;
    }
    try {
        String query = "status:new age:" + TimeUnit.MILLISECONDS.toMinutes(cfg.getAbandonAfter()) + "m";
        if (!cfg.getAbandonIfMergeable()) {
            query += " -is:mergeable";
        }
        List<ChangeData> changesToAbandon = queryProcessor.enforceVisibility(false).queryChanges(queryBuilder.parse(query)).changes();
        int count = 0;
        for (ChangeData cd : changesToAbandon) {
            try {
                if (noNeedToAbandon(cd, query)) {
                    log.debug("Change data \"{}\" does not satisfy the query \"{}\" any" + " more, and hence skip it in clean up", cd, query);
                    continue;
                }
                abandon.abandon(changeControl(cd), cfg.getAbandonMessage(), null);
                count++;
            } catch (ResourceConflictException e) {
            // Change was already merged or abandoned.
            } catch (Throwable e) {
                log.error(String.format("Failed to auto-abandon inactive open change %d.", cd.getId().get()), e);
            }
        }
        log.info(String.format("Auto-Abandoned %d of %d changes.", count, changesToAbandon.size()));
    } catch (QueryParseException | OrmException e) {
        log.error("Failed to query inactive open changes for auto-abandoning.", e);
    }
}
#method_after
public void abandonInactiveOpenChanges() {
    if (cfg.getAbandonAfter() <= 0) {
        return;
    }
    try {
        String query = "status:new age:" + TimeUnit.MILLISECONDS.toMinutes(cfg.getAbandonAfter()) + "m";
        if (!cfg.getAbandonIfMergeable()) {
            query += " -is:mergeable";
        }
        List<ChangeData> changesToAbandon = queryProcessor.enforceVisibility(false).queryChanges(queryBuilder.parse(query)).changes();
        int count = 0;
        for (ChangeData cd : changesToAbandon) {
            try {
                if (noNeedToAbandon(cd, query)) {
                    log.debug("Change data \"{}\" does not satisfy the query \"{}\" any" + " more, hence skipping it in clean up", cd, query);
                    continue;
                }
                abandon.abandon(changeControl(cd), cfg.getAbandonMessage(), null);
                count++;
            } catch (ResourceConflictException e) {
            // Change was already merged or abandoned.
            } catch (Throwable e) {
                log.error(String.format("Failed to auto-abandon inactive open change %d.", cd.getId().get()), e);
            }
        }
        log.info(String.format("Auto-Abandoned %d of %d changes.", count, changesToAbandon.size()));
    } catch (QueryParseException | OrmException e) {
        log.error("Failed to query inactive open changes for auto-abandoning.", e);
    }
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, String base) {
    final RevisionInfo rev = info.revision(revision);
    RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(b, rev, lastReply, group, comments, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    group.addListener(new AsyncCallback<Void>() {

        @Override
        public void onSuccess(Void result) {
            loadConfigInfo(info, rev);
        }

        @Override
        public void onFailure(Throwable caught) {
            loadConfigInfo(info, rev);
        }
    });
    group.done();
}
#method_after
private void loadConfigInfo(final ChangeInfo info, String base) {
    final RevisionInfo rev = info.revision(revision);
    RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(b, rev, lastReply, group, comments, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    group.addListener(new AsyncCallback<Void>() {

        @Override
        public void onSuccess(Void result) {
            loadConfigInfo(info, rev);
        }

        @Override
        public void onFailure(Throwable caught) {
            logger.log(Level.SEVERE, "Loading file list and inline comments failed: " + caught.getMessage());
            loadConfigInfo(info, rev);
        }
    });
    group.done();
}
#end_block

#method_before
@Override
protected void formatChange() throws EmailException {
    appendText(textTemplate("Reverted.soy"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(textTemplate("Reverted"));
}
#end_block

#method_before
@Override
protected void formatChange() throws EmailException {
    appendText(textTemplate("Restored.soy"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(textTemplate("Restored"));
}
#end_block

#method_before
@Test
public void submitNoPermission() throws Exception {
    // create project where submit is blocked
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.block(cfg, Permission.SUBMIT, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    submit(result.getChangeId(), new SubmitInput(), AuthException.class, "submit not permitted");
}
#method_after
@Test
public void submitNoPermission() throws Exception {
    // create project where submit is blocked
    Project.NameKey p = createProject("p");
    block(Permission.SUBMIT, REGISTERED_USERS, "refs/*", p);
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    submit(result.getChangeId(), new SubmitInput(), AuthException.class, "submit not permitted");
}
#end_block

#method_before
@Test
public void submitNoPermission() throws Exception {
    // create project where submit is blocked
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.block(cfg, Permission.SUBMIT, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    submit(result.getChangeId(), new SubmitInput(), AuthException.class, "submit not permitted");
}
#method_after
@Test
public void submitNoPermission() throws Exception {
    // create project where submit is blocked
    Project.NameKey p = createProject("p");
    block(Permission.SUBMIT, REGISTERED_USERS, "refs/*", p);
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    submit(result.getChangeId(), new SubmitInput(), AuthException.class, "submit not permitted");
}
#end_block

#method_before
private void deleteGitRepository(final Project.NameKey project, final File repoFile) throws IOException {
    // Delete the repository from disk
    Path trash = moveToTrash(repoFile.toPath(), project);
    try {
        recursiveDelete(trash);
    } catch (IOException e) {
        // Only log if delete failed - repo already moved to trash.
        // Otherwise, listeners are never called.
        log.warn("Error trying to delete " + trash, e);
    }
    // Delete parent folders if they are (now) empty
    recursiveDeleteParent(repoFile.getParentFile(), gitDir.toFile());
    // Send an event that the repository was deleted
    ProjectDeletedListener.Event event = new ProjectDeletedListener.Event() {

        @Override
        public String getProjectName() {
            return project.get();
        }

        @Override
        public NotifyHandling getNotify() {
            return NotifyHandling.NONE;
        }
    };
    for (ProjectDeletedListener l : deletedListener) {
        try {
            l.onProjectDeleted(event);
        } catch (RuntimeException e) {
            log.warn("Failure in ProjectDeletedListener", e);
        }
    }
}
#method_after
private void deleteGitRepository(final Project.NameKey project, final File repoFile) throws IOException {
    // Delete the repository from disk
    Path trash = moveToTrash(repoFile.toPath(), project);
    boolean ok = false;
    try {
        recursiveDelete(trash);
        ok = true;
    } catch (IOException e) {
        // Only log if delete failed - repo already moved to trash.
        // Otherwise, listeners are never called.
        log.warn("Error trying to delete " + trash, e);
    }
    // Delete parent folders if they are (now) empty
    if (ok) {
        try {
            recursiveDeleteParent(repoFile.getParentFile(), gitDir.toFile());
        } catch (IOException e) {
            log.warn("Couldn't delete (empty) parents of " + repoFile, e);
        }
    }
    // Send an event that the repository was deleted
    ProjectDeletedListener.Event event = new ProjectDeletedListener.Event() {

        @Override
        public String getProjectName() {
            return project.get();
        }

        @Override
        public NotifyHandling getNotify() {
            return NotifyHandling.NONE;
        }
    };
    for (ProjectDeletedListener l : deletedListener) {
        try {
            l.onProjectDeleted(event);
        } catch (RuntimeException e) {
            log.warn("Failure in ProjectDeletedListener", e);
        }
    }
}
#end_block

#method_before
private void recursiveDeleteParent(File file, File until) {
    if (file.equals(until)) {
        return;
    }
    if (file.listFiles().length == 0) {
        File parent = file.getParentFile();
        if (file.delete()) {
            recursiveDeleteParent(parent, until);
        }
    }
}
#method_after
private void recursiveDeleteParent(File file, File until) throws IOException {
    if (file.equals(until)) {
        return;
    }
    if (file.listFiles().length == 0) {
        File parent = file.getParentFile();
        Files.delete(file.toPath());
        recursiveDeleteParent(parent, until);
    }
}
#end_block

#method_before
protected void onInitUI() {
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
    } else {
        labelIdx = 0;
        fieldIdx = 1;
    }
    nameTxt = new NpTextBox();
    nameTxt.setVisibleLength(60);
    nameTxt.setReadOnly(!canEditFullName());
    emailPick = new ListBox();
    final Grid infoPlainText = new Grid(2, 2);
    infoPlainText.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoPlainText.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    body.add(infoPlainText);
    registerNewEmail = new Button(Util.C.buttonOpenRegisterNewEmail());
    registerNewEmail.setEnabled(false);
    registerNewEmail.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doRegisterNewEmail();
        }
    });
    final FlowPanel emailLine = new FlowPanel();
    emailLine.add(emailPick);
    if (canRegisterNewEmail()) {
        emailLine.add(registerNewEmail);
    }
    int row = 0;
    if (!Gerrit.info().auth().canEdit(FieldName.USER_NAME) && Gerrit.info().auth().siteHasUsernames()) {
        infoPlainText.resizeRows(infoPlainText.getRowCount() + 1);
        row(infoPlainText, row++, Util.C.userName(), new UsernameField());
    }
    if (!canEditFullName()) {
        FlowPanel nameLine = new FlowPanel();
        nameLine.add(nameTxt);
        if (Gerrit.info().auth().editFullNameUrl() != null) {
            Button edit = new Button(Util.C.linkEditFullName());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    Window.open(Gerrit.info().auth().editFullNameUrl(), "_blank", null);
                }
            });
            nameLine.add(edit);
        }
        Button reload = new Button(Util.C.linkReloadContact());
        reload.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                Window.Location.replace(Gerrit.loginRedirect(PageLinks.SETTINGS_CONTACT));
            }
        });
        nameLine.add(reload);
        row(infoPlainText, row++, Util.C.contactFieldFullName(), nameLine);
    } else {
        row(infoPlainText, row++, Util.C.contactFieldFullName(), nameTxt);
    }
    row(infoPlainText, row++, Util.C.contactFieldEmail(), emailLine);
    infoPlainText.getCellFormatter().addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    infoPlainText.getCellFormatter().addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    infoPlainText.getCellFormatter().addStyleName(row - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave(null);
        }
    });
    emailPick.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            final int idx = emailPick.getSelectedIndex();
            final String v = 0 <= idx ? emailPick.getValue(idx) : null;
            if (Util.C.buttonOpenRegisterNewEmail().equals(v)) {
                for (int i = 0; i < emailPick.getItemCount(); i++) {
                    if (currentEmail.equals(emailPick.getValue(i))) {
                        emailPick.setSelectedIndex(i);
                        break;
                    }
                }
                doRegisterNewEmail();
            } else {
                save.setEnabled(true);
            }
        }
    });
}
#method_after
protected void onInitUI() {
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
    } else {
        labelIdx = 0;
        fieldIdx = 1;
    }
    nameTxt = new NpTextBox();
    nameTxt.setVisibleLength(60);
    nameTxt.setReadOnly(!canEditFullName());
    emailPick = new ListBox();
    final Grid infoPlainText = new Grid(2, 2);
    infoPlainText.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoPlainText.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    body.add(infoPlainText);
    registerNewEmail = new Button(Util.C.buttonOpenRegisterNewEmail());
    registerNewEmail.setEnabled(false);
    registerNewEmail.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doRegisterNewEmail();
        }
    });
    final FlowPanel emailLine = new FlowPanel();
    emailLine.add(emailPick);
    if (canRegisterNewEmail()) {
        emailLine.add(registerNewEmail);
    }
    int row = 0;
    if (!Gerrit.info().auth().canEdit(FieldName.USER_NAME) && Gerrit.info().auth().siteHasUsernames()) {
        infoPlainText.resizeRows(infoPlainText.getRowCount() + 1);
        row(infoPlainText, row++, Util.C.userName(), new UsernameField());
    }
    if (!canEditFullName()) {
        FlowPanel nameLine = new FlowPanel();
        nameLine.add(nameTxt);
        if (Gerrit.info().auth().editFullNameUrl() != null) {
            Button edit = new Button(Util.C.linkEditFullName());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    Window.open(Gerrit.info().auth().editFullNameUrl(), "_blank", null);
                }
            });
            nameLine.add(edit);
        }
        Button reload = new Button(Util.C.linkReloadContact());
        reload.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                Window.Location.replace(Gerrit.loginRedirect(PageLinks.SETTINGS_CONTACT));
            }
        });
        nameLine.add(reload);
        row(infoPlainText, row++, Util.C.contactFieldFullName(), nameLine);
    } else {
        row(infoPlainText, row++, Util.C.contactFieldFullName(), nameTxt);
    }
    row(infoPlainText, row++, Util.C.contactFieldEmail(), emailLine);
    infoPlainText.getCellFormatter().addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    infoPlainText.getCellFormatter().addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    infoPlainText.getCellFormatter().addStyleName(row - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    emailPick.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            final int idx = emailPick.getSelectedIndex();
            final String v = 0 <= idx ? emailPick.getValue(idx) : null;
            if (Util.C.buttonOpenRegisterNewEmail().equals(v)) {
                for (int i = 0; i < emailPick.getItemCount(); i++) {
                    if (currentEmail.equals(emailPick.getValue(i))) {
                        emailPick.setSelectedIndex(i);
                        break;
                    }
                }
                doRegisterNewEmail();
            } else {
                save.setEnabled(true);
            }
        }
    });
    onEditEnabler = new OnEditEnabler(save, nameTxt);
}
#end_block

#method_before
private void postLoad() {
    if (haveAccount && haveEmails) {
        updateEmailList();
        registerNewEmail.setEnabled(true);
        save.setEnabled(false);
        new OnEditEnabler(save, nameTxt);
    }
    display();
}
#method_after
private void postLoad() {
    if (haveAccount && haveEmails) {
        updateEmailList();
        registerNewEmail.setEnabled(true);
        save.setEnabled(false);
        onEditEnabler.updateOriginalValue(nameTxt);
    }
    display();
}
#end_block

#method_before
protected void display(AccountInfo account) {
    currentEmail = account.email();
    nameTxt.setText(account.name());
    save.setEnabled(false);
    new OnEditEnabler(save, nameTxt);
}
#method_after
protected void display(AccountInfo account) {
    currentEmail = account.email();
    nameTxt.setText(account.name());
    save.setEnabled(false);
    onEditEnabler.updateOriginalValue(nameTxt);
}
#end_block

#method_before
void doSave(final AsyncCallback<Account> onSave) {
    String newName = canEditFullName() ? nameTxt.getText() : null;
    if (newName != null && newName.trim().isEmpty()) {
        newName = null;
    }
    final String newEmail;
    if (emailPick.isEnabled() && emailPick.getSelectedIndex() >= 0) {
        final String v = emailPick.getValue(emailPick.getSelectedIndex());
        if (Util.C.buttonOpenRegisterNewEmail().equals(v)) {
            newEmail = currentEmail;
        } else {
            newEmail = v;
        }
    } else {
        newEmail = currentEmail;
    }
    save.setEnabled(false);
    registerNewEmail.setEnabled(false);
    CallbackGroup group = new CallbackGroup();
    if (!newEmail.equals(currentEmail)) {
        AccountApi.setPreferredEmail("self", newEmail, group.add(new GerritCallback<NativeString>() {

            @Override
            public void onSuccess(NativeString result) {
            }
        }));
    }
    AccountApi.setName("self", newName, group.add(new GerritCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            registerNewEmail.setEnabled(true);
        // TODO update
        }

        @Override
        public void onFailure(Throwable caught) {
            save.setEnabled(true);
            registerNewEmail.setEnabled(true);
            super.onFailure(caught);
        }
    }));
}
#method_after
void doSave() {
    final String newName;
    String name = canEditFullName() ? nameTxt.getText() : null;
    if (name != null && name.trim().isEmpty()) {
        newName = null;
    } else {
        newName = name;
    }
    final String newEmail;
    if (emailPick.isEnabled() && emailPick.getSelectedIndex() >= 0) {
        final String v = emailPick.getValue(emailPick.getSelectedIndex());
        if (Util.C.buttonOpenRegisterNewEmail().equals(v)) {
            newEmail = currentEmail;
        } else {
            newEmail = v;
        }
    } else {
        newEmail = currentEmail;
    }
    save.setEnabled(false);
    registerNewEmail.setEnabled(false);
    CallbackGroup group = new CallbackGroup();
    if (!newEmail.equals(currentEmail)) {
        AccountApi.setPreferredEmail("self", newEmail, group.add(new GerritCallback<NativeString>() {

            @Override
            public void onSuccess(NativeString result) {
            }
        }));
    }
    AccountApi.setName("self", newName, group.add(new GerritCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
        }

        @Override
        public void onFailure(Throwable caught) {
            save.setEnabled(true);
            registerNewEmail.setEnabled(true);
            super.onFailure(caught);
        }
    }));
    group.done();
    group.addListener(new GerritCallback<Void>() {

        @Override
        public void onSuccess(Void result) {
            currentEmail = newEmail;
            AccountInfo me = Gerrit.getUserAccount();
            me.email(currentEmail);
            me.name(newName);
            onSaveSuccess(me);
            registerNewEmail.setEnabled(true);
        }
    });
}
#end_block

#method_before
public static void putEditPreferences(EditPreferences in, AsyncCallback<VoidResult> cb) {
    self().view("preferences.edit").put(in, cb);
}
#method_after
public static void putEditPreferences(EditPreferences in, AsyncCallback<EditPreferences> cb) {
    self().view("preferences.edit").put(in, cb);
}
#end_block

#method_before
public static void suggest(String query, int limit, AsyncCallback<JsArray<AccountInfo>> cb) {
    new RestApi("/accounts/").addParameter("q", query).addParameter("n", limit).background().get(cb);
}
#method_after
public static void suggest(String query, int limit, AsyncCallback<JsArray<AccountInfo>> cb) {
    new RestApi("/accounts/").addParameterTrue("suggest").addParameter("q", query).addParameter("n", limit).background().get(cb);
}
#end_block

#method_before
protected void setupSoyContext() {
    soyContext = new LinkedHashMap<String, Object>();
    soyContext.put("messageClass", messageClass);
    soyContextEmailData = new LinkedHashMap<String, Object>();
    soyContextEmailData.put("settingsUrl", getSettingsUrl());
    soyContextEmailData.put("gerritHost", getGerritHost());
    soyContextEmailData.put("gerritUrl", getGerritUrl());
    soyContext.put("email", soyContextEmailData);
}
#method_after
protected void setupSoyContext() {
    soyContext = new HashMap<>();
    soyContext.put("messageClass", messageClass);
    soyContextEmailData = new HashMap<>();
    soyContextEmailData.put("settingsUrl", getSettingsUrl());
    soyContextEmailData.put("gerritHost", getGerritHost());
    soyContextEmailData.put("gerritUrl", getGerritUrl());
    soyContext.put("email", soyContextEmailData);
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    LinkedHashMap<String, String> changeData = new LinkedHashMap<String, String>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    soyContext.put("change", changeData);
    LinkedHashMap<String, Object> patchSetData = new LinkedHashMap<String, Object>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
// TODO(wyatta): patchSetInfo
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    soyContext.put("change", changeData);
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
// TODO(wyatta): patchSetInfo
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("projectName", branch.getParentKey().get());
    soyContextEmailData.put("sshHost", getSshHost());
    LinkedHashMap<String, String> branchData = new LinkedHashMap<String, String>();
    branchData.put("shortName", branch.getShortName());
    soyContext.put("branch", branchData);
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("projectName", branch.getParentKey().get());
    soyContextEmailData.put("sshHost", getSshHost());
    Map<String, String> branchData = new HashMap<>();
    branchData.put("shortName", branch.getShortName());
    soyContext.put("branch", branchData);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p, QueryOptions opts) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriter.getPossibleStatus(p);
    List<ChangeSubIndex> indexes = new ArrayList<>(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, queryBuilder.toQuery(p), opts, getSort());
}
#method_after
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p, QueryOptions opts) throws QueryParseException {
    Set<Change.Status> statuses = ChangeIndexRewriter.getPossibleStatus(p);
    List<ChangeSubIndex> indexes = new ArrayList<>(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, queryBuilder.toQuery(p), opts, getSort());
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interrupted");
    }
    return new ChangeDataResults(executor.submit(new Callable<List<ChangeData>>() {

        @Override
        public List<ChangeData> call() throws IOException {
            return doRead();
        }
    }));
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interrupted");
    }
    final Set<String> fields = fields(opts);
    return new ChangeDataResults(executor.submit(new Callable<List<Document>>() {

        @Override
        public List<Document> call() throws IOException {
            return doRead(fields);
        }
    }), fields);
}
#end_block

#method_before
private List<ChangeData> doRead() throws IOException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    try {
        int realLimit = opts.start() + opts.limit();
        TopFieldDocs[] hits = new TopFieldDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, realLimit, sort);
        }
        TopDocs docs = TopDocs.merge(sort, realLimit, hits);
        List<ChangeData> result = new ArrayList<>(docs.scoreDocs.length);
        Set<String> fields = fields(opts);
        String idFieldName = LEGACY_ID.getName();
        for (int i = opts.start(); i < docs.scoreDocs.length; i++) {
            ScoreDoc sd = docs.scoreDocs[i];
            Document doc = searchers[sd.shardIndex].doc(sd.doc, fields);
            result.add(toChangeData(fields(doc, fields), fields, idFieldName));
        }
        return result;
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#method_after
private List<Document> doRead(Set<String> fields) throws IOException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    try {
        int realLimit = opts.start() + opts.limit();
        TopFieldDocs[] hits = new TopFieldDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, realLimit, sort);
        }
        TopDocs docs = TopDocs.merge(sort, realLimit, hits);
        List<Document> result = new ArrayList<>(docs.scoreDocs.length);
        for (int i = opts.start(); i < docs.scoreDocs.length; i++) {
            ScoreDoc sd = docs.scoreDocs[i];
            result.add(searchers[sd.shardIndex].doc(sd.doc, fields));
        }
        return result;
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public List<ChangeData> toList() {
    try {
        return future.get();
    } catch (InterruptedException e) {
        close();
        throw new OrmRuntimeException(e);
    } catch (ExecutionException e) {
        Throwables.propagateIfPossible(e.getCause());
        throw new OrmRuntimeException(e.getCause());
    }
}
#method_after
@Override
public List<ChangeData> toList() {
    try {
        List<Document> docs = future.get();
        List<ChangeData> result = new ArrayList<>(docs.size());
        String idFieldName = LEGACY_ID.getName();
        for (Document doc : docs) {
            result.add(toChangeData(fields(doc, fields), fields, idFieldName));
        }
        return result;
    } catch (InterruptedException e) {
        close();
        throw new OrmRuntimeException(e);
    } catch (ExecutionException e) {
        Throwables.propagateIfPossible(e.getCause());
        throw new OrmRuntimeException(e.getCause());
    }
}
#end_block

#method_before
private void decodeChangedLines(Multimap<String, IndexableField> doc, ChangeData cd) {
    IndexableField added = Iterables.getFirst(doc.get(ADDED_FIELD), null);
    IndexableField deleted = Iterables.getFirst(doc.get(DELETED_FIELD), null);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    }
}
#method_after
private void decodeChangedLines(Multimap<String, IndexableField> doc, ChangeData cd) {
    IndexableField added = Iterables.getFirst(doc.get(ADDED_FIELD), null);
    IndexableField deleted = Iterables.getFirst(doc.get(DELETED_FIELD), null);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    } else {
        // No ChangedLines stored, likely due to failure during reindexing, for
        // example due to LargeObjectException. But we know the field was
        // requested, so update ChangeData to prevent callers from trying to
        // lazily load it, as that would probably also fail.
        cd.setNoChangedLines();
    }
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.propagateIfPossible(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    if (notesMigration.readChanges()) {
        allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    } else {
        allUsers.addAll(cd.reviewers().all());
    }
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, tag, date));
        }
    }
}
#method_after
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, tag, date));
        }
    }
}
#end_block

#method_before
void sendMessages() {
    for (CommitValidationMessage m : messages) {
        if (m.isError()) {
            messageSender.sendError(m.getMessage());
        } else {
            messageSender.sendMessage(m.getMessage());
        }
    }
}
#method_after
void sendMessages() {
    for (ValidationMessage m : messages) {
        if (m.isError()) {
            messageSender.sendError(m.getMessage());
        } else {
            messageSender.sendMessage(m.getMessage());
        }
    }
}
#end_block

#method_before
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    logDebug("Executing batch with {} commands", batch.getCommands().size());
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                logDebug("Allowing non-fast-forward for edit ref");
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            logError(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                logDebug("Updating tag cache on fast-forward of {}", c.getRefName());
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                logDebug("Reloading project in cache");
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                logDebug("Firing ref update for {}", c.getRefName());
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            } else {
                logDebug("Assuming ref update event for {} has fired", c.getRefName());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        logError("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    log.warn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), c.change.getStatus() == Change.Status.DRAFT, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, u.replaceOp != null && u.replaceOp.getPatchSet().isDraft(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean draft, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (draft) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            checkState(NEW_PATCHSET.matcher(replace.inputCommand.getRefName()).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), replace.inputCommand.getRefName());
            try {
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            log.error("Error submit changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            String refName = replace.inputCommand.getRefName();
            checkState(NEW_PATCHSET.matcher(refName).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), refName);
            try {
                logDebug("One-off insertion of patch set for {}", refName);
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                logError(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            logError(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    // No need to continue.
    if (magicBranch == null) {
        logDebug("No magic branch, nothing more to do");
        return;
    } else if (magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranch.cmd.getResult(), Strings.nullToEmpty(magicBranch.cmd.getMessage())));
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            logError(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    logDebug("Counted {} ok to insert, out of {} to replace and {} new", okToInsert, replaceCount, newChanges.size());
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        logError(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#end_block

#method_before
private void parseDelete(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    logDebug("Deleting {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
String parse(CmdLineParser clp, Repository repo, Set<String> refs) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        clp.parseOptionMap(options);
        ref = ref.substring(0, optionStart);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#method_after
String parse(CmdLineParser clp, Repository repo, Set<String> refs, ListMultimap<String, String> pushOptions) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    ListMultimap<String, String> options = LinkedListMultimap.create(pushOptions);
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        ref = ref.substring(0, optionStart);
    }
    if (!options.isEmpty()) {
        clp.parseOptionMap(options);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String pushOption : pushOptions) {
            int e = pushOption.indexOf('=');
            if (0 < e) {
                options.put(pushOption.substring(0, e), pushOption.substring(e + 1));
            } else {
                options.put(pushOption, "");
            }
        }
        clp.parseOptionMap(options);
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        logDebug("Forcing newChangeForAllNotInTarget = false");
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        logDebug("Handling %base: {}", magicBranch.base);
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        logDebug("Handling newChangeForAllNotInTarget");
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        } catch (IOException ex) {
            logWarn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    logDebug("Parsing replace command");
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
        logDebug("Replacing with {}", newCommit);
    } catch (IOException e) {
        logError("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        logError("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        logError("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    logDebug("Replacing change {}", changeEnt.getId());
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            logDebug("Marking {} base commits uninteresting", magicBranch.baseCommit.size());
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                logDebug("Marking target ref {} ({}) uninteresting", magicBranch.ctl.getRefName(), targetRef.getObjectId().name());
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, Lists.transform(changes, new Function<ChangeData, String>() {

                    @Override
                    public String apply(ChangeData in) {
                        return in.getId().toString();
                    }
                }));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    int i = 0;
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
                i++;
            } catch (IOException e) {
                logWarn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
    logDebug("Marked {} heads as uninteresting", i);
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            if (req.prev != null) {
                batch.addCommand(req.prev);
            }
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        logError(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        logError(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    logDebug("Read {} changes to replace", replaceByChange.size());
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            if (req.prev != null) {
                batch.addCommand(req.prev);
            }
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
private boolean newEdit() {
    psId = notes.getChange().currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = notes.getChange().currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        logError("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
void insertPatchSetWithoutBatchUpdate() throws IOException, UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins);
        addOps(bu, replaceProgress);
        bu.execute();
    }
}
#method_after
void insertPatchSetWithoutBatchUpdate() throws IOException, UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins);
        bu.setRequestId(receiveId);
        addOps(bu, replaceProgress);
        bu.execute();
    }
}
#end_block

#method_before
static boolean parentsEqual(RevCommit a, RevCommit b) {
    if (a.getParentCount() != b.getParentCount()) {
        return false;
    }
    for (int i = 0; i < a.getParentCount(); i++) {
        if (a.getParent(i) != b.getParent(i)) {
            return false;
        }
    }
    return true;
}
#method_after
static boolean parentsEqual(RevCommit a, RevCommit b) {
    if (a.getParentCount() != b.getParentCount()) {
        return false;
    }
    for (int i = 0; i < a.getParentCount(); i++) {
        if (!a.getParent(i).equals(b.getParent(i))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        logDebug("Short-circuiting new commit validation");
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        bu.execute();
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with" + " new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInResolver.Result d = IncludedInResolver.resolve(r, rw, rev);
        Map<String, Collection<String>> external = new HashMap<>();
        for (ExternalIncludedIn ext : includedIn) {
            Multimap<String, String> m = ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches());
            for (Map.Entry<String, Collection<String>> e : m.asMap().entrySet()) {
                external.put(e.getKey(), e.getValue());
            }
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external : null));
    }
}
#method_after
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInResolver.Result d = IncludedInResolver.resolve(r, rw, rev);
        Multimap<String, String> external = ArrayListMultimap.create();
        for (ExternalIncludedIn ext : includedIn) {
            external.putAll(ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches()));
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external.asMap() : null));
    }
}
#end_block

#method_before
public Change abandon(ChangeControl control, String msgTxt, NotifyHandling notifyHandling) throws RestApiException, UpdateException {
    Op op = new Op(control, msgTxt, notifyHandling);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), op.getProject(), op.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return op.change;
}
#method_after
public Change abandon(ChangeControl control) throws RestApiException, UpdateException {
    return abandon(control, "", NotifyHandling.ALL);
}
#end_block

#method_before
public Change abandon(ChangeControl control, String msgTxt, NotifyHandling notifyHandling) throws RestApiException, UpdateException {
    Op op = new Op(control, msgTxt, notifyHandling);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), op.getProject(), op.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return op.change;
}
#method_after
public Change abandon(ChangeControl control, String msgTxt, NotifyHandling notifyHandling) throws RestApiException, UpdateException {
    Op op = new Op(control, msgTxt, notifyHandling);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return op.change;
}
#end_block

#method_before
@Override
protected LargeFileRepository getLargeFileRepository(LfsRequest request, String path) throws LfsException {
    String pathInfo = path.startsWith("/") ? path : "/" + path;
    Matcher matcher = URL_PATTERN.matcher(pathInfo);
    if (!matcher.matches()) {
        return null;
    }
    Project.NameKey project = Project.NameKey.parse(ProjectUtil.stripGitSuffix(matcher.group(1)));
    ProjectState state = projectCache.get(project);
    if (state == null || state.getProject().getState() == HIDDEN) {
        throw new LfsRepositoryNotFound(project.get());
    }
    if (request.getOperation().equals("upload") && state.getProject().getState() == READ_ONLY) {
        throw new LfsRepositoryReadOnly(project.get());
    }
    Config config = pluginConfigFactory.getProjectPluginConfigWithInheritance(state, pluginName);
    // Only accept requests for projects where LFS is enabled
    if (!config.getBoolean("lfs", "enabled", false)) {
        return null;
    }
    if (request.getOperation().equals("upload")) {
        // Check object sizes against limit, if configured
        long maxObjectSize = config.getLong("lfs", "maxObjectSize", 0);
        if (maxObjectSize > 0) {
            for (LfsObject object : request.getObjects()) {
                if (object.getSize() > maxObjectSize) {
                    throw new LfsValidationError("size of object " + object.getOid() + " exceeds limit");
                }
            }
        }
    }
    return getRepository();
}
#method_after
@Override
protected LargeFileRepository getLargeFileRepository(LfsRequest request, String path) throws LfsException {
    String pathInfo = path.startsWith("/") ? path : "/" + path;
    Matcher matcher = URL_PATTERN.matcher(pathInfo);
    if (!matcher.matches()) {
        return null;
    }
    Project.NameKey project = Project.NameKey.parse(ProjectUtil.stripGitSuffix(matcher.group(1)));
    ProjectState state = projectCache.get(project);
    if (state == null || state.getProject().getState() == HIDDEN) {
        throw new LfsRepositoryNotFound(project.get());
    }
    if (request.getOperation().equals("upload") && state.getProject().getState() == READ_ONLY) {
        throw new LfsRepositoryReadOnly(project.get());
    }
    Config config = pluginConfigFactory.getProjectPluginConfigWithInheritance(state, pluginName);
    // Only accept requests for projects where LFS is enabled
    if (!config.getBoolean("lfs", "enabled", false)) {
        return null;
    }
    if (request.getOperation().equals("upload")) {
        // Check object sizes against limit, if configured
        long maxObjectSize = config.getLong("lfs", "maxObjectSize", 0);
        if (maxObjectSize > 0) {
            for (LfsObject object : request.getObjects()) {
                if (object.getSize() > maxObjectSize) {
                    throw new LfsValidationError(String.format("size of object %s (%d bytes) exceeds limit (%d bytes)", object.getOid(), object.getSize(), maxObjectSize));
                }
            }
        }
    }
    return getRepository();
}
#end_block

#method_before
@Override
public synchronized void start() {
    if (daemonAcceptor == null && !listen.isEmpty()) {
        checkConfig();
        if (sessionFactory == null) {
            sessionFactory = createSessionFactory();
        }
        sessionFactory.setServer(this);
        daemonAcceptor = createAcceptor();
        try {
            String listenAddress = cfg.getString("sshd", null, "listenAddress");
            boolean rewrite = !Strings.isNullOrEmpty(listenAddress) && listenAddress.endsWith(":0");
            daemonAcceptor.bind(listen);
            if (rewrite) {
                SocketAddress bound = Iterables.getOnlyElement(daemonAcceptor.getBoundAddresses());
                cfg.setString("sshd", null, "listenAddress", format((InetSocketAddress) bound));
            }
        } catch (IOException e) {
            throw new IllegalStateException("Cannot bind to " + addressList(), e);
        }
        log.info(String.format("Started Gerrit %s on %s", version, addressList()));
    }
}
#method_after
@Override
public synchronized void start() {
    if (daemonAcceptor == null && !listen.isEmpty()) {
        checkConfig();
        if (getSessionFactory() == null) {
            setSessionFactory(createSessionFactory());
        }
        daemonAcceptor = createAcceptor();
        try {
            String listenAddress = cfg.getString("sshd", null, "listenAddress");
            boolean rewrite = !Strings.isNullOrEmpty(listenAddress) && listenAddress.endsWith(":0");
            daemonAcceptor.bind(listen);
            if (rewrite) {
                SocketAddress bound = Iterables.getOnlyElement(daemonAcceptor.getBoundAddresses());
                cfg.setString("sshd", null, "listenAddress", format((InetSocketAddress) bound));
            }
        } catch (IOException e) {
            throw new IllegalStateException("Cannot bind to " + addressList(), e);
        }
        sshDaemonLog.info(String.format("Started Gerrit %s on %s", getVersion(), addressList()));
    }
}
#end_block

#method_before
@Override
public synchronized void stop() {
    if (daemonAcceptor != null) {
        try {
            daemonAcceptor.close(true).await();
            log.info("Stopped Gerrit SSHD");
        } catch (InterruptedException e) {
            log.warn("Exception caught while closing", e);
        } finally {
            daemonAcceptor = null;
        }
    }
}
#method_after
@Override
public synchronized void stop() {
    if (daemonAcceptor != null) {
        try {
            daemonAcceptor.close(true).await();
            sshDaemonLog.info("Stopped Gerrit SSHD");
        } catch (IOException e) {
            sshDaemonLog.warn("Exception caught while closing", e);
        } finally {
            daemonAcceptor = null;
        }
    }
}
#end_block

#method_before
private List<HostKey> computeHostKeys() {
    if (listen.isEmpty()) {
        return Collections.emptyList();
    }
    final List<PublicKey> keys = myHostKeys();
    final List<HostKey> r = new ArrayList<>();
    for (final PublicKey pub : keys) {
        final Buffer buf = new Buffer();
        buf.putRawPublicKey(pub);
        final byte[] keyBin = buf.getCompactData();
        for (final String addr : advertised) {
            try {
                r.add(new HostKey(addr, keyBin));
            } catch (JSchException e) {
                log.warn("Cannot format SSHD host key", e);
            }
        }
    }
    return Collections.unmodifiableList(r);
}
#method_after
private List<HostKey> computeHostKeys() {
    if (listen.isEmpty()) {
        return Collections.emptyList();
    }
    final List<PublicKey> keys = myHostKeys();
    final List<HostKey> r = new ArrayList<>();
    for (final PublicKey pub : keys) {
        final Buffer buf = new ByteArrayBuffer();
        buf.putRawPublicKey(pub);
        final byte[] keyBin = buf.getCompactData();
        for (final String addr : advertised) {
            try {
                r.add(new HostKey(addr, keyBin));
            } catch (JSchException e) {
                sshDaemonLog.warn("Cannot format SSHD host key", e);
            }
        }
    }
    return Collections.unmodifiableList(r);
}
#end_block

#method_before
private void initProviderBouncyCastle(Config cfg) {
    setKeyExchangeFactories(filter(cfg, "kex", new DHG14.Factory(), new DHG1.Factory(), new DHGEX.Factory(), new DHGEX256.Factory(), new ECDHP256.Factory(), new ECDHP384.Factory(), new ECDHP521.Factory()));
    NamedFactory<Random> factory;
    if (cfg.getBoolean("sshd", null, "testUseInsecureRandom", false)) {
        factory = new InsecureBouncyCastleRandom.Factory();
    } else {
        factory = new BouncyCastleRandom.Factory();
    }
    setRandomFactory(new SingletonRandomFactory(factory));
}
#method_after
private void initProviderBouncyCastle(Config cfg) {
    NamedFactory<Random> factory;
    if (cfg.getBoolean("sshd", null, "testUseInsecureRandom", false)) {
        factory = new InsecureBouncyCastleRandom.Factory();
    } else {
        factory = SecurityUtils.getRandomFactory();
    }
    setRandomFactory(new SingletonRandomFactory(factory));
}
#end_block

#method_before
@Override
public void fill(byte[] bytes, int start, int len) {
    random.nextBytes(bytes, start, len);
}
#method_after
@Override
public void fill(byte[] bytes) {
    random.nextBytes(bytes);
}
#end_block

#method_before
private void initProviderJce() {
    setKeyExchangeFactories(Arrays.<NamedFactory<KeyExchange>>asList(new DHG1.Factory()));
    setRandomFactory(new SingletonRandomFactory(new JceRandom.Factory()));
}
#method_after
private void initProviderJce() {
    setRandomFactory(new SingletonRandomFactory(JceRandomFactory.INSTANCE));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void initCiphers(final Config cfg) {
    final List<NamedFactory<Cipher>> a = new LinkedList<>();
    a.add(new AES128CBC.Factory());
    a.add(new TripleDESCBC.Factory());
    a.add(new BlowfishCBC.Factory());
    a.add(new AES192CBC.Factory());
    a.add(new AES256CBC.Factory());
    a.add(new AES128CTR.Factory());
    a.add(new AES256CTR.Factory());
    a.add(new ARCFOUR256.Factory());
    a.add(new ARCFOUR128.Factory());
    for (Iterator<NamedFactory<Cipher>> i = a.iterator(); i.hasNext(); ) {
        final NamedFactory<Cipher> f = i.next();
        try {
            final Cipher c = f.create();
            final byte[] key = new byte[c.getBlockSize()];
            final byte[] iv = new byte[c.getIVSize()];
            c.init(Cipher.Mode.Encrypt, key, iv);
        } catch (InvalidKeyException e) {
            log.warn("Disabling cipher " + f.getName() + ": " + e.getMessage() + "; try installing unlimited cryptography extension");
            i.remove();
        } catch (Exception e) {
            log.warn("Disabling cipher " + f.getName() + ": " + e.getMessage());
            i.remove();
        }
    }
    a.add(null);
    a.add(new CipherNone.Factory());
    setCipherFactories(filter(cfg, "cipher", (NamedFactory<Cipher>[]) a.toArray(new NamedFactory[a.size()])));
}
#method_after
@SuppressWarnings("unchecked")
private void initCiphers(final Config cfg) {
    final List<NamedFactory<Cipher>> a = BaseBuilder.setUpDefaultCiphers(true);
    for (Iterator<NamedFactory<Cipher>> i = a.iterator(); i.hasNext(); ) {
        final NamedFactory<Cipher> f = i.next();
        try {
            final Cipher c = f.create();
            final byte[] key = new byte[c.getBlockSize()];
            final byte[] iv = new byte[c.getIVSize()];
            c.init(Cipher.Mode.Encrypt, key, iv);
        } catch (InvalidKeyException e) {
            sshDaemonLog.warn("Disabling cipher " + f.getName() + ": " + e.getMessage() + "; try installing unlimited cryptography extension");
            i.remove();
        } catch (Exception e) {
            sshDaemonLog.warn("Disabling cipher " + f.getName() + ": " + e.getMessage());
            i.remove();
        }
    }
    a.add(null);
    setCipherFactories(filter(cfg, "cipher", (NamedFactory<Cipher>[]) a.toArray(new NamedFactory[a.size()])));
}
#end_block

#method_before
private void initMacs(final Config cfg) {
    setMacFactories(filter(cfg, "mac", new HMACMD5.Factory(), new HMACSHA1.Factory(), new HMACMD596.Factory(), new HMACSHA196.Factory()));
}
#method_after
@SuppressWarnings("unchecked")
private void initMacs(Config cfg) {
    List<NamedFactory<Mac>> m = BaseBuilder.setUpDefaultMacs(true);
    setMacFactories(filter(cfg, "mac", (NamedFactory<Mac>[]) m.toArray(new NamedFactory[m.size()])));
}
#end_block

#method_before
@SafeVarargs
private static <T> List<NamedFactory<T>> filter(final Config cfg, final String key, final NamedFactory<T>... avail) {
    final ArrayList<NamedFactory<T>> def = new ArrayList<>();
    for (final NamedFactory<T> n : avail) {
        if (n == null) {
            break;
        }
        def.add(n);
    }
    final String[] want = cfg.getStringList("sshd", null, key);
    if (want == null || want.length == 0) {
        return def;
    }
    boolean didClear = false;
    for (final String setting : want) {
        String name = setting.trim();
        boolean add = true;
        if (name.startsWith("-")) {
            add = false;
            name = name.substring(1).trim();
        } else if (name.startsWith("+")) {
            name = name.substring(1).trim();
        } else if (!didClear) {
            didClear = true;
            def.clear();
        }
        final NamedFactory<T> n = find(name, avail);
        if (n == null) {
            final StringBuilder msg = new StringBuilder();
            msg.append("sshd.").append(key).append(" = ").append(name).append(" unsupported; only ");
            for (int i = 0; i < avail.length; i++) {
                if (avail[i] == null) {
                    continue;
                }
                if (i > 0) {
                    msg.append(", ");
                }
                msg.append(avail[i].getName());
            }
            msg.append(" is supported");
            log.error(msg.toString());
        } else if (add) {
            if (!def.contains(n)) {
                def.add(n);
            }
        } else {
            def.remove(n);
        }
    }
    return def;
}
#method_after
@SafeVarargs
private static <T> List<NamedFactory<T>> filter(final Config cfg, final String key, final NamedFactory<T>... avail) {
    final ArrayList<NamedFactory<T>> def = new ArrayList<>();
    for (final NamedFactory<T> n : avail) {
        if (n == null) {
            break;
        }
        def.add(n);
    }
    final String[] want = cfg.getStringList("sshd", null, key);
    if (want == null || want.length == 0) {
        return def;
    }
    boolean didClear = false;
    for (final String setting : want) {
        String name = setting.trim();
        boolean add = true;
        if (name.startsWith("-")) {
            add = false;
            name = name.substring(1).trim();
        } else if (name.startsWith("+")) {
            name = name.substring(1).trim();
        } else if (!didClear) {
            didClear = true;
            def.clear();
        }
        final NamedFactory<T> n = find(name, avail);
        if (n == null) {
            final StringBuilder msg = new StringBuilder();
            msg.append("sshd.").append(key).append(" = ").append(name).append(" unsupported; only ");
            for (int i = 0; i < avail.length; i++) {
                if (avail[i] == null) {
                    continue;
                }
                if (i > 0) {
                    msg.append(", ");
                }
                msg.append(avail[i].getName());
            }
            msg.append(" is supported");
            sshDaemonLog.error(msg.toString());
        } else if (add) {
            if (!def.contains(n)) {
                def.add(n);
            }
        } else {
            def.remove(n);
        }
    }
    return def;
}
#end_block

#method_before
private void initSignatures() {
    setSignatureFactories(Arrays.<NamedFactory<Signature>>asList(new SignatureDSA.Factory(), new SignatureRSA.Factory(), new SignatureECDSA.NISTP256Factory(), new SignatureECDSA.NISTP384Factory(), new SignatureECDSA.NISTP521Factory()));
}
#method_after
private void initSignatures() {
    setSignatureFactories(BaseBuilder.setUpDefaultSignatures(true));
}
#end_block

#method_before
private void initCompression(boolean enableCompression) {
    List<NamedFactory<Compression>> compressionFactories = Lists.newArrayList();
    // Always support no compression over SSHD.
    compressionFactories.add(new CompressionNone.Factory());
    if (enableCompression) {
        compressionFactories.add(new CompressionZlib.Factory());
    }
    setCompressionFactories(compressionFactories);
}
#method_after
private void initCompression(boolean enableCompression) {
    List<NamedFactory<Compression>> compressionFactories = new ArrayList<>();
    // Always support no compression over SSHD.
    compressionFactories.add(BuiltinCompressions.none);
    if (enableCompression) {
        compressionFactories.add(BuiltinCompressions.zlib);
    }
    setCompressionFactories(compressionFactories);
}
#end_block

#method_before
private void initChannels() {
    setChannelFactories(Arrays.<NamedFactory<Channel>>asList(// 
    new ChannelSession.Factory(), // 
    new TcpipServerChannel.DirectTcpipFactory()));
}
#method_after
private void initChannels() {
    setChannelFactories(ServerBuilder.DEFAULT_CHANNEL_FACTORIES);
}
#end_block

#method_before
private void initUserAuth(final PublickeyAuthenticator pubkey, final GSSAuthenticator kerberosAuthenticator, String kerberosKeytab, String kerberosPrincipal) {
    List<NamedFactory<UserAuth>> authFactories = Lists.newArrayList();
    if (kerberosKeytab != null) {
        authFactories.add(new UserAuthGSS.Factory());
        log.info("Enabling kerberos with keytab " + kerberosKeytab);
        if (!new File(kerberosKeytab).canRead()) {
            log.error("Keytab " + kerberosKeytab + " does not exist or is not readable; further errors are possible");
        }
        kerberosAuthenticator.setKeytabFile(kerberosKeytab);
        if (kerberosPrincipal == null) {
            try {
                kerberosPrincipal = "host/" + InetAddress.getLocalHost().getCanonicalHostName();
            } catch (UnknownHostException e) {
                kerberosPrincipal = "host/localhost";
            }
        }
        log.info("Using kerberos principal " + kerberosPrincipal);
        if (!kerberosPrincipal.startsWith("host/")) {
            log.warn("Host principal does not start with host/ " + "which most SSH clients will supply automatically");
        }
        kerberosAuthenticator.setServicePrincipalName(kerberosPrincipal);
        setGSSAuthenticator(kerberosAuthenticator);
    }
    authFactories.add(new UserAuthPublicKey.Factory());
    setUserAuthFactories(authFactories);
    setPublickeyAuthenticator(pubkey);
}
#method_after
private void initUserAuth(final PublickeyAuthenticator pubkey, final GSSAuthenticator kerberosAuthenticator, String kerberosKeytab, String kerberosPrincipal) {
    List<NamedFactory<UserAuth>> authFactories = new ArrayList<>();
    if (kerberosKeytab != null) {
        authFactories.add(UserAuthGSSFactory.INSTANCE);
        log.info("Enabling kerberos with keytab " + kerberosKeytab);
        if (!new File(kerberosKeytab).canRead()) {
            sshDaemonLog.error("Keytab " + kerberosKeytab + " does not exist or is not readable; further errors are possible");
        }
        kerberosAuthenticator.setKeytabFile(kerberosKeytab);
        if (kerberosPrincipal == null) {
            try {
                kerberosPrincipal = "host/" + InetAddress.getLocalHost().getCanonicalHostName();
            } catch (UnknownHostException e) {
                kerberosPrincipal = "host/localhost";
            }
        }
        sshDaemonLog.info("Using kerberos principal " + kerberosPrincipal);
        if (!kerberosPrincipal.startsWith("host/")) {
            sshDaemonLog.warn("Host principal does not start with host/ " + "which most SSH clients will supply automatically");
        }
        kerberosAuthenticator.setServicePrincipalName(kerberosPrincipal);
        setGSSAuthenticator(kerberosAuthenticator);
    }
    authFactories.add(UserAuthPublicKeyFactory.INSTANCE);
    setUserAuthFactories(authFactories);
    setPublickeyAuthenticator(pubkey);
}
#end_block

#method_before
private void initForwarding() {
    setTcpipForwardingFilter(new ForwardingFilter() {

        @Override
        public boolean canForwardAgent(Session session) {
            return false;
        }

        @Override
        public boolean canForwardX11(Session session) {
            return false;
        }

        @Override
        public boolean canListen(SshdSocketAddress address, Session session) {
            return false;
        }

        @Override
        public boolean canConnect(SshdSocketAddress address, Session session) {
            return false;
        }
    });
    setTcpipForwarderFactory(new DefaultTcpipForwarderFactory());
}
#method_after
private void initForwarding() {
    setTcpipForwardingFilter(new ForwardingFilter() {

        @Override
        public boolean canForwardAgent(Session session) {
            return false;
        }

        @Override
        public boolean canForwardX11(Session session) {
            return false;
        }

        @Override
        public boolean canListen(SshdSocketAddress address, Session session) {
            return false;
        }

        @Override
        public boolean canConnect(Type type, SshdSocketAddress address, Session session) {
            return false;
        }
    });
    setTcpipForwarderFactory(new DefaultTcpipForwarderFactory());
}
#end_block

#method_before
private void initFileSystemFactory() {
    setFileSystemFactory(new FileSystemFactory() {

        @Override
        public FileSystemView createFileSystemView(Session session) throws IOException {
            return new FileSystemView() {

                @Override
                public SshFile getFile(SshFile baseDir, String file) {
                    return null;
                }

                @Override
                public SshFile getFile(String file) {
                    return null;
                }

                @Override
                public FileSystemView getNormalizedView() {
                    return this;
                }
            };
        }
    });
}
#method_after
private void initFileSystemFactory() {
    setFileSystemFactory(new FileSystemFactory() {

        @Override
        public FileSystem createFileSystem(Session session) throws IOException {
            return new FileSystem() {

                @Override
                public void close() throws IOException {
                }

                @Override
                public Iterable<FileStore> getFileStores() {
                    return null;
                }

                @Override
                public Path getPath(String arg0, String... arg1) {
                    return null;
                }

                @Override
                public PathMatcher getPathMatcher(String arg0) {
                    return null;
                }

                @Override
                public Iterable<Path> getRootDirectories() {
                    return null;
                }

                @Override
                public String getSeparator() {
                    return null;
                }

                @Override
                public UserPrincipalLookupService getUserPrincipalLookupService() {
                    return null;
                }

                @Override
                public boolean isOpen() {
                    return false;
                }

                @Override
                public boolean isReadOnly() {
                    return false;
                }

                @Override
                public WatchService newWatchService() throws IOException {
                    return null;
                }

                @Override
                public FileSystemProvider provider() {
                    return null;
                }

                @Override
                public Set<String> supportedFileAttributeViews() {
                    return null;
                }
            };
        }
    });
}
#end_block

#method_before
protected void setApiHeaders(HttpServletRequest req, HttpServletResponse res, String contentType) throws IOException {
    if (!Strings.isNullOrEmpty(contentType)) {
        res.setContentType(contentType);
    }
    res.setCharacterEncoding(UTF_8.name());
    res.setHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment");
    GitilesAccess access = getAccess(req);
    String[] allowOrigin = access.getConfig().getStringList("gitiles", null, "allowOriginRegex");
    if (allowOrigin.length > 0) {
        String origin = req.getHeader(HttpHeaders.ORIGIN);
        Pattern allowOriginPattern = Pattern.compile(Joiner.on("|").skipNulls().join(allowOrigin));
        if (!(origin == null || origin.isEmpty()) && allowOriginPattern.matcher(origin).matches()) {
            res.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, origin);
        }
    } else {
        res.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, "*");
    }
    setCacheHeaders(res);
}
#method_after
protected void setApiHeaders(HttpServletRequest req, HttpServletResponse res, String contentType) throws IOException {
    if (!Strings.isNullOrEmpty(contentType)) {
        res.setContentType(contentType);
    }
    res.setCharacterEncoding(UTF_8.name());
    res.setHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment");
    GitilesAccess access = getAccess(req);
    String[] allowOrigin = access.getConfig().getStringList("gitiles", null, "allowOriginRegex");
    if (allowOrigin.length > 0) {
        String origin = req.getHeader(HttpHeaders.ORIGIN);
        Pattern allowOriginPattern = Pattern.compile(Joiner.on("|").join(allowOrigin));
        if (!Strings.isNullOrEmpty(origin) && allowOriginPattern.matcher(origin).matches()) {
            res.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, origin);
        }
    } else {
        res.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, "*");
    }
    setCacheHeaders(res);
}
#end_block

#method_before
protected FakeHttpServletResponse buildResponse(String path, String queryString, int expectedStatus) throws Exception {
    FakeHttpServletRequest req = FakeHttpServletRequest.newRequest();
    req.setHeader(HttpHeaders.ORIGIN, "http://localhost");
    req.setPathInfo(path);
    if (queryString != null) {
        req.setQueryString(queryString);
    }
    FakeHttpServletResponse res = new FakeHttpServletResponse();
    servlet.service(req, res);
    assertThat(res.getStatus()).isEqualTo(expectedStatus);
    return res;
}
#method_after
protected FakeHttpServletResponse buildResponse(String path, String queryString, int expectedStatus, String origin) throws Exception {
    FakeHttpServletRequest req = FakeHttpServletRequest.newRequest();
    req.setHeader(HttpHeaders.ORIGIN, origin);
    req.setPathInfo(path);
    if (queryString != null) {
        req.setQueryString(queryString);
    }
    FakeHttpServletResponse res = new FakeHttpServletResponse();
    servlet.service(req, res);
    assertThat(res.getStatus()).isEqualTo(expectedStatus);
    return res;
}
#end_block

#method_before
protected FakeHttpServletResponse buildResponse(String path, String queryString, int expectedStatus) throws Exception {
    FakeHttpServletRequest req = FakeHttpServletRequest.newRequest();
    req.setHeader(HttpHeaders.ORIGIN, "http://localhost");
    req.setPathInfo(path);
    if (queryString != null) {
        req.setQueryString(queryString);
    }
    FakeHttpServletResponse res = new FakeHttpServletResponse();
    servlet.service(req, res);
    assertThat(res.getStatus()).isEqualTo(expectedStatus);
    return res;
}
#method_after
protected FakeHttpServletResponse buildResponse(String path, String queryString, int expectedStatus) throws Exception {
    return buildResponse(path, queryString, expectedStatus, "http://localhost");
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).toProvider(SoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    AccountApi.getAgreements("self", new GerritCallback<JsArray<AgreementInfo>>() {

        @Override
        public void onSuccess(JsArray<AgreementInfo> result) {
            agreements.display(Natives.asList(result));
        }
    });
    display();
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    AccountApi.getAgreements("self", new ScreenLoadCallback<JsArray<AgreementInfo>>(this) {

        @Override
        public void preDisplay(JsArray<AgreementInfo> result) {
            agreements.display(Natives.asList(result));
        }
    });
}
#end_block

#method_before
void addOne(AgreementInfo info) {
    int row = table.getRowCount();
    table.insertRow(row);
    applyDataRowStyle(row);
    String url = info.url();
    if (url != null && url.length() > 0) {
        Anchor a = new Anchor(info.name(), url);
        a.setTarget("_blank");
        table.setWidget(row, 1, a);
    } else {
        table.setText(row, 1, info.name());
    }
    table.setText(row, 2, info.description());
    FlexCellFormatter fmt = table.getFlexCellFormatter();
    for (int c = 1; c < 2; c++) {
        fmt.addStyleName(row, c, Gerrit.RESOURCES.css().dataCell());
    }
}
#method_after
void addOne(AgreementInfo info) {
    int row = table.getRowCount();
    table.insertRow(row);
    applyDataRowStyle(row);
    String url = info.url();
    if (url != null && url.length() > 0) {
        Anchor a = new Anchor(info.name(), url);
        a.setTarget("_blank");
        table.setWidget(row, 1, a);
    } else {
        table.setText(row, 1, info.name());
    }
    table.setText(row, 2, info.description());
    FlexCellFormatter fmt = table.getFlexCellFormatter();
    for (int c = 1; c < 3; c++) {
        fmt.addStyleName(row, c, Gerrit.RESOURCES.css().dataCell());
    }
}
#end_block

#method_before
public static void suggest(String query, int limit, AsyncCallback<JsArray<AccountInfo>> cb) {
    new RestApi("/accounts/").addParameter("q", query).addParameter("n", limit).background().get(cb);
}
#method_after
public static void suggest(String query, int limit, AsyncCallback<JsArray<AccountInfo>> cb) {
    new RestApi("/accounts/").addParameterTrue("suggest").addParameter("q", query).addParameter("n", limit).background().get(cb);
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            Optional<String> notValid = validateRefCreation(rsrc, u);
            if (notValid.isPresent()) {
                throw new ResourceConflictException(notValid.get());
            }
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            return new BranchInfo(ref, revid.getName(), refControl.canDelete());
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, BranchInput input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new BranchInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(db.get(), repo, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            refCreationValidator.validateRefOperation(rsrc.getName(), identifiedUser.get(), u);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = RefUtil.getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = RefUtil.getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (RefUtil.InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#end_block

#method_before
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (dbProvider.get().changes().byBranchOpenAll(rsrc.getBranchKey()).iterator().hasNext()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    Repository r = repoManager.openRepository(rsrc.getNameKey());
    try {
        RefUpdate.Result result;
        RefUpdate u;
        try {
            u = r.updateRef(rsrc.getRef());
            u.setForceUpdate(true);
            Optional<String> notValid = validateRefDeletion(rsrc, u);
            if (notValid.isPresent()) {
                throw new ResourceConflictException(notValid.get());
            }
            result = u.delete();
        } catch (IOException e) {
            log.error("Cannot delete " + rsrc.getBranchKey(), e);
            throw e;
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u);
                hooks.doRefUpdatedHook(rsrc.getBranchKey(), u, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.warn("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    } finally {
        r.close();
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        refDeletionValidator.validateRefOperation(rsrc.getName(), identifiedUser.get(), u);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case RENAMED:
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#end_block

#method_before
public void setMessageSender(final MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#method_after
public void setMessageSender(MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            try {
                switch(c.getType()) {
                    case CREATE:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case // otherwise known as a fast-forward
                    UPDATE:
                        tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case UPDATE_NONFASTFORWARD:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case DELETE:
                        break;
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only fire gitRefUpdated for direct refs updates.
                    // Events for change refs are fired when they are created.
                    // 
                    gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            } catch (NoSuchChangeException e) {
                c.setResult(REJECTED_OTHER_REASON, "No such change: " + e.getMessage());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    logDebug("Executing batch with {} commands", batch.getCommands().size());
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                logDebug("Allowing non-fast-forward for edit ref");
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            logError(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                logDebug("Updating tag cache on fast-forward of {}", c.getRefName());
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                logDebug("Reloading project in cache");
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                logDebug("Firing ref update for {}", c.getRefName());
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            } else {
                logDebug("Assuming ref update event for {} has fired", c.getRefName());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        logError("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), c.change.getStatus() == Change.Status.DRAFT, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, u.replaceOp != null && u.replaceOp.getPatchSet().isDraft(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(change.getSubject()));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean draft, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (draft) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            } catch (InsertException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, InsertException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, InsertException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (InsertException err) {
        log.error("Can't insert change/patchset for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            String refName = replace.inputCommand.getRefName();
            checkState(NEW_PATCHSET.matcher(refName).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), refName);
            try {
                logDebug("One-off insertion of patch set for {}", refName);
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                logError(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            logError(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    // No need to continue.
    if (magicBranch == null) {
        logDebug("No magic branch, nothing more to do");
        return;
    } else if (magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranch.cmd.getResult(), Strings.nullToEmpty(magicBranch.cmd.getMessage())));
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            logError(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    logDebug("Counted {} ok to insert, out of {} to replace and {} new", okToInsert, replaceCount, newChanges.size());
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        logError(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    logDebug("Deleting {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Option(name = "-r", metaVar = "EMAIL", usage = "add reviewer to changes")
void reviewer(Account.Id id) {
    reviewer.add(id);
}
#method_after
@Option(name = "--reviewer", aliases = { "-r" }, metaVar = "EMAIL", usage = "add reviewer to changes")
void reviewer(Account.Id id) {
    reviewer.add(id);
}
#end_block

#method_before
@Option(name = "-l", metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.getLabel());
        ApprovalsUtil.checkLabel(labelTypes, v.getLabel(), v.getValue());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.getLabel(), v.getValue());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
String parse(CmdLineParser clp, Repository repo, Set<String> refs) throws CmdLineException {
    String ref = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        clp.parseOptionMap(options);
        ref = ref.substring(0, optionStart);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#method_after
String parse(CmdLineParser clp, Repository repo, Set<String> refs) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        clp.parseOptionMap(options);
        ref = ref.substring(0, optionStart);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        logDebug("Forcing newChangeForAllNotInTarget = false");
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        logDebug("Handling %base: {}", magicBranch.base);
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        logDebug("Handling newChangeForAllNotInTarget");
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        } catch (IOException ex) {
            logWarn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    logDebug("Parsing replace command");
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
        logDebug("Replacing with {}", newCommit);
    } catch (IOException e) {
        logError("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        logError("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        logError("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    logDebug("Replacing change {}", changeEnt.getId());
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    int i = 0;
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
                i++;
            } catch (IOException e) {
                logWarn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
    logDebug("Marked {} heads as uninteresting", i);
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c;
    try {
        // Force submit even if submit rule evaluation fails.
        c = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                    replaceByCommit.remove(req.newCommit);
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        logError(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        logError(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    logDebug("Read {} changes to replace", replaceByChange.size());
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            if (req.prev != null) {
                batch.addCommand(req.prev);
            }
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<Change, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(db.changes().getAsync(request.ontoChange));
    }
    for (CheckedFuture<Change, OrmException> f : futures) {
        Change c = f.checkedGet();
        if (c != null) {
            replaceByChange.get(c.getId()).change = c;
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    Collection<ChangeNotes> allNotes = notesFactory.create(db, Collections2.transform(replaceByChange.values(), new Function<ReplaceRequest, Change.Id>() {

        @Override
        public Change.Id apply(ReplaceRequest in) {
            return in.ontoChange;
        }
    }));
    for (ChangeNotes notes : allNotes) {
        replaceByChange.get(notes.getChangeId()).notes = notes;
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = notes.getChange().currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    changeCtl = projectControl.controlFor(notes);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot add patch set to " + ontoChange + locked);
        return false;
    } else if (notes.getChange().getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private List<Ref> refs(Change.Id changeId) {
    if (refsByChange == null) {
        int estRefsPerChange = 4;
        refsByChange = ArrayListMultimap.create(allRefs.size() / estRefsPerChange, estRefsPerChange);
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() != null) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                if (psId != null) {
                    refsByChange.put(psId.getParentKey(), ref);
                }
            }
        }
    }
    return refsByChange.get(changeId);
}
#method_after
private List<Ref> refs(Change.Id changeId) {
    return refsByChange().get(changeId);
}
#end_block

#method_before
private SetMultimap<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : repo.getRefDatabase().getRefs(REFS_CHANGES).values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() {
    initChangeRefMaps();
    return refsById;
}
#end_block

#method_before
static boolean parentsEqual(RevCommit a, RevCommit b) {
    if (a.getParentCount() != b.getParentCount()) {
        return false;
    }
    for (int i = 0; i < a.getParentCount(); i++) {
        if (a.getParent(i) != b.getParent(i)) {
            return false;
        }
    }
    return true;
}
#method_after
static boolean parentsEqual(RevCommit a, RevCommit b) {
    if (a.getParentCount() != b.getParentCount()) {
        return false;
    }
    for (int i = 0; i < a.getParentCount(); i++) {
        if (!a.getParent(i).equals(b.getParent(i))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean validRefOperation(final ReceiveCommand cmd) {
    RefOperationValidators refValidators = refValidatorsFactory.create(getProject(), currentUser, cmd);
    try {
        messages.addAll(refValidators.validateForRefOperation());
    } catch (RefOperationValidationException e) {
        messages.addAll(Lists.newArrayList(e.getMessages()));
        reject(cmd, e.getMessage());
        return false;
    }
    return true;
}
#method_after
private boolean validRefOperation(ReceiveCommand cmd) {
    RefOperationValidators refValidators = refValidatorsFactory.create(getProject(), user, cmd);
    try {
        messages.addAll(refValidators.validateForRefOperation());
    } catch (RefOperationValidationException e) {
        messages.addAll(Lists.newArrayList(e.getMessages()));
        reject(cmd, e.getMessage());
        return false;
    }
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        logDebug("Short-circuiting new commit validation");
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) throws NoSuchChangeException {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount());
        subOp.update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with" + " new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
private static boolean isHead(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#method_after
private static boolean isHead(ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#method_after
private static boolean isConfig(ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#end_block

#method_before
@Test
public void testUSER_NoPreferredEmailUser() {
    setFrom("USER");
    final String name = "A U. Thor";
    final Account.Id user = user(name, null);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name);
    assertThat(r.email).isEqualTo(ident.getEmailAddress());
    verify(accountCache);
}
#method_after
@Test
public void testUSER_NoPreferredEmailUser() {
    setFrom("USER");
    final String name = "A U. Thor";
    final Account.Id user = user(name, null);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name + " (Code Review)");
    assertThat(r.email).isEqualTo(ident.getEmailAddress());
    verify(accountCache);
}
#end_block

#method_before
@Test
public void testUSERAllowDomain() {
    setFrom("USER");
    setDomain(Arrays.asList("*.example.com"));
    final String name = "A U. Thor";
    final String email = "a.u.thor@test.example.com";
    final Account.Id user = user(name, email);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name);
    assertThat(r.email).isEqualTo(email);
    verify(accountCache);
}
#method_after
@Test
public void testUSERAllowDomain() {
    setFrom("USER");
    setDomains(Arrays.asList("*.example.com"));
    final String name = "A U. Thor";
    final String email = "a.u.thor@test.example.com";
    final Account.Id user = user(name, email);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name);
    assertThat(r.email).isEqualTo(email);
    verify(accountCache);
}
#end_block

#method_before
@Test
public void testUSERNoAllowDomain() {
    setFrom("USER");
    setDomain(Arrays.asList("example.com"));
    final String name = "A U. Thor";
    final String email = "a.u.thor@test.com";
    final Account.Id user = user(name, email);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name);
    assertThat(r.email).isEqualTo(ident.getEmailAddress());
    verify(accountCache);
}
#method_after
@Test
public void testUSERNoAllowDomain() {
    setFrom("USER");
    setDomains(Arrays.asList("example.com"));
    final String name = "A U. Thor";
    final String email = "a.u.thor@test.com";
    final Account.Id user = user(name, email);
    replay(accountCache);
    final Address r = create().from(user);
    assertThat(r).isNotNull();
    assertThat(r.name).isEqualTo(name + " (Code Review)");
    assertThat(r.email).isEqualTo(ident.getEmailAddress());
    verify(accountCache);
}
#end_block

#method_before
@Override
public Address from(final Account.Id fromId) {
    if (fromId != null) {
        Account a = accountCache.get(fromId).getAccount();
        String userEmail = a.getPreferredEmail();
        return new Address(a.getFullName(), canRelay(domains, userEmail) ? userEmail : srvAddr.getEmail());
    }
    return srvAddr;
}
#method_after
@Override
public Address from(final Account.Id fromId) {
    String senderName;
    if (fromId != null) {
        Account a = accountCache.get(fromId).getAccount();
        String fullName = a.getFullName();
        String userEmail = a.getPreferredEmail();
        if (canRelay(userEmail)) {
            return new Address(fullName, userEmail);
        }
        if (fullName == null || "".equals(fullName.trim())) {
            fullName = anonymousCowardName;
        }
        senderName = nameRewriteTmpl.replace("user", fullName).toString();
    } else {
        senderName = serverAddress.name;
    }
    String senderEmail;
    ParameterizedString senderEmailPattern = new ParameterizedString(serverAddress.email);
    if (senderEmailPattern.getParameterNames().isEmpty()) {
        senderEmail = senderEmailPattern.getRawPattern();
    } else {
        senderEmail = senderEmailPattern.replace("userHash", hashOf(senderName)).toString();
    }
    return new Address(senderName, senderEmail);
}
#end_block

#method_before
private boolean canRelay(String[] domains, String userEmail) {
    if (userEmail == null) {
        return false;
    }
    int index = userEmail.indexOf("@");
    if (index == -1) {
        return false;
    }
    String userDomain = userEmail.substring(index + 1);
    for (String domain : domains) {
        // Support wildcard
        domain = Pattern.quote(domain).replace("*", "\\E.*\\Q");
        if (userDomain.matches(domain)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean canRelay(String userEmail) {
    if (userEmail != null) {
        int index = userEmail.indexOf('@');
        if (index > 0 && index < userEmail.length() - 1) {
            return domainPattern.matcher(userEmail.substring(index + 1)).matches();
        }
    }
    return false;
}
#end_block

#method_before
public void addApprovals(ReviewDb db, ChangeUpdate update, LabelTypes labelTypes, PatchSet ps, ChangeControl changeCtl, Map<String, Short> approvals) throws OrmException {
    Iterable<PatchSetApproval> cells = makeApprovals(update, labelTypes, ps, changeCtl, approvals);
    db.patchSetApprovals().insert(cells);
}
#method_after
public Iterable<PatchSetApproval> addApprovals(ReviewDb db, ChangeUpdate update, LabelTypes labelTypes, PatchSet ps, ChangeControl changeCtl, Map<String, Short> approvals) throws OrmException {
    if (approvals.isEmpty()) {
        return Collections.emptyList();
    }
    checkApprovals(approvals, changeCtl);
    List<PatchSetApproval> cells = new ArrayList<>(approvals.size());
    Date ts = update.getWhen();
    for (Map.Entry<String, Short> vote : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(vote.getKey());
        cells.add(new PatchSetApproval(new PatchSetApproval.Key(ps.getId(), ps.getUploader(), lt.getLabelId()), vote.getValue(), ts));
    }
    for (PatchSetApproval psa : cells) {
        update.putApproval(psa.getLabel(), psa.getValue());
    }
    db.patchSetApprovals().insert(cells);
    return cells;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> incomingApprovals = approvalsUtil.makeApprovals(update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, incomingApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    ctx.getDb().patchSetApprovals().insert(incomingApprovals);
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), patchSetId);
    msg.setMessage(message.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx, msg);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovals(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), patchSetId);
    msg.setMessage(message.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx, msg);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#end_block

#method_before
@Test
public void pushNewPatchsetOverridingStickyLabel() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyMaxScore(true);
    cfg.getLabelSections().put(codeReview.getName(), codeReview);
    PushOneCommit.Result r = pushTo("refs/for/master%l=Code-Review+2");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master%l=Code-Review+1");
    r.assertOkStatus();
}
#method_after
@Test
public void pushNewPatchsetOverridingStickyLabel() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyMaxScore(true);
    cfg.getLabelSections().put(codeReview.getName(), codeReview);
    saveProjectConfig(cfg);
    PushOneCommit.Result r = pushTo("refs/for/master%l=Code-Review+2");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master%l=Code-Review+1");
    r.assertOkStatus();
}
#end_block

#method_before
public void copy(ReviewDb db, ChangeControl ctl, PatchSet ps) throws OrmException {
    Iterable<PatchSetApproval> incomingApprovals = Collections.emptyList();
    copy(db, ctl, ps, incomingApprovals);
}
#method_after
public void copy(ReviewDb db, ChangeControl ctl, PatchSet ps) throws OrmException {
    copy(db, ctl, ps, Collections.<PatchSetApproval>emptyList());
}
#end_block

#method_before
public void copy(ReviewDb db, ChangeControl ctl, PatchSet ps, Iterable<PatchSetApproval> incomingApprovals) throws OrmException {
    db.patchSetApprovals().insert(getForPatchSet(db, ctl, ps, incomingApprovals));
}
#method_after
public void copy(ReviewDb db, ChangeControl ctl, PatchSet ps, Iterable<PatchSetApproval> dontCopy) throws OrmException {
    db.patchSetApprovals().insert(getForPatchSet(db, ctl, ps, dontCopy));
}
#end_block

#method_before
Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    Iterable<PatchSetApproval> incomingApprovals = Collections.emptyList();
    return getForPatchSet(db, ctl, psId, incomingApprovals);
}
#method_after
Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    return getForPatchSet(db, ctl, psId, Collections.<PatchSetApproval>emptyList());
}
#end_block

#method_before
Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId, Iterable<PatchSetApproval> incomingApprovals) throws OrmException {
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psId);
    if (ps == null) {
        return Collections.emptyList();
    }
    return getForPatchSet(db, ctl, ps, incomingApprovals);
}
#method_after
Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId, Iterable<PatchSetApproval> dontCopy) throws OrmException {
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psId);
    if (ps == null) {
        return Collections.emptyList();
    }
    return getForPatchSet(db, ctl, ps, dontCopy);
}
#end_block

#method_before
private Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet ps, Iterable<PatchSetApproval> incomingApprovals) throws OrmException {
    checkNotNull(ps, "ps should not be null");
    ChangeData cd = changeDataFactory.create(db, ctl);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.approvals();
        checkNotNull(all, "all should not be null");
        Table<String, Account.Id, PatchSetApproval> wontCopy = HashBasedTable.create();
        for (PatchSetApproval psa : incomingApprovals) {
            wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(ps.getId())) {
            byUser.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        TreeMap<Integer, PatchSet> patchSets = getPatchSets(cd);
        try (Repository repo = repoManager.openRepository(project.getProject().getNameKey())) {
            // Walk patch sets strictly less than current in descending order.
            Collection<PatchSet> allPrior = patchSets.descendingMap().tailMap(ps.getId().get(), false).values();
            for (PatchSet priorPs : allPrior) {
                List<PatchSetApproval> priorApprovals = all.get(priorPs.getId());
                if (priorApprovals.isEmpty()) {
                    continue;
                }
                ChangeKind kind = changeKindCache.getChangeKind(project, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(ps.getRevision().get()));
                for (PatchSetApproval psa : priorApprovals) {
                    if (wontCopy.contains(psa.getLabel(), psa.getAccountId())) {
                        continue;
                    }
                    if (byUser.contains(psa.getLabel(), psa.getAccountId())) {
                        continue;
                    }
                    if (!canCopy(project, psa, ps.getId(), kind)) {
                        wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
                        continue;
                    }
                    byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, ps.getId()));
                }
            }
            return labelNormalizer.normalize(ctl, byUser.values()).getNormalized();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet ps, Iterable<PatchSetApproval> dontCopy) throws OrmException {
    checkNotNull(ps, "ps should not be null");
    ChangeData cd = changeDataFactory.create(db, ctl);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.approvals();
        checkNotNull(all, "all should not be null");
        Table<String, Account.Id, PatchSetApproval> wontCopy = HashBasedTable.create();
        for (PatchSetApproval psa : dontCopy) {
            wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(ps.getId())) {
            if (!wontCopy.contains(psa.getLabel(), psa.getAccountId())) {
                byUser.put(psa.getLabel(), psa.getAccountId(), psa);
            }
        }
        TreeMap<Integer, PatchSet> patchSets = getPatchSets(cd);
        try (Repository repo = repoManager.openRepository(project.getProject().getNameKey())) {
            // Walk patch sets strictly less than current in descending order.
            Collection<PatchSet> allPrior = patchSets.descendingMap().tailMap(ps.getId().get(), false).values();
            for (PatchSet priorPs : allPrior) {
                List<PatchSetApproval> priorApprovals = all.get(priorPs.getId());
                if (priorApprovals.isEmpty()) {
                    continue;
                }
                ChangeKind kind = changeKindCache.getChangeKind(project, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(ps.getRevision().get()));
                for (PatchSetApproval psa : priorApprovals) {
                    if (wontCopy.contains(psa.getLabel(), psa.getAccountId())) {
                        continue;
                    }
                    if (byUser.contains(psa.getLabel(), psa.getAccountId())) {
                        continue;
                    }
                    if (!canCopy(project, psa, ps.getId(), kind)) {
                        wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
                        continue;
                    }
                    byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, ps.getId()));
                }
            }
            return labelNormalizer.normalize(ctl, byUser.values()).getNormalized();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException {
    Account.Id reviewerId = reviewer.getId();
    currChange = ctx.getChange();
    currPs = psUtil.current(dbProvider.get(), ctx.getNotes());
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        if (ctx.getControl().canRemoveReviewer(a)) {
            del.add(a);
            if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
                oldApprovals.put(a.getLabel(), a.getValue());
                if (msg.length() == 0) {
                    msg.append("Removed the following votes:\n\n");
                }
                msg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
            }
        } else {
            throw new AuthException("delete not permitted");
        }
    }
    if (del.isEmpty()) {
        throw new ResourceNotFoundException();
    }
    msg.insert(0, "Removed the following reviewer: " + reviewer.getFullName() + "\n");
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = new ChangeMessage(new ChangeMessage.Key(currChange.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), currPs.getId());
    changeMessage.setMessage(msg.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException {
    Account.Id reviewerId = reviewer.getId();
    if (!approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all().contains(reviewerId)) {
        throw new ResourceNotFoundException();
    }
    currChange = ctx.getChange();
    currPs = psUtil.current(ctx.getDb(), ctx.getNotes());
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed reviewer " + reviewer.getFullName());
    StringBuilder removedVotesMsg = new StringBuilder();
    removedVotesMsg.append(" with the following votes:\n\n");
    boolean votesRemoved = false;
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        if (ctx.getControl().canRemoveReviewer(a)) {
            del.add(a);
            if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
                oldApprovals.put(a.getLabel(), a.getValue());
                removedVotesMsg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                votesRemoved = true;
            }
        } else {
            throw new AuthException("delete reviewer not permitted");
        }
    }
    if (votesRemoved) {
        msg.append(removedVotesMsg);
    } else {
        msg.append(".");
    }
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = new ChangeMessage(new ChangeMessage.Key(currChange.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), currPs.getId());
    changeMessage.setMessage(msg.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    emailReviewers(ctx.getProject(), currChange, del, changeMessage);
    try {
        hooks.doReviewerDeletedHook(currChange, reviewer, currPs, changeMessage.getMessage(), newApprovals, oldApprovals, dbProvider.get());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    emailReviewers(ctx.getProject(), currChange, del, changeMessage);
    reviewerDeleted.fire(currChange, currPs, reviewer, ctx.getAccount(), changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getWhen());
}
#end_block

#method_before
private Iterable<PatchSetApproval> approvals(ChangeContext ctx, final Account.Id accountId) throws OrmException {
    return Iterables.filter(approvalsUtil.byChange(ctx.getDb(), ctx.getNotes()).values(), new Predicate<PatchSetApproval>() {

        @Override
        public boolean apply(PatchSetApproval input) {
            return accountId.equals(input.getAccountId());
        }
    });
}
#method_after
private Iterable<PatchSetApproval> approvals(ChangeContext ctx, final Account.Id accountId) throws OrmException {
    Change.Id changeId = ctx.getNotes().getChangeId();
    Iterable<PatchSetApproval> approvals;
    if (migration.readChanges()) {
        // Because NoteDb and ReviewDb have different semantics for zero-value
        // approvals, we must fall back to ReviewDb as the source of truth here.
        ReviewDb db = ctx.getDb();
        if (db instanceof BatchUpdateReviewDb) {
            db = ((BatchUpdateReviewDb) db).unsafeGetDelegate();
        }
        db = ReviewDbUtil.unwrapDb(db);
        approvals = db.patchSetApprovals().byChange(changeId);
    } else {
        approvals = approvalsUtil.byChange(ctx.getDb(), ctx.getNotes()).values();
    }
    return Iterables.filter(approvals, new Predicate<PatchSetApproval>() {

        @Override
        public boolean apply(PatchSetApproval input) {
            return accountId.equals(input.getAccountId());
        }
    });
}
#end_block

#method_before
private String formatLabelValue(short value) {
    if (value > 0) {
        return "+" + value;
    } else {
        return Short.toString(value);
    }
}
#method_after
private String formatLabelValue(short value) {
    if (value > 0) {
        return "+" + value;
    }
    return Short.toString(value);
}
#end_block

#method_before
private void emailReviewers(Project.NameKey projectName, Change change, List<PatchSetApproval> dels, ChangeMessage changeMessage) {
    // The user knows they removed themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(dels.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : dels) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            DeleteReviewerSender cm = deleteReviewerSenderFactory.create(projectName, change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.setChangeMessage(changeMessage);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot email update for change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Project.NameKey projectName, Change change, List<PatchSetApproval> dels, ChangeMessage changeMessage) {
    // The user knows they removed themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(dels.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : dels) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            DeleteReviewerSender cm = deleteReviewerSenderFactory.create(projectName, change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.setChangeMessage(changeMessage.getMessage(), changeMessage.getWrittenOn());
            cm.send();
        } catch (Exception err) {
            log.error("Cannot email update for change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
private void validateReviewer(String reviewer) throws RestApiException {
    try (ReviewDb reviewDb = schemaFactory.open()) {
        Account account = accountResolver.find(reviewDb, reviewer);
        if (account == null) {
            try {
                groupsCollection.get().parse(reviewer);
            } catch (UnprocessableEntityException e) {
                throw new ResourceNotFoundException("Account or group " + reviewer + " not found");
            }
        }
    } catch (OrmException e) {
        log.error("Failed to resolve account " + reviewer);
    }
}
#method_after
private void validateReviewer(String reviewer) throws RestApiException {
    try {
        Account account = accountResolver.find(reviewDbProvider.get(), reviewer);
        if (account == null) {
            try {
                groupsCollection.get().parse(reviewer);
            } catch (UnprocessableEntityException e) {
                throw new ResourceNotFoundException("Account or group " + reviewer + " not found");
            }
        }
    } catch (OrmException e) {
        log.error("Failed to resolve account " + reviewer);
    }
}
#end_block

#method_before
@Override
public GroupInfo apply(TopLevelResource resource, GroupInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, OrmException, IOException {
    return create(input, Collections.singleton(self.get().getAccountId()));
}
#method_after
@Override
public GroupInfo apply(TopLevelResource resource, GroupInput input) throws AuthException, BadRequestException, UnprocessableEntityException, ResourceConflictException, OrmException, IOException {
    if (input == null) {
        input = new GroupInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    AccountGroup.Id ownerId = owner(input);
    CreateGroupArgs args = new CreateGroupArgs();
    args.setGroupName(name);
    args.groupDescription = Strings.emptyToNull(input.description);
    args.visibleToAll = MoreObjects.firstNonNull(input.visibleToAll, defaultVisibleToAll);
    args.ownerGroupId = ownerId;
    if (input.members != null && !input.members.isEmpty()) {
        List<Account.Id> members = new ArrayList<>();
        for (String nameOrEmailOrId : input.members) {
            Account a = addMembers.findAccount(nameOrEmailOrId);
            if (!a.isActive()) {
                throw new UnprocessableEntityException(String.format("Account Inactive: %s", nameOrEmailOrId));
            }
            members.add(a.getId());
        }
        args.initialMembers = members;
    } else {
        args.initialMembers = ownerId == null ? Collections.singleton(self.get().getAccountId()) : Collections.<Account.Id>emptySet();
    }
    for (GroupCreationValidationListener l : groupCreationValidationListeners) {
        try {
            l.validateNewGroup(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    return json.format(GroupDescriptions.forAccountGroup(createGroup(args)));
}
#end_block

#method_before
@Provides
@Singleton
@Named(POLYGERRIT_INDEX_SERVLET)
HttpServlet getPolyGerritUiIndexServlet(@Named(CACHE) Cache<Path, Resource> cache) {
    return new SingleFileServlet(cache, polyGerritBasePath().resolve("index.html"), true, true);
}
#method_after
@Provides
@Singleton
@Named(POLYGERRIT_INDEX_SERVLET)
HttpServlet getPolyGerritUiIndexServlet(@Named(CACHE) Cache<Path, Resource> cache) {
    return new SingleFileServlet(cache, polyGerritBasePath().resolve("index.html"), getPaths().isDev(), false);
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    String name;
    if (req.getPathInfo() == null) {
        name = "/";
    } else {
        name = CharMatcher.is('/').trimFrom(req.getPathInfo());
    }
    if (isUnreasonableName(name)) {
        notFound(rsp);
        return;
    }
    Path p = getResourcePath(name);
    if (p == null) {
        notFound(rsp);
        return;
    }
    Resource r = cache.getIfPresent(p);
    try {
        if (r == null) {
            if (maybeStream(p, req, rsp)) {
                // Bypass cache for large resource.
                return;
            }
            r = cache.get(p, newLoader(p));
        }
        if (noClientCache) {
            CacheHeaders.setNotCacheable(rsp);
        }
        if (refresh && r.isStale(p, this)) {
            cache.invalidate(p);
            r = cache.get(p, newLoader(p));
        }
    } catch (ExecutionException e) {
        log.warn("Cannot load static resource " + req.getPathInfo(), e);
        CacheHeaders.setNotCacheable(rsp);
        rsp.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    }
    if (r == Resource.NOT_FOUND) {
        // Cached not found response.
        notFound(rsp);
        return;
    }
    String e = req.getParameter("e");
    if (e != null && !r.etag.equals(e)) {
        CacheHeaders.setNotCacheable(rsp);
        rsp.setStatus(SC_NOT_FOUND);
        return;
    } else if (r.etag.equals(req.getHeader(IF_NONE_MATCH))) {
        rsp.setStatus(SC_NOT_MODIFIED);
        return;
    }
    byte[] tosend = r.raw;
    if (!r.contentType.equals(JS) && RPCServletUtils.acceptsGzipEncoding(req)) {
        byte[] gz = HtmlDomUtil.compress(tosend);
        if ((gz.length + 24) < tosend.length) {
            rsp.setHeader(CONTENT_ENCODING, "gzip");
            tosend = gz;
        }
    }
    if (!CacheHeaders.hasCacheHeader(rsp)) {
        if (e != null && r.etag.equals(e)) {
            CacheHeaders.setCacheable(req, rsp, 360, DAYS, false);
        } else {
            CacheHeaders.setCacheable(req, rsp, 15, MINUTES, refresh);
        }
    }
    if (!noClientCache) {
        rsp.setHeader(ETAG, r.etag);
    }
    rsp.setContentType(r.contentType);
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    String name;
    if (req.getPathInfo() == null) {
        name = "/";
    } else {
        name = CharMatcher.is('/').trimFrom(req.getPathInfo());
    }
    if (isUnreasonableName(name)) {
        notFound(rsp);
        return;
    }
    Path p = getResourcePath(name);
    if (p == null) {
        notFound(rsp);
        return;
    }
    Resource r = cache.getIfPresent(p);
    try {
        if (r == null) {
            if (maybeStream(p, req, rsp)) {
                // Bypass cache for large resource.
                return;
            }
            r = cache.get(p, newLoader(p));
        }
        if (refresh && r.isStale(p, this)) {
            cache.invalidate(p);
            r = cache.get(p, newLoader(p));
        }
    } catch (ExecutionException e) {
        log.warn("Cannot load static resource " + req.getPathInfo(), e);
        CacheHeaders.setNotCacheable(rsp);
        rsp.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    }
    if (r == Resource.NOT_FOUND) {
        // Cached not found response.
        notFound(rsp);
        return;
    }
    String e = req.getParameter("e");
    if (e != null && !r.etag.equals(e)) {
        CacheHeaders.setNotCacheable(rsp);
        rsp.setStatus(SC_NOT_FOUND);
        return;
    } else if (cacheOnClient && r.etag.equals(req.getHeader(IF_NONE_MATCH))) {
        rsp.setStatus(SC_NOT_MODIFIED);
        return;
    }
    byte[] tosend = r.raw;
    if (!r.contentType.equals(JS) && RPCServletUtils.acceptsGzipEncoding(req)) {
        byte[] gz = HtmlDomUtil.compress(tosend);
        if ((gz.length + 24) < tosend.length) {
            rsp.setHeader(CONTENT_ENCODING, "gzip");
            tosend = gz;
        }
    }
    if (cacheOnClient) {
        rsp.setHeader(ETAG, r.etag);
    } else {
        CacheHeaders.setNotCacheable(rsp);
    }
    if (!CacheHeaders.hasCacheHeader(rsp)) {
        if (e != null && r.etag.equals(e)) {
            CacheHeaders.setCacheable(req, rsp, 360, DAYS, false);
        } else {
            CacheHeaders.setCacheable(req, rsp, 15, MINUTES, refresh);
        }
    }
    rsp.setContentType(r.contentType);
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#end_block

#method_before
@Test
public void checkAlreadyMergedCommit() throws Exception {
    ObjectId c0 = testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    testRepo.branch("HEAD").commit().insertChangeId().message("second commit").add("b.txt", "b contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    assertAlreadyMerged("master", c0.getName(), "");
}
#method_after
@Test
public void checkAlreadyMergedCommit() throws Exception {
    ObjectId c0 = testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    testRepo.branch("HEAD").commit().insertChangeId().message("second commit").add("b.txt", "b contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    assertCommitMerged("master", c0.getName(), "");
}
#end_block

#method_before
@Test
@TestProjectInput(submitType = SubmitType.CHERRY_PICK)
public void checkContentMergedCommit() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    // create a change, and cherrypick into master
    PushOneCommit.Result cId = createChange();
    approve(cId.getChangeId());
    RevCommit commitId = cId.getCommit();
    gApi.changes().id(cId.getChangeId()).current().submit();
    ObjectId remoteId = getRemoteHead();
    assertThat(remoteId).isNotEqualTo(commitId);
    assertMergeable("master", commitId.getName(), "recursive");
}
#method_after
@Test
public void checkContentMergedCommit() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    // create a change, and cherrypick into master
    PushOneCommit.Result cId = createChange();
    RevCommit commitId = cId.getCommit();
    CherryPickInput cpi = new CherryPickInput();
    cpi.destination = "master";
    cpi.message = "cherry pick the commit";
    ChangeApi orig = gApi.changes().id(cId.getChangeId());
    ChangeApi cherry = orig.current().cherryPick(cpi);
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
    ObjectId remoteId = getRemoteHead();
    assertThat(remoteId).isNotEqualTo(commitId);
    assertContentMerged("master", commitId.getName(), "recursive");
}
#end_block

#method_before
@Test
public void checkInvalidSource() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    assertBadRequest("master", "fdsafsdf", "recursive", "Cannot resolve 'fdsafsdf' into a commit");
}
#method_after
@Test
public void checkInvalidSource() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    assertBadRequest("master", "fdsafsdf", "recursive", "Cannot resolve 'fdsafsdf' to a commit");
}
#end_block

#method_before
private void assertUnMergeable(String targetBranch, String source, String strategy, String... conflicts) throws Exception {
    MergeableInfo mergeableInfo = getMergeableInfo(targetBranch, source, strategy);
    assertThat(mergeableInfo.mergeable).isFalse();
    assertThat(mergeableInfo.conflicts).containsExactly(conflicts);
}
#method_after
private void assertUnMergeable(String targetBranch, String source, String strategy, String... conflicts) throws Exception {
    MergeableInfo mergeableInfo = getMergeableInfo(targetBranch, source, strategy);
    assertThat(mergeableInfo.mergeable).isFalse();
    assertThat(mergeableInfo.conflicts).containsExactly((Object[]) conflicts);
}
#end_block

#method_before
public static RevCommit createMergeCommit(Repository repo, ObjectInserter inserter, RevCommit mergeTip, RevCommit originalCommit, String mergeStrategy, PersonIdent committerIndent, String commitMsg, RevWalk rw) throws IOException, MergeIdenticalTreeException, MergeConflictException {
    if (rw.isMergedInto(originalCommit, mergeTip)) {
        throw new ChangeAlreadyMergedException("'" + originalCommit.getName() + "' has already been merged!");
    }
    Merger m = newMerger(repo, inserter, mergeStrategy);
    if (m.merge(false, mergeTip, originalCommit)) {
        ObjectId tree = m.getResultTreeId();
        CommitBuilder mergeCommit = new CommitBuilder();
        mergeCommit.setTreeId(tree);
        mergeCommit.setParentIds(mergeTip, originalCommit);
        mergeCommit.setAuthor(committerIndent);
        mergeCommit.setCommitter(committerIndent);
        mergeCommit.setMessage(commitMsg);
        return rw.parseCommit(inserter.insert(mergeCommit));
    }
    List<String> conflicts = ImmutableList.of();
    if (m instanceof ResolveMerger) {
        conflicts = ((ResolveMerger) m).getUnmergedPaths();
    }
    throw new MergeConflictException(createConflictMessage(conflicts));
}
#method_after
public static RevCommit createMergeCommit(Repository repo, ObjectInserter inserter, RevCommit mergeTip, RevCommit originalCommit, String mergeStrategy, PersonIdent committerIndent, String commitMsg, RevWalk rw) throws IOException, MergeIdenticalTreeException, MergeConflictException {
    if (rw.isMergedInto(originalCommit, mergeTip)) {
        throw new ChangeAlreadyMergedException("'" + originalCommit.getName() + "' has already been merged");
    }
    Merger m = newMerger(repo, inserter, mergeStrategy);
    if (m.merge(false, mergeTip, originalCommit)) {
        ObjectId tree = m.getResultTreeId();
        CommitBuilder mergeCommit = new CommitBuilder();
        mergeCommit.setTreeId(tree);
        mergeCommit.setParentIds(mergeTip, originalCommit);
        mergeCommit.setAuthor(committerIndent);
        mergeCommit.setCommitter(committerIndent);
        mergeCommit.setMessage(commitMsg);
        return rw.parseCommit(inserter.insert(mergeCommit));
    }
    List<String> conflicts = ImmutableList.of();
    if (m instanceof ResolveMerger) {
        conflicts = ((ResolveMerger) m).getUnmergedPaths();
    }
    throw new MergeConflictException(createConflictMessage(conflicts));
}
#end_block

#method_before
public static RevCommit resolveCommit(Repository repo, RevWalk rw, String str) throws BadRequestException, ResourceNotFoundException, IOException {
    try {
        ObjectId commitId = repo.resolve(str);
        if (commitId == null) {
            throw new BadRequestException("Cannot resolve '" + str + "' into a commit");
        }
        return rw.parseCommit(commitId);
    } catch (AmbiguousObjectException | IncorrectObjectTypeException | RevisionSyntaxException e) {
        throw new BadRequestException(e.getMessage());
    } catch (MissingObjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#method_after
public static RevCommit resolveCommit(Repository repo, RevWalk rw, String str) throws BadRequestException, ResourceNotFoundException, IOException {
    try {
        ObjectId commitId = repo.resolve(str);
        if (commitId == null) {
            throw new BadRequestException("Cannot resolve '" + str + "' to a commit");
        }
        return rw.parseCommit(commitId);
    } catch (AmbiguousObjectException | IncorrectObjectTypeException | RevisionSyntaxException e) {
        throw new BadRequestException(e.getMessage());
    } catch (MissingObjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#end_block

#method_before
@Test
public void invalidSource() throws Exception {
    changeInTwoBranches("branchA", "a.txt", "branchB", "b.txt");
    ChangeInput in = newMergeChangeInput("branchA", "invalid", "");
    assertCreateFails(in, BadRequestException.class, "Cannot resolve 'invalid' into a commit");
}
#method_after
@Test
public void invalidSource() throws Exception {
    changeInTwoBranches("branchA", "a.txt", "branchB", "b.txt");
    ChangeInput in = newMergeChangeInput("branchA", "invalid", "");
    assertCreateFails(in, BadRequestException.class, "Cannot resolve 'invalid' to a commit");
}
#end_block

#method_before
@Test
public void alreadyMerged() throws Exception {
    ObjectId c0 = testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    testRepo.branch("HEAD").commit().insertChangeId().message("second commit").add("b.txt", "b contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    ChangeInput in = newMergeChangeInput("master", c0.getName(), "");
    assertCreateFails(in, BadRequestException.class, "'" + c0.getName() + "' has already been merged!");
}
#method_after
@Test
public void alreadyMerged() throws Exception {
    ObjectId c0 = testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    testRepo.branch("HEAD").commit().insertChangeId().message("second commit").add("b.txt", "b contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    ChangeInput in = newMergeChangeInput("master", c0.getName(), "");
    assertCreateFails(in, ChangeAlreadyMergedException.class, "'" + c0.getName() + "' has already been merged");
}
#end_block

#method_before
@Test
@TestProjectInput(submitType = SubmitType.CHERRY_PICK)
public void onlyContentMerged() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    // create a change, and cherrypick into master
    PushOneCommit.Result cId = createChange();
    approve(cId.getChangeId());
    RevCommit commitId = cId.getCommit();
    gApi.changes().id(cId.getChangeId()).current().submit();
    ObjectId remoteId = getRemoteHead();
    assertThat(remoteId).isNotEqualTo(commitId);
    ChangeInput in = newMergeChangeInput("master", commitId.getName(), "");
    assertCreateSucceeds(in);
}
#method_after
@Test
public void onlyContentMerged() throws Exception {
    testRepo.branch("HEAD").commit().insertChangeId().message("first commit").add("a.txt", "a contents ").create();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    // create a change, and cherrypick into master
    PushOneCommit.Result cId = createChange();
    RevCommit commitId = cId.getCommit();
    CherryPickInput cpi = new CherryPickInput();
    cpi.destination = "master";
    cpi.message = "cherry pick the commit";
    ChangeApi orig = gApi.changes().id(cId.getChangeId());
    ChangeApi cherry = orig.current().cherryPick(cpi);
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
    ObjectId remoteId = getRemoteHead();
    assertThat(remoteId).isNotEqualTo(commitId);
    ChangeInput in = newMergeChangeInput("master", commitId.getName(), "");
    assertCreateSucceeds(in);
}
#end_block

#method_before
private void changeInTwoBranches(String branchA, String fileA, String branchB, String fileB) throws Exception {
    // create a initial commit in master
    Result initialCommit = pushFactory.create(db, user.getIdent(), testRepo, "initial commit", "readme.txt", "initial commit").to("refs/heads/master");
    initialCommit.assertOkStatus();
    // create a new branch branchA
    createBranch(new Branch.NameKey(project, branchA));
    createBranch(new Branch.NameKey(project, branchB));
    // create a commit in branchA
    Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", fileA, "A content").to("refs/heads/" + branchA);
    changeA.assertOkStatus();
    // create a commit in branchB
    PushOneCommit commitB = pushFactory.create(db, user.getIdent(), testRepo, "change B", fileB, "B content");
    commitB.setParent(initialCommit.getCommit());
    Result changeB = commitB.to("refs/heads/" + branchB);
    changeB.assertOkStatus();
}
#method_after
private void changeInTwoBranches(String branchA, String fileA, String branchB, String fileB) throws Exception {
    // create a initial commit in master
    Result initialCommit = pushFactory.create(db, user.getIdent(), testRepo, "initial commit", "readme.txt", "initial commit").to("refs/heads/master");
    initialCommit.assertOkStatus();
    // create two new branches
    createBranch(new Branch.NameKey(project, branchA));
    createBranch(new Branch.NameKey(project, branchB));
    // create a commit in branchA
    Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", fileA, "A content").to("refs/heads/" + branchA);
    changeA.assertOkStatus();
    // create a commit in branchB
    PushOneCommit commitB = pushFactory.create(db, user.getIdent(), testRepo, "change B", fileB, "B content");
    commitB.setParent(initialCommit.getCommit());
    Result changeB = commitB.to("refs/heads/" + branchB);
    changeB.assertOkStatus();
}
#end_block

#method_before
@Override
public MergeableInfo apply(BranchResource resource) throws IOException, BadRequestException, ResourceNotFoundException {
    MergeableInfo result = new MergeableInfo();
    result.strategy = strategy;
    try (Repository git = gitManager.openRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(git);
        ObjectInserter inserter = new InMemoryInserter(git)) {
        Merger m = MergeUtil.newMerger(git, inserter, strategy);
        Ref destRef = git.getRefDatabase().exactRef(resource.getRef());
        if (destRef == null) {
            throw new ResourceNotFoundException(resource.getRef());
        }
        RevCommit targetCommit = rw.parseCommit(destRef.getObjectId());
        RevCommit sourceCommit = MergeUtil.resolveCommit(git, rw, source);
        if (!resource.getControl().canReadCommit(db.get(), git, sourceCommit)) {
            throw new BadRequestException("Do not have read permission for: " + source);
        }
        if (rw.isMergedInto(sourceCommit, targetCommit)) {
            throw new ChangeAlreadyMergedException("'" + source + "' has already been merged!");
        }
        result.mergeable = m.merge(false, targetCommit, sourceCommit);
        if (m instanceof ResolveMerger) {
            result.conflicts = ((ResolveMerger) m).getUnmergedPaths();
        }
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
    return result;
}
#method_after
@Override
public MergeableInfo apply(BranchResource resource) throws IOException, BadRequestException, ResourceNotFoundException {
    if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
        throw new BadRequestException("Submit type: " + submitType + " is not supported");
    }
    MergeableInfo result = new MergeableInfo();
    result.submitType = submitType;
    result.strategy = strategy;
    try (Repository git = gitManager.openRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(git);
        ObjectInserter inserter = new InMemoryInserter(git)) {
        Merger m = MergeUtil.newMerger(git, inserter, strategy);
        Ref destRef = git.getRefDatabase().exactRef(resource.getRef());
        if (destRef == null) {
            throw new ResourceNotFoundException(resource.getRef());
        }
        RevCommit targetCommit = rw.parseCommit(destRef.getObjectId());
        RevCommit sourceCommit = MergeUtil.resolveCommit(git, rw, source);
        if (!resource.getControl().canReadCommit(db.get(), git, sourceCommit)) {
            throw new BadRequestException("do not have read permission for: " + source);
        }
        if (rw.isMergedInto(sourceCommit, targetCommit)) {
            result.mergeable = true;
            result.commitMerged = true;
            result.contentMerged = true;
            return result;
        }
        if (m.merge(false, targetCommit, sourceCommit)) {
            result.mergeable = true;
            result.commitMerged = false;
            result.contentMerged = m.getResultTreeId().equals(targetCommit.getTree());
        } else {
            result.mergeable = false;
            if (m instanceof ResolveMerger) {
                result.conflicts = ((ResolveMerger) m).getUnmergedPaths();
            }
        }
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
    return result;
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        RevWalk rw = new RevWalk(oi.newReader())) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setGroups(groups);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        RevWalk rw = new RevWalk(oi.newReader())) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setGroups(groups);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
int shutdown() {
    int cnt = 0;
    if (pool != null) {
        cnt = pool.shutdownNow().size();
        pool.unregisterWorkQueue();
        pool = null;
    }
    return cnt;
}
#method_after
int shutdown() {
    int cnt = 0;
    if (pool != null) {
        for (Runnable r : pool.getQueue()) {
            repLog.warn(String.format("Cancelling replication event %s", r));
        }
        cnt = pool.shutdownNow().size();
        pool.unregisterWorkQueue();
        pool = null;
    }
    return cnt;
}
#end_block

#method_before
@Override
public void run() throws IOException {
    ui.header("Index");
    IndexType type = index.select("Type", "type", IndexType.LUCENE);
    if ((site.isNew || isEmptySite()) && type == IndexType.LUCENE) {
        for (SchemaDefinitions<?> def : IndexModule.ALL_SCHEMA_DEFS) {
            AbstractLuceneIndex.setReady(site, def.getName(), def.getLatest().getVersion(), true);
        }
    } else {
        final String message = String.format("\nThe index must be %sbuilt before starting Gerrit:\n" + "  java -jar gerrit.war reindex -d site_path\n", site.isNew ? "" : "re");
        ui.message(message);
        initFlags.autoStart = false;
    }
}
#method_after
@Override
public void run() throws IOException {
    IndexType type = IndexType.LUCENE;
    if (IndexType.values().length > 1) {
        ui.header("Index");
        type = index.select("Type", "type", type);
    }
    if ((site.isNew || isEmptySite()) && type == IndexType.LUCENE) {
        for (SchemaDefinitions<?> def : IndexModule.ALL_SCHEMA_DEFS) {
            AbstractLuceneIndex.setReady(site, def.getName(), def.getLatest().getVersion(), true);
        }
    } else {
        if (IndexType.values().length <= 1) {
            ui.header("Index");
        }
        String message = String.format("\nThe index must be %sbuilt before starting Gerrit:\n" + "  java -jar gerrit.war reindex -d site_path\n", site.isNew ? "" : "re");
        ui.message(message);
        initFlags.autoStart = false;
    }
}
#end_block

#method_before
private void json(final Object data, final StringWriter w) {
    JsonServlet.defaultGsonBuilder().create().toJson(data, w);
}
#method_after
private void json(Object data, StringWriter w) {
    JsonServlet.defaultGsonBuilder().create().toJson(data, w);
}
#end_block

#method_before
private Page get() {
    Page p = page;
    if (refreshHeaderFooter && p.isStale()) {
        final Page newPage;
        try {
            newPage = new Page();
        } catch (IOException e) {
            log.error("Cannot refresh site header/footer", e);
            return p;
        }
        p = newPage;
        page = p;
    }
    return p;
}
#method_after
private Page get() {
    Page p = page;
    try {
        if (refreshHeaderFooter && p.isStale()) {
            p = new Page();
            page = p;
        }
    } catch (IOException e) {
        log.error("Cannot refresh site header/footer", e);
    }
    return p;
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final Page.Content page = select(req);
    final StringWriter w = new StringWriter();
    final CurrentUser user = currentUser.get();
    if (user.isIdentifiedUser()) {
        w.write(HPD_ID + ".account=");
        json(((IdentifiedUser) user).getAccount(), w);
        w.write(";");
        w.write(HPD_ID + ".xGerritAuth=");
        json(session.get().getXGerritAuth(), w);
        w.write(";");
        w.write(HPD_ID + ".accountDiffPref=");
        json(((IdentifiedUser) user).getAccountDiffPreference(), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
    } else {
        w.write(HPD_ID + ".theme=");
        json(signedOutTheme, w);
        w.write(";");
    }
    plugins(w);
    messages(w);
    final byte[] hpd = w.toString().getBytes("UTF-8");
    final byte[] raw = Bytes.concat(page.part1, hpd, page.part2);
    final byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    CacheHeaders.setNotCacheable(rsp);
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC);
    rsp.setContentLength(tosend.length);
    final OutputStream out = rsp.getOutputStream();
    try {
        out.write(tosend);
    } finally {
        out.close();
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    Page.Content page = select(req);
    StringWriter w = new StringWriter();
    CurrentUser user = currentUser.get();
    if (user.isIdentifiedUser()) {
        w.write(HPD_ID + ".accountDiffPref=");
        json(getDiffPreferences(user.asIdentifiedUser()), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
    } else {
        w.write(HPD_ID + ".theme=");
        json(signedOutTheme, w);
        w.write(";");
    }
    plugins(w);
    messages(w);
    byte[] hpd = w.toString().getBytes(UTF_8);
    byte[] raw = Bytes.concat(page.part1, hpd, page.part2);
    byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    CacheHeaders.setNotCacheable(rsp);
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#end_block

#method_before
private void plugins(StringWriter w) {
    List<String> urls = Lists.newArrayList();
    for (WebUiPlugin u : plugins) {
        urls.add(String.format("plugins/%s/%s", u.getPluginName(), u.getJavaScriptResourcePath()));
    }
    if (!urls.isEmpty()) {
        w.write(HPD_ID + ".plugins=");
        json(urls, w);
        w.write(";");
    }
}
#method_after
private void plugins(StringWriter w) {
    List<String> urls = new ArrayList<>();
    for (WebUiPlugin u : plugins) {
        urls.add(String.format("plugins/%s/%s", u.getPluginName(), u.getJavaScriptResourcePath()));
    }
    if (!urls.isEmpty()) {
        w.write(HPD_ID + ".plugins=");
        json(urls, w);
        w.write(";");
    }
}
#end_block

#method_before
private void insertETags(Element e) {
    if ("img".equalsIgnoreCase(e.getTagName()) || "script".equalsIgnoreCase(e.getTagName())) {
        String src = e.getAttribute("src");
        if (src != null && src.startsWith("static/")) {
            String name = src.substring("static/".length());
            StaticServlet.Resource r = staticServlet.getResource(name);
            if (r != null) {
                e.setAttribute("src", src + "?e=" + r.etag);
            }
        }
    }
    for (Node n = e.getFirstChild(); n != null; n = n.getNextSibling()) {
        if (n instanceof Element) {
            insertETags((Element) n);
        }
    }
}
#method_after
private void insertETags(Element e) {
    if ("img".equalsIgnoreCase(e.getTagName()) || "script".equalsIgnoreCase(e.getTagName())) {
        String src = e.getAttribute("src");
        if (src != null && src.startsWith("static/")) {
            String name = src.substring("static/".length());
            ResourceServlet.Resource r = staticServlet.getResource(name);
            if (r != null) {
                e.setAttribute("src", src + "?e=" + r.etag);
            }
        }
    }
    for (Node n = e.getFirstChild(); n != null; n = n.getNextSibling()) {
        if (n instanceof Element) {
            insertETags((Element) n);
        }
    }
}
#end_block

#method_before
boolean isStale() {
    return time != path.lastModified();
}
#method_after
boolean isStale() {
    return time != lastModified(path);
}
#end_block

#method_before
private void asScript(final Element scriptNode) {
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#method_after
private void asScript(Element scriptNode) {
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#end_block

#method_before
private FileInfo injectCssFile(final Document hostDoc, final String id, final File src) throws IOException {
    final FileInfo info = new FileInfo(src);
    final Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    String css = HtmlDomUtil.readFile(src.getParentFile(), src.getName());
    if (css == null) {
        return info;
    }
    banner.appendChild(hostDoc.createCDATASection("\n" + css + "\n"));
    return info;
}
#method_after
private FileInfo injectCssFile(Document hostDoc, String id, Path src) throws IOException {
    FileInfo info = new FileInfo(src);
    Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    String css = HtmlDomUtil.readFile(src.getParent(), src.getFileName().toString());
    if (css == null) {
        return info;
    }
    banner.appendChild(hostDoc.createCDATASection("\n" + css + "\n"));
    return info;
}
#end_block

#method_before
private FileInfo injectXmlFile(final Document hostDoc, final String id, final File src) throws IOException {
    final FileInfo info = new FileInfo(src);
    final Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    Document html = HtmlDomUtil.parseFile(src);
    if (html == null) {
        return info;
    }
    Element content = html.getDocumentElement();
    insertETags(content);
    banner.appendChild(hostDoc.importNode(content, true));
    return info;
}
#method_after
private FileInfo injectXmlFile(Document hostDoc, String id, Path src) throws IOException {
    FileInfo info = new FileInfo(src);
    Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    Document html = HtmlDomUtil.parseFile(src);
    if (html == null) {
        return info;
    }
    Element content = html.getDocumentElement();
    insertETags(content);
    banner.appendChild(hostDoc.importNode(content, true));
    return info;
}
#end_block

#method_before
public static void display(final String token, final Screen view) {
    if (view.isRequiresSignIn() && !isSignedIn()) {
        doSignIn(token);
    } else {
        view.setToken(token);
        body.setView(view);
    }
}
#method_after
public static void display(final String token, final Screen view) {
    if (view.isRequiresSignIn() && !isSignedIn()) {
        doSignIn(token);
    } else {
        view.setToken(token);
        if (isSignedIn()) {
            LocalComments.saveInlineComments();
        }
        body.setView(view);
    }
}
#end_block

#method_before
public static void setHeaderVisible(boolean visible) {
    topMenu.setVisible(visible);
    siteHeader.setVisible(visible && (myAccount != null ? myAccount.getGeneralPreferences().isShowSiteHeader() : true));
}
#method_after
public static void setHeaderVisible(boolean visible) {
    topMenu.setVisible(visible);
    siteHeader.setVisible(visible && getUserPreferences().showSiteHeader());
}
#end_block

#method_before
public static Account getUserAccount() {
    return myAccount;
}
#method_after
public static AccountInfo getUserAccount() {
    return myAccount;
}
#end_block

#method_before
public static boolean isSignedIn() {
    return getUserAccount() != null;
}
#method_after
public static boolean isSignedIn() {
    return xGerritAuth != null;
}
#end_block

#method_before
public static String loginRedirect(String token) {
    if (token == null) {
        token = "";
    } else if (token.startsWith("/")) {
        token = token.substring(1);
    }
    return selfRedirect("/login/" + token);
}
#method_after
public static String loginRedirect(String token) {
    if (token == null) {
        token = "";
    } else if (token.startsWith("/")) {
        token = token.substring(1);
    }
    return selfRedirect("login/") + URL.encodePathSegment("#/" + token);
}
#end_block

#method_before
static void deleteSessionCookie() {
    myAccount = null;
    myAccountDiffPref = null;
    xGerritAuth = null;
    refreshMenuBar();
    // If the cookie was HttpOnly, this request to delete it will
    // most likely not be successful.  We can try anyway though.
    // 
    Cookies.removeCookie("GerritAccount");
}
#method_after
static void deleteSessionCookie() {
    myAccount = AccountInfo.create(0, null, null, null);
    myAccountDiffPref = null;
    editPrefs = null;
    myPrefs = GeneralPreferences.createDefault();
    urlAliasMatcher.clearUserAliases();
    xGerritAuth = null;
    refreshMenuBar();
    // If the cookie was HttpOnly, this request to delete it will
    // most likely not be successful.  We can try anyway though.
    // 
    Cookies.removeCookie("GerritAccount");
}
#end_block

#method_before
@Override
public void onModuleLoad() {
    if (canLoadInIFrame(GWT.getModuleBaseURL() + GWT.getModuleName())) {
        UserAgent.assertNotInIFrame();
    }
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    if (!canLoadInIFrame()) {
        UserAgent.assertNotInIFrame();
    }
    setXsrfToken();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    RpcStatus.INSTANCE = new RpcStatus();
    CallbackGroup cbg = new CallbackGroup();
    getDocIndex(cbg.add(new GerritCallback<DocInfo>() {

        @Override
        public void onSuccess(DocInfo indexInfo) {
            hasDocumentation = indexInfo != null;
            docUrl = selfRedirect("/Documentation/");
        }
    }));
    ConfigServerApi.serverInfo(cbg.add(new GerritCallback<ServerInfo>() {

        @Override
        public void onSuccess(ServerInfo info) {
            myServerInfo = info;
            urlAliasMatcher = new UrlAliasMatcher(info.urlAliases());
            String du = info.gerrit().docUrl();
            if (du != null && !du.isEmpty()) {
                hasDocumentation = true;
                docUrl = du;
            }
            docSearch = info.gerrit().docSearch();
        }
    }));
    HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(cbg.addFinal(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
            }
            if (result.accountDiffPref != null) {
                // TODO: Support options on the GetDetail REST endpoint so that it can
                // also return the preferences. Then we can fetch everything with a
                // single request and we don't need the callback group anymore.
                CallbackGroup cbg = new CallbackGroup();
                AccountApi.self().view("detail").get(cbg.add(new GerritCallback<AccountInfo>() {

                    @Override
                    public void onSuccess(AccountInfo result) {
                        myAccount = result;
                    }
                }));
                AccountApi.self().view("preferences").get(cbg.add(new GerritCallback<GeneralPreferences>() {

                    @Override
                    public void onSuccess(GeneralPreferences prefs) {
                        myPrefs = prefs;
                        onModuleLoad2(result);
                    }
                }));
                AccountApi.getEditPreferences(cbg.addFinal(new GerritCallback<EditPreferences>() {

                    @Override
                    public void onSuccess(EditPreferences prefs) {
                        EditPreferencesInfo prefsInfo = new EditPreferencesInfo();
                        prefs.copyTo(prefsInfo);
                        editPrefs = prefsInfo;
                    }
                }));
            } else {
                myAccount = AccountInfo.create(0, null, null, null);
                myPrefs = GeneralPreferences.createDefault();
                editPrefs = null;
                onModuleLoad2(result);
            }
        }
    }));
}
#end_block

#method_before
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineLabel(C.keyHelp()));
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    final String reportBugText = getConfig().getReportBugText();
    Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, getConfig().getReportBugUrl());
    a.setTarget("_blank");
    a.setStyleName("");
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(a);
}
#method_after
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    String reportBugUrl = info().gerrit().reportBugUrl();
    if (reportBugUrl != null) {
        String reportBugText = info().gerrit().reportBugText();
        Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineLabel(C.keyHelp()));
}
#end_block

#method_before
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            String token = view.getToken();
            History.newItem(token, false);
            dispatchHistoryHooks(token);
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
            lastViewToken = token;
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus();
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    ApiGlue.init();
    applyUserPreferences();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    saveDefaultTheme();
    if (hpd.messages != null) {
        new MessageOfTheDayBar(hpd.messages).show();
    }
    PluginLoader.load(hpd.plugins, token);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            String token = view.getToken();
            History.newItem(token, false);
            dispatchHistoryHooks(token);
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
            lastViewToken = token;
        }
    };
    gBody.add(body);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    ApiGlue.init();
    applyUserPreferences();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    saveDefaultTheme();
    if (hpd.messages != null) {
        new MessageOfTheDayBar(hpd.messages).show();
    }
    PluginLoader.load(hpd.plugins, hpd.pluginsLoadTimeout, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            String token = History.getToken();
            if (token.isEmpty()) {
                token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
            }
            display(token);
        }
    });
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        final LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, m);
        AccountApi.self().view("preferences").get(new AsyncCallback<Preferences>() {

            @Override
            public void onSuccess(Preferences prefs) {
                for (TopMenuItem item : Natives.asList(prefs.my())) {
                    addExtensionLink(myBar, item);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar() {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            if (event.getScreen() instanceof ProjectScreen) {
                menuLeft.selectTab(menuLeft.getWidgetIndex(this));
            }
        }
    };
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    addProjectLink(projectsBar, C.menuProjectsInfo(), ProjectScreen.INFO);
    addProjectLink(projectsBar, C.menuProjectsBranches(), ProjectScreen.BRANCH);
    addProjectLink(projectsBar, C.menuProjectsAccess(), ProjectScreen.ACCESS);
    final LinkMenuItem dashboardsMenuItem = addProjectLink(projectsBar, C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(menu.getName(), bar);
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = info().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (myPrefs.my() != null) {
            myBar.clear();
            String url = null;
            List<TopMenuItem> myMenuItems = Natives.asList(myPrefs.my());
            if (!myMenuItems.isEmpty()) {
                if (myMenuItems.get(0).getUrl().startsWith("#")) {
                    url = myMenuItems.get(0).getUrl().substring(1);
                }
                for (TopMenuItem item : myMenuItems) {
                    addExtensionLink(myBar, item);
                }
            }
            defaultScreenToken = url;
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCHES));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsTags(), ProjectScreen.TAGS));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (hasDocumentation) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#end_block

#method_before
public static void applyUserPreferences() {
    if (myAccount != null) {
        final AccountGeneralPreferences p = myAccount.getGeneralPreferences();
        CopyableLabel.setFlashEnabled(p.isUseFlashClipboard());
        if (siteHeader != null) {
            siteHeader.setVisible(p.isShowSiteHeader());
        }
        if (siteFooter != null) {
            siteFooter.setVisible(p.isShowSiteHeader());
        }
        FormatUtil.setPreferences(myAccount.getGeneralPreferences());
    }
}
#method_after
private static void applyUserPreferences() {
    CopyableLabel.setFlashEnabled(myPrefs.useFlashClipboard());
    if (siteHeader != null) {
        siteHeader.setVisible(myPrefs.showSiteHeader());
    }
    if (siteFooter != null) {
        siteFooter.setVisible(myPrefs.showSiteHeader());
    }
    FormatUtil.setPreferences(myPrefs);
    urlAliasMatcher.updateUserAliases(myPrefs.urlAliases());
}
#end_block

#method_before
private static void whoAmI(boolean canLogOut) {
    AccountInfo account = getUserAccountInfo();
    final UserPopupPanel userPopup = new UserPopupPanel(account, canLogOut, true);
    final FlowPanel userSummaryPanel = new FlowPanel();
    class PopupHandler implements KeyDownHandler, ClickHandler {

        private void showHidePopup() {
            if (userPopup.isShowing() && userPopup.isVisible()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(userSummaryPanel);
            }
        }

        @Override
        public void onClick(ClickEvent event) {
            showHidePopup();
        }

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                showHidePopup();
                event.preventDefault();
            }
        }
    }
    final PopupHandler popupHandler = new PopupHandler();
    final InlineLabel l = new InlineLabel(FormatUtil.name(account));
    l.setStyleName(RESOURCES.css().menuBarUserName());
    final AvatarImage avatar = new AvatarImage(account, 26, false);
    avatar.setStyleName(RESOURCES.css().menuBarUserNameAvatar());
    userSummaryPanel.setStyleName(RESOURCES.css().menuBarUserNamePanel());
    userSummaryPanel.add(l);
    userSummaryPanel.add(avatar);
    // "BLACK DOWN-POINTING SMALL TRIANGLE"
    userSummaryPanel.add(new InlineLabel(" \u25be"));
    userPopup.addAutoHidePartner(userSummaryPanel.getElement());
    FocusPanel fp = new FocusPanel(userSummaryPanel);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(popupHandler);
    fp.addClickHandler(popupHandler);
    menuRight.add(fp);
}
#method_after
private static void whoAmI(boolean canLogOut) {
    AccountInfo account = getUserAccount();
    final UserPopupPanel userPopup = new UserPopupPanel(account, canLogOut, true);
    final FlowPanel userSummaryPanel = new FlowPanel();
    class PopupHandler implements KeyDownHandler, ClickHandler {

        private void showHidePopup() {
            if (userPopup.isShowing() && userPopup.isVisible()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(userSummaryPanel);
            }
        }

        @Override
        public void onClick(ClickEvent event) {
            showHidePopup();
        }

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                showHidePopup();
                event.preventDefault();
            }
        }
    }
    final PopupHandler popupHandler = new PopupHandler();
    final InlineLabel l = new InlineLabel(FormatUtil.name(account));
    l.setStyleName(RESOURCES.css().menuBarUserName());
    final AvatarImage avatar = new AvatarImage(account, 26, false);
    avatar.setStyleName(RESOURCES.css().menuBarUserNameAvatar());
    userSummaryPanel.setStyleName(RESOURCES.css().menuBarUserNamePanel());
    userSummaryPanel.add(l);
    userSummaryPanel.add(avatar);
    // "BLACK DOWN-POINTING SMALL TRIANGLE"
    userSummaryPanel.add(new InlineLabel(" \u25be"));
    userPopup.addAutoHidePartner(userSummaryPanel.getElement());
    FocusPanel fp = new FocusPanel(userSummaryPanel);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(popupHandler);
    fp.addClickHandler(popupHandler);
    menuRight.add(fp);
}
#end_block

#method_before
private static LinkMenuItem addProjectLink(final LinkMenuBar m, final String text, final String panel) {
    LinkMenuItem i = new LinkMenuItem(text, "") {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            Screen screen = event.getScreen();
            Project.NameKey projectKey;
            if (screen instanceof ProjectScreen) {
                projectKey = ((ProjectScreen) screen).getProjectKey();
            } else {
                projectKey = ProjectScreen.getSavedKey();
            }
            if (projectKey != null) {
                setVisible(true);
                setTargetHistoryToken(Dispatcher.toProjectAdmin(projectKey, panel));
            } else {
                setVisible(false);
            }
            super.onScreenLoad(event);
        }
    };
    m.addItem(i);
    return i;
}
#method_after
private static LinkMenuItem addProjectLink(LinkMenuBar m, TopMenuItem item) {
    LinkMenuItem i = new ProjectLinkMenuItem(item.getName(), item.getUrl()) {

        @Override
        protected void onScreenLoad(Project.NameKey project) {
            String p = panel.replace(PROJECT_NAME_MENU_VAR, URL.encodeQueryString(project.get()));
            if (!panel.startsWith("/x/") && !isAbsolute(panel)) {
                UrlBuilder builder = new UrlBuilder();
                builder.setProtocol(Location.getProtocol());
                builder.setHost(Location.getHost());
                String port = Location.getPort();
                if (port != null && !port.isEmpty()) {
                    builder.setPort(Integer.parseInt(port));
                }
                builder.setPath(Location.getPath());
                p = builder.buildString() + p;
            }
            getElement().setPropertyString("href", p);
        }

        @Override
        public void go() {
            String href = getElement().getPropertyString("href");
            if (href.startsWith("#")) {
                super.go();
            } else {
                Window.open(href, getElement().getPropertyString("target"), "");
            }
        }
    };
    if (item.getTarget() != null && !item.getTarget().isEmpty()) {
        i.getElement().setAttribute("target", item.getTarget());
    }
    if (item.getId() != null) {
        i.getElement().setAttribute("id", item.getId());
    }
    m.addItem(i);
    return i;
}
#end_block

#method_before
private static void addDocLink(final LinkMenuBar m, final String text, final String href) {
    final Anchor atag = anchor(text, selfRedirect("/Documentation/" + href));
    atag.setTarget("_blank");
    m.add(atag);
}
#method_after
private static void addDocLink(final LinkMenuBar m, final String text, final String href) {
    final Anchor atag = anchor(text, docUrl + href);
    atag.setTarget("_blank");
    m.add(atag);
}
#end_block

#method_before
private static void addExtensionLink(LinkMenuBar m, TopMenuItem item) {
    if (item.getUrl().startsWith("#") && (item.getTarget() == null || item.getTarget().isEmpty())) {
        LinkMenuItem a = new LinkMenuItem(item.getName(), item.getUrl().substring(1));
        if (item.getId() != null) {
            a.getElement().setAttribute("id", item.getId());
        }
        m.add(a);
    } else {
        Anchor atag = anchor(item.getName(), isAbsolute(item.getUrl()) ? item.getUrl() : selfRedirect(item.getUrl()));
        if (item.getTarget() != null && !item.getTarget().isEmpty()) {
            atag.setTarget(item.getTarget());
        }
        if (item.getId() != null) {
            atag.getElement().setAttribute("id", item.getId());
        }
        m.add(atag);
    }
}
#method_after
private static void addExtensionLink(LinkMenuBar m, TopMenuItem item) {
    if (item.getUrl().startsWith("#") && (item.getTarget() == null || item.getTarget().isEmpty())) {
        LinkMenuItem a = new LinkMenuItem(item.getName(), item.getUrl().substring(1));
        if (item.getId() != null) {
            a.getElement().setAttribute("id", item.getId());
        }
        m.addItem(a);
    } else {
        Anchor atag = anchor(item.getName(), isAbsolute(item.getUrl()) ? item.getUrl() : selfRedirect(item.getUrl()));
        if (item.getTarget() != null && !item.getTarget().isEmpty()) {
            atag.setTarget(item.getTarget());
        }
        if (item.getId() != null) {
            atag.getElement().setAttribute("id", item.getId());
        }
        m.add(atag);
    }
}
#end_block

#method_before
@Test
public void stickyAcrossMultiplePatchSets() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Code-Review").setCopyMaxScore(true);
    cfg.getLabelSections().get("Verified").setCopyAllScoresIfNoCodeChange(true);
    saveProjectConfig(project, cfg);
    String changeId = createChange(REWORK);
    vote(admin, changeId, 2, 1);
    for (int i = 0; i < 5; i++) {
        updateChange(changeId, NO_CODE_CHANGE);
        ChangeInfo c = detailedChange(changeId);
        assertVotes(c, admin, 2, 1, NO_CODE_CHANGE);
    }
    updateChange(changeId, REWORK);
    ChangeInfo c = detailedChange(changeId);
    assertVotes(c, admin, 2, 0, NO_CODE_CHANGE);
}
#method_after
@Test
public void stickyAcrossMultiplePatchSets() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Code-Review").setCopyMaxScore(true);
    cfg.getLabelSections().get("Verified").setCopyAllScoresIfNoCodeChange(true);
    saveProjectConfig(project, cfg);
    String changeId = createChange(REWORK);
    vote(admin, changeId, 2, 1);
    for (int i = 0; i < 5; i++) {
        updateChange(changeId, NO_CODE_CHANGE);
        ChangeInfo c = detailedChange(changeId);
        assertVotes(c, admin, 2, 1, NO_CODE_CHANGE);
    }
    updateChange(changeId, REWORK);
    ChangeInfo c = detailedChange(changeId);
    assertVotes(c, admin, 2, 0, REWORK);
}
#end_block

#method_before
private Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet ps) throws OrmException {
    checkNotNull(ps, "ps should not be null");
    ChangeData cd = changeDataFactory.create(db, ctl);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.approvals();
        checkNotNull(all, "all should not be null");
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(ps.getId())) {
            byUser.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        TreeMap<Integer, PatchSet> patchSets = getPatchSets(cd);
        try (Repository repo = repoManager.openRepository(project.getProject().getNameKey())) {
            // Walk patch sets strictly less than current in descending order.
            Collection<PatchSet> allPrior = patchSets.descendingMap().tailMap(ps.getId().get(), false).values();
            for (PatchSet priorPs : allPrior) {
                List<PatchSetApproval> priorApprovals = all.get(priorPs.getId());
                if (priorApprovals.isEmpty()) {
                    continue;
                }
                ChangeKind kind = changeKindCache.getChangeKind(project, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(ps.getRevision().get()));
                for (PatchSetApproval psa : priorApprovals) {
                    if (!byUser.contains(psa.getLabel(), psa.getAccountId()) && canCopy(project, psa, ps.getId(), kind)) {
                        byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, ps.getId()));
                    }
                }
            }
            return labelNormalizer.normalize(ctl, byUser.values()).getNormalized();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet ps) throws OrmException {
    checkNotNull(ps, "ps should not be null");
    ChangeData cd = changeDataFactory.create(db, ctl);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.approvals();
        checkNotNull(all, "all should not be null");
        Table<String, Account.Id, PatchSetApproval> wontCopy = HashBasedTable.create();
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(ps.getId())) {
            byUser.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        TreeMap<Integer, PatchSet> patchSets = getPatchSets(cd);
        try (Repository repo = repoManager.openRepository(project.getProject().getNameKey())) {
            // Walk patch sets strictly less than current in descending order.
            Collection<PatchSet> allPrior = patchSets.descendingMap().tailMap(ps.getId().get(), false).values();
            for (PatchSet priorPs : allPrior) {
                List<PatchSetApproval> priorApprovals = all.get(priorPs.getId());
                if (priorApprovals.isEmpty()) {
                    continue;
                }
                ChangeKind kind = changeKindCache.getChangeKind(project, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(ps.getRevision().get()));
                for (PatchSetApproval psa : priorApprovals) {
                    if (wontCopy.contains(psa.getLabel(), psa.getAccountId())) {
                        continue;
                    }
                    if (byUser.contains(psa.getLabel(), psa.getAccountId())) {
                        continue;
                    }
                    if (!canCopy(project, psa, ps.getId(), kind)) {
                        wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
                        continue;
                    }
                    byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, ps.getId()));
                }
            }
            return labelNormalizer.normalize(ctl, byUser.values()).getNormalized();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private <K, V, I extends Index<K, V>> void initIndex(IndexDefinition<K, V, I> def, GerritIndexStatus cfg) {
    TreeMap<Integer, Version<V>> versions = scanVersions(def, cfg);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version<V> search = null;
    List<Version<V>> write = Lists.newArrayListWithCapacity(2);
    for (Version<V> v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(runReindexMsg);
    }
    IndexFactory<K, V, I> factory = def.getIndexFactory();
    I searchIndex = factory.create(search.schema);
    IndexCollection<K, V, I> indexes = def.getIndexCollection();
    indexes.setSearchIndex(searchIndex);
    for (Version<V> v : write) {
        if (v.schema != null) {
            if (v.version != search.version) {
                indexes.addWriteIndex(factory.create(v.schema));
            } else {
                indexes.addWriteIndex(searchIndex);
            }
        }
    }
    markNotReady(cfg, def.getName(), versions.values(), write);
    int latest = write.get(0).version;
    if (onlineUpgrade && latest != search.version) {
        OnlineReindexer<K, V, I> reindexer = new OnlineReindexer<>(def, latest);
        synchronized (this) {
            if (!reindexers.containsKey(def.getName())) {
                reindexers.put(def.getName(), reindexer);
                reindexer.start();
            }
        }
    }
}
#method_after
private <K, V, I extends Index<K, V>> void initIndex(IndexDefinition<K, V, I> def, GerritIndexStatus cfg) {
    TreeMap<Integer, Version<V>> versions = scanVersions(def, cfg);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version<V> search = null;
    List<Version<V>> write = Lists.newArrayListWithCapacity(2);
    for (Version<V> v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(runReindexMsg);
    }
    IndexFactory<K, V, I> factory = def.getIndexFactory();
    I searchIndex = factory.create(search.schema);
    IndexCollection<K, V, I> indexes = def.getIndexCollection();
    indexes.setSearchIndex(searchIndex);
    for (Version<V> v : write) {
        if (v.schema != null) {
            if (v.version != search.version) {
                indexes.addWriteIndex(factory.create(v.schema));
            } else {
                indexes.addWriteIndex(searchIndex);
            }
        }
    }
    markNotReady(cfg, def.getName(), versions.values(), write);
    int latest = write.get(0).version;
    OnlineReindexer<K, V, I> reindexer = new OnlineReindexer<>(def, latest);
    reindexers.put(def.getName(), reindexer);
    if (onlineUpgrade && latest != search.version) {
        synchronized (this) {
            if (!reindexers.containsKey(def.getName())) {
                reindexer.start();
            }
        }
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    try {
        if (luceneVersionManager.startReindexer(name, force)) {
            stdout.println("Reindexer started");
        } else {
            stdout.println("Nothing to reindex, index is already the latest version");
        }
    } catch (ReindexerAlreadyRunningException e) {
        throw new UnloggedFailure("Failed to start reindexer: " + e.getMessage());
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    try {
        if (luceneVersionManager.startReindexer(name, force)) {
            stdout.println("Reindexer started");
        } else {
            stdout.println("Nothing to reindex, index is already the latest version");
        }
    } catch (ReindexerAlreadyRunningException e) {
        throw die("Failed to start reindexer: " + e.getMessage());
    }
}
#end_block

#method_before
public boolean appliesTo(Branch.NameKey branch) {
    for (RefSpec r : refSpecs) {
        if (r.matchSource(branch.get())) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean appliesTo(Branch.NameKey branch) {
    for (RefSpec r : matchingRefSpecs) {
        if (r.matchSource(branch.get())) {
            return true;
        }
    }
    for (RefSpec r : multiMatchRefSpecs) {
        if (r.matchSource(branch.get())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder ret = new StringBuilder();
    ret.append("[SubscribeSection, project=");
    ret.append(project);
    ret.append(", refs=[");
    for (RefSpec r : refSpecs) {
        ret.append(r.toString());
        ret.append(", ");
    }
    ret.append("]");
    return ret.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder ret = new StringBuilder();
    ret.append("[SubscribeSection, project=");
    ret.append(project);
    if (!matchingRefSpecs.isEmpty()) {
        ret.append(", matching=[");
        for (RefSpec r : matchingRefSpecs) {
            ret.append(r.toString());
            ret.append(", ");
        }
    }
    if (!multiMatchRefSpecs.isEmpty()) {
        ret.append(", all=[");
        for (RefSpec r : multiMatchRefSpecs) {
            ret.append(r.toString());
            ret.append(", ");
        }
    }
    ret.append("]");
    return ret.toString();
}
#end_block

#method_before
@Test
@GerritConfig(name = "submodule.enableSuperProjectSubscriptions", value = "false")
public void testSubscriptionWithoutGlobalServerSetting() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#method_after
@Test
@GerritConfig(name = "submodule.enableSuperProjectSubscriptions", value = "false")
public void testSubscriptionWithoutGlobalServerSetting() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#end_block

#method_before
@Test
public void testSubscriptionToEmptyRepo() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isTrue();
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#method_after
@Test
public void testSubscriptionToEmptyRepo() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isTrue();
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#end_block

#method_before
@Test
public void testSubscriptionToExistingRepo() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isTrue();
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#method_after
@Test
public void testSubscriptionToExistingRepo() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isTrue();
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#end_block

#method_before
@Test
public void testSubscriptionWildcardACLForSingleBranch() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    // master is allowed to be subscribed to any superprojects branch:
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", null);
    // create 'branch':
    pushChangeTo(superRepo, "branch");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(superRepo, "branch", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
    expectToHaveSubmoduleState(superRepo, "branch", "subscribed-to-project", subHEAD);
}
#method_after
@Test
public void testSubscriptionWildcardACLForSingleBranch() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    // master is allowed to be subscribed to master branch only:
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", null);
    // create 'branch':
    pushChangeTo(superRepo, "branch");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(superRepo, "branch", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
    assertThat(hasSubmodule(superRepo, "branch", "subscribed-to-project")).isFalse();
}
#end_block

#method_before
@Test
public void testSubscriptionWildcardACLForMissingProject() throws Exception {
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/*", "not-existing-super-project", "refs/heads/*");
    pushChangeTo(subRepo, "master");
}
#method_after
@Test
public void testSubscriptionWildcardACLForMissingProject() throws Exception {
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/*", "not-existing-super-project", "refs/heads/*");
    pushChangeTo(subRepo, "master");
}
#end_block

#method_before
@Test
public void testSubscriptionWildcardACLForMissingBranch() throws Exception {
    createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/*", "super-project", "refs/heads/*");
    pushChangeTo(subRepo, "foo");
}
#method_after
@Test
public void testSubscriptionWildcardACLForMissingBranch() throws Exception {
    createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/*", "super-project", "refs/heads/*");
    pushChangeTo(subRepo, "foo");
}
#end_block

#method_before
@Test
public void testSubscriptionWildcardACLForMissingGitmodules() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/*", "super-project", "refs/heads/*");
    pushChangeTo(superRepo, "master");
    pushChangeTo(subRepo, "master");
}
#method_after
@Test
public void testSubscriptionWildcardACLForMissingGitmodules() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/*", "super-project", "refs/heads/*");
    pushChangeTo(superRepo, "master");
    pushChangeTo(subRepo, "master");
}
#end_block

#method_before
@Test
public void testSubscriptionWildcardACLOneOnOneMapping() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    // any branch is allowed to be subscribed to the same superprojects branch:
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/*", "super-project", "refs/heads/*");
    // create 'branch' in both repos:
    pushChangeTo(superRepo, "branch");
    pushChangeTo(subRepo, "branch");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(superRepo, "branch", "subscribed-to-project", "branch");
    ObjectId subHEAD1 = pushChangeTo(subRepo, "master");
    ObjectId subHEAD2 = pushChangeTo(subRepo, "branch");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD1);
    expectToHaveSubmoduleState(superRepo, "branch", "subscribed-to-project", subHEAD2);
    // Now test that cross subscriptions do not work:
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "branch");
    ObjectId subHEAD3 = pushChangeTo(subRepo, "branch");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD1);
    expectToHaveSubmoduleState(superRepo, "branch", "subscribed-to-project", subHEAD3);
}
#method_after
@Test
public void testSubscriptionWildcardACLOneOnOneMapping() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    // any branch is allowed to be subscribed to the same superprojects branch:
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/*", "super-project", "refs/heads/*");
    // create 'branch' in both repos:
    pushChangeTo(superRepo, "branch");
    pushChangeTo(subRepo, "branch");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(superRepo, "branch", "subscribed-to-project", "branch");
    ObjectId subHEAD1 = pushChangeTo(subRepo, "master");
    ObjectId subHEAD2 = pushChangeTo(subRepo, "branch");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD1);
    expectToHaveSubmoduleState(superRepo, "branch", "subscribed-to-project", subHEAD2);
    // Now test that cross subscriptions do not work:
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "branch");
    ObjectId subHEAD3 = pushChangeTo(subRepo, "branch");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD1);
    expectToHaveSubmoduleState(superRepo, "branch", "subscribed-to-project", subHEAD3);
}
#end_block

#method_before
@Test
public void testSubscriptionWildcardACLForManyBranches() throws Exception {
    createProjectWithPush("inherit-from");
    Project.NameKey inherit = new Project.NameKey(name("inherit-from"));
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project", inherit);
    TestRepository<?> subRepo2 = createProjectWithPush("subscribed-to-project2", inherit);
    // Any branch is allowed to be subscribed to any superproject branch:
    allowSubmoduleSubscription("inherit-from", "refs/heads/*", "super-project", null);
    // create 'branch' in both repos:
    pushChangeTo(superRepo, "branch");
    pushChangeTo(subRepo, "branch");
    pushChangeTo(subRepo2, "branch2");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project2", "master");
    createSubmoduleSubscription(superRepo, "branch", "subscribed-to-project", "branch");
    createSubmoduleSubscription(superRepo, "branch", "subscribed-to-project2", "branch2");
    ObjectId subHEAD1m = pushChangeTo(subRepo, "master");
    ObjectId subHEAD1b = pushChangeTo(subRepo, "branch");
    ObjectId subHEAD2m = pushChangeTo(subRepo, "master");
    ObjectId subHEAD2b = pushChangeTo(subRepo, "branch2");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD1m);
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project2", subHEAD2m);
    expectToHaveSubmoduleState(superRepo, "branch", "subscribed-to-project", subHEAD1b);
    expectToHaveSubmoduleState(superRepo, "branch", "subscribed-to-project2", subHEAD2b);
}
#method_after
@Test
public void testSubscriptionWildcardACLForManyBranches() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    // Any branch is allowed to be subscribed to any superproject branch:
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/*", "super-project", null, false);
    pushChangeTo(superRepo, "branch");
    pushChangeTo(subRepo, "another-branch");
    createSubmoduleSubscription(superRepo, "branch", "subscribed-to-project", "another-branch");
    ObjectId subHEAD = pushChangeTo(subRepo, "another-branch");
    expectToHaveSubmoduleState(superRepo, "branch", "subscribed-to-project", subHEAD);
}
#end_block

#method_before
@Test
@GerritConfig(name = "submodule.verboseSuperprojectUpdate", value = "false")
public void testSubmoduleShortCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    // The first update doesn't include any commit messages
    ObjectId subRepoId = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subRepoId);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n");
    // Any following update also has a short message
    subRepoId = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subRepoId);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n");
}
#method_after
@Test
@GerritConfig(name = "submodule.verboseSuperprojectUpdate", value = "false")
public void testSubmoduleShortCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    // The first update doesn't include any commit messages
    ObjectId subRepoId = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subRepoId);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n");
    // Any following update also has a short message
    subRepoId = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subRepoId);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n");
}
#end_block

#method_before
@Test
public void testSubmoduleCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'" + "\n  - " + subCommitMsg.getFullMessage().replace("\n", "\n    "));
}
#method_after
@Test
public void testSubmoduleCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'" + "\n  - " + subCommitMsg.getFullMessage().replace("\n", "\n    "));
}
#end_block

#method_before
@Test
public void testSubscriptionUnsubscribe() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEADbeforeUnsubscribing = pushChangeTo(subRepo, "master");
    deleteAllSubscriptions(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
    pushChangeTo(superRepo, "refs/heads/master", "commit after unsubscribe", "");
    pushChangeTo(subRepo, "refs/heads/master", "commit after unsubscribe", "");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
}
#method_after
@Test
public void testSubscriptionUnsubscribe() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEADbeforeUnsubscribing = pushChangeTo(subRepo, "master");
    deleteAllSubscriptions(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
    pushChangeTo(superRepo, "refs/heads/master", "commit after unsubscribe", "");
    pushChangeTo(subRepo, "refs/heads/master", "commit after unsubscribe", "");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
}
#end_block

#method_before
@Test
public void testSubscriptionUnsubscribeByDeletingGitModules() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEADbeforeUnsubscribing = pushChangeTo(subRepo, "master");
    deleteGitModulesFile(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
    pushChangeTo(superRepo, "refs/heads/master", "commit after unsubscribe", "");
    pushChangeTo(subRepo, "refs/heads/master", "commit after unsubscribe", "");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
}
#method_after
@Test
public void testSubscriptionUnsubscribeByDeletingGitModules() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEADbeforeUnsubscribing = pushChangeTo(subRepo, "master");
    deleteGitModulesFile(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
    pushChangeTo(superRepo, "refs/heads/master", "commit after unsubscribe", "");
    pushChangeTo(subRepo, "refs/heads/master", "commit after unsubscribe", "");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
}
#end_block

#method_before
@Test
public void testSubscriptionToDifferentBranches() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/foo", "super-project", "refs/heads/master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "foo");
    ObjectId subFoo = pushChangeTo(subRepo, "foo");
    pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subFoo);
}
#method_after
@Test
public void testSubscriptionToDifferentBranches() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/foo", "super-project", "refs/heads/master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "foo");
    ObjectId subFoo = pushChangeTo(subRepo, "foo");
    pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subFoo);
}
#end_block

#method_before
@Test
public void testBranchCircularSubscription() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    allowSubmoduleSubscription("super-project", "refs/heads/master", "subscribed-to-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(subRepo, "master", "super-project", "master");
    pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    assertThat(hasSubmodule(subRepo, "master", "super-project")).isFalse();
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#method_after
@Test
public void testBranchCircularSubscription() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    allowMatchingSubmoduleSubscription("super-project", "refs/heads/master", "subscribed-to-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(subRepo, "master", "super-project", "master");
    pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    assertThat(hasSubmodule(subRepo, "master", "super-project")).isFalse();
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#end_block

#method_before
@Test
public void testProjectCircularSubscription() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    allowSubmoduleSubscription("super-project", "refs/heads/dev", "subscribed-to-project", "refs/heads/dev");
    pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    pushChangeTo(subRepo, "dev");
    pushChangeTo(superRepo, "dev");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(subRepo, "dev", "super-project", "dev");
    ObjectId subMasterHead = pushChangeTo(subRepo, "master");
    ObjectId superDevHead = pushChangeTo(superRepo, "dev");
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isTrue();
    assertThat(hasSubmodule(subRepo, "dev", "super-project")).isTrue();
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subMasterHead);
    expectToHaveSubmoduleState(subRepo, "dev", "super-project", superDevHead);
}
#method_after
@Test
public void testProjectCircularSubscription() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    allowMatchingSubmoduleSubscription("super-project", "refs/heads/dev", "subscribed-to-project", "refs/heads/dev");
    pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    pushChangeTo(subRepo, "dev");
    pushChangeTo(superRepo, "dev");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(subRepo, "dev", "super-project", "dev");
    ObjectId subMasterHead = pushChangeTo(subRepo, "master");
    ObjectId superDevHead = pushChangeTo(superRepo, "dev");
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isTrue();
    assertThat(hasSubmodule(subRepo, "dev", "super-project")).isTrue();
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subMasterHead);
    expectToHaveSubmoduleState(subRepo, "dev", "super-project", superDevHead);
}
#end_block

#method_before
@Test
public void testSubscriptionFailOnWrongProjectACL() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "wrong-super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#method_after
@Test
public void testSubscriptionFailOnWrongProjectACL() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "wrong-super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#end_block

#method_before
@Test
public void testSubscriptionFailOnWrongBranchACL() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/wrong-branch");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#method_after
@Test
public void testSubscriptionFailOnWrongBranchACL() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/wrong-branch");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#end_block

#method_before
@Test
public void testSubscriptionInheritACL() throws Exception {
    createProjectWithPush("config-repo");
    createProjectWithPush("config-repo2", new Project.NameKey(name("config-repo")));
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project", new Project.NameKey(name("config-repo2")));
    allowSubmoduleSubscription("config-repo", "refs/heads/*", "super-project", "refs/heads/*");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#method_after
@Test
public void testSubscriptionInheritACL() throws Exception {
    createProjectWithPush("config-repo");
    createProjectWithPush("config-repo2", new Project.NameKey(name("config-repo")));
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project", new Project.NameKey(name("config-repo2")));
    allowMatchingSubmoduleSubscription("config-repo", "refs/heads/*", "super-project", "refs/heads/*");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#end_block

#method_before
@Test
public void testAllowedButNotSubscribed() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    subRepo.branch("HEAD").commit().insertChangeId().message("some change").add("b.txt", "b contents for testing").create();
    String refspec = "HEAD:refs/heads/master";
    PushResult r = Iterables.getOnlyElement(subRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec(refspec)).call());
    assertThat(r.getMessages()).doesNotContain("error");
    assertThat(r.getRemoteUpdate("refs/heads/master").getStatus()).isEqualTo(RemoteRefUpdate.Status.OK);
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#method_after
@Test
public void testAllowedButNotSubscribed() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    subRepo.branch("HEAD").commit().insertChangeId().message("some change").add("b.txt", "b contents for testing").create();
    String refspec = "HEAD:refs/heads/master";
    PushResult r = Iterables.getOnlyElement(subRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec(refspec)).call());
    assertThat(r.getMessages()).doesNotContain("error");
    assertThat(r.getRemoteUpdate("refs/heads/master").getStatus()).isEqualTo(RemoteRefUpdate.Status.OK);
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#end_block

#method_before
@Test
public void testSubscriptionDeepRelative() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("nested/subscribed-to-project");
    // master is allowed to be subscribed to any superprojects branch:
    allowSubmoduleSubscription("nested/subscribed-to-project", "refs/heads/master", "super-project", null);
    pushChangeTo(subRepo, "master");
    createRelativeSubmoduleSubscription(superRepo, "master", "../", "nested/subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "nested/subscribed-to-project", subHEAD);
}
#method_after
@Test
public void testSubscriptionDeepRelative() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("nested/subscribed-to-project");
    // master is allowed to be subscribed to any superprojects branch:
    allowMatchingSubmoduleSubscription("nested/subscribed-to-project", "refs/heads/master", "super-project", null);
    pushChangeTo(subRepo, "master");
    createRelativeSubmoduleSubscription(superRepo, "master", "../", "nested/subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "nested/subscribed-to-project", subHEAD);
}
#end_block

#method_before
public List<PatchSetApproval> addReviewers(ReviewDb db, ChangeNotes notes, ChangeUpdate update, LabelTypes labelTypes, Change change, Iterable<Account.Id> wantReviewers) throws OrmException {
    PatchSet.Id psId = change.currentPatchSetId();
    Collection<Account.Id> existingReviewers;
    if (migration.readChanges()) {
        // If using NoteDB, we only want reviewers in the REVIEWER state.
        existingReviewers = notes.load().getReviewers().byState(REVIEWER);
    } else {
        // Prior to NoteDB, we gather all reviewers regardless of state.
        existingReviewers = getReviewers(db, notes).all();
    }
    // Existing reviewers should include pending additions in the REVIEWER
    // state, taken from ChangeUpdate.
    existingReviewers = Lists.newArrayList(existingReviewers);
    for (Map.Entry<Account.Id, ReviewerStateInternal> entry : update.reviewers().entrySet()) {
        if (entry.getValue() == REVIEWER) {
            existingReviewers.add(entry.getKey());
        }
    }
    return addReviewers(db, update, labelTypes, change, psId, false, null, null, wantReviewers, existingReviewers);
}
#method_after
public List<PatchSetApproval> addReviewers(ReviewDb db, ChangeNotes notes, ChangeUpdate update, LabelTypes labelTypes, Change change, Iterable<Account.Id> wantReviewers) throws OrmException {
    PatchSet.Id psId = change.currentPatchSetId();
    Collection<Account.Id> existingReviewers;
    if (migration.readChanges()) {
        // If using NoteDB, we only want reviewers in the REVIEWER state.
        existingReviewers = notes.load().getReviewers().byState(REVIEWER);
    } else {
        // Prior to NoteDB, we gather all reviewers regardless of state.
        existingReviewers = getReviewers(db, notes).all();
    }
    // Existing reviewers should include pending additions in the REVIEWER
    // state, taken from ChangeUpdate.
    existingReviewers = Lists.newArrayList(existingReviewers);
    for (Map.Entry<Account.Id, ReviewerStateInternal> entry : update.getReviewers().entrySet()) {
        if (entry.getValue() == REVIEWER) {
            existingReviewers.add(entry.getKey());
        }
    }
    return addReviewers(db, update, labelTypes, change, psId, false, null, null, wantReviewers, existingReviewers);
}
#end_block

#method_before
private Collection<Account.Id> addCcs(ChangeUpdate update, Collection<Account.Id> wantCCs, ReviewerSet existingReviewers) {
    Set<Account.Id> need = new LinkedHashSet<>(wantCCs);
    need.removeAll(existingReviewers.all());
    need.removeAll(update.reviewers().keySet());
    for (Account.Id account : need) {
        update.putReviewer(account, CC);
    }
    return need;
}
#method_after
private Collection<Account.Id> addCcs(ChangeUpdate update, Collection<Account.Id> wantCCs, ReviewerSet existingReviewers) {
    Set<Account.Id> need = new LinkedHashSet<>(wantCCs);
    need.removeAll(existingReviewers.all());
    need.removeAll(update.getReviewers().keySet());
    for (Account.Id account : need) {
        update.putReviewer(account, CC);
    }
    return need;
}
#end_block

#method_before
@Override
public void starChange(String id) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void starChange(String changeId) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void unstarChange(String id) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void unstarChange(String changeId) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<AgreementInfo> apply(AccountResource resource) throws AuthException {
    if (self.get() != resource.getUser()) {
        throw new AuthException("not allowed to get agreements");
    }
    List<AgreementInfo> results = Lists.newArrayList();
    Collection<ContributorAgreement> cas = projectCache.getAllProjects().getConfig().getContributorAgreements();
    for (ContributorAgreement ca : cas) {
        List<AccountGroup.UUID> groupIds = Lists.newArrayList();
        for (PermissionRule rule : ca.getAccepted()) {
            if ((rule.getAction() == Action.ALLOW) && (rule.getGroup() != null)) {
                if (rule.getGroup().getUUID() == null) {
                    log.warn("group \"" + rule.getGroup().getName() + "\" does not " + " exist, referenced in CLA \"" + ca.getName() + "\"");
                } else {
                    groupIds.add(new AccountGroup.UUID(rule.getGroup().getUUID().get()));
                }
            }
        }
        if (self.get().getEffectiveGroups().containsAnyOf(groupIds)) {
            AgreementInfo info = new AgreementInfo();
            info.name = ca.getName();
            info.description = ca.getDescription();
            info.url = ca.getAgreementUrl();
            results.add(info);
        }
    }
    return results;
}
#method_after
@Override
public List<AgreementInfo> apply(AccountResource resource) throws RestApiException {
    if (!agreementsEnabled) {
        throw new MethodNotAllowedException("contributor agreements disabled");
    }
    if (self.get() != resource.getUser()) {
        throw new AuthException("not allowed to get contributor agreements");
    }
    IdentifiedUser user = identifiedUserFactory.create(self.get().getAccountId());
    List<AgreementInfo> results = new ArrayList<>();
    Collection<ContributorAgreement> cas = projectCache.getAllProjects().getConfig().getContributorAgreements();
    for (ContributorAgreement ca : cas) {
        List<AccountGroup.UUID> groupIds = new ArrayList<>();
        for (PermissionRule rule : ca.getAccepted()) {
            if ((rule.getAction() == Action.ALLOW) && (rule.getGroup() != null)) {
                if (rule.getGroup().getUUID() != null) {
                    groupIds.add(rule.getGroup().getUUID());
                } else {
                    log.warn("group \"" + rule.getGroup().getName() + "\" does not " + " exist, referenced in CLA \"" + ca.getName() + "\"");
                }
            }
        }
        if (user.getEffectiveGroups().containsAnyOf(groupIds)) {
            AgreementInfo info = new AgreementInfo();
            info.name = ca.getName();
            info.description = ca.getDescription();
            info.url = ca.getAgreementUrl();
            results.add(info);
        }
    }
    return results;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    get(ACCOUNT_KIND, "agreements").to(GetAgreements.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    DynamicMap.mapOf(binder(), STAR_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watched.projects").to(GetWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects").to(PostWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects:delete").to(DeleteWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    get(ACCOUNT_KIND, "agreements").to(GetAgreements.class);
    put(ACCOUNT_KIND, "agreements").to(PutAgreement.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    child(ACCOUNT_KIND, "stars.changes").to(Stars.class);
    get(STAR_KIND).to(Stars.Get.class);
    post(STAR_KIND).to(Stars.Post.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#end_block

#method_before
@Override
public void starChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        starredChangesCreate.setChange(rsrc);
        starredChangesCreate.apply(account, new StarredChanges.EmptyInput());
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot star change", e);
    }
}
#method_after
@Override
public void starChange(String changeId) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(changeId));
        starredChangesCreate.setChange(rsrc);
        starredChangesCreate.apply(account, new StarredChanges.EmptyInput());
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot star change", e);
    }
}
#end_block

#method_before
@Override
public void unstarChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        AccountResource.StarredChange starredChange = new AccountResource.StarredChange(account.getUser(), rsrc);
        starredChangesDelete.apply(starredChange, new StarredChanges.EmptyInput());
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot unstar change", e);
    }
}
#method_after
@Override
public void unstarChange(String changeId) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(changeId));
        AccountResource.StarredChange starredChange = new AccountResource.StarredChange(account.getUser(), rsrc);
        starredChangesDelete.apply(starredChange, new StarredChanges.EmptyInput());
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot unstar change", e);
    }
}
#end_block

#method_before
@Override
public void addEmail(EmailInput input) throws RestApiException {
    AccountResource.Email rsrc = new AccountResource.Email(account.getUser(), input.email);
    try {
        createEmailFactory.create(input.email).apply(rsrc, input);
    } catch (EmailException | OrmException e) {
        throw new RestApiException("Cannot add email", e);
    }
}
#method_after
@Override
public void addEmail(EmailInput input) throws RestApiException {
    AccountResource.Email rsrc = new AccountResource.Email(account.getUser(), input.email);
    try {
        createEmailFactory.create(input.email).apply(rsrc, input);
    } catch (EmailException | OrmException | IOException e) {
        throw new RestApiException("Cannot add email", e);
    }
}
#end_block

#method_before
@Override
public List<SshKeyInfo> listSshKeys() throws RestApiException {
    try {
        return getSshKeys.apply(account);
    } catch (OrmException e) {
        throw new RestApiException("Cannot list SSH keys", e);
    }
}
#method_after
@Override
public List<SshKeyInfo> listSshKeys() throws RestApiException {
    try {
        return getSshKeys.apply(account);
    } catch (OrmException | IOException | ConfigInvalidException e) {
        throw new RestApiException("Cannot list SSH keys", e);
    }
}
#end_block

#method_before
@Override
public SshKeyInfo addSshKey(String key) throws RestApiException {
    AddSshKey.Input in = new AddSshKey.Input();
    in.raw = RawInputUtil.create(key);
    try {
        return addSshKey.apply(account, in).value();
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot add SSH key", e);
    }
}
#method_after
@Override
public SshKeyInfo addSshKey(String key) throws RestApiException {
    AddSshKey.Input in = new AddSshKey.Input();
    in.raw = RawInputUtil.create(key);
    try {
        return addSshKey.apply(account, in).value();
    } catch (OrmException | IOException | ConfigInvalidException e) {
        throw new RestApiException("Cannot add SSH key", e);
    }
}
#end_block

#method_before
@After
public void cleanUp() throws Exception {
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    try {
        fetch(allUsersRepo, RefNames.REFS_USERS_DEFAULT + ":defaults");
    } catch (TransportException e) {
        if (e.getMessage().equals("Remote does not have " + RefNames.REFS_USERS_DEFAULT + " available for fetch.")) {
            return;
        }
        throw e;
    }
    allUsersRepo.reset("defaults");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Delete default preferences", VersionedAccountPreferences.PREFERENCES, "");
    push.rm(RefNames.REFS_USERS_DEFAULT).assertOkStatus();
}
#method_after
@After
public void cleanUp() throws Exception {
    try (Repository git = repoManager.openRepository(allUsers)) {
        if (git.exactRef(RefNames.REFS_USERS_DEFAULT) != null) {
            RefUpdate u = git.updateRef(RefNames.REFS_USERS_DEFAULT);
            u.setForceUpdate(true);
            assertThat(u.delete()).isEqualTo(RefUpdate.Result.FORCED);
        }
    }
    accountCache.evictAll();
}
#end_block

#method_before
private static AccountState newState(Account account) {
    return new AccountState(account, ImmutableSet.<AccountGroup.UUID>of(), ImmutableSet.<AccountExternalId>of(), ImmutableSet.<AccountProjectWatch>of());
}
#method_after
private static AccountState newState(Account account) {
    return new AccountState(account, ImmutableSet.<AccountGroup.UUID>of(), ImmutableSet.<AccountExternalId>of(), new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
@After
public void cleanUp() throws Exception {
    gApi.accounts().id(user42.getId().toString()).setPreferences(GeneralPreferencesInfo.defaults());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    try {
        fetch(allUsersRepo, RefNames.REFS_USERS_DEFAULT + ":defaults");
    } catch (TransportException e) {
        if (e.getMessage().equals("Remote does not have " + RefNames.REFS_USERS_DEFAULT + " available for fetch.")) {
            return;
        }
        throw e;
    }
    allUsersRepo.reset("defaults");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Delete default preferences", VersionedAccountPreferences.PREFERENCES, "");
    push.rm(RefNames.REFS_USERS_DEFAULT).assertOkStatus();
}
#method_after
@After
public void cleanUp() throws Exception {
    gApi.accounts().id(user42.getId().toString()).setPreferences(GeneralPreferencesInfo.defaults());
    try (Repository git = repoManager.openRepository(allUsers)) {
        if (git.exactRef(RefNames.REFS_USERS_DEFAULT) != null) {
            RefUpdate u = git.updateRef(RefNames.REFS_USERS_DEFAULT);
            u.setForceUpdate(true);
            assertThat(u.delete()).isEqualTo(RefUpdate.Result.FORCED);
        }
    }
    accountCache.evictAll();
}
#end_block

#method_before
private static AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Collection<AccountExternalId> ids = Collections.emptySet();
    Collection<AccountProjectWatch> projectWatches = Collections.emptySet();
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(account, anon, ids, projectWatches);
}
#method_after
private static AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Collection<AccountExternalId> ids = Collections.emptySet();
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(account, anon, ids, new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException {
    Account account = db.accounts().get(who);
    if (account == null) {
        // Account no longer exists? They are anonymous.
        return missing(who);
    }
    Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    Collection<AccountProjectWatch> projectWatches = Collections.unmodifiableCollection(db.accountProjectWatches().byAccount(who).toList());
    return new AccountState(account, internalGroups, externalIds, projectWatches);
}
#method_after
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException, IOException, ConfigInvalidException {
    Account account = db.accounts().get(who);
    if (account == null) {
        // Account no longer exists? They are anonymous.
        return missing(who);
    }
    Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = readFromGit ? watchConfig.get().getProjectWatches(who) : GetWatchedProjects.readProjectWatchesFromDb(db, who);
    return new AccountState(account, internalGroups, externalIds, projectWatches);
}
#end_block

#method_before
@Override
public Optional<Account.Id> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        final AccountExternalId.Key key = new // 
        AccountExternalId.Key(// 
        AccountExternalId.SCHEME_USERNAME, username);
        final AccountExternalId id = db.accountExternalIds().get(key);
        if (id != null) {
            return Optional.of(id.getAccountId());
        }
        return Optional.absent();
    }
}
#method_after
@Override
public Optional<Account.Id> load(String username) throws Exception {
    AccountExternalId.Key key = new // 
    AccountExternalId.Key(// 
    AccountExternalId.SCHEME_USERNAME, username);
    if (accountIndexes.getSearchIndex() != null) {
        AccountState accountState = accountQueryProvider.get().oneByExternalId(key.get());
        return accountState != null ? Optional.of(accountState.getAccount().getId()) : Optional.<Account.Id>absent();
    }
    try (ReviewDb db = schema.open()) {
        AccountExternalId id = db.accountExternalIds().get(key);
        if (id != null) {
            return Optional.of(id.getAccountId());
        }
        return Optional.absent();
    }
}
#end_block

#method_before
private Change insertPatchSet(ChangeEdit edit, Change change, Repository repo, RevWalk rw, ObjectInserter oi, PatchSet basePatchSet, RevCommit squashed) throws NoSuchProjectException, RestApiException, UpdateException, IOException {
    RefControl ctl = projectControlFactory.controlFor(change.getProject(), edit.getUser()).controlForRef(change.getDest());
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
    PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, squashed);
    inserter.setUploader(ctl.getUser().getAccountId());
    StringBuilder message = new StringBuilder("Patch Set ").append(inserter.getPatchSetId().get()).append(": ");
    ProjectState project = projectCache.get(change.getDest().getParentKey());
    // Previously checked that the base patch set is the current patch set.
    ObjectId prior = ObjectId.fromString(basePatchSet.getRevision().get());
    ChangeKind kind = changeKindCache.getChangeKind(project, repo, prior, squashed);
    if (kind == ChangeKind.NO_CODE_CHANGE) {
        message.append("Commit message was updated.");
    } else {
        message.append("Published edit on patch set ").append(basePatchSet.getPatchSetId()).append(".");
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        bu.setRepository(repo, rw, oi);
        bu.addOp(change.getId(), inserter.setDraft(change.getStatus() == Status.DRAFT || basePatchSet.isDraft()).setMessage(message.toString()));
        bu.execute();
    }
    return inserter.getChange();
}
#method_after
private Change insertPatchSet(ChangeEdit edit, Change change, Repository repo, RevWalk rw, ObjectInserter oi, PatchSet basePatchSet, RevCommit squashed) throws NoSuchProjectException, RestApiException, UpdateException, IOException {
    RefControl ctl = projectControlFactory.controlFor(change.getProject(), edit.getUser()).controlForRef(change.getDest());
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
    PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, squashed);
    inserter.setUploader(edit.getUser().getAccountId());
    StringBuilder message = new StringBuilder("Patch Set ").append(inserter.getPatchSetId().get()).append(": ");
    ProjectState project = projectCache.get(change.getDest().getParentKey());
    // Previously checked that the base patch set is the current patch set.
    ObjectId prior = ObjectId.fromString(basePatchSet.getRevision().get());
    ChangeKind kind = changeKindCache.getChangeKind(project, repo, prior, squashed);
    if (kind == ChangeKind.NO_CODE_CHANGE) {
        message.append("Commit message was updated.");
    } else {
        message.append("Published edit on patch set ").append(basePatchSet.getPatchSetId()).append(".");
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        bu.setRepository(repo, rw, oi);
        bu.addOp(change.getId(), inserter.setDraft(change.getStatus() == Status.DRAFT || basePatchSet.isDraft()).setMessage(message.toString()));
        bu.execute();
    }
    return inserter.getChange();
}
#end_block

#method_before
@Test
public void testSubmoduleSubjectCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'" + "\n  - " + subCommitMsg.getShortMessage());
}
#method_after
@Test
@GerritConfig(name = "submodule.verboseSuperprojectUpdate", value = "SUBJECT_ONLY")
public void testSubmoduleSubjectCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'" + "\n  - " + subCommitMsg.getShortMessage());
}
#end_block

#method_before
@Test
@GerritConfig(name = "submodule.verboseSuperprojectUpdate", value = "true")
public void testSubmoduleCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'" + "\n  - " + subCommitMsg.getFullMessage().replace("\n", "\n    "));
}
#method_after
@Test
public void testSubmoduleCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "* Update " + name("subscribed-to-project") + " from branch 'master'" + "\n  - " + subCommitMsg.getFullMessage().replace("\n", "\n    "));
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    CodeReviewCommit currentCommit;
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    currentCommit = or.rw.parseCommit(r.getObjectId());
    StringBuilder msgbuf = new StringBuilder("");
    PersonIdent author = null;
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        RevCommit newCommit = updateSubmodule(dc, ed, msgbuf, s);
        if (newCommit != null) {
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                author = myIdent;
            }
        }
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already in the branch, return null
    if (newTreeId.equals(currentCommit.getTree())) {
        return null;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentId(currentCommit);
    StringBuilder commitMsg = new StringBuilder("Update git submodules\n\n");
    if (!verboseSuperProject.equals(VerboseSuperprojectUpdate.FALSE)) {
        commitMsg.append(msgbuf);
    }
    commit.setMessage(commitMsg.toString());
    commit.setAuthor(author);
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    CodeReviewCommit currentCommit;
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    currentCommit = or.rw.parseCommit(r.getObjectId());
    StringBuilder msgbuf = new StringBuilder("");
    PersonIdent author = null;
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        RevCommit newCommit = updateSubmodule(dc, ed, msgbuf, s);
        if (newCommit != null) {
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                author = myIdent;
            }
        }
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already in the branch, return null
    if (newTreeId.equals(currentCommit.getTree())) {
        return null;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentId(currentCommit);
    StringBuilder commitMsg = new StringBuilder("Update git submodules\n\n");
    if (verboseSuperProject != VerboseSuperprojectUpdate.FALSE) {
        commitMsg.append(msgbuf);
    }
    commit.setMessage(commitMsg.toString());
    commit.setAuthor(author);
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, CodeReviewCommit currentCommit) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    StringBuilder msgbuf = new StringBuilder("");
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        updateSubmodule(dc, ed, msgbuf, s);
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already updated, just return the commit
    if (newTreeId.equals(currentCommit.getTree())) {
        return currentCommit;
    }
    or.rw.parseBody(currentCommit);
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentIds(currentCommit.getParents());
    if (!verboseSuperProject.equals(VerboseSuperprojectUpdate.FALSE)) {
        commit.setMessage(currentCommit.getFullMessage() + "\n\n*submodules:\n" + msgbuf.toString());
    } else {
        commit.setMessage(currentCommit.getFullMessage());
    }
    commit.setAuthor(currentCommit.getAuthorIdent());
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, CodeReviewCommit currentCommit) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    StringBuilder msgbuf = new StringBuilder("");
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        updateSubmodule(dc, ed, msgbuf, s);
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already updated, just return the commit
    if (newTreeId.equals(currentCommit.getTree())) {
        return currentCommit;
    }
    or.rw.parseBody(currentCommit);
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentIds(currentCommit.getParents());
    if (verboseSuperProject != VerboseSuperprojectUpdate.FALSE) {
        // TODO:czhen handle cherrypick footer
        commit.setMessage(currentCommit.getFullMessage() + "\n\n*submodules:\n" + msgbuf.toString());
    } else {
        commit.setMessage(currentCommit.getFullMessage());
    }
    commit.setAuthor(currentCommit.getAuthorIdent());
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#end_block

#method_before
private RevCommit updateSubmodule(DirCache dc, DirCacheEditor ed, StringBuilder msgbuf, final SubmoduleSubscription s) throws SubmoduleException, IOException {
    OpenRepo subOr;
    try {
        subOr = orm.openRepo(s.getSubmodule().getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access submodule", e);
    }
    DirCacheEntry dce = dc.getEntry(s.getPath());
    RevCommit oldCommit = null;
    if (dce != null) {
        if (!dce.getFileMode().equals(FileMode.GITLINK)) {
            String errMsg = "Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.";
            throw new SubmoduleException(errMsg);
        }
        oldCommit = subOr.rw.parseCommit(dce.getObjectId());
    }
    final RevCommit newCommit;
    if (branchTips.containsKey(s.getSubmodule())) {
        newCommit = branchTips.get(s.getSubmodule());
    } else {
        Ref ref = subOr.repo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            return null;
        }
        newCommit = subOr.rw.parseCommit(ref.getObjectId());
    }
    if (Objects.equals(newCommit, oldCommit)) {
        // gitlink have already been updated for this submodule
        return null;
    }
    ed.add(new PathEdit(s.getPath()) {

        @Override
        public void apply(DirCacheEntry ent) {
            ent.setFileMode(FileMode.GITLINK);
            ent.setObjectId(newCommit.getId());
        }
    });
    if (!verboseSuperProject.equals(VerboseSuperprojectUpdate.FALSE)) {
        createSubmoduleCommitMsg(msgbuf, s, subOr, newCommit, oldCommit);
    }
    subOr.rw.parseBody(newCommit);
    return newCommit;
}
#method_after
private RevCommit updateSubmodule(DirCache dc, DirCacheEditor ed, StringBuilder msgbuf, final SubmoduleSubscription s) throws SubmoduleException, IOException {
    OpenRepo subOr;
    try {
        subOr = orm.openRepo(s.getSubmodule().getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access submodule", e);
    }
    DirCacheEntry dce = dc.getEntry(s.getPath());
    RevCommit oldCommit = null;
    if (dce != null) {
        if (!dce.getFileMode().equals(FileMode.GITLINK)) {
            String errMsg = "Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.";
            throw new SubmoduleException(errMsg);
        }
        oldCommit = subOr.rw.parseCommit(dce.getObjectId());
    }
    final RevCommit newCommit;
    if (branchTips.containsKey(s.getSubmodule())) {
        newCommit = branchTips.get(s.getSubmodule());
    } else {
        Ref ref = subOr.repo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            return null;
        }
        newCommit = subOr.rw.parseCommit(ref.getObjectId());
    }
    if (Objects.equals(newCommit, oldCommit)) {
        // gitlink have already been updated for this submodule
        return null;
    }
    ed.add(new PathEdit(s.getPath()) {

        @Override
        public void apply(DirCacheEntry ent) {
            ent.setFileMode(FileMode.GITLINK);
            ent.setObjectId(newCommit.getId());
        }
    });
    if (verboseSuperProject != VerboseSuperprojectUpdate.FALSE) {
        createSubmoduleCommitMsg(msgbuf, s, subOr, newCommit, oldCommit);
    }
    subOr.rw.parseBody(newCommit);
    return newCommit;
}
#end_block

#method_before
private void createSubmoduleCommitMsg(StringBuilder msgbuf, SubmoduleSubscription s, OpenRepo subOr, RevCommit newCommit, RevCommit oldCommit) throws SubmoduleException {
    msgbuf.append("* Update " + s.getPath());
    msgbuf.append(" from branch '" + s.getSubmodule().getShortName() + "'");
    // newly created submodule gitlink, do not append whole history
    if (oldCommit == null) {
        return;
    }
    try {
        subOr.rw.resetRetain(subOr.canMergeFlag);
        subOr.rw.markStart(newCommit);
        subOr.rw.markUninteresting(oldCommit);
        for (RevCommit c : subOr.rw) {
            subOr.rw.parseBody(c);
            if (verboseSuperProject.equals(VerboseSuperprojectUpdate.SUBJECT_ONLY)) {
                msgbuf.append("\n  - " + c.getShortMessage());
            } else if (verboseSuperProject.equals(VerboseSuperprojectUpdate.TRUE)) {
                msgbuf.append("\n  - " + c.getFullMessage().replace("\n", "\n    "));
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
    }
}
#method_after
private void createSubmoduleCommitMsg(StringBuilder msgbuf, SubmoduleSubscription s, OpenRepo subOr, RevCommit newCommit, RevCommit oldCommit) throws SubmoduleException {
    msgbuf.append("* Update " + s.getPath());
    msgbuf.append(" from branch '" + s.getSubmodule().getShortName() + "'");
    // newly created submodule gitlink, do not append whole history
    if (oldCommit == null) {
        return;
    }
    try {
        subOr.rw.resetRetain(subOr.canMergeFlag);
        subOr.rw.markStart(newCommit);
        subOr.rw.markUninteresting(oldCommit);
        for (RevCommit c : subOr.rw) {
            subOr.rw.parseBody(c);
            if (verboseSuperProject == VerboseSuperprojectUpdate.SUBJECT_ONLY) {
                msgbuf.append("\n  - " + c.getShortMessage());
            } else if (verboseSuperProject == VerboseSuperprojectUpdate.TRUE) {
                msgbuf.append("\n  - " + c.getFullMessage().replace("\n", "\n    "));
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
    }
}
#end_block

#method_before
@Override
public void close() {
    writerThread.shutdown();
    try {
        if (!writerThread.awaitTermination(5, TimeUnit.SECONDS)) {
            log.warn("shutting down with pending Lucene writes");
        }
    } catch (InterruptedException e) {
        log.warn("interrupted waiting for pending Lucene writes", e);
    }
    reopenThread.close();
    // not have flushed.
    try {
        searcherManager.maybeRefreshBlocking();
    } catch (IOException e) {
        log.warn("error finishing pending Lucene writes", e);
    }
    try {
        writer.getIndexWriter().close();
    } catch (AlreadyClosedException e) {
    // Ignore.
    } catch (IOException e) {
        log.warn("error closing Lucene writer", e);
    }
    try {
        dir.close();
    } catch (IOException e) {
        log.warn("error closing Lucene directory", e);
    }
}
#method_after
@Override
public void close() {
    if (autoCommitExecutor != null) {
        autoCommitExecutor.shutdown();
    }
    writerThread.shutdown();
    try {
        if (!writerThread.awaitTermination(5, TimeUnit.SECONDS)) {
            log.warn("shutting down " + name + " index with pending Lucene writes");
        }
    } catch (InterruptedException e) {
        log.warn("interrupted waiting for pending Lucene writes of " + name + " index", e);
    }
    reopenThread.close();
    // not have flushed.
    try {
        searcherManager.maybeRefreshBlocking();
    } catch (IOException e) {
        log.warn("error finishing pending Lucene writes", e);
    }
    try {
        writer.getIndexWriter().close();
    } catch (AlreadyClosedException e) {
    // Ignore.
    } catch (IOException e) {
        log.warn("error closing Lucene writer", e);
    }
    try {
        dir.close();
    } catch (IOException e) {
        log.warn("error closing Lucene directory", e);
    }
}
#end_block

#method_before
private void decodeChangedLines(Multimap<String, IndexableField> doc, ChangeData cd) {
    IndexableField added = Iterables.getFirst(doc.get(ADDED_FIELD), null);
    IndexableField deleted = Iterables.getFirst(doc.get(DELETED_FIELD), null);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    }
}
#method_after
private void decodeChangedLines(Multimap<String, IndexableField> doc, ChangeData cd) {
    IndexableField added = Iterables.getFirst(doc.get(ADDED_FIELD), null);
    IndexableField deleted = Iterables.getFirst(doc.get(DELETED_FIELD), null);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    } else {
        // No ChangedLines stored, likely due to failure during reindexing, for
        // example due to LargeObjectException. But we know the field was
        // requested, so update ChangeData to prevent callers from trying to
        // lazily load it, as that would probably also fail.
        cd.setNoChangedLines();
    }
}
#end_block

#method_before
public synchronized GlobalPluginConfig getGlobalPluginConfig(String pluginName) {
    if (pluginConfigs.containsKey(pluginName)) {
        return pluginConfigs.get(pluginName);
    }
    Path pluginConfigFile = site.etc_dir.resolve(pluginName + ".config");
    FileBasedConfig cfg = new FileBasedConfig(pluginConfigFile.toFile(), FS.DETECTED);
    GlobalPluginConfig pluginConfig = new GlobalPluginConfig(pluginName, cfg, secureStore);
    pluginConfigs.put(pluginName, pluginConfig);
    if (!cfg.getFile().exists()) {
        log.info("No " + pluginConfigFile.toAbsolutePath() + "; assuming defaults");
        return pluginConfig;
    }
    try {
        cfg.load();
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + pluginConfigFile.toAbsolutePath(), e);
    }
    return pluginConfig;
}
#method_after
public synchronized Config getGlobalPluginConfig(String pluginName) {
    if (pluginConfigs.containsKey(pluginName)) {
        return pluginConfigs.get(pluginName);
    }
    Path pluginConfigFile = site.etc_dir.resolve(pluginName + ".config");
    FileBasedConfig cfg = new FileBasedConfig(pluginConfigFile.toFile(), FS.DETECTED);
    GlobalPluginConfig pluginConfig = new GlobalPluginConfig(pluginName, cfg, secureStore);
    pluginConfigs.put(pluginName, pluginConfig);
    if (!cfg.getFile().exists()) {
        log.info("No " + pluginConfigFile.toAbsolutePath() + "; assuming defaults");
        return pluginConfig;
    }
    try {
        cfg.load();
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + pluginConfigFile.toAbsolutePath(), e);
    }
    return pluginConfig;
}
#end_block

#method_before
@Override
public String[] getListForPlugin(String pluginName, String section, String subsection, String name) {
    File pluginConfigFile = site.etc_dir.resolve(pluginName + ".secure.config").toFile();
    if (pluginConfigFile.exists()) {
        FileBasedConfig cfg = new FileBasedConfig(pluginConfigFile, FS.DETECTED);
        try {
            cfg.load();
            return cfg.getStringList(section, subsection, name);
        } catch (Exception e) {
        // Do nothing for now
        }
    }
    return null;
}
#method_after
@Override
public synchronized String[] getListForPlugin(String pluginName, String section, String subsection, String name) {
    FileBasedConfig cfg = null;
    if (pluginSec.containsKey(pluginName)) {
        cfg = pluginSec.get(pluginName);
    } else {
        String filename = pluginName + ".secure.config";
        File pluginConfigFile = site.etc_dir.resolve(filename).toFile();
        if (pluginConfigFile.exists()) {
            cfg = new FileBasedConfig(pluginConfigFile, FS.DETECTED);
            try {
                cfg.load();
                pluginSec.put(pluginName, cfg);
            } catch (IOException | ConfigInvalidException e) {
                throw new RuntimeException("Cannot load " + filename, e);
            }
        }
    }
    return cfg != null ? cfg.getStringList(section, subsection, name) : null;
}
#end_block

#method_before
@Test
public void deleteNonExistingProjectWatch() throws Exception {
    String projectName = project.get();
    // Let another user watch a project
    setApiUser(admin);
    List<ProjectWatchInfo> projectsToWatch = new LinkedList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    // Try to delete a watched project using a different user
    List<ProjectWatchInfo> d = Lists.newArrayList(pwi);
    gApi.accounts().self().deleteWatchedProjects(d);
    // Check that trying to delete a non-existing watch doesn't fail
    gApi.accounts().self().deleteWatchedProjects(d);
}
#method_after
@Test
public void deleteNonExistingProjectWatch() throws Exception {
    String projectName = project.get();
    // Let another user watch a project
    setApiUser(admin);
    List<ProjectWatchInfo> projectsToWatch = new LinkedList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    // Try to delete a watched project using a different user
    List<ProjectWatchInfo> d = Lists.newArrayList(pwi);
    gApi.accounts().self().deleteWatchedProjects(d);
    // Check that trying to delete a non-existing watch doesn't fail
    setApiUser(user);
    gApi.accounts().self().deleteWatchedProjects(d);
}
#end_block

#method_before
public Map<ProjectWatchKey, Collection<NotifyType>> getProjectWatches(Account.Id accountId) throws IOException, ConfigInvalidException {
    try (Repository git = repoManager.openRepository(allUsersName);
        WatchConfig watchConfig = new WatchConfig(accountId)) {
        watchConfig.load(git);
        return watchConfig.getProjectWatches();
    }
}
#method_after
public Map<ProjectWatchKey, Set<NotifyType>> getProjectWatches(Account.Id accountId) throws IOException, ConfigInvalidException {
    try (Repository git = repoManager.openRepository(allUsersName);
        WatchConfig watchConfig = new WatchConfig(accountId)) {
        watchConfig.load(git);
        return watchConfig.getProjectWatches();
    }
}
#end_block

#method_before
public void upsertProjectWatches(Account.Id accountId, Map<ProjectWatchKey, Collection<NotifyType>> newProjectWatches) throws IOException, ConfigInvalidException {
    try (WatchConfig watchConfig = open(accountId)) {
        Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = watchConfig.getProjectWatches();
        projectWatches.putAll(newProjectWatches);
        commit(watchConfig);
    }
}
#method_after
public void upsertProjectWatches(Account.Id accountId, Map<ProjectWatchKey, Set<NotifyType>> newProjectWatches) throws IOException, ConfigInvalidException {
    try (WatchConfig watchConfig = open(accountId)) {
        Map<ProjectWatchKey, Set<NotifyType>> projectWatches = watchConfig.getProjectWatches();
        projectWatches.putAll(newProjectWatches);
        commit(watchConfig);
    }
}
#end_block

#method_before
public void deleteProjectWatches(Account.Id accountId, Collection<ProjectWatchKey> projectWatchKeys) throws IOException, ConfigInvalidException {
    try (WatchConfig watchConfig = open(accountId)) {
        Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = watchConfig.getProjectWatches();
        for (ProjectWatchKey key : projectWatchKeys) {
            projectWatches.remove(key);
        }
        commit(watchConfig);
    }
}
#method_after
public void deleteProjectWatches(Account.Id accountId, Collection<ProjectWatchKey> projectWatchKeys) throws IOException, ConfigInvalidException {
    try (WatchConfig watchConfig = open(accountId)) {
        Map<ProjectWatchKey, Set<NotifyType>> projectWatches = watchConfig.getProjectWatches();
        boolean commit = false;
        for (ProjectWatchKey key : projectWatchKeys) {
            if (projectWatches.remove(key) != null) {
                commit = true;
            }
        }
        if (commit) {
            commit(watchConfig);
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    projectWatches = new HashMap<>();
    Config cfg = readConfig(WATCH_CONFIG);
    for (String projectWatchKey : cfg.getSubsections(PROJECT)) {
        ProjectWatchKey key = ProjectWatchKey.parse(projectWatchKey);
        projectWatches.put(key, new HashSet<NotifyType>());
        List<String> notifyValues = Arrays.asList(cfg.getStringList(PROJECT, projectWatchKey, KEY_NOTIFY));
        if (!notifyValues.contains(NOTIFY_NONE)) {
            for (String notify : notifyValues) {
                try {
                    projectWatches.get(key).add(AccountProjectWatch.NotifyType.valueOf(notify));
                } catch (IllegalArgumentException e) {
                    log.warn(String.format("Project watch configuration %s of account %d" + " contains invalid notify type: %s", projectWatchKey, accountId.get(), notify), e);
                }
            }
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Config cfg = readConfig(WATCH_CONFIG);
    projectWatches = parse(accountId, cfg);
}
#end_block

#method_before
Map<ProjectWatchKey, Collection<NotifyType>> getProjectWatches() {
    checkLoaded();
    return projectWatches;
}
#method_after
Map<ProjectWatchKey, Set<NotifyType>> getProjectWatches() {
    checkLoaded();
    return projectWatches;
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkLoaded();
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated watch configuration\n");
    }
    Config cfg = readConfig(WATCH_CONFIG);
    clearSection(cfg, PROJECT);
    for (Map.Entry<ProjectWatchKey, Collection<NotifyType>> e : projectWatches.entrySet()) {
        if (e.getValue().isEmpty()) {
            // set notify to 'none' since empty sections are not persisted
            cfg.setString(PROJECT, e.getKey().toString(), KEY_NOTIFY, NOTIFY_NONE);
        } else {
            List<String> notifyValues = FluentIterable.from(e.getValue()).transform(new Function<NotifyType, String>() {

                @Override
                public String apply(NotifyType notify) {
                    return notify.name();
                }
            }).toList();
            cfg.setStringList(PROJECT, e.getKey().toString(), KEY_NOTIFY, notifyValues);
        }
    }
    saveConfig(WATCH_CONFIG, cfg);
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkLoaded();
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Updated watch configuration\n");
    }
    Config cfg = readConfig(WATCH_CONFIG);
    for (String projectName : cfg.getSubsections(PROJECT)) {
        cfg.unset(PROJECT, projectName, KEY_NOTIFY);
    }
    Multimap<String, String> notifyValuesByProject = ArrayListMultimap.create();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : projectWatches.entrySet()) {
        NotifyValue notifyValue = NotifyValue.create(e.getKey().filter(), e.getValue());
        notifyValuesByProject.put(e.getKey().project().get(), notifyValue.toString());
    }
    for (Map.Entry<String, Collection<String>> e : notifyValuesByProject.asMap().entrySet()) {
        cfg.setStringList(PROJECT, e.getKey(), KEY_NOTIFY, new ArrayList<>(e.getValue()));
    }
    saveConfig(WATCH_CONFIG, cfg);
    return true;
}
#end_block

#method_before
private void checkLoaded() {
    checkNotNull(projectWatches, "project watches not loaded yet");
}
#method_after
private void checkLoaded() {
    checkState(projectWatches != null, "project watches not loaded yet");
}
#end_block

#method_before
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<>();
    for (AccountState a : args.accountQueryProvider.get().byWatchedProject(project)) {
        Account.Id accountId = a.getAccount().getId();
        for (Map.Entry<ProjectWatchKey, Collection<NotifyType>> e : a.getProjectWatches().entrySet()) {
            if (add(matching, accountId, e.getKey(), e.getValue(), type)) {
                // We only want to prevent matching All-Projects if this filter hits
                projectWatchers.add(accountId);
            }
        }
    }
    for (AccountState a : args.accountQueryProvider.get().byWatchedProject(args.allProjectsName)) {
        for (Map.Entry<ProjectWatchKey, Collection<NotifyType>> e : a.getProjectWatches().entrySet()) {
            Account.Id accountId = a.getAccount().getId();
            if (!projectWatchers.contains(accountId)) {
                add(matching, accountId, e.getKey(), e.getValue(), type);
            }
        }
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc);
                } catch (QueryParseException e) {
                    log.warn("Project {} has invalid notify {} filter \"{}\": {}", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage());
                }
            }
        }
    }
    return matching;
}
#method_after
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching;
    if (args.accountIndexes.getSearchIndex() != null) {
        matching = getWatchersFromIndex(type);
    } else {
        matching = getWatchersFromDb(type);
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc);
                } catch (QueryParseException e) {
                    log.warn("Project {} has invalid notify {} filter \"{}\": {}", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage());
                }
            }
        }
    }
    return matching;
}
#end_block

#method_before
private boolean add(Watchers matching, Account.Id accountId, ProjectWatchKey key, Collection<NotifyType> watchedTypes, NotifyType type) throws OrmException {
    IdentifiedUser user = args.identifiedUserFactory.create(accountId);
    try {
        if (filterMatch(user, key.filter())) {
            // Otherwise, still return true to stop notifications for this user.
            if (watchedTypes.contains(type)) {
                matching.bcc.accounts.add(accountId);
            }
            return true;
        }
    } catch (QueryParseException e) {
    // Ignore broken filter expressions.
    }
    return false;
}
#method_after
private boolean add(Watchers matching, Account.Id accountId, ProjectWatchKey key, Set<NotifyType> watchedTypes, NotifyType type) throws OrmException {
    IdentifiedUser user = args.identifiedUserFactory.create(accountId);
    try {
        if (filterMatch(user, key.filter())) {
            // Otherwise, still return true to stop notifications for this user.
            if (watchedTypes.contains(type)) {
                matching.bcc.accounts.add(accountId);
            }
            return true;
        }
    } catch (QueryParseException e) {
    // Ignore broken filter expressions.
    }
    return false;
}
#end_block

#method_before
private AccountState makeUser(final String name, final String email) {
    final Account.Id userId = new Account.Id(42);
    final Account account = new Account(userId, TimeUtil.nowTs());
    account.setFullName(name);
    account.setPreferredEmail(email);
    return new AccountState(account, Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountExternalId>emptySet(), new HashMap<ProjectWatchKey, Collection<NotifyType>>());
}
#method_after
private AccountState makeUser(final String name, final String email) {
    final Account.Id userId = new Account.Id(42);
    final Account account = new Account(userId, TimeUtil.nowTs());
    account.setFullName(name);
    account.setPreferredEmail(email);
    return new AccountState(account, Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountExternalId>emptySet(), new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
private void updateInDb(Account.Id accountId, List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException, OrmException {
    Set<AccountProjectWatch.Key> keys = new HashSet<>();
    List<AccountProjectWatch> watchedProjects = new LinkedList<>();
    for (ProjectWatchInfo a : input) {
        if (a.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        Project.NameKey projectKey = projectsCollection.parse(a.project).getNameKey();
        AccountProjectWatch.Key key = new AccountProjectWatch.Key(accountId, projectKey, a.filter);
        if (!keys.add(key)) {
            throw new BadRequestException("duplicate entry for project " + key.getProjectName().get() + (!AccountProjectWatch.FILTER_ALL.equals(key.getFilter().get()) ? " and filter " + key.getFilter().get() : ""));
        }
        AccountProjectWatch apw = new AccountProjectWatch(key);
        apw.setNotify(AccountProjectWatch.NotifyType.ABANDONED_CHANGES, toBoolean(a.notifyAbandonedChanges));
        apw.setNotify(AccountProjectWatch.NotifyType.ALL_COMMENTS, toBoolean(a.notifyAllComments));
        apw.setNotify(AccountProjectWatch.NotifyType.NEW_CHANGES, toBoolean(a.notifyNewChanges));
        apw.setNotify(AccountProjectWatch.NotifyType.NEW_PATCHSETS, toBoolean(a.notifyNewPatchSets));
        apw.setNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES, toBoolean(a.notifySubmittedChanges));
        watchedProjects.add(apw);
    }
    dbProvider.get().accountProjectWatches().upsert(watchedProjects);
}
#method_after
private void updateInDb(Account.Id accountId, List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException, OrmException {
    Set<AccountProjectWatch.Key> keys = new HashSet<>();
    List<AccountProjectWatch> watchedProjects = new LinkedList<>();
    for (ProjectWatchInfo a : input) {
        if (a.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        Project.NameKey projectKey = projectsCollection.parse(a.project).getNameKey();
        AccountProjectWatch.Key key = new AccountProjectWatch.Key(accountId, projectKey, a.filter);
        if (!keys.add(key)) {
            throw new BadRequestException("duplicate entry for project " + format(key.getProjectName().get(), key.getFilter().get()));
        }
        AccountProjectWatch apw = new AccountProjectWatch(key);
        apw.setNotify(AccountProjectWatch.NotifyType.ABANDONED_CHANGES, toBoolean(a.notifyAbandonedChanges));
        apw.setNotify(AccountProjectWatch.NotifyType.ALL_COMMENTS, toBoolean(a.notifyAllComments));
        apw.setNotify(AccountProjectWatch.NotifyType.NEW_CHANGES, toBoolean(a.notifyNewChanges));
        apw.setNotify(AccountProjectWatch.NotifyType.NEW_PATCHSETS, toBoolean(a.notifyNewPatchSets));
        apw.setNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES, toBoolean(a.notifySubmittedChanges));
        watchedProjects.add(apw);
    }
    dbProvider.get().accountProjectWatches().upsert(watchedProjects);
}
#end_block

#method_before
private Map<ProjectWatchKey, Collection<NotifyType>> asMap(List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException {
    Map<ProjectWatchKey, Collection<NotifyType>> m = new HashMap<>();
    for (ProjectWatchInfo info : input) {
        if (info.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        ProjectWatchKey key = ProjectWatchKey.create(projectsCollection.parse(info.project).getNameKey(), info.filter);
        if (m.containsKey(key)) {
            throw new BadRequestException("duplicate entry for project " + info.project + (info.filter != null ? " and filter " + info.filter : ""));
        }
        Set<NotifyType> notifyValues = new HashSet<>();
        if (toBoolean(info.notifyAbandonedChanges)) {
            notifyValues.add(NotifyType.ABANDONED_CHANGES);
        }
        if (toBoolean(info.notifyAllComments)) {
            notifyValues.add(NotifyType.ALL_COMMENTS);
        }
        if (toBoolean(info.notifyNewChanges)) {
            notifyValues.add(NotifyType.NEW_CHANGES);
        }
        if (toBoolean(info.notifyNewPatchSets)) {
            notifyValues.add(NotifyType.NEW_PATCHSETS);
        }
        if (toBoolean(info.notifySubmittedChanges)) {
            notifyValues.add(NotifyType.SUBMITTED_CHANGES);
        }
        m.put(key, notifyValues);
    }
    return m;
}
#method_after
private Map<ProjectWatchKey, Set<NotifyType>> asMap(List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException {
    Map<ProjectWatchKey, Set<NotifyType>> m = new HashMap<>();
    for (ProjectWatchInfo info : input) {
        if (info.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        ProjectWatchKey key = ProjectWatchKey.create(projectsCollection.parse(info.project).getNameKey(), info.filter);
        if (m.containsKey(key)) {
            throw new BadRequestException("duplicate entry for project " + format(info.project, info.filter));
        }
        Set<NotifyType> notifyValues = EnumSet.noneOf(NotifyType.class);
        if (toBoolean(info.notifyAbandonedChanges)) {
            notifyValues.add(NotifyType.ABANDONED_CHANGES);
        }
        if (toBoolean(info.notifyAllComments)) {
            notifyValues.add(NotifyType.ALL_COMMENTS);
        }
        if (toBoolean(info.notifyNewChanges)) {
            notifyValues.add(NotifyType.NEW_CHANGES);
        }
        if (toBoolean(info.notifyNewPatchSets)) {
            notifyValues.add(NotifyType.NEW_PATCHSETS);
        }
        if (toBoolean(info.notifySubmittedChanges)) {
            notifyValues.add(NotifyType.SUBMITTED_CHANGES);
        }
        m.put(key, notifyValues);
    }
    return m;
}
#end_block

#method_before
private static AccountState newState(Account account) {
    return new AccountState(account, ImmutableSet.<AccountGroup.UUID>of(), ImmutableSet.<AccountExternalId>of(), new HashMap<ProjectWatchKey, Collection<NotifyType>>());
}
#method_after
private static AccountState newState(Account account) {
    return new AccountState(account, ImmutableSet.<AccountGroup.UUID>of(), ImmutableSet.<AccountExternalId>of(), new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
public Map<ProjectWatchKey, Collection<NotifyType>> getProjectWatches() {
    return projectWatches;
}
#method_after
public Map<ProjectWatchKey, Set<NotifyType>> getProjectWatches() {
    return projectWatches;
}
#end_block

#method_before
private static AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Collection<AccountExternalId> ids = Collections.emptySet();
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(account, anon, ids, new HashMap<ProjectWatchKey, Collection<NotifyType>>());
}
#method_after
private static AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Collection<AccountExternalId> ids = Collections.emptySet();
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(account, anon, ids, new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException, IOException, ConfigInvalidException {
    Account account = db.accounts().get(who);
    if (account == null) {
        // Account no longer exists? They are anonymous.
        return missing(who);
    }
    Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = readFromGit ? watchConfig.get().getProjectWatches(who) : GetWatchedProjects.readProjectWatchesFromDb(db, who);
    return new AccountState(account, internalGroups, externalIds, projectWatches);
}
#method_after
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException, IOException, ConfigInvalidException {
    Account account = db.accounts().get(who);
    if (account == null) {
        // Account no longer exists? They are anonymous.
        return missing(who);
    }
    Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = readFromGit ? watchConfig.get().getProjectWatches(who) : GetWatchedProjects.readProjectWatchesFromDb(db, who);
    return new AccountState(account, internalGroups, externalIds, projectWatches);
}
#end_block

#method_before
@Override
public Optional<Account.Id> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        final AccountExternalId.Key key = new // 
        AccountExternalId.Key(// 
        AccountExternalId.SCHEME_USERNAME, username);
        final AccountExternalId id = db.accountExternalIds().get(key);
        if (id != null) {
            return Optional.of(id.getAccountId());
        }
        return Optional.absent();
    }
}
#method_after
@Override
public Optional<Account.Id> load(String username) throws Exception {
    AccountExternalId.Key key = new // 
    AccountExternalId.Key(// 
    AccountExternalId.SCHEME_USERNAME, username);
    if (accountIndexes.getSearchIndex() != null) {
        AccountState accountState = accountQueryProvider.get().oneByExternalId(key.get());
        return accountState != null ? Optional.of(accountState.getAccount().getId()) : Optional.<Account.Id>absent();
    }
    try (ReviewDb db = schema.open()) {
        AccountExternalId id = db.accountExternalIds().get(key);
        if (id != null) {
            return Optional.of(id.getAccountId());
        }
        return Optional.absent();
    }
}
#end_block

#method_before
private void deleteFromDb(Account.Id accountId, List<ProjectWatchInfo> input) throws OrmException, IOException {
    ResultSet<AccountProjectWatch> watchedProjects = dbProvider.get().accountProjectWatches().byAccount(accountId);
    HashMap<AccountProjectWatch.Key, AccountProjectWatch> watchedProjectsMap = new HashMap<>();
    for (AccountProjectWatch watchedProject : watchedProjects) {
        watchedProjectsMap.put(watchedProject.getKey(), watchedProject);
    }
    List<AccountProjectWatch> watchesToDelete = new LinkedList<>();
    for (ProjectWatchInfo projectInfo : input) {
        AccountProjectWatch.Key key = new AccountProjectWatch.Key(accountId, new Project.NameKey(projectInfo.project), projectInfo.filter);
        if (watchedProjectsMap.containsKey(key)) {
            watchesToDelete.add(watchedProjectsMap.get(key));
        }
    }
    dbProvider.get().accountProjectWatches().delete(watchesToDelete);
    accountCache.evict(accountId);
}
#method_after
private void deleteFromDb(Account.Id accountId, List<ProjectWatchInfo> input) throws OrmException, IOException {
    ResultSet<AccountProjectWatch> watchedProjects = dbProvider.get().accountProjectWatches().byAccount(accountId);
    HashMap<AccountProjectWatch.Key, AccountProjectWatch> watchedProjectsMap = new HashMap<>();
    for (AccountProjectWatch watchedProject : watchedProjects) {
        watchedProjectsMap.put(watchedProject.getKey(), watchedProject);
    }
    List<AccountProjectWatch> watchesToDelete = new LinkedList<>();
    for (ProjectWatchInfo projectInfo : input) {
        AccountProjectWatch.Key key = new AccountProjectWatch.Key(accountId, new Project.NameKey(projectInfo.project), projectInfo.filter);
        if (watchedProjectsMap.containsKey(key)) {
            watchesToDelete.add(watchedProjectsMap.get(key));
        }
    }
    if (!watchesToDelete.isEmpty()) {
        dbProvider.get().accountProjectWatches().delete(watchesToDelete);
        accountCache.evict(accountId);
    }
}
#end_block

#method_before
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to list project watches " + "of other users");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = readFromGit ? watchConfig.getProjectWatches(accountId) : readProjectWatchesFromDb(dbProvider.get(), accountId);
    List<ProjectWatchInfo> projectWatchInfos = new LinkedList<>();
    for (Map.Entry<ProjectWatchKey, Collection<NotifyType>> e : projectWatches.entrySet()) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = e.getKey().filter();
        pwi.project = e.getKey().project().get();
        pwi.notifyAbandonedChanges = toBoolean(e.getValue().contains(NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(e.getValue().contains(NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(e.getValue().contains(NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(e.getValue().contains(NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(e.getValue().contains(NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    return projectWatchInfos;
}
#method_after
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to list project watches " + "of other users");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = readFromGit ? watchConfig.getProjectWatches(accountId) : readProjectWatchesFromDb(dbProvider.get(), accountId);
    List<ProjectWatchInfo> projectWatchInfos = new LinkedList<>();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : projectWatches.entrySet()) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = e.getKey().filter();
        pwi.project = e.getKey().project().get();
        pwi.notifyAbandonedChanges = toBoolean(e.getValue().contains(NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(e.getValue().contains(NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(e.getValue().contains(NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(e.getValue().contains(NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(e.getValue().contains(NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    Collections.sort(projectWatchInfos, new Comparator<ProjectWatchInfo>() {

        @Override
        public int compare(ProjectWatchInfo pwi1, ProjectWatchInfo pwi2) {
            return ComparisonChain.start().compare(pwi1.project, pwi2.project).compare(Strings.nullToEmpty(pwi1.filter), Strings.nullToEmpty(pwi2.filter)).result();
        }
    });
    return projectWatchInfos;
}
#end_block

#method_before
public static Map<ProjectWatchKey, Collection<NotifyType>> readProjectWatchesFromDb(ReviewDb db, Account.Id who) throws OrmException {
    Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = new HashMap<>();
    Collection<AccountProjectWatch> accountProjectWatches = Collections.unmodifiableCollection(db.accountProjectWatches().byAccount(who).toList());
    for (AccountProjectWatch apw : accountProjectWatches) {
        ProjectWatchKey key = ProjectWatchKey.create(apw.getProjectNameKey(), apw.getFilter());
        Set<NotifyType> notifyValues = new HashSet<>();
        if (apw.isNotify(NotifyType.ABANDONED_CHANGES)) {
            notifyValues.add(NotifyType.ABANDONED_CHANGES);
        }
        if (apw.isNotify(NotifyType.ALL_COMMENTS)) {
            notifyValues.add(NotifyType.ALL_COMMENTS);
        }
        if (apw.isNotify(NotifyType.NEW_CHANGES)) {
            notifyValues.add(NotifyType.NEW_CHANGES);
        }
        if (apw.isNotify(NotifyType.NEW_PATCHSETS)) {
            notifyValues.add(NotifyType.NEW_PATCHSETS);
        }
        if (apw.isNotify(NotifyType.SUBMITTED_CHANGES)) {
            notifyValues.add(NotifyType.SUBMITTED_CHANGES);
        }
        projectWatches.put(key, notifyValues);
    }
    return projectWatches;
}
#method_after
public static Map<ProjectWatchKey, Set<NotifyType>> readProjectWatchesFromDb(ReviewDb db, Account.Id who) throws OrmException {
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = new HashMap<>();
    for (AccountProjectWatch apw : db.accountProjectWatches().byAccount(who)) {
        ProjectWatchKey key = ProjectWatchKey.create(apw.getProjectNameKey(), apw.getFilter());
        Set<NotifyType> notifyValues = EnumSet.noneOf(NotifyType.class);
        for (NotifyType notifyType : NotifyType.values()) {
            if (apw.isNotify(notifyType)) {
                notifyValues.add(notifyType);
            }
        }
        projectWatches.put(key, notifyValues);
    }
    return projectWatches;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    CodeReviewCommit merged = toMerge;
    // Modify the fast forward commit with gitlink update
    if (args.submoduleOp.hasSubscription(args.destBranch)) {
        try {
            merged = args.submoduleOp.composeGitlinksCommit(args.destBranch, merged);
        } catch (SubmoduleException | OrmException e) {
            logError("can not update gitlink for the merge commit at branch: " + args.destBranch);
        }
    }
    args.mergeTip.moveTipTo(merged, toMerge);
}
#method_after
@Override
protected void updateRepoImpl(RepoContext ctx) throws IntegrationException {
    args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    PersonIdent caller = ctx.getUser().asIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone());
    if (args.mergeTip.getCurrentTip() == null) {
        throw new IllegalStateException("cannot merge commit " + toMerge.name() + " onto a null tip; expected at least one fast-forward prior to" + " this operation");
    }
    // TODO(dborowitz): args.rw is needed because it's a CodeReviewRevWalk.
    // When hoisting BatchUpdate into MergeOp, we will need to teach
    // BatchUpdate how to produce CodeReviewRevWalks.
    CodeReviewCommit merged = args.mergeUtil.mergeOneCommit(caller, args.serverIdent, ctx.getRepository(), args.rw, ctx.getInserter(), args.destBranch, args.mergeTip.getCurrentTip(), toMerge);
    // Modify the mergy commit with gitlink update
    if (args.submoduleOp.hasSubscription(args.destBranch)) {
        try {
            merged = args.submoduleOp.composeGitlinksCommit(args.destBranch, merged);
        } catch (SubmoduleException | OrmException e) {
            logError("can not update gitlink for the merge commit at branch: " + args.destBranch);
        }
    }
    args.mergeTip.moveTipTo(merged, toMerge);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    PersonIdent caller = ctx.getIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone());
    if (args.mergeTip.getCurrentTip() == null) {
        throw new IllegalStateException("cannot merge commit " + toMerge.name() + " onto a null tip; expected at least one fast-forward prior to" + " this operation");
    }
    // TODO(dborowitz): args.rw is needed because it's a CodeReviewRevWalk.
    // When hoisting BatchUpdate into MergeOp, we will need to teach
    // BatchUpdate how to produce CodeReviewRevWalks.
    CodeReviewCommit merged = args.mergeUtil.mergeOneCommit(caller, args.serverIdent, ctx.getRepository(), args.rw, ctx.getInserter(), args.destBranch, args.mergeTip.getCurrentTip(), toMerge);
    args.mergeTip.moveTipTo(amendGitlink(merged), toMerge);
}
#end_block

#method_before
private void checkSubmitRulesAndState() throws ResourceConflictException {
    for (ChangeData cd : commits.changes.values()) {
        try {
            if (cd.change().getStatus() != Change.Status.NEW) {
                commits.problem(cd.getId(), "Change " + cd.getId() + " is " + cd.change().getStatus().toString().toLowerCase());
            } else {
                checkSubmitRule(cd);
            }
        } catch (ResourceConflictException e) {
            commits.problem(cd.getId(), e.getMessage());
        } catch (OrmException e) {
            String msg = "Error checking submit rules for change";
            log.warn(msg + " " + cd.getId(), e);
            commits.problem(cd.getId(), msg);
        }
    }
    commits.maybeFailVerbose();
}
#method_after
private void checkSubmitRulesAndState(ChangeSet cs) throws ResourceConflictException {
    checkArgument(!cs.furtherHiddenChanges(), "checkSubmitRulesAndState called for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        try {
            if (cd.change().getStatus() != Change.Status.NEW) {
                commits.problem(cd.getId(), "Change " + cd.getId() + " is " + cd.change().getStatus().toString().toLowerCase());
            } else {
                checkSubmitRule(cd);
            }
        } catch (ResourceConflictException e) {
            commits.problem(cd.getId(), e.getMessage());
        } catch (OrmException e) {
            String msg = "Error checking submit rules for change";
            log.warn(msg + " " + cd.getId(), e);
            commits.problem(cd.getId(), msg);
        }
    }
    commits.maybeFailVerbose();
}
#end_block

#method_before
private void bypassSubmitRules(ChangeSet cs) {
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(records);
    }
}
#method_after
private void bypassSubmitRules(ChangeSet cs) {
    checkArgument(!cs.furtherHiddenChanges(), "cannot bypass submit rules for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(records);
    }
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState();
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projectsWithChanges = br.keySet();
    Collection<Branch.NameKey> branchesWithChanges = cbb.keySet();
    openRepos(projectsWithChanges);
    for (Branch.NameKey branch : branchesWithChanges) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    List<SubmitStrategy> strategies = new ArrayList<>();
    SubmoduleOp submoduleOp = subOpFactory.create(br.values(), orm);
    try {
        LinkedHashSet<Branch.NameKey> branches = submoduleOp.getOrdedBranches();
        for (Branch.NameKey branch : branchesWithChanges) {
            if (!branches.contains(branch)) {
                branches.add(branch);
            }
        }
        for (Branch.NameKey branch : branches) {
            OpenRepo or = orm.getRepo(branch.getParentKey());
            if (cbb.containsKey(branch)) {
                BranchBatch submitting = toSubmit.get(branch);
                OpenBranch ob = or.getBranch(branch);
                checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
                Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
                ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
                SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip, submoduleOp);
                strategies.add(strategy);
                strategy.addOps(or.getUpdate(), commitsToSubmit);
            } else {
                // no open change for this branch
                // add submodule triggered op into BatchUpdate
                or.getUpdate().addRepoOnlyOp(new SubmoduleOp.RepoOnlyOp(submoduleOp, branch));
            }
        }
        LinkedHashSet<Project.NameKey> projects = submoduleOp.getOrdedProjects();
        for (Project.NameKey project : projectsWithChanges) {
            if (!projects.contains(project)) {
                projects.add(project);
            }
        }
        BatchUpdate.execute(orm.batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException | SubmoduleException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Set<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
    try {
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp);
        Set<Project.NameKey> allProjects = submoduleOp.getProjectsInOrder();
        // in case superproject subscription is disabled, allProjects would be null
        if (allProjects == null) {
            allProjects = projects;
        }
        BatchUpdate.execute(orm.batchUpdates(allProjects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException | SubmoduleException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "") + ": \n" + e.getMessage();
        }
        throw new IntegrationException(msg, e);
    }
}
#end_block

#method_before
private Set<RevCommit> getAlreadyAccepted(OpenRepo or, CodeReviewCommit branchTip) throws IntegrationException {
    Set<RevCommit> alreadyAccepted = new HashSet<>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (Ref r : or.repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            try {
                alreadyAccepted.add(or.rw.parseCommit(r.getObjectId()));
            } catch (IncorrectObjectTypeException iote) {
            // Not a commit? Skip over it.
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Failed to determine already accepted commits.", e);
    }
    logDebug("Found {} existing heads", alreadyAccepted.size());
    return alreadyAccepted;
}
#method_after
private Set<RevCommit> getAlreadyAccepted(OpenRepo or, CodeReviewCommit branchTip) throws IntegrationException {
    Set<RevCommit> alreadyAccepted = new HashSet<>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (Ref r : or.repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            try {
                CodeReviewCommit aac = or.rw.parseCommit(r.getObjectId());
                if (!commits.commits.values().contains(aac)) {
                    alreadyAccepted.add(aac);
                }
            } catch (IncorrectObjectTypeException iote) {
            // Not a commit? Skip over it.
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Failed to determine already accepted commits.", e);
    }
    logDebug("Found {} existing heads", alreadyAccepted.size());
    return alreadyAccepted;
}
#end_block

#method_before
private LabelNormalizer.Result approve(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    PatchSet.Id psId = update.getPatchSetId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = new HashMap<>();
    for (PatchSetApproval psa : args.approvalsUtil.byPatchSet(ctx.getDb(), ctx.getControl(), psId)) {
        byKey.put(psa.getKey(), psa);
    }
    submitter = new PatchSetApproval(new PatchSetApproval.Key(psId, ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
    byKey.put(submitter.getKey(), submitter);
    submitter.setValue((short) 1);
    submitter.setGranted(ctx.getWhen());
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = args.labelNormalizer.normalize(ctx.getControl(), byKey.values());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    saveApprovals(normalized, ctx, update, false);
    return normalized;
}
#method_after
private LabelNormalizer.Result approve(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    PatchSet.Id psId = update.getPatchSetId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = new HashMap<>();
    for (PatchSetApproval psa : args.approvalsUtil.byPatchSet(ctx.getDb(), ctx.getControl(), psId)) {
        byKey.put(psa.getKey(), psa);
    }
    submitter = new PatchSetApproval(new PatchSetApproval.Key(psId, ctx.getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
    byKey.put(submitter.getKey(), submitter);
    submitter.setValue((short) 1);
    submitter.setGranted(ctx.getWhen());
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = args.labelNormalizer.normalize(ctx.getControl(), byKey.values());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    saveApprovals(normalized, ctx, update, false);
    return normalized;
}
#end_block

#method_before
private ChangeMessage message(ChangeContext ctx, PatchSet.Id psId, String body) {
    checkNotNull(psId);
    String uuid;
    try {
        uuid = ChangeUtil.messageUUID(ctx.getDb());
    } catch (OrmException e) {
        return null;
    }
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), uuid), ctx.getUser().getAccountId(), ctx.getWhen(), psId);
    m.setMessage(body);
    return m;
}
#method_after
private ChangeMessage message(ChangeContext ctx, PatchSet.Id psId, String body) {
    checkNotNull(psId);
    String uuid;
    try {
        uuid = ChangeUtil.messageUUID(ctx.getDb());
    } catch (OrmException e) {
        return null;
    }
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), uuid), ctx.getAccountId(), ctx.getWhen(), psId);
    m.setMessage(body);
    return m;
}
#end_block

#method_before
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null) {
        try {
            args.hooks.doChangeMergedHook(updatedChange, args.accountCache.get(submitter.getAccountId()).getAccount(), mergedPatchSet, ctx.getDb(), args.mergeTip.getCurrentTip().name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + getId(), ex);
        }
    }
}
#method_after
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null) {
        args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()).getAccount(), args.mergeTip.getCurrentTip().name(), ctx.getWhen());
    }
}
#end_block

#method_before
private Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey srcBranch) throws IOException {
    logDebug("Calculating possible superprojects for " + srcBranch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey srcProject = srcBranch.getParentKey();
    ProjectConfig cfg = projectCache.get(srcProject).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(srcBranch)) {
        logDebug("Checking subscribe section " + s);
        Collection<Branch.NameKey> branches = getDestinationBranches(srcBranch, s);
        for (Branch.NameKey targetBranch : branches) {
            Project.NameKey targetProject = targetBranch.getParentKey();
            try {
                orm.openRepo(targetProject, false);
                OpenRepo or = orm.getRepo(targetProject);
                ObjectId id = or.repo.resolve(targetBranch.get());
                if (id == null) {
                    logDebug("The branch " + targetBranch + " doesn't exist.");
                    continue;
                }
            } catch (NoSuchProjectException e) {
                logDebug("The project " + targetProject + " doesn't exist");
                continue;
            }
            GitModules m = gitmodulesFactory.create(targetBranch, orm);
            for (SubmoduleSubscription ss : m.subscribedTo(srcBranch)) {
                logDebug("Checking SubmoduleSubscription " + ss);
                if (projectCache.get(ss.getSubmodule().getParentKey()) != null) {
                    logDebug("Adding SubmoduleSubscription " + ss);
                    ret.add(ss);
                }
            }
        }
    }
    logDebug("Calculated superprojects for " + srcBranch + " are " + ret);
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey srcBranch) throws IOException {
    logDebug("Calculating possible superprojects for " + srcBranch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey srcProject = srcBranch.getParentKey();
    ProjectConfig cfg = projectCache.get(srcProject).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(srcBranch)) {
        logDebug("Checking subscribe section " + s);
        Collection<Branch.NameKey> branches = getDestinationBranches(srcBranch, s);
        for (Branch.NameKey targetBranch : branches) {
            Project.NameKey targetProject = targetBranch.getParentKey();
            try {
                orm.openRepo(targetProject, false);
                OpenRepo or = orm.getRepo(targetProject);
                ObjectId id = or.repo.resolve(targetBranch.get());
                if (id == null) {
                    logDebug("The branch " + targetBranch + " doesn't exist.");
                    continue;
                }
            } catch (NoSuchProjectException e) {
                logDebug("The project " + targetProject + " doesn't exist");
                continue;
            }
            GitModules m = branchGitModules.get(targetBranch);
            if (m == null) {
                m = gitmodulesFactory.create(targetBranch, orm);
                branchGitModules.put(targetBranch, m);
            }
            ret.addAll(m.subscribedTo(srcBranch));
        }
    }
    logDebug("Calculated superprojects for " + srcBranch + " are " + ret);
    return ret;
}
#end_block

#method_before
public void updateSuperProjects() throws SubmoduleException {
    SetMultimap<Project.NameKey, Branch.NameKey> dst = branchesByProject();
    LinkedHashSet<Project.NameKey> projects = getOrdedProjects();
    try {
        for (Project.NameKey project : projects) {
            // get a new BatchUpdate for the project
            orm.openRepo(project, false);
            orm.getRepo(project).resetUpdate();
            for (Branch.NameKey branch : dst.get(project)) {
                SubmoduleOp.RepoOnlyOp op = new SubmoduleOp.RepoOnlyOp(this, branch);
                orm.getRepo(project).getUpdate().addRepoOnlyOp(op);
            }
        }
        BatchUpdate.execute(orm.batchUpdates(projects), new Listener());
    } catch (RestApiException | UpdateException | IOException | NoSuchProjectException e) {
        throw new SubmoduleException("Cannot update gitlinks", e);
    }
}
#method_after
public void updateSuperProjects() throws SubmoduleException {
    ImmutableSet<Project.NameKey> projects = getProjectsInOrder();
    if (projects == null) {
        return;
    }
    SetMultimap<Project.NameKey, Branch.NameKey> dst = branchesByProject();
    LinkedHashSet<Project.NameKey> superProjects = new LinkedHashSet<>();
    try {
        for (Project.NameKey project : projects) {
            // only need superprojects
            if (dst.containsKey(project)) {
                superProjects.add(project);
                // get a new BatchUpdate for the super project
                orm.openRepo(project, false);
                for (Branch.NameKey branch : dst.get(project)) {
                    addOp(orm.getRepo(project).getUpdate(), branch);
                }
            }
        }
        BatchUpdate.execute(orm.batchUpdates(superProjects), Listener.NONE);
    } catch (RestApiException | UpdateException | IOException | NoSuchProjectException e) {
        throw new SubmoduleException("Cannot update gitlinks", e);
    }
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, RevCommit baseCommit) throws IOException, SubmoduleException, OrmException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    RevCommit currentCommit = (baseCommit != null) ? baseCommit : or.rw.parseCommit(or.repo.exactRef(subscriber.get()).getObjectId());
    or.rw.parseBody(currentCommit);
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        try {
            orm.openRepo(s.getSubmodule().getParentKey(), false);
        } catch (NoSuchProjectException | IOException e) {
            throw new SubmoduleException("Cannot access submodule", e);
        }
        OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
        Repository subRepo = subOr.repo;
        Ref ref = subRepo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            continue;
        }
        ObjectId updateTo = ref.getObjectId();
        if (branchTips.containsKey(s.getSubmodule())) {
            updateTo = branchTips.get(s.getSubmodule());
        }
        RevWalk subOrRw = subOr.rw;
        final RevCommit newCommit = subOrRw.parseCommit(updateTo);
        subOrRw.parseBody(newCommit);
        if (author == null) {
            author = newCommit.getAuthorIdent();
        } else if (!author.equals(newCommit.getAuthorIdent())) {
            sameAuthorForAll = false;
        }
        DirCacheEntry dce = dc.getEntry(s.getPath());
        ObjectId oldId;
        if (dce != null) {
            if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                continue;
            }
            oldId = dce.getObjectId();
        } else {
            // This submodule did not exist before. We do not want to add
            // the full submodule history to the commit message, so omit it.
            oldId = updateTo;
        }
        ed.add(new PathEdit(s.getPath()) {

            @Override
            public void apply(DirCacheEntry ent) {
                ent.setFileMode(FileMode.GITLINK);
                ent.setObjectId(newCommit.getId());
            }
        });
        if (verboseSuperProject) {
            msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
            msgbuf.append(" " + s.getSubmodule().getShortName());
            msgbuf.append(" " + newCommit.getName());
            msgbuf.append("\n\n");
            try {
                subOrRw.resetRetain(subOr.canMergeFlag);
                subOrRw.markStart(newCommit);
                subOrRw.markUninteresting(subOrRw.parseCommit(oldId));
                for (RevCommit c : subOrRw) {
                    subOrRw.parseBody(c);
                    msgbuf.append(c.getFullMessage() + "\n\n");
                }
            } catch (IOException e) {
                throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
            }
        }
    }
    ed.finish();
    ObjectInserter oi = or.repo.newObjectInserter();
    CodeReviewRevWalk rw = or.rw;
    ObjectId tree = dc.writeTree(oi);
    if (!sameAuthorForAll || author == null) {
        author = myIdent;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(tree);
    if (baseCommit != null) {
        // modify the baseCommit
        commit.setParentIds(baseCommit.getParents());
        commit.setMessage(baseCommit.getFullMessage() + "\n\n" + msgbuf.toString());
        commit.setAuthor(baseCommit.getAuthorIdent());
    } else {
        // create a new commit
        commit.setParentId(currentCommit);
        commit.setMessage(msgbuf.toString());
        commit.setAuthor(author);
    }
    commit.setCommitter(myIdent);
    ObjectId id = oi.insert(commit);
    oi.flush();
    return rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, RevCommit baseCommit) throws IOException, SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    RevCommit currentCommit = (baseCommit != null) ? baseCommit : or.rw.parseCommit(or.repo.exactRef(subscriber.get()).getObjectId());
    or.rw.parseBody(currentCommit);
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        try {
            orm.openRepo(s.getSubmodule().getParentKey(), false);
        } catch (NoSuchProjectException | IOException e) {
            throw new SubmoduleException("Cannot access submodule", e);
        }
        OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
        Repository subRepo = subOr.repo;
        Ref ref = subRepo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            continue;
        }
        ObjectId updateTo = ref.getObjectId();
        if (branchTips.containsKey(s.getSubmodule())) {
            updateTo = branchTips.get(s.getSubmodule());
        }
        RevWalk subOrRw = subOr.rw;
        final RevCommit newCommit = subOrRw.parseCommit(updateTo);
        subOrRw.parseBody(newCommit);
        if (author == null) {
            author = newCommit.getAuthorIdent();
        } else if (!author.equals(newCommit.getAuthorIdent())) {
            sameAuthorForAll = false;
        }
        DirCacheEntry dce = dc.getEntry(s.getPath());
        ObjectId oldId;
        if (dce != null) {
            if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                String errMsg = "Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.";
                throw new SubmoduleException(errMsg);
            }
            oldId = dce.getObjectId();
        } else {
            // This submodule did not exist before. We do not want to add
            // the full submodule history to the commit message, so omit it.
            oldId = updateTo;
        }
        ed.add(new PathEdit(s.getPath()) {

            @Override
            public void apply(DirCacheEntry ent) {
                ent.setFileMode(FileMode.GITLINK);
                ent.setObjectId(newCommit.getId());
            }
        });
        if (verboseSuperProject) {
            msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
            msgbuf.append(" " + s.getSubmodule().getShortName());
            msgbuf.append(" " + newCommit.getName());
            msgbuf.append("\n\n");
            try {
                subOrRw.resetRetain(subOr.canMergeFlag);
                subOrRw.markStart(newCommit);
                subOrRw.markUninteresting(subOrRw.parseCommit(oldId));
                for (RevCommit c : subOrRw) {
                    subOrRw.parseBody(c);
                    msgbuf.append(c.getFullMessage() + "\n\n");
                }
            } catch (IOException e) {
                throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
            }
        }
    }
    ed.finish();
    ObjectInserter oi = or.ins;
    CodeReviewRevWalk rw = or.rw;
    ObjectId tree = dc.writeTree(oi);
    if (!sameAuthorForAll || author == null) {
        author = myIdent;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(tree);
    if (baseCommit != null) {
        // modify the baseCommit
        commit.setParentIds(baseCommit.getParents());
        commit.setMessage(baseCommit.getFullMessage() + "\n\n" + msgbuf.toString());
        commit.setAuthor(baseCommit.getAuthorIdent());
    } else {
        // create a new commit
        commit.setParentId(currentCommit);
        commit.setMessage(msgbuf.toString());
        commit.setAuthor(author);
    }
    commit.setCommitter(myIdent);
    ObjectId id = oi.insert(commit);
    return rw.parseCommit(id);
}
#end_block

#method_before
private Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey srcBranch) throws IOException {
    logDebug("Calculating possible superprojects for " + srcBranch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey srcProject = srcBranch.getParentKey();
    ProjectConfig cfg = projectCache.get(srcProject).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(srcBranch)) {
        logDebug("Checking subscribe section " + s);
        Collection<Branch.NameKey> branches = getDestinationBranches(srcBranch, s);
        for (Branch.NameKey targetBranch : branches) {
            Project.NameKey targetProject = targetBranch.getParentKey();
            try {
                orm.openRepo(targetProject, false);
                OpenRepo or = orm.getRepo(targetProject);
                ObjectId id = or.repo.resolve(targetBranch.get());
                if (id == null) {
                    logDebug("The branch " + targetBranch + " doesn't exist.");
                    continue;
                }
            } catch (NoSuchProjectException e) {
                logDebug("The project " + targetProject + " doesn't exist");
                continue;
            }
            GitModules m = gitmodulesFactory.create(targetBranch, orm);
            for (SubmoduleSubscription ss : m.subscribedTo(srcBranch)) {
                logDebug("Checking SubmoduleSubscription " + ss);
                if (projectCache.get(ss.getSubmodule().getParentKey()) != null) {
                    logDebug("Adding SubmoduleSubscription " + ss);
                    ret.add(ss);
                }
            }
        }
    }
    logDebug("Calculated superprojects for " + srcBranch + " are " + ret);
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey srcBranch) throws IOException {
    logDebug("Calculating possible superprojects for " + srcBranch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey srcProject = srcBranch.getParentKey();
    ProjectConfig cfg = projectCache.get(srcProject).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(srcBranch)) {
        logDebug("Checking subscribe section " + s);
        Collection<Branch.NameKey> branches = getDestinationBranches(srcBranch, s);
        for (Branch.NameKey targetBranch : branches) {
            Project.NameKey targetProject = targetBranch.getParentKey();
            try {
                orm.openRepo(targetProject, false);
                OpenRepo or = orm.getRepo(targetProject);
                ObjectId id = or.repo.resolve(targetBranch.get());
                if (id == null) {
                    logDebug("The branch " + targetBranch + " doesn't exist.");
                    continue;
                }
            } catch (NoSuchProjectException e) {
                logDebug("The project " + targetProject + " doesn't exist");
                continue;
            }
            GitModules m = branchGitModules.get(targetBranch);
            if (m == null) {
                m = gitmodulesFactory.create(targetBranch, orm);
                branchGitModules.put(targetBranch, m);
            }
            ret.addAll(m.subscribedTo(srcBranch));
        }
    }
    logDebug("Calculated superprojects for " + srcBranch + " are " + ret);
    return ret;
}
#end_block

#method_before
public void updateSuperProjects() throws SubmoduleException {
    SetMultimap<Project.NameKey, Branch.NameKey> dst = branchesByProject();
    LinkedHashSet<Project.NameKey> projects = getOrdedProjects();
    try {
        for (Project.NameKey project : projects) {
            // get a new BatchUpdate for the project
            orm.openRepo(project, false);
            orm.getRepo(project).resetUpdate();
            for (Branch.NameKey branch : dst.get(project)) {
                SubmoduleOp.RepoOnlyOp op = new SubmoduleOp.RepoOnlyOp(this, branch);
                orm.getRepo(project).getUpdate().addRepoOnlyOp(op);
            }
        }
        BatchUpdate.execute(orm.batchUpdates(projects), new Listener());
    } catch (RestApiException | UpdateException | IOException | NoSuchProjectException e) {
        throw new SubmoduleException("Cannot update gitlinks", e);
    }
}
#method_after
public void updateSuperProjects() throws SubmoduleException {
    ImmutableSet<Project.NameKey> projects = getProjectsInOrder();
    if (projects == null) {
        return;
    }
    SetMultimap<Project.NameKey, Branch.NameKey> dst = branchesByProject();
    LinkedHashSet<Project.NameKey> superProjects = new LinkedHashSet<>();
    try {
        for (Project.NameKey project : projects) {
            // only need superprojects
            if (dst.containsKey(project)) {
                superProjects.add(project);
                // get a new BatchUpdate for the super project
                orm.openRepo(project, false);
                // TODO:czhen remove this when MergeOp combine this into BatchUpdate
                orm.getRepo(project).resetUpdate();
                for (Branch.NameKey branch : dst.get(project)) {
                    SubmoduleOp.GitlinkOp op = new SubmoduleOp.GitlinkOp(branch);
                    orm.getRepo(project).getUpdate().addRepoOnlyOp(op);
                }
            }
        }
        BatchUpdate.execute(orm.batchUpdates(superProjects), Listener.NONE);
    } catch (RestApiException | UpdateException | IOException | NoSuchProjectException e) {
        throw new SubmoduleException("Cannot update gitlinks", e);
    }
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, RevCommit baseCommit) throws IOException, SubmoduleException, OrmException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    RevCommit currentCommit = (baseCommit != null) ? baseCommit : or.rw.parseCommit(or.repo.exactRef(subscriber.get()).getObjectId());
    or.rw.parseBody(currentCommit);
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        try {
            orm.openRepo(s.getSubmodule().getParentKey(), false);
        } catch (NoSuchProjectException | IOException e) {
            throw new SubmoduleException("Cannot access submodule", e);
        }
        OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
        Repository subRepo = subOr.repo;
        Ref ref = subRepo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            continue;
        }
        ObjectId updateTo = ref.getObjectId();
        if (branchTips.containsKey(s.getSubmodule())) {
            updateTo = branchTips.get(s.getSubmodule());
        }
        RevWalk subOrRw = subOr.rw;
        final RevCommit newCommit = subOrRw.parseCommit(updateTo);
        subOrRw.parseBody(newCommit);
        if (author == null) {
            author = newCommit.getAuthorIdent();
        } else if (!author.equals(newCommit.getAuthorIdent())) {
            sameAuthorForAll = false;
        }
        DirCacheEntry dce = dc.getEntry(s.getPath());
        ObjectId oldId;
        if (dce != null) {
            if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                continue;
            }
            oldId = dce.getObjectId();
        } else {
            // This submodule did not exist before. We do not want to add
            // the full submodule history to the commit message, so omit it.
            oldId = updateTo;
        }
        ed.add(new PathEdit(s.getPath()) {

            @Override
            public void apply(DirCacheEntry ent) {
                ent.setFileMode(FileMode.GITLINK);
                ent.setObjectId(newCommit.getId());
            }
        });
        if (verboseSuperProject) {
            msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
            msgbuf.append(" " + s.getSubmodule().getShortName());
            msgbuf.append(" " + newCommit.getName());
            msgbuf.append("\n\n");
            try {
                subOrRw.resetRetain(subOr.canMergeFlag);
                subOrRw.markStart(newCommit);
                subOrRw.markUninteresting(subOrRw.parseCommit(oldId));
                for (RevCommit c : subOrRw) {
                    subOrRw.parseBody(c);
                    msgbuf.append(c.getFullMessage() + "\n\n");
                }
            } catch (IOException e) {
                throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
            }
        }
    }
    ed.finish();
    ObjectInserter oi = or.repo.newObjectInserter();
    CodeReviewRevWalk rw = or.rw;
    ObjectId tree = dc.writeTree(oi);
    if (!sameAuthorForAll || author == null) {
        author = myIdent;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(tree);
    if (baseCommit != null) {
        // modify the baseCommit
        commit.setParentIds(baseCommit.getParents());
        commit.setMessage(baseCommit.getFullMessage() + "\n\n" + msgbuf.toString());
        commit.setAuthor(baseCommit.getAuthorIdent());
    } else {
        // create a new commit
        commit.setParentId(currentCommit);
        commit.setMessage(msgbuf.toString());
        commit.setAuthor(author);
    }
    commit.setCommitter(myIdent);
    ObjectId id = oi.insert(commit);
    oi.flush();
    return rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, RevCommit baseCommit) throws IOException, SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    RevCommit currentCommit = (baseCommit != null) ? baseCommit : or.rw.parseCommit(or.repo.exactRef(subscriber.get()).getObjectId());
    or.rw.parseBody(currentCommit);
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        try {
            orm.openRepo(s.getSubmodule().getParentKey(), false);
        } catch (NoSuchProjectException | IOException e) {
            throw new SubmoduleException("Cannot access submodule", e);
        }
        OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
        Repository subRepo = subOr.repo;
        Ref ref = subRepo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            continue;
        }
        ObjectId updateTo = ref.getObjectId();
        if (branchTips.containsKey(s.getSubmodule())) {
            updateTo = branchTips.get(s.getSubmodule());
        }
        RevWalk subOrRw = subOr.rw;
        final RevCommit newCommit = subOrRw.parseCommit(updateTo);
        subOrRw.parseBody(newCommit);
        if (author == null) {
            author = newCommit.getAuthorIdent();
        } else if (!author.equals(newCommit.getAuthorIdent())) {
            sameAuthorForAll = false;
        }
        DirCacheEntry dce = dc.getEntry(s.getPath());
        ObjectId oldId;
        if (dce != null) {
            if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                String errMsg = "Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.";
                throw new SubmoduleException(errMsg);
            }
            oldId = dce.getObjectId();
        } else {
            // This submodule did not exist before. We do not want to add
            // the full submodule history to the commit message, so omit it.
            oldId = updateTo;
        }
        ed.add(new PathEdit(s.getPath()) {

            @Override
            public void apply(DirCacheEntry ent) {
                ent.setFileMode(FileMode.GITLINK);
                ent.setObjectId(newCommit.getId());
            }
        });
        if (verboseSuperProject) {
            msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
            msgbuf.append(" " + s.getSubmodule().getShortName());
            msgbuf.append(" " + newCommit.getName());
            msgbuf.append("\n\n");
            try {
                subOrRw.resetRetain(subOr.canMergeFlag);
                subOrRw.markStart(newCommit);
                subOrRw.markUninteresting(subOrRw.parseCommit(oldId));
                for (RevCommit c : subOrRw) {
                    subOrRw.parseBody(c);
                    msgbuf.append(c.getFullMessage() + "\n\n");
                }
            } catch (IOException e) {
                throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
            }
        }
    }
    ed.finish();
    ObjectInserter oi = or.ins;
    CodeReviewRevWalk rw = or.rw;
    ObjectId tree = dc.writeTree(oi);
    if (!sameAuthorForAll || author == null) {
        author = myIdent;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(tree);
    if (baseCommit != null) {
        // modify the baseCommit
        commit.setParentIds(baseCommit.getParents());
        commit.setMessage(baseCommit.getFullMessage() + "\n\n" + msgbuf.toString());
        commit.setAuthor(baseCommit.getAuthorIdent());
    } else {
        // create a new commit
        commit.setParentId(currentCommit);
        commit.setMessage(msgbuf.toString());
        commit.setAuthor(author);
    }
    commit.setCommitter(myIdent);
    ObjectId id = oi.insert(commit);
    return rw.parseCommit(id);
}
#end_block

#method_before
@Test
public void testRecursiveSubmodules() throws Exception {
    TestRepository<?> topRepo = createProjectWithPush("top-project");
    TestRepository<?> midRepo = createProjectWithPush("mid-project");
    TestRepository<?> bottomRepo = createProjectWithPush("bottom-project");
    allowSubmoduleSubscription("mid-project", "refs/heads/master", "top-project", "refs/heads/master");
    allowSubmoduleSubscription("bottom-project", "refs/heads/master", "mid-project", "refs/heads/master");
    createSubmoduleSubscription(topRepo, "master", "mid-project", "master");
    createSubmoduleSubscription(midRepo, "master", "bottom-project", "master");
    ObjectId bottomHead = bottomRepo.branch("HEAD").commit().insertChangeId().message("some change").add("a.txt", "a contents ").create();
    bottomRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    RevCommit c = bottomRepo.getRevWalk().parseCommit(bottomHead);
    RevCommit c1 = bottomRepo.branch("HEAD").commit().insertChangeId().message("first change").add("asdf", "asdf\n").create();
    bottomRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/for/master/" + name("topic-foo"))).call();
    bottomRepo.reset(c.getId());
    RevCommit c2 = bottomRepo.branch("HEAD").commit().insertChangeId().message("qwerty").add("qwerty", "qwerty").create();
    RevCommit c3 = bottomRepo.branch("HEAD").commit().insertChangeId().message("qwerty followup").add("qwerty", "qwerty\nqwerty\n").create();
    bottomRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/for/master/" + name("topic-foo"))).call();
    RevCommit c4 = topRepo.branch("HEAD").commit().insertChangeId().message("new change on top project").add("foo", "bar").create();
    topRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/for/master/" + name("topic-foo"))).call();
    String id1 = getChangeId(bottomRepo, c1).get();
    String id2 = getChangeId(bottomRepo, c2).get();
    String id3 = getChangeId(bottomRepo, c3).get();
    String id4 = getChangeId(topRepo, c4).get();
    gApi.changes().id(id1).current().review(ReviewInput.approve());
    gApi.changes().id(id2).current().review(ReviewInput.approve());
    gApi.changes().id(id3).current().review(ReviewInput.approve());
    gApi.changes().id(id4).current().review(ReviewInput.approve());
    gApi.changes().id(id1).current().submit();
    ObjectId bottomRepoId = bottomRepo.git().fetch().setRemote("origin").call().getAdvertisedRef("refs/heads/master").getObjectId();
    ObjectId midRepoId = midRepo.git().fetch().setRemote("origin").call().getAdvertisedRef("refs/heads/master").getObjectId();
    expectToHaveSubmoduleState(midRepo, "master", "bottom-project", bottomRepoId);
    expectToHaveSubmoduleState(topRepo, "master", "mid-project", midRepoId);
}
#method_after
@Test
public void testRecursiveSubmodules() throws Exception {
    TestRepository<?> topRepo = createProjectWithPush("top-project");
    TestRepository<?> midRepo = createProjectWithPush("mid-project");
    TestRepository<?> bottomRepo = createProjectWithPush("bottom-project");
    allowSubmoduleSubscription("mid-project", "refs/heads/master", "top-project", "refs/heads/master");
    allowSubmoduleSubscription("bottom-project", "refs/heads/master", "mid-project", "refs/heads/master");
    createSubmoduleSubscription(topRepo, "master", "mid-project", "master");
    createSubmoduleSubscription(midRepo, "master", "bottom-project", "master");
    ObjectId bottomHead = pushChangeTo(bottomRepo, "refs/for/master", "some message", "same-topic");
    ObjectId topHead = pushChangeTo(topRepo, "refs/for/master", "some message", "same-topic");
    String id1 = getChangeId(bottomRepo, bottomHead).get();
    String id2 = getChangeId(topRepo, topHead).get();
    gApi.changes().id(id1).current().review(ReviewInput.approve());
    gApi.changes().id(id2).current().review(ReviewInput.approve());
    gApi.changes().id(id1).current().submit();
    assertThat(hasSubmodule(midRepo, "master", "bottom-project")).isTrue();
    assertThat(hasSubmodule(topRepo, "master", "mid-project")).isTrue();
}
#end_block

#method_before
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (ObjectReader reader = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader);
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        // b - current commit object (not a hash commit)
        final RevCommit b = rw.parseCommit(key.getNewId());
        // a - ancestor object
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = null;
        if (key.getOldId() != null) {
            PatchListKey newKey = new PatchListKey(null, key.getNewId(), key.getWhitespace());
            PatchListKey oldKey = new PatchListKey(null, key.getOldId(), key.getWhitespace());
            paths = FluentIterable.from(patchListCache.get(newKey, project).getPatches()).append(patchListCache.get(oldKey, project).getPatches()).transform(new Function<PatchListEntry, String>() {

                @Override
                public String apply(PatchListEntry entry) {
                    return entry.getNewName();
                }
            }).toSet();
        }
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry e = diffEntries.get(i);
            if (paths == null || paths.contains(e.getNewPath()) || paths.contains(e.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, e);
                long oldSize = getFileSize(repo, reader, e.getOldMode(), e.getOldPath(), aTree);
                long newSize = getFileSize(repo, reader, e.getNewMode(), e.getNewPath(), bTree);
                entries.add(newEntry(aTree, fh, newSize - oldSize));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#method_after
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader);
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, ins, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = null;
        if (key.getOldId() != null && b.getParentCount() == 1) {
            PatchListKey newKey = PatchListKey.againstDefaultBase(key.getNewId(), key.getWhitespace());
            PatchListKey oldKey = PatchListKey.againstDefaultBase(key.getOldId(), key.getWhitespace());
            paths = FluentIterable.from(patchListCache.get(newKey, project).getPatches()).append(patchListCache.get(oldKey, project).getPatches()).transform(new Function<PatchListEntry, String>() {

                @Override
                public String apply(PatchListEntry entry) {
                    return entry.getNewName();
                }
            }).toSet();
        }
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry e = diffEntries.get(i);
            if (paths == null || paths.contains(e.getNewPath()) || paths.contains(e.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, e);
                long oldSize = getFileSize(repo, reader, e.getOldMode(), e.getOldPath(), aTree);
                long newSize = getFileSize(repo, reader, e.getNewMode(), e.getNewPath(), bTree);
                entries.add(newEntry(aTree, fh, newSize, newSize - oldSize));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#end_block

#method_before
private FileHeader toFileHeader(PatchListKey key, final DiffFormatter diffFormatter, final DiffEntry diffEntry) throws IOException {
    Future<FileHeader> result = diffExecutor.submit(new Callable<FileHeader>() {

        @Override
        public FileHeader call() throws IOException {
            synchronized (lock) {
                return diffFormatter.toFileHeader(diffEntry);
            }
        }
    });
    try {
        return result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for Diff loader" + " in project " + project + " on commit " + key.getNewId().name() + " on path " + diffEntry.getNewPath() + " comparing " + diffEntry.getOldId().name() + ".." + diffEntry.getNewId().name());
        result.cancel(true);
        synchronized (lock) {
            return toFileHeaderWithoutMyersDiff(diffFormatter, diffEntry);
        }
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException(e.getMessage(), e.getCause());
    }
}
#method_after
private FileHeader toFileHeader(PatchListKey key, final DiffFormatter diffFormatter, final DiffEntry diffEntry) throws IOException {
    Future<FileHeader> result = diffExecutor.submit(new Callable<FileHeader>() {

        @Override
        public FileHeader call() throws IOException {
            synchronized (diffEntry) {
                return diffFormatter.toFileHeader(diffEntry);
            }
        }
    });
    try {
        return result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for Diff loader" + " in project " + project + " on commit " + key.getNewId().name() + " on path " + diffEntry.getNewPath() + " comparing " + diffEntry.getOldId().name() + ".." + diffEntry.getNewId().name());
        result.cancel(true);
        synchronized (diffEntry) {
            return toFileHeaderWithoutMyersDiff(diffFormatter, diffEntry);
        }
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException(e.getMessage(), e.getCause());
    }
}
#end_block

#method_before
private PatchListEntry newCommitMessage(final RawTextComparator cmp, final ObjectReader reader, final RevCommit aCommit, final RevCommit bCommit) throws IOException {
    StringBuilder hdr = new StringBuilder();
    hdr.append("diff --git");
    if (aCommit != null) {
        hdr.append(" a/").append(Patch.COMMIT_MSG);
    } else {
        hdr.append(" ").append(FileHeader.DEV_NULL);
    }
    hdr.append(" b/").append(Patch.COMMIT_MSG);
    hdr.append("\n");
    if (aCommit != null) {
        hdr.append("--- a/").append(Patch.COMMIT_MSG).append("\n");
    } else {
        hdr.append("--- ").append(FileHeader.DEV_NULL).append("\n");
    }
    hdr.append("+++ b/").append(Patch.COMMIT_MSG).append("\n");
    Text aText = aCommit != null ? Text.forCommit(reader, aCommit) : Text.EMPTY;
    Text bText = Text.forCommit(reader, bCommit);
    byte[] rawHdr = hdr.toString().getBytes(UTF_8);
    byte[] aContent = aText.getContent();
    byte[] bContent = bText.getContent();
    long sizeDelta = bContent.length - aContent.length;
    RawText aRawText = new RawText(aContent);
    RawText bRawText = new RawText(bContent);
    EditList edits = new HistogramDiff().diff(cmp, aRawText, bRawText);
    FileHeader fh = new FileHeader(rawHdr, edits, PatchType.UNIFIED);
    return new PatchListEntry(fh, edits, sizeDelta);
}
#method_after
private PatchListEntry newCommitMessage(final RawTextComparator cmp, final ObjectReader reader, final RevCommit aCommit, final RevCommit bCommit) throws IOException {
    StringBuilder hdr = new StringBuilder();
    hdr.append("diff --git");
    if (aCommit != null) {
        hdr.append(" a/").append(Patch.COMMIT_MSG);
    } else {
        hdr.append(" ").append(FileHeader.DEV_NULL);
    }
    hdr.append(" b/").append(Patch.COMMIT_MSG);
    hdr.append("\n");
    if (aCommit != null) {
        hdr.append("--- a/").append(Patch.COMMIT_MSG).append("\n");
    } else {
        hdr.append("--- ").append(FileHeader.DEV_NULL).append("\n");
    }
    hdr.append("+++ b/").append(Patch.COMMIT_MSG).append("\n");
    Text aText = aCommit != null ? Text.forCommit(reader, aCommit) : Text.EMPTY;
    Text bText = Text.forCommit(reader, bCommit);
    byte[] rawHdr = hdr.toString().getBytes(UTF_8);
    byte[] aContent = aText.getContent();
    byte[] bContent = bText.getContent();
    long size = bContent.length;
    long sizeDelta = bContent.length - aContent.length;
    RawText aRawText = new RawText(aContent);
    RawText bRawText = new RawText(bContent);
    EditList edits = new HistogramDiff().diff(cmp, aRawText, bRawText);
    FileHeader fh = new FileHeader(rawHdr, edits, PatchType.UNIFIED);
    return new PatchListEntry(fh, edits, size, sizeDelta);
}
#end_block

#method_before
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader, long sizeDelta) {
    final FileMode oldMode = fileHeader.getOldMode();
    final FileMode newMode = fileHeader.getNewMode();
    if (oldMode == FileMode.GITLINK || newMode == FileMode.GITLINK) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    } else {
        return new PatchListEntry(fileHeader, edits, sizeDelta);
    }
}
#method_after
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader, long size, long sizeDelta) {
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), size, sizeDelta);
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), size, sizeDelta);
    }
    return new PatchListEntry(fileHeader, edits, size, sizeDelta);
}
#end_block

#method_before
private RevObject aFor(final PatchListKey key, final Repository repo, final RevWalk rw, final RevCommit b) throws IOException {
    if (key.getOldId() != null) {
        return rw.parseAny(key.getOldId());
    }
    switch(b.getParentCount()) {
        case 0:
            return rw.parseAny(emptyTree(repo));
        case 1:
            {
                RevCommit r = b.getParent(0);
                rw.parseBody(r);
                return r;
            }
        case 2:
            return automerge(repo, rw, b, mergeStrategy);
        default:
            // TODO(sop) handle an octopus merge.
            return null;
    }
}
#method_after
private RevObject aFor(PatchListKey key, Repository repo, RevWalk rw, ObjectInserter ins, RevCommit b) throws IOException {
    if (key.getOldId() != null) {
        return rw.parseAny(key.getOldId());
    }
    switch(b.getParentCount()) {
        case 0:
            return rw.parseAny(emptyTree(repo));
        case 1:
            {
                RevCommit r = b.getParent(0);
                rw.parseBody(r);
                return r;
            }
        case 2:
            if (key.getParentNum() != null) {
                RevCommit r = b.getParent(key.getParentNum() - 1);
                rw.parseBody(r);
                return r;
            }
            return autoMerger.merge(repo, rw, ins, b, mergeStrategy);
        default:
            // TODO(sop) handle an octopus merge.
            return null;
    }
}
#end_block

#method_before
@Test
public void pushWatchConfigToUserBranch() throws Exception {
    // change something in the user preferences to ensure that the user branch
    // is created
    GeneralPreferencesInfo input = new GeneralPreferencesInfo();
    input.changesPerPage = GeneralPreferencesInfo.defaults().changesPerPage + 10;
    gApi.accounts().self().setPreferences(input);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, RefNames.refsUsers(admin.id) + ":userRef");
    allUsersRepo.reset("userRef");
    Config wc = new Config();
    wc.setString(WatchConfig.PROJECT, project.get(), WatchConfig.KEY_NOTIFY, NotifyValue.create(null, EnumSet.of(NotifyType.ALL_COMMENTS)).toString());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Add project watch", WatchConfig.WATCH_CONFIG, wc.toText());
    push.to(RefNames.REFS_USERS_SELF).assertOkStatus();
    String invalidNotifyValue = "]invalid[";
    wc.setString(WatchConfig.PROJECT, project.get(), WatchConfig.KEY_NOTIFY, invalidNotifyValue);
    push = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Add invalid project watch", WatchConfig.WATCH_CONFIG, wc.toText());
    PushOneCommit.Result r = push.to(RefNames.REFS_USERS_SELF);
    r.assertErrorStatus("invalid watch configuration");
    r.assertMessage(String.format("%s: Invalid project watch of account %d for project %s: %s", WatchConfig.WATCH_CONFIG, admin.getId().get(), project.get(), invalidNotifyValue));
}
#method_after
@Test
public void pushWatchConfigToUserBranch() throws Exception {
    // change something in the user preferences to ensure that the user branch
    // is created
    GeneralPreferencesInfo input = new GeneralPreferencesInfo();
    input.changesPerPage = GeneralPreferencesInfo.defaults().changesPerPage + 10;
    gApi.accounts().self().setPreferences(input);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, RefNames.refsUsers(admin.id) + ":userRef");
    allUsersRepo.reset("userRef");
    Config wc = new Config();
    wc.setString(WatchConfig.PROJECT, project.get(), WatchConfig.KEY_NOTIFY, WatchConfig.NotifyValue.create(null, EnumSet.of(NotifyType.ALL_COMMENTS)).toString());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Add project watch", WatchConfig.WATCH_CONFIG, wc.toText());
    push.to(RefNames.REFS_USERS_SELF).assertOkStatus();
    String invalidNotifyValue = "]invalid[";
    wc.setString(WatchConfig.PROJECT, project.get(), WatchConfig.KEY_NOTIFY, invalidNotifyValue);
    push = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Add invalid project watch", WatchConfig.WATCH_CONFIG, wc.toText());
    PushOneCommit.Result r = push.to(RefNames.REFS_USERS_SELF);
    r.assertErrorStatus("invalid watch configuration");
    r.assertMessage(String.format("%s: Invalid project watch of account %d for project %s: %s", WatchConfig.WATCH_CONFIG, admin.getId().get(), project.get(), invalidNotifyValue));
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    if (REFS_CONFIG.equals(refControl.getRefName())) {
        List<CommitValidationMessage> messages = new LinkedList<>();
        try {
            ProjectConfig cfg = new ProjectConfig(receiveEvent.project.getNameKey());
            cfg.load(repo, receiveEvent.command.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:", messages);
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage(), messages);
                }
                throw new ConfigInvalidException("invalid project configuration");
            }
        } catch (Exception e) {
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + receiveEvent.command.getNewId().name() + " for " + receiveEvent.project.getName(), e);
            throw new CommitValidationException("invalid project configuration", messages);
        }
    }
    if (allUsers.equals(refControl.getProjectControl().getProject().getNameKey()) && RefNames.isRefsUsers(refControl.getRefName())) {
        List<CommitValidationMessage> messages = new LinkedList<>();
        Account.Id accountId = Account.Id.fromRef(refControl.getRefName());
        if (accountId != null) {
            try {
                @SuppressWarnings("resource")
                WatchConfig wc = new WatchConfig(accountId);
                wc.load(repo, receiveEvent.command.getNewId());
                if (!wc.getValidationErrors().isEmpty()) {
                    addError("Invalid project configuration:", messages);
                    for (ValidationError err : wc.getValidationErrors()) {
                        addError("  " + err.getMessage(), messages);
                    }
                    throw new ConfigInvalidException("invalid watch configuration");
                }
            } catch (IOException | ConfigInvalidException e) {
                log.error("User " + currentUser.getUserName() + " tried to push an invalid watch configuration " + receiveEvent.command.getNewId().name() + " for account " + accountId.get(), e);
                throw new CommitValidationException("invalid watch configuration", messages);
            }
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    if (REFS_CONFIG.equals(refControl.getRefName())) {
        List<CommitValidationMessage> messages = new LinkedList<>();
        try {
            ProjectConfig cfg = new ProjectConfig(receiveEvent.project.getNameKey());
            cfg.load(repo, receiveEvent.command.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:", messages);
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage(), messages);
                }
                throw new ConfigInvalidException("invalid project configuration");
            }
        } catch (ConfigInvalidException | IOException e) {
            log.error("User " + currentUser.getUserName() + " tried to push an invalid project configuration " + receiveEvent.command.getNewId().name() + " for project " + receiveEvent.project.getName(), e);
            throw new CommitValidationException("invalid project configuration", messages);
        }
    }
    if (allUsers.equals(refControl.getProjectControl().getProject().getNameKey()) && RefNames.isRefsUsers(refControl.getRefName())) {
        List<CommitValidationMessage> messages = new LinkedList<>();
        Account.Id accountId = Account.Id.fromRef(refControl.getRefName());
        if (accountId != null) {
            try {
                @SuppressWarnings("resource")
                WatchConfig wc = new WatchConfig(accountId);
                wc.load(repo, receiveEvent.command.getNewId());
                if (!wc.getValidationErrors().isEmpty()) {
                    addError("Invalid project configuration:", messages);
                    for (ValidationError err : wc.getValidationErrors()) {
                        addError("  " + err.getMessage(), messages);
                    }
                    throw new ConfigInvalidException("invalid watch configuration");
                }
            } catch (IOException | ConfigInvalidException e) {
                log.error("User " + currentUser.getUserName() + " tried to push an invalid watch configuration " + receiveEvent.command.getNewId().name() + " for account " + accountId.get(), e);
                throw new CommitValidationException("invalid watch configuration", messages);
            }
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
private static S3Config getS3Config(PluginConfigFactory configFactory, String pluginName) {
    Config pluginCfg = configFactory.getGlobalPluginConfig(pluginName);
    String section = "s3";
    String region = pluginCfg.getString(section, null, "region");
    String bucket = pluginCfg.getString(section, null, "bucket");
    String storageClass = MoreObjects.firstNonNull(pluginCfg.getString(section, null, "storageClass"), "REDUCED_REDUNDANCY");
    int expirationSeconds = pluginCfg.getInt(section, null, "expirationSeconds", 60);
    boolean disableSslVerify = pluginCfg.getBoolean(section, null, "disableSslVerify", false);
    PluginConfig cfg = configFactory.getFromGerritConfig(pluginName);
    String accessKey = cfg.getString("accessKey", null);
    String secretKey = cfg.getString("secretKey", null);
    return new S3Config(region, bucket, storageClass, accessKey, secretKey, expirationSeconds, disableSslVerify);
}
#method_after
private static S3Config getS3Config(PluginConfigFactory configFactory, String pluginName) {
    Config config = configFactory.getGlobalPluginConfig(pluginName);
    String section = LfsBackend.S3.name();
    String region = config.getString(section, null, "region");
    String bucket = config.getString(section, null, "bucket");
    String storageClass = MoreObjects.firstNonNull(config.getString(section, null, "storageClass"), "REDUCED_REDUNDANCY");
    int expirationSeconds = config.getInt(section, null, "expirationSeconds", 60);
    boolean disableSslVerify = config.getBoolean(section, null, "disableSslVerify", false);
    PluginConfig pluginCfg = configFactory.getFromGerritConfig(pluginName);
    String accessKey = pluginCfg.getString("s3AccessKey", null);
    String secretKey = pluginCfg.getString("s3SecretKey", null);
    return new S3Config(region, bucket, storageClass, accessKey, secretKey, expirationSeconds, disableSslVerify);
}
#end_block

#method_before
private static Path getOrCreateDataDir(PluginConfigFactory cfgFactory, String pluginName, Path defaultDataDir) throws IOException {
    Config cfg = cfgFactory.getGlobalPluginConfig(pluginName);
    String dataDir = cfg.getString("fs", null, "directory");
    if (Strings.isNullOrEmpty(dataDir)) {
        return defaultDataDir;
    }
    // note that the following method not only creates missing
    // directory/directories but throws exception when path
    // exists and points to file
    Path ensured = Files.createDirectories(Paths.get(dataDir));
    // we should at least make sure that directory is readable
    if (!Files.isReadable(ensured)) {
        throw new IOException("Path '" + ensured.toAbsolutePath() + "' cannot be accessed");
    }
    return ensured;
}
#method_after
private static Path getOrCreateDataDir(PluginConfigFactory cfgFactory, String pluginName, Path defaultDataDir) throws IOException {
    Config cfg = cfgFactory.getGlobalPluginConfig(pluginName);
    String dataDir = cfg.getString(LfsBackend.FS.name(), null, "directory");
    if (Strings.isNullOrEmpty(dataDir)) {
        return defaultDataDir;
    }
    // note that the following method not only creates missing
    // directory/directories but throws exception when path
    // exists and points to file
    Path ensured = Files.createDirectories(Paths.get(dataDir));
    // we should at least make sure that directory is readable
    if (!Files.isReadable(ensured)) {
        throw new IOException("Path '" + ensured.toAbsolutePath() + "' cannot be accessed");
    }
    return ensured;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    LfsBackend backend = config.getEnum("data", null, "backend", LfsBackend.FS);
    switch(backend) {
        case FS:
            serveRegex(URL_REGEX).with(LfsFsApiServlet.class);
            bind(LocalLargeFileRepository.class);
            serve("/" + CONTENT_PATH + "/*").with(LfsFsContentServlet.class);
            break;
        case S3:
            serveRegex(URL_REGEX).with(LfsS3ApiServlet.class);
            bind(S3LargeFileRepository.class);
            break;
        default:
            throw new RuntimeException("Unsupported backend: " + backend);
    }
}
#method_after
@Override
protected void configureServlets() {
    LfsBackend backend = config.getEnum("storage", null, "backend", LfsBackend.FS);
    switch(backend) {
        case FS:
            serveRegex(URL_REGEX).with(LfsFsApiServlet.class);
            bind(LocalLargeFileRepository.class);
            serve("/" + CONTENT_PATH + "/*").with(LfsFsContentServlet.class);
            break;
        case S3:
            serveRegex(URL_REGEX).with(LfsS3ApiServlet.class);
            bind(S3LargeFileRepository.class);
            break;
        default:
            throw new RuntimeException("Unsupported backend: " + backend);
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    LfsBackend backend = config.getEnum("backend", LfsBackend.FS);
    switch(backend) {
        case FS:
            serveRegex(URL_REGEX).with(LfsFsApiServlet.class);
            bind(LocalLargeFileRepository.class);
            serve("/" + DATA_URL + "*").with(LfsFsContentServlet.class);
            break;
        case S3:
            serveRegex(URL_REGEX).with(LfsS3ApiServlet.class);
            bind(S3LargeFileRepository.class);
            break;
        default:
            throw new RuntimeException("Unsupported backend: " + backend);
    }
}
#method_after
@Override
protected void configureServlets() {
    LfsBackend backend = config.getEnum("backend", LfsBackend.FS);
    switch(backend) {
        case FS:
            serveRegex(URL_REGEX).with(LfsFsApiServlet.class);
            bind(LocalLargeFileRepository.class);
            serve("/" + CONTENT_PATH + "/*").with(LfsFsContentServlet.class);
            break;
        case S3:
            serveRegex(URL_REGEX).with(LfsS3ApiServlet.class);
            bind(S3LargeFileRepository.class);
            break;
        default:
            throw new RuntimeException("Unsupported backend: " + backend);
    }
}
#end_block

#method_before
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), refName), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.getChange() != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.getChange(), c.getChange().getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    log.warn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getMessage();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            checkState(NEW_PATCHSET.matcher(replace.inputCommand.getRefName()).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), replace.inputCommand.getRefName());
            try {
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        newProgress.update(newChanges.size());
        replaceProgress.update(replaceByChange.size());
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            log.error("Error submit changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            checkState(NEW_PATCHSET.matcher(replace.inputCommand.getRefName()).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), replace.inputCommand.getRefName());
            try {
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            log.error("Error submit changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    try {
        RevWalk rw = rp.getRevWalk();
        RevCommit commit = rw.parseCommit(commitId);
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    try {
        RevWalk rw = rp.getRevWalk();
        RevCommit commit = rw.parseCommit(commitId);
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        bySha.put(r.commitId, r.getChange());
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.change);
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkState(tipChange != null, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commitId, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<ChangeNotes, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(notesFactory.createAsync(changeUpdateExector, db, project.getNameKey(), request.ontoChange));
    }
    for (CheckedFuture<ChangeNotes, OrmException> f : futures) {
        ChangeNotes notes = f.checkedGet();
        if (notes.getChange() != null) {
            replaceByChange.get(notes.getChangeId()).change = notes.getChange();
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    Collection<ChangeNotes> allNotes = notesFactory.create(db, Collections2.transform(replaceByChange.values(), new Function<ReplaceRequest, Change.Id>() {

        @Override
        public Change.Id apply(ReplaceRequest in) {
            return in.ontoChange;
        }
    }));
    for (ChangeNotes notes : allNotes) {
        replaceByChange.get(notes.getChangeId()).notes = notes;
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = notes.getChange().currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    changeCtl = projectControl.controlFor(notes);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (notes.getChange().getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = notes.getChange().currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), notes.getChangeId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#method_after
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, notes.getChange().currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
void addOps(BatchUpdate bu) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, change.getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    bu.addOp(change.getId(), replaceOp);
}
#method_after
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#end_block

#method_before
void insertPatchSetWithoutBatchUpdate() throws IOException, UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins);
        addOps(bu);
        bu.execute();
    }
}
#method_after
void insertPatchSetWithoutBatchUpdate() throws IOException, UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins);
        addOps(bu, replaceProgress);
        bu.execute();
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        int n = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                n++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    Change.Id id = onto.getId();
                    final ReplaceRequest req = new ReplaceRequest(id, c, cmd, false);
                    req.change = onto;
                    if (req.validate(true)) {
                        n++;
                        req.addOps(bu);
                        bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                            @Override
                            public PatchSet get() {
                                return req.replaceOp.getPatchSet();
                            }
                        }));
                    }
                    break;
                }
            }
        }
        bu.execute();
        closeProgress.update(n);
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        bu.execute();
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, ChangeNotes> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, ChangeNotes> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.notes());
    }
    return r;
}
#end_block

#method_before
public void updateSuperProjects() throws SubmoduleException {
    SetMultimap<Project.NameKey, Branch.NameKey> dst = branchesByProject();
    Set<Project.NameKey> projects = dst.keySet();
    try {
        for (Project.NameKey project : projects) {
            // get a new BatchUpdate for the project
            orm.openRepo(project, false);
            orm.getRepo(project).resetUpdate();
            for (Branch.NameKey branch : dst.get(project)) {
                SubmoduleOp.RepoOnlyOp op = new SubmoduleOp.RepoOnlyOp(this, branch);
                orm.getRepo(project).getUpdate().addRepoOnlyOp(op);
            }
        }
        BatchUpdate.execute(orm.batchUpdates(projects), new Listener());
    } catch (RestApiException | UpdateException | IOException | NoSuchProjectException e) {
        throw new SubmoduleException("Cannot update gitlinks", e);
    }
}
#method_after
public void updateSuperProjects() throws SubmoduleException {
    SetMultimap<Project.NameKey, Branch.NameKey> dst = branchesByProject();
    Set<Project.NameKey> projects = dst.keySet();
    try {
        for (Project.NameKey project : projects) {
            // get a new BatchUpdate for the project
            orm.openRepo(project, false);
            // TODO:czhen remove this when MergeOp combine this into BatchUpdate
            orm.getRepo(project).resetUpdate();
            for (Branch.NameKey branch : dst.get(project)) {
                SubmoduleOp.GitlinkOp op = new SubmoduleOp.GitlinkOp(branch);
                orm.getRepo(project).getUpdate().addRepoOnlyOp(op);
            }
        }
        BatchUpdate.execute(orm.batchUpdates(projects), Listener.NONE);
    } catch (RestApiException | UpdateException | IOException | NoSuchProjectException e) {
        throw new SubmoduleException("Cannot update gitlinks", e);
    }
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, RevCommit baseCommit) throws IOException, SubmoduleException, OrmException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    RevCommit currentCommit = (baseCommit != null) ? baseCommit : or.rw.parseCommit(or.repo.exactRef(subscriber.get()).getObjectId());
    or.rw.parseBody(currentCommit);
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        try {
            orm.openRepo(s.getSubmodule().getParentKey(), false);
        } catch (NoSuchProjectException | IOException e) {
            throw new SubmoduleException("Cannot access submodule", e);
        }
        OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
        Repository subRepo = subOr.repo;
        Ref ref = subRepo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            continue;
        }
        ObjectId updateTo = ref.getObjectId();
        if (branchTips.containsKey(s.getSubmodule())) {
            updateTo = branchTips.get(s.getSubmodule());
        }
        RevWalk subOrRw = subOr.rw;
        final RevCommit newCommit = subOrRw.parseCommit(updateTo);
        subOrRw.parseBody(newCommit);
        if (author == null) {
            author = newCommit.getAuthorIdent();
        } else if (!author.equals(newCommit.getAuthorIdent())) {
            sameAuthorForAll = false;
        }
        DirCacheEntry dce = dc.getEntry(s.getPath());
        ObjectId oldId;
        if (dce != null) {
            if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                continue;
            }
            oldId = dce.getObjectId();
        } else {
            // This submodule did not exist before. We do not want to add
            // the full submodule history to the commit message, so omit it.
            oldId = updateTo;
        }
        ed.add(new PathEdit(s.getPath()) {

            @Override
            public void apply(DirCacheEntry ent) {
                ent.setFileMode(FileMode.GITLINK);
                ent.setObjectId(newCommit.getId());
            }
        });
        if (verboseSuperProject) {
            msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
            msgbuf.append(" " + s.getSubmodule().getShortName());
            msgbuf.append(" " + newCommit.getName());
            msgbuf.append("\n\n");
            try {
                subOrRw.resetRetain(subOr.canMergeFlag);
                subOrRw.markStart(newCommit);
                subOrRw.markUninteresting(subOrRw.parseCommit(oldId));
                for (RevCommit c : subOrRw) {
                    subOrRw.parseBody(c);
                    msgbuf.append(c.getFullMessage() + "\n\n");
                }
            } catch (IOException e) {
                throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
            }
        }
    }
    ed.finish();
    ObjectInserter oi = or.repo.newObjectInserter();
    CodeReviewRevWalk rw = or.rw;
    ObjectId tree = dc.writeTree(oi);
    if (!sameAuthorForAll || author == null) {
        author = myIdent;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(tree);
    if (baseCommit != null) {
        // modify the baseCommit
        commit.setParentIds(baseCommit.getParents());
        commit.setMessage(baseCommit.getFullMessage() + "\n\n" + msgbuf.toString());
        commit.setAuthor(baseCommit.getAuthorIdent());
    } else {
        // create a new commit
        commit.setParentId(currentCommit);
        commit.setMessage(msgbuf.toString());
        commit.setAuthor(author);
    }
    commit.setCommitter(myIdent);
    ObjectId id = oi.insert(commit);
    oi.flush();
    return rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, RevCommit baseCommit) throws IOException, SubmoduleException, OrmException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    RevCommit currentCommit = (baseCommit != null) ? baseCommit : or.rw.parseCommit(or.repo.exactRef(subscriber.get()).getObjectId());
    or.rw.parseBody(currentCommit);
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        try {
            orm.openRepo(s.getSubmodule().getParentKey(), false);
        } catch (NoSuchProjectException | IOException e) {
            throw new SubmoduleException("Cannot access submodule", e);
        }
        OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
        Repository subRepo = subOr.repo;
        Ref ref = subRepo.getRefDatabase().exactRef(s.getSubmodule().get());
        if (ref == null) {
            ed.add(new DeletePath(s.getPath()));
            continue;
        }
        ObjectId updateTo = ref.getObjectId();
        if (branchTips.containsKey(s.getSubmodule())) {
            updateTo = branchTips.get(s.getSubmodule());
        }
        RevWalk subOrRw = subOr.rw;
        final RevCommit newCommit = subOrRw.parseCommit(updateTo);
        subOrRw.parseBody(newCommit);
        if (author == null) {
            author = newCommit.getAuthorIdent();
        } else if (!author.equals(newCommit.getAuthorIdent())) {
            sameAuthorForAll = false;
        }
        DirCacheEntry dce = dc.getEntry(s.getPath());
        ObjectId oldId;
        if (dce != null) {
            if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                String errMsg = "Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.";
                throw new SubmoduleException(errMsg);
            }
            oldId = dce.getObjectId();
        } else {
            // This submodule did not exist before. We do not want to add
            // the full submodule history to the commit message, so omit it.
            oldId = updateTo;
        }
        ed.add(new PathEdit(s.getPath()) {

            @Override
            public void apply(DirCacheEntry ent) {
                ent.setFileMode(FileMode.GITLINK);
                ent.setObjectId(newCommit.getId());
            }
        });
        if (verboseSuperProject) {
            msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
            msgbuf.append(" " + s.getSubmodule().getShortName());
            msgbuf.append(" " + newCommit.getName());
            msgbuf.append("\n\n");
            try {
                subOrRw.resetRetain(subOr.canMergeFlag);
                subOrRw.markStart(newCommit);
                subOrRw.markUninteresting(subOrRw.parseCommit(oldId));
                for (RevCommit c : subOrRw) {
                    subOrRw.parseBody(c);
                    msgbuf.append(c.getFullMessage() + "\n\n");
                }
            } catch (IOException e) {
                throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
            }
        }
    }
    ed.finish();
    ObjectInserter oi = or.ins;
    CodeReviewRevWalk rw = or.rw;
    ObjectId tree = dc.writeTree(oi);
    if (!sameAuthorForAll || author == null) {
        author = myIdent;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(tree);
    if (baseCommit != null) {
        // modify the baseCommit
        commit.setParentIds(baseCommit.getParents());
        commit.setMessage(baseCommit.getFullMessage() + "\n\n" + msgbuf.toString());
        commit.setAuthor(baseCommit.getAuthorIdent());
    } else {
        // create a new commit
        commit.setParentId(currentCommit);
        commit.setMessage(msgbuf.toString());
        commit.setAuthor(author);
    }
    commit.setCommitter(myIdent);
    ObjectId id = oi.insert(commit);
    return rw.parseCommit(id);
}
#end_block

#method_before
private void checkSubmitRulesAndState() throws ResourceConflictException {
    for (ChangeData cd : commits.changes.values()) {
        try {
            if (cd.change().getStatus() != Change.Status.NEW) {
                commits.problem(cd.getId(), "Change " + cd.getId() + " is " + cd.change().getStatus().toString().toLowerCase());
            } else {
                checkSubmitRule(cd);
            }
        } catch (ResourceConflictException e) {
            commits.problem(cd.getId(), e.getMessage());
        } catch (OrmException e) {
            String msg = "Error checking submit rules for change";
            log.warn(msg + " " + cd.getId(), e);
            commits.problem(cd.getId(), msg);
        }
    }
    commits.maybeFailVerbose();
}
#method_after
private void checkSubmitRulesAndState(ChangeSet cs) throws ResourceConflictException {
    checkArgument(!cs.furtherHiddenChanges(), "checkSubmitRulesAndState called for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        try {
            if (cd.change().getStatus() != Change.Status.NEW) {
                commits.problem(cd.getId(), "Change " + cd.getId() + " is " + cd.change().getStatus().toString().toLowerCase());
            } else {
                checkSubmitRule(cd);
            }
        } catch (ResourceConflictException e) {
            commits.problem(cd.getId(), e.getMessage());
        } catch (OrmException e) {
            String msg = "Error checking submit rules for change";
            log.warn(msg + " " + cd.getId(), e);
            commits.problem(cd.getId(), msg);
        }
    }
    commits.maybeFailVerbose();
}
#end_block

#method_before
private void bypassSubmitRules(ChangeSet cs) {
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(records);
    }
}
#method_after
private void bypassSubmitRules(ChangeSet cs) {
    checkArgument(!cs.furtherHiddenChanges(), "cannot bypass submit rules for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(records);
    }
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState();
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Collection<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    List<SubmitStrategy> strategies = new ArrayList<>(branches.size());
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        OpenBranch ob = or.getBranch(branch);
        BranchBatch submitting = toSubmit.get(branch);
        checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
        Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
        ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
        SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip);
        strategies.add(strategy);
        strategy.addOps(or.getUpdate(), commitsToSubmit);
    }
    try {
        BatchUpdate.execute(batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    updateSuperProjects(br.values());
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Collection<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    List<SubmitStrategy> strategies = new ArrayList<>(branches.size());
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        OpenBranch ob = or.getBranch(branch);
        BranchBatch submitting = toSubmit.get(branch);
        checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
        Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
        ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
        SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip);
        strategies.add(strategy);
        strategy.addOps(or.getUpdate(), commitsToSubmit);
    }
    try {
        BatchUpdate.execute(batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    updateSuperProjects(br.values());
}
#end_block

#method_before
private Set<RevCommit> getAlreadyAccepted(OpenRepo or, CodeReviewCommit branchTip) throws IntegrationException {
    Set<RevCommit> alreadyAccepted = new HashSet<>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (Ref r : or.repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            try {
                alreadyAccepted.add(or.rw.parseCommit(r.getObjectId()));
            } catch (IncorrectObjectTypeException iote) {
            // Not a commit? Skip over it.
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Failed to determine already accepted commits.", e);
    }
    logDebug("Found {} existing heads", alreadyAccepted.size());
    return alreadyAccepted;
}
#method_after
private Set<RevCommit> getAlreadyAccepted(OpenRepo or, CodeReviewCommit branchTip) throws IntegrationException {
    Set<RevCommit> alreadyAccepted = new HashSet<>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (Ref r : or.repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            try {
                CodeReviewCommit aac = or.rw.parseCommit(r.getObjectId());
                if (!commits.commits.values().contains(aac)) {
                    alreadyAccepted.add(aac);
                }
            } catch (IncorrectObjectTypeException iote) {
            // Not a commit? Skip over it.
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Failed to determine already accepted commits.", e);
    }
    logDebug("Found {} existing heads", alreadyAccepted.size());
    return alreadyAccepted;
}
#end_block

#method_before
public BatchUpdate addOp(Change.Id id, Op op) {
    checkArgument(!(op instanceof InsertChangeOp), "use insertChange");
    ops.put(id, op);
    return this;
}
#method_after
public BatchUpdate addOp(Change.Id id, Op op) {
    checkArgument(!(op instanceof InsertChangeOp), "use insertChange");
    checkNotNull(op);
    ops.put(id, op);
    return this;
}
#end_block

#method_before
private void executeChangeOps(boolean parallel) throws UpdateException, RestApiException {
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        if (notesMigration.commitChangeWrites() && repo != null) {
            // A NoteDb change may have been rebuilt since the repo was originally
            // opened, so make sure we see that.
            repo.scanForRepoChanges();
        }
        if (!ops.isEmpty() && notesMigration.failChangeWrites()) {
            // this is a programmer error.
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread());
            tasks.add(task);
            futures.add(executor.submit(task));
        }
        long startNanos = System.nanoTime();
        Futures.allAsList(futures).get();
        long elapsedNanos = System.nanoTime() - startNanos;
        if (elapsedNanos > logThresholdNanos && log.isDebugEnabled()) {
            log.debug("Slow change update", new SlowUpdateException("Slow change update (%d ms) to %s for %s", NANOSECONDS.toMillis(elapsedNanos), project, ops.keySet()));
        }
        if (notesMigration.commitChangeWrites()) {
            startNanos = System.nanoTime();
            executeNoteDbUpdates(tasks);
            elapsedNanos = System.nanoTime() - startNanos;
            if (elapsedNanos > logThresholdNanos && log.isDebugEnabled()) {
                log.debug("Slow NoteDb update", new SlowUpdateException("Slow NoteDb update (%d ms) to %s for %s", NANOSECONDS.toMillis(elapsedNanos), project, ops.keySet()));
            }
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    } catch (OrmException | IOException e) {
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else if (task.dirty) {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#method_after
private void executeChangeOps(boolean parallel) throws UpdateException, RestApiException {
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        if (notesMigration.commitChangeWrites() && repo != null) {
            // A NoteDb change may have been rebuilt since the repo was originally
            // opened, so make sure we see that.
            repo.scanForRepoChanges();
        }
        if (!ops.isEmpty() && notesMigration.failChangeWrites()) {
            // this is a programmer error.
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread());
            tasks.add(task);
            futures.add(executor.submit(task));
        }
        long startNanos = System.nanoTime();
        Futures.allAsList(futures).get();
        maybeLogSlowUpdate(startNanos, "change");
        if (notesMigration.commitChangeWrites()) {
            startNanos = System.nanoTime();
            executeNoteDbUpdates(tasks);
            maybeLogSlowUpdate(startNanos, "NoteDb");
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    } catch (OrmException | IOException e) {
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else if (task.dirty) {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#end_block

#method_before
@Test
public void addGroupAsReviewer() throws Exception {
    // Set up two groups, one that is too large too add as reviewer, and one
    // that is too large to add without confirmation.
    String largeGroup = createGroup("largeGroup");
    String mediumGroup = createGroup("mediumGroup");
    int largeGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS + 1;
    int mediumGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK + 1;
    List<TestAccount> users = createAccounts(largeGroupSize, "addGroupAsReviewer");
    List<String> largeGroupUsernames = new ArrayList<>(mediumGroupSize);
    for (TestAccount u : users) {
        largeGroupUsernames.add(u.username);
    }
    List<String> mediumGroupUsernames = largeGroupUsernames.subList(0, mediumGroupSize);
    gApi.groups().id(largeGroup).addMembers(largeGroupUsernames.toArray(new String[largeGroupSize]));
    gApi.groups().id(mediumGroup).addMembers(mediumGroupUsernames.toArray(new String[mediumGroupSize]));
    // Attempt to add overly large group as reviewers.
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerResult result = addReviewer(changeId, largeGroup);
    assertThat(result.reviewer).isEqualTo(largeGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).contains("has too many members to add them all as reviewers");
    assertThat(result.reviewers).isNull();
    // Attempt to add medium group without confirmation.
    result = addReviewer(changeId, mediumGroup);
    assertThat(result.reviewer).isEqualTo(mediumGroup);
    assertThat(result.confirm).isTrue();
    assertThat(result.error).contains("has " + mediumGroupSize + " members. Do you want to add them" + " all as reviewers?");
    assertThat(result.reviewers).isNull();
    // Add medium group with confirmation.
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = mediumGroup;
    in.confirmed = true;
    result = addReviewer(changeId, in);
    assertThat(result.reviewer).isEqualTo(mediumGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    assertThat(result.reviewers).hasSize(mediumGroupSize);
    // Verify that group members were added as reviewers.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, notesMigration.readChanges() ? REVIEWER : CC, users.subList(0, mediumGroupSize));
}
#method_after
@Test
public void addGroupAsReviewer() throws Exception {
    // Set up two groups, one that is too large too add as reviewer, and one
    // that is too large to add without confirmation.
    String largeGroup = createGroup("largeGroup");
    String mediumGroup = createGroup("mediumGroup");
    int largeGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS + 1;
    int mediumGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK + 1;
    List<TestAccount> users = createAccounts(largeGroupSize, "addGroupAsReviewer");
    List<String> largeGroupUsernames = new ArrayList<>(mediumGroupSize);
    for (TestAccount u : users) {
        largeGroupUsernames.add(u.username);
    }
    List<String> mediumGroupUsernames = largeGroupUsernames.subList(0, mediumGroupSize);
    gApi.groups().id(largeGroup).addMembers(largeGroupUsernames.toArray(new String[largeGroupSize]));
    gApi.groups().id(mediumGroup).addMembers(mediumGroupUsernames.toArray(new String[mediumGroupSize]));
    // Attempt to add overly large group as reviewers.
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerResult result = addReviewer(changeId, largeGroup);
    assertThat(result.input).isEqualTo(largeGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).contains("has too many members to add them all as reviewers");
    assertThat(result.reviewers).isNull();
    // Attempt to add medium group without confirmation.
    result = addReviewer(changeId, mediumGroup);
    assertThat(result.input).isEqualTo(mediumGroup);
    assertThat(result.confirm).isTrue();
    assertThat(result.error).contains("has " + mediumGroupSize + " members. Do you want to add them" + " all as reviewers?");
    assertThat(result.reviewers).isNull();
    // Add medium group with confirmation.
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = mediumGroup;
    in.confirmed = true;
    result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(mediumGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    assertThat(result.reviewers).hasSize(mediumGroupSize);
    // Verify that group members were added as reviewers.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, notesMigration.readChanges() ? REVIEWER : CC, users.subList(0, mediumGroupSize));
}
#end_block

#method_before
@Test
public void addCcAccount() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    sender.clear();
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    in.state = CC;
    AddReviewerResult result = addReviewer(changeId, in);
    assertThat(result.reviewer).isEqualTo(user.email);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertThat(result.reviewers).isNull();
        assertThat(result.ccs).hasSize(1);
        AccountInfo ai = result.ccs.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, CC, user);
    } else {
        assertThat(result.ccs).isNull();
        assertThat(result.reviewers).hasSize(1);
        AccountInfo ai = result.reviewers.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, CC, user);
    }
    // Verify email was sent to CCed account.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    if (notesMigration.readChanges()) {
        assertThat(m.body()).contains(admin.fullName + " has uploaded a new change for review.");
    } else {
        assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
        assertThat(m.body()).contains("I'd like you to do a code review.");
    }
}
#method_after
@Test
public void addCcAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    in.state = CC;
    AddReviewerResult result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(user.email);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertThat(result.reviewers).isNull();
        assertThat(result.ccs).hasSize(1);
        AccountInfo ai = result.ccs.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, CC, user);
    } else {
        assertThat(result.ccs).isNull();
        assertThat(result.reviewers).hasSize(1);
        AccountInfo ai = result.reviewers.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, CC, user);
    }
    // Verify email was sent to CCed account.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    if (notesMigration.readChanges()) {
        assertThat(m.body()).contains(admin.fullName + " has uploaded a new change for review.");
    } else {
        assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
        assertThat(m.body()).contains("I'd like you to do a code review.");
    }
}
#end_block

#method_before
@Test
public void addCcGroup() throws Exception {
    List<TestAccount> users = createAccounts(6, "addCcGroup");
    List<String> usernames = new ArrayList<>(6);
    for (TestAccount u : users) {
        usernames.add(u.username);
    }
    List<TestAccount> firstUsers = users.subList(0, 3);
    List<String> firstUsernames = usernames.subList(0, 3);
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    sender.clear();
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = createGroup("cc1");
    in.state = CC;
    gApi.groups().id(in.reviewer).addMembers(firstUsernames.toArray(new String[firstUsernames.size()]));
    AddReviewerResult result = addReviewer(changeId, in);
    assertThat(result.reviewer).isEqualTo(in.reviewer);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    if (notesMigration.readChanges()) {
        assertThat(result.reviewers).isNull();
    } else {
        assertThat(result.ccs).isNull();
    }
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, CC, firstUsers);
    // Verify emails were sent to each of the group's accounts.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    List<Address> expectedAddresses = new ArrayList<>(firstUsers.size());
    for (TestAccount u : firstUsers) {
        expectedAddresses.add(u.emailAddress);
    }
    assertThat(m.rcpt()).containsExactlyElementsIn(expectedAddresses);
    // CC a group that overlaps with some existing reviewers and CCed accounts.
    TestAccount reviewer = accounts.create(name("reviewer"), "addCcGroup-reviewer@example.com", "Reviewer");
    result = addReviewer(changeId, reviewer.username);
    assertThat(result.error).isNull();
    sender.clear();
    in.reviewer = createGroup("cc2");
    gApi.groups().id(in.reviewer).addMembers(usernames.toArray(new String[usernames.size()]));
    gApi.groups().id(in.reviewer).addMembers(reviewer.username);
    result = addReviewer(changeId, in);
    assertThat(result.reviewer).isEqualTo(in.reviewer);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertThat(result.ccs).hasSize(3);
        assertThat(result.reviewers).isNull();
        assertReviewers(c, REVIEWER, reviewer);
        assertReviewers(c, CC, users);
    } else {
        assertThat(result.ccs).isNull();
        assertThat(result.reviewers).hasSize(3);
        List<TestAccount> expectedUsers = new ArrayList<>(users.size() + 2);
        expectedUsers.addAll(users);
        expectedUsers.add(reviewer);
        assertReviewers(c, CC, expectedUsers);
    }
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    expectedAddresses = new ArrayList<>(4);
    for (int i = 0; i < 3; i++) {
        expectedAddresses.add(users.get(users.size() - i - 1).emailAddress);
    }
    if (notesMigration.readChanges()) {
        expectedAddresses.add(reviewer.emailAddress);
    }
    assertThat(m.rcpt()).containsExactlyElementsIn(expectedAddresses);
}
#method_after
@Test
public void addCcGroup() throws Exception {
    List<TestAccount> users = createAccounts(6, "addCcGroup");
    List<String> usernames = new ArrayList<>(6);
    for (TestAccount u : users) {
        usernames.add(u.username);
    }
    List<TestAccount> firstUsers = users.subList(0, 3);
    List<String> firstUsernames = usernames.subList(0, 3);
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = createGroup("cc1");
    in.state = CC;
    gApi.groups().id(in.reviewer).addMembers(firstUsernames.toArray(new String[firstUsernames.size()]));
    AddReviewerResult result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(in.reviewer);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    if (notesMigration.readChanges()) {
        assertThat(result.reviewers).isNull();
    } else {
        assertThat(result.ccs).isNull();
    }
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, CC, firstUsers);
    // Verify emails were sent to each of the group's accounts.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    List<Address> expectedAddresses = new ArrayList<>(firstUsers.size());
    for (TestAccount u : firstUsers) {
        expectedAddresses.add(u.emailAddress);
    }
    assertThat(m.rcpt()).containsExactlyElementsIn(expectedAddresses);
    // CC a group that overlaps with some existing reviewers and CCed accounts.
    TestAccount reviewer = accounts.create(name("reviewer"), "addCcGroup-reviewer@example.com", "Reviewer");
    result = addReviewer(changeId, reviewer.username);
    assertThat(result.error).isNull();
    sender.clear();
    in.reviewer = createGroup("cc2");
    gApi.groups().id(in.reviewer).addMembers(usernames.toArray(new String[usernames.size()]));
    gApi.groups().id(in.reviewer).addMembers(reviewer.username);
    result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(in.reviewer);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertThat(result.ccs).hasSize(3);
        assertThat(result.reviewers).isNull();
        assertReviewers(c, REVIEWER, reviewer);
        assertReviewers(c, CC, users);
    } else {
        assertThat(result.ccs).isNull();
        assertThat(result.reviewers).hasSize(3);
        List<TestAccount> expectedUsers = new ArrayList<>(users.size() + 2);
        expectedUsers.addAll(users);
        expectedUsers.add(reviewer);
        assertReviewers(c, CC, expectedUsers);
    }
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    expectedAddresses = new ArrayList<>(4);
    for (int i = 0; i < 3; i++) {
        expectedAddresses.add(users.get(users.size() - i - 1).emailAddress);
    }
    if (notesMigration.readChanges()) {
        expectedAddresses.add(reviewer.emailAddress);
    }
    assertThat(m.rcpt()).containsExactlyElementsIn(expectedAddresses);
}
#end_block

#method_before
@Test
public void reviewAndAddReviewers() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    sender.clear();
    TestAccount observer = accounts.user2();
    PushOneCommit.Result r = createChange();
    ReviewInput input = ReviewInput.approve().reviewer(user.email).reviewer(observer.email, CC, false);
    ReviewResult result = review(r.getChangeId(), r.getCommit().name(), input);
    assertThat(result.labels).isNotNull();
    assertThat(result.reviewers).isNotNull();
    assertThat(result.reviewers).hasSize(2);
    // Verify reviewer and CC were added. If not in NoteDb read mode, both
    // parties will be returned as CCed.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertReviewers(c, REVIEWER, admin, user);
        assertReviewers(c, CC, observer);
    } else {
        // In legacy mode, change owner should be the only reviewer.
        assertReviewers(c, REVIEWER, admin);
        assertReviewers(c, CC, user, observer);
    }
    // Verify emails were sent to added reviewers.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(3);
    // First email to user.
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    // Second email to reviewer and observer.
    m = messages.get(1);
    if (notesMigration.readChanges()) {
        assertThat(m.rcpt()).containsExactly(user.emailAddress, observer.emailAddress);
        assertThat(m.body()).contains(admin.fullName + " has uploaded a new change for review.");
    } else {
        assertThat(m.rcpt()).containsExactly(observer.emailAddress);
        assertThat(m.body()).contains("Hello " + observer.fullName + ",\n");
        assertThat(m.body()).contains("I'd like you to do a code review.");
    }
    // Third email is review to user and observer.
    m = messages.get(2);
    assertThat(m.rcpt()).containsExactly(user.emailAddress, observer.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has posted comments on this change.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertThat(m.body()).contains("Patch Set 1: Code-Review+2\n");
}
#method_after
@Test
public void reviewAndAddReviewers() throws Exception {
    TestAccount observer = accounts.user2();
    PushOneCommit.Result r = createChange();
    ReviewInput input = ReviewInput.approve().reviewer(user.email).reviewer(observer.email, CC, false);
    ReviewResult result = review(r.getChangeId(), r.getCommit().name(), input);
    assertThat(result.labels).isNotNull();
    assertThat(result.reviewers).isNotNull();
    assertThat(result.reviewers).hasSize(2);
    // Verify reviewer and CC were added. If not in NoteDb read mode, both
    // parties will be returned as CCed.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertReviewers(c, REVIEWER, admin, user);
        assertReviewers(c, CC, observer);
    } else {
        // In legacy mode, change owner should be the only reviewer.
        assertReviewers(c, REVIEWER, admin);
        assertReviewers(c, CC, user, observer);
    }
    // Verify emails were sent to added reviewers.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(3);
    // First email to user.
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    // Second email to reviewer and observer.
    m = messages.get(1);
    if (notesMigration.readChanges()) {
        assertThat(m.rcpt()).containsExactly(user.emailAddress, observer.emailAddress);
        assertThat(m.body()).contains(admin.fullName + " has uploaded a new change for review.");
    } else {
        assertThat(m.rcpt()).containsExactly(observer.emailAddress);
        assertThat(m.body()).contains("Hello " + observer.fullName + ",\n");
        assertThat(m.body()).contains("I'd like you to do a code review.");
    }
    // Third email is review to user and observer.
    m = messages.get(2);
    assertThat(m.rcpt()).containsExactly(user.emailAddress, observer.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has posted comments on this change.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertThat(m.body()).contains("Patch Set 1: Code-Review+2\n");
}
#end_block

#method_before
private static void assertReviewers(ChangeInfo c, ReviewerState reviewerState, Iterable<TestAccount> accounts) throws Exception {
    Collection<AccountInfo> actualAccounts = c.reviewers.get(reviewerState);
    assertThat(actualAccounts).isNotNull();
    List<Integer> actualAccountIds = new ArrayList<>(actualAccounts.size());
    for (AccountInfo account : actualAccounts) {
        actualAccountIds.add(account._accountId);
    }
    List<Integer> expectedAccountIds = new ArrayList<>();
    for (TestAccount account : accounts) {
        expectedAccountIds.add(account.getId().get());
    }
    assertThat(actualAccountIds).containsExactlyElementsIn(expectedAccountIds);
}
#method_after
private static void assertReviewers(ChangeInfo c, ReviewerState reviewerState, Iterable<TestAccount> accounts) throws Exception {
    Collection<AccountInfo> actualAccounts = c.reviewers.get(reviewerState);
    if (actualAccounts == null) {
        assertThat(accounts.iterator().hasNext()).isFalse();
        return;
    }
    assertThat(actualAccounts).isNotNull();
    List<Integer> actualAccountIds = new ArrayList<>(actualAccounts.size());
    for (AccountInfo account : actualAccounts) {
        actualAccountIds.add(account._accountId);
    }
    List<Integer> expectedAccountIds = new ArrayList<>();
    for (TestAccount account : accounts) {
        expectedAccountIds.add(account.getId().get());
    }
    assertThat(actualAccountIds).containsExactlyElementsIn(expectedAccountIds);
}
#end_block

#method_before
@Override
public AddReviewerResult apply(ChangeResource rsrc, AddReviewerInput input) throws IOException, OrmException, RestApiException, UpdateException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    Addition addition = prepareApplication(rsrc, input);
    addition.apply(rsrc);
    return addition.result;
}
#method_after
@Override
public AddReviewerResult apply(ChangeResource rsrc, AddReviewerInput input) throws IOException, OrmException, RestApiException, UpdateException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    Addition addition = prepareApplication(rsrc, input);
    if (addition.op == null) {
        return addition.result;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, addition.op);
        bu.execute();
        addition.gatherResults();
    }
    return addition.result;
}
#end_block

#method_before
public Addition prepareApplication(ChangeResource rsrc, AddReviewerInput input) throws OrmException, RestApiException {
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.state());
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#method_after
public Addition prepareApplication(ChangeResource rsrc, AddReviewerInput input) throws OrmException, RestApiException, IOException {
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.state());
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#end_block

#method_before
private Addition putGroup(ChangeResource rsrc, AddReviewerInput input) throws RestApiException, OrmException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName()));
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IOException e) {
        // TODO(logan): return error to client
        throw new UnprocessableEntityException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName()));
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        return fail(input.reviewer, true, MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size()));
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    return new Addition(input.reviewer, rsrc, reviewers, input.state());
}
#method_after
private Addition putGroup(ChangeResource rsrc, AddReviewerInput input) throws RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName()));
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName()));
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        return fail(input.reviewer, true, MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size()));
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    return new Addition(input.reviewer, rsrc, reviewers, input.state());
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws Exception {
    if (addedCCs != null) {
        emailCCs(rsrc.getChange(), addedCCs);
    }
    if (addedReviewers != null) {
        emailReviewers(rsrc.getChange(), addedReviewers);
        if (!addedReviewers.isEmpty()) {
            for (PatchSetApproval psa : addedReviewers) {
                Account account = accountCache.get(psa.getAccountId()).getAccount();
                reviewerAdded.fire(rsrc.getChange(), patchSet, account);
            }
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws Exception {
    if (addedReviewers != null || addedCCs != null) {
        if (addedReviewers == null) {
            addedReviewers = new ArrayList<>();
        }
        if (addedCCs == null) {
            addedCCs = new ArrayList<>();
        }
        emailReviewers(rsrc.getChange(), addedReviewers, addedCCs);
        if (!addedReviewers.isEmpty()) {
            for (PatchSetApproval psa : addedReviewers) {
                Account account = accountCache.get(psa.getAccountId()).getAccount();
                reviewerAdded.fire(rsrc.getChange(), patchSet, account, ctx.getAccount(), ctx.getWhen());
            }
        }
    }
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Change change, List<PatchSetApproval> added, Collection<Account.Id> copied) {
    if (added.isEmpty() && copied.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    List<Account.Id> toCopy = Lists.newArrayListWithCapacity(copied.size());
    for (Account.Id id : copied) {
        if (!id.equals(userId)) {
            toCopy.add(id);
        }
    }
    if (toMail.isEmpty() && toCopy.isEmpty()) {
        return;
    }
    try {
        AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
        cm.setFrom(userId);
        cm.addReviewers(toMail);
        cm.addExtraCC(toCopy);
        cm.send();
    } catch (Exception err) {
        log.error("Cannot send email to new reviewers of change " + change.getId(), err);
    }
}
#end_block

#method_before
@Override
public ReviewResult apply(RevisionResource revision, ReviewInput input) throws RestApiException, UpdateException, OrmException {
    return apply(revision, input, TimeUtil.nowTs());
}
#method_after
@Override
public ReviewResult apply(RevisionResource revision, ReviewInput input) throws RestApiException, UpdateException, OrmException, IOException {
    return apply(revision, input, TimeUtil.nowTs());
}
#end_block

#method_before
public ReviewResult apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        // TODO(logan): return new PatchSetApprovals
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return output;
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            // Generate result details and fill AccountLoader. This occurs outside
            // the Op because the accounts are in a different table.
            PostReviewers.Op op = reviewerResult.op;
            if (migration.readChanges() && op.state == ReviewerState.CC) {
                reviewerResult.result.ccs = Lists.newArrayListWithCapacity(op.addedCCs.size());
                for (Account.Id accountId : op.addedCCs) {
                    reviewerResult.result.ccs.add(reviewerJson.format(new ReviewerInfo(accountId.get()), op.reviewers.get(accountId)));
                }
                accountLoaderFactory.create(true).fill(reviewerResult.result.ccs);
            } else {
                reviewerResult.result.reviewers = Lists.newArrayListWithCapacity(op.addedReviewers.size());
                for (PatchSetApproval psa : op.addedReviewers) {
                    // New reviewers have value 0, don't bother normalizing.
                    reviewerResult.result.reviewers.add(reviewerJson.format(new ReviewerInfo(psa.getAccountId().get()), op.reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
                }
                accountLoaderFactory.create(true).fill(reviewerResult.result.reviewers);
            }
        }
    }
    return output;
}
#method_after
public ReviewResult apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return output;
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
    }
    return output;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getUser().asIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#end_block

#method_before
@Test
public void addGroupAsReviewer() throws Exception {
    // Set up two groups, one that is too large too add as reviewer, and one
    // that is too large to add without confirmation.
    String largeGroup = createGroup("largeGroup");
    String mediumGroup = createGroup("mediumGroup");
    TestAccount[] users = new TestAccount[PostReviewers.DEFAULT_MAX_REVIEWERS + 1];
    String[] largeGroupUsernames = new String[PostReviewers.DEFAULT_MAX_REVIEWERS + 1];
    String[] mediumGroupUsernames = new String[PostReviewers.DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK + 1];
    for (int i = 0; i < users.length; i++) {
        users[i] = accounts.create("u" + i, "u" + i + "@example.com", "Full Name " + i);
        largeGroupUsernames[i] = users[i].username;
        if (i < mediumGroupUsernames.length) {
            mediumGroupUsernames[i] = users[i].username;
        }
    }
    gApi.groups().id(largeGroup).addMembers(largeGroupUsernames);
    gApi.groups().id(mediumGroup).addMembers(mediumGroupUsernames);
    // Attempt to add overly large group as reviewers.
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerResult result = addReviewer(changeId, largeGroup);
    assertThat(result.reviewer).isEqualTo(largeGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).contains("has too many members to add them all as reviewers");
    assertThat(result.reviewers).isNull();
    // Attempt to add medium group without confirmation.
    result = addReviewer(changeId, mediumGroup);
    assertThat(result.reviewer).isEqualTo(mediumGroup);
    assertThat(result.confirm).isTrue();
    assertThat(result.error).contains("has " + mediumGroupUsernames.length + " members. Do you want to add them all" + " as reviewers?");
    assertThat(result.reviewers).isNull();
    // Add medium group with confirmation.
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = mediumGroup;
    in.confirmed = true;
    result = addReviewer(changeId, in);
    assertThat(result.reviewer).isEqualTo(mediumGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    assertThat(result.reviewers).hasSize(mediumGroupUsernames.length);
    // Verify that group members were added as reviewers.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, NoteDbMode.readWrite() ? REVIEWER : CC, Arrays.copyOf(users, mediumGroupUsernames.length));
}
#method_after
@Test
public void addGroupAsReviewer() throws Exception {
    // Set up two groups, one that is too large too add as reviewer, and one
    // that is too large to add without confirmation.
    String largeGroup = createGroup("largeGroup");
    String mediumGroup = createGroup("mediumGroup");
    int largeGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS + 1;
    int mediumGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK + 1;
    List<TestAccount> users = createAccounts(largeGroupSize, "addGroupAsReviewer");
    List<String> largeGroupUsernames = new ArrayList<>(mediumGroupSize);
    for (TestAccount u : users) {
        largeGroupUsernames.add(u.username);
    }
    List<String> mediumGroupUsernames = largeGroupUsernames.subList(0, mediumGroupSize);
    gApi.groups().id(largeGroup).addMembers(largeGroupUsernames.toArray(new String[largeGroupSize]));
    gApi.groups().id(mediumGroup).addMembers(mediumGroupUsernames.toArray(new String[mediumGroupSize]));
    // Attempt to add overly large group as reviewers.
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerResult result = addReviewer(changeId, largeGroup);
    assertThat(result.input).isEqualTo(largeGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).contains("has too many members to add them all as reviewers");
    assertThat(result.reviewers).isNull();
    // Attempt to add medium group without confirmation.
    result = addReviewer(changeId, mediumGroup);
    assertThat(result.input).isEqualTo(mediumGroup);
    assertThat(result.confirm).isTrue();
    assertThat(result.error).contains("has " + mediumGroupSize + " members. Do you want to add them" + " all as reviewers?");
    assertThat(result.reviewers).isNull();
    // Add medium group with confirmation.
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = mediumGroup;
    in.confirmed = true;
    result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(mediumGroup);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    assertThat(result.reviewers).hasSize(mediumGroupSize);
    // Verify that group members were added as reviewers.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertReviewers(c, notesMigration.readChanges() ? REVIEWER : CC, users.subList(0, mediumGroupSize));
}
#end_block

#method_before
AddReviewerResult addReviewer(String changeId, String reviewer) throws Exception {
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = reviewer;
    return addReviewer(changeId, in);
}
#method_after
private AddReviewerResult addReviewer(String changeId, String reviewer) throws Exception {
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = reviewer;
    return addReviewer(changeId, in);
}
#end_block

#method_before
AddReviewerResult addReviewer(String changeId, AddReviewerInput in) throws Exception {
    RestResponse resp = adminRestSession.post("/changes/" + changeId + "/reviewers", in);
    return readContentFromJson(resp, AddReviewerResult.class);
}
#method_after
private AddReviewerResult addReviewer(String changeId, AddReviewerInput in) throws Exception {
    RestResponse resp = adminRestSession.post("/changes/" + changeId + "/reviewers", in);
    return readContentFromJson(resp, AddReviewerResult.class);
}
#end_block

#method_before
private static void assertReviewers(ChangeInfo c, ReviewerState reviewerState, TestAccount... accounts) throws Exception {
    Collection<AccountInfo> actualAccounts = c.reviewers.get(reviewerState);
    assertThat(actualAccounts).isNotNull();
    List<Integer> actualAccountIds = Lists.newArrayListWithCapacity(actualAccounts.size());
    for (AccountInfo account : actualAccounts) {
        actualAccountIds.add(account._accountId);
    }
    List<Integer> expectedAccountIds = Lists.newArrayListWithCapacity(accounts.length);
    for (TestAccount account : accounts) {
        expectedAccountIds.add(account.getId().get());
    }
    assertThat(actualAccountIds).containsExactlyElementsIn(expectedAccountIds);
}
#method_after
private static void assertReviewers(ChangeInfo c, ReviewerState reviewerState, TestAccount... accounts) throws Exception {
    List<TestAccount> accountList = new ArrayList<>(accounts.length);
    for (TestAccount a : accounts) {
        accountList.add(a);
    }
    assertReviewers(c, reviewerState, accountList);
}
#end_block

#method_before
private static void assertReviewers(ChangeInfo c, ReviewerState reviewerState, TestAccount... accounts) throws Exception {
    Collection<AccountInfo> actualAccounts = c.reviewers.get(reviewerState);
    assertThat(actualAccounts).isNotNull();
    List<Integer> actualAccountIds = Lists.newArrayListWithCapacity(actualAccounts.size());
    for (AccountInfo account : actualAccounts) {
        actualAccountIds.add(account._accountId);
    }
    List<Integer> expectedAccountIds = Lists.newArrayListWithCapacity(accounts.length);
    for (TestAccount account : accounts) {
        expectedAccountIds.add(account.getId().get());
    }
    assertThat(actualAccountIds).containsExactlyElementsIn(expectedAccountIds);
}
#method_after
private static void assertReviewers(ChangeInfo c, ReviewerState reviewerState, Iterable<TestAccount> accounts) throws Exception {
    Collection<AccountInfo> actualAccounts = c.reviewers.get(reviewerState);
    if (actualAccounts == null) {
        assertThat(accounts.iterator().hasNext()).isFalse();
        return;
    }
    assertThat(actualAccounts).isNotNull();
    List<Integer> actualAccountIds = new ArrayList<>(actualAccounts.size());
    for (AccountInfo account : actualAccounts) {
        actualAccountIds.add(account._accountId);
    }
    List<Integer> expectedAccountIds = new ArrayList<>();
    for (TestAccount account : accounts) {
        expectedAccountIds.add(account.getId().get());
    }
    assertThat(actualAccountIds).containsExactlyElementsIn(expectedAccountIds);
}
#end_block

#method_before
@Override
public AddReviewerResult apply(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, OrmException, RestApiException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.cc());
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#method_after
@Override
public AddReviewerResult apply(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, OrmException, RestApiException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.state());
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#end_block

#method_before
private AddReviewerResult putAccount(String reviewer, ReviewerResource rsrc, boolean cc) throws OrmException, UpdateException, RestApiException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    AddReviewerResult result = new AddReviewerResult(reviewer);
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc.getChangeResource(), result, ImmutableMap.of(member.getId(), control), cc);
    }
    return result;
}
#method_after
private AddReviewerResult putAccount(String reviewer, ReviewerResource rsrc, ReviewerState state) throws OrmException, UpdateException, RestApiException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    AddReviewerResult result = new AddReviewerResult(reviewer);
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc.getChangeResource(), result, ImmutableMap.of(member.getId(), control), state);
    }
    return result;
}
#end_block

#method_before
private AddReviewerResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    AddReviewerResult result = new AddReviewerResult(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers, input.cc());
    return result;
}
#method_after
private AddReviewerResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    AddReviewerResult result = new AddReviewerResult(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers, input.state());
    return result;
}
#end_block

#method_before
private void addReviewers(ChangeResource rsrc, AddReviewerResult result, Map<Account.Id, ChangeControl> reviewers, boolean cc) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc, reviewers, cc);
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, op);
        bu.execute();
        // the Op because the accounts are in a different table.
        if (migration.readChanges() && cc) {
            result.ccs = Lists.newArrayListWithCapacity(op.addedCCs.size());
            for (Account.Id accountId : op.addedCCs) {
                result.ccs.add(json.format(new ReviewerInfo(accountId.get()), reviewers.get(accountId)));
            }
            accountLoaderFactory.create(true).fill(result.ccs);
        } else {
            result.reviewers = Lists.newArrayListWithCapacity(op.addedReviewers.size());
            for (PatchSetApproval psa : op.addedReviewers) {
                // New reviewers have value 0, don't bother normalizing.
                result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId().get()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
            }
            accountLoaderFactory.create(true).fill(result.reviewers);
        }
    }
}
#method_after
private void addReviewers(ChangeResource rsrc, AddReviewerResult result, Map<Account.Id, ChangeControl> reviewers, ReviewerState state) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc, reviewers, state);
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, op);
        bu.execute();
        // the Op because the accounts are in a different table.
        if (migration.readChanges() && state == CC) {
            result.ccs = Lists.newArrayListWithCapacity(op.addedCCs.size());
            for (Account.Id accountId : op.addedCCs) {
                result.ccs.add(json.format(new ReviewerInfo(accountId.get()), reviewers.get(accountId)));
            }
            accountLoaderFactory.create(true).fill(result.ccs);
        } else {
            result.reviewers = Lists.newArrayListWithCapacity(op.addedReviewers.size());
            for (PatchSetApproval psa : op.addedReviewers) {
                // New reviewers have value 0, don't bother normalizing.
                result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId().get()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
            }
            accountLoaderFactory.create(true).fill(result.reviewers);
        }
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    if (migration.readChanges() && cc) {
        addedCCs = approvalsUtil.addCCs(ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), reviewers.keySet());
        if (addedCCs.isEmpty()) {
            return false;
        }
    } else {
        addedReviewers = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
        if (addedReviewers.isEmpty()) {
            return false;
        }
    }
    patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    if (migration.readChanges() && state == CC) {
        addedCCs = approvalsUtil.addCcs(ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), reviewers.keySet());
        if (addedCCs.isEmpty()) {
            return false;
        }
    } else {
        addedReviewers = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
        if (addedReviewers.isEmpty()) {
            return false;
        }
    }
    patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws Exception {
    if (addedCCs != null) {
        emailCCs(rsrc.getChange(), addedCCs);
    }
    if (addedReviewers != null) {
        emailReviewers(rsrc.getChange(), addedReviewers);
        if (!addedReviewers.isEmpty()) {
            for (PatchSetApproval psa : addedReviewers) {
                Account account = accountCache.get(psa.getAccountId()).getAccount();
                reviewerAdded.fire(rsrc.getChange(), patchSet, account);
            }
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws Exception {
    if (addedReviewers != null || addedCCs != null) {
        if (addedReviewers == null) {
            addedReviewers = new ArrayList<>();
        }
        if (addedCCs == null) {
            addedCCs = new ArrayList<>();
        }
        emailReviewers(rsrc.getChange(), addedReviewers, addedCCs);
        if (!addedReviewers.isEmpty()) {
            for (PatchSetApproval psa : addedReviewers) {
                Account account = accountCache.get(psa.getAccountId()).getAccount();
                reviewerAdded.fire(rsrc.getChange(), patchSet, account, ctx.getAccount(), ctx.getWhen());
            }
        }
    }
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (toMail.isEmpty()) {
        return;
    }
    try {
        AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
        cm.setFrom(userId);
        cm.addReviewers(toMail);
        cm.send();
    } catch (Exception err) {
        log.error("Cannot send email to new reviewers of change " + change.getId(), err);
    }
}
#method_after
private void emailReviewers(Change change, List<PatchSetApproval> added, Collection<Account.Id> copied) {
    if (added.isEmpty() && copied.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    List<Account.Id> toCopy = Lists.newArrayListWithCapacity(copied.size());
    for (Account.Id id : copied) {
        if (!id.equals(userId)) {
            toCopy.add(id);
        }
    }
    if (toMail.isEmpty() && toCopy.isEmpty()) {
        return;
    }
    try {
        AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
        cm.setFrom(userId);
        cm.addReviewers(toMail);
        cm.addExtraCC(toCopy);
        cm.send();
    } catch (Exception err) {
        log.error("Cannot send email to new reviewers of change " + change.getId(), err);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    PatchSetApproval psa = null;
    StringBuilder msg = new StringBuilder();
    // get all of the current approvals
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> currentApprovals = new HashMap<>();
    for (LabelType lt : labelTypes.getLabelTypes()) {
        currentApprovals.put(lt.getName(), (short) 0);
        for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
            if (lt.getLabelId().equals(a.getLabelId())) {
                currentApprovals.put(lt.getName(), a.getValue());
            }
        }
    }
    // removing votes so we need to determine the new set of approval scores
    newApprovals.putAll(currentApprovals);
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (ctl.canRemoveReviewer(a)) {
            if (a.getLabel().equals(label)) {
                // set the approval to 0 if vote is being removed
                newApprovals.put(a.getLabel(), (short) 0);
                // set old value only if the vote changed
                oldApprovals.put(a.getLabel(), a.getValue());
                msg.append("Removed ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                psa = a;
                a.setValue((short) 0);
                ctx.getUpdate(psId).removeApprovalFor(a.getAccountId(), label);
                break;
            }
        } else {
            throw new AuthException("delete vote not permitted");
        }
    }
    if (psa == null) {
        throw new ResourceNotFoundException();
    }
    ctx.getDb().patchSetApprovals().update(Collections.singleton(psa));
    if (msg.length() > 0) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().asIdentifiedUser().getAccountId(), ctx.getWhen(), change.currentPatchSetId());
        changeMessage.setMessage(msg.toString());
        cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    PatchSetApproval psa = null;
    StringBuilder msg = new StringBuilder();
    // get all of the current approvals
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> currentApprovals = new HashMap<>();
    for (LabelType lt : labelTypes.getLabelTypes()) {
        currentApprovals.put(lt.getName(), (short) 0);
        for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
            if (lt.getLabelId().equals(a.getLabelId())) {
                currentApprovals.put(lt.getName(), a.getValue());
            }
        }
    }
    // removing votes so we need to determine the new set of approval scores
    newApprovals.putAll(currentApprovals);
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (ctl.canRemoveReviewer(a)) {
            if (a.getLabel().equals(label)) {
                // set the approval to 0 if vote is being removed
                newApprovals.put(a.getLabel(), (short) 0);
                // set old value only if the vote changed
                oldApprovals.put(a.getLabel(), a.getValue());
                msg.append("Removed ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                psa = a;
                a.setValue((short) 0);
                ctx.getUpdate(psId).removeApprovalFor(a.getAccountId(), label);
                break;
            }
        } else {
            throw new AuthException("delete vote not permitted");
        }
    }
    if (psa == null) {
        throw new ResourceNotFoundException();
    }
    ctx.getDb().patchSetApprovals().update(Collections.singleton(psa));
    if (msg.length() > 0) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
        changeMessage.setMessage(msg.toString());
        cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    if (input.notify.compareTo(NotifyHandling.NONE) > 0) {
        try {
            ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen());
            cm.setNotify(input.notify);
            cm.send();
        } catch (Exception e) {
            log.error("Cannot email update for change " + change.getId(), e);
        }
    }
    voteDeleted.fire(change, ps, newApprovals, oldApprovals, user.getAccount(), ctx.getWhen());
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getIdentifiedUser();
    if (input.notify.compareTo(NotifyHandling.NONE) > 0) {
        try {
            ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen());
            cm.setNotify(input.notify);
            cm.send();
        } catch (Exception e) {
            log.error("Cannot email update for change " + change.getId(), e);
        }
    }
    voteDeleted.fire(change, ps, newApprovals, oldApprovals, input.notify, changeMessage.getMessage(), user.getAccount(), ctx.getWhen());
}
#end_block

#method_before
public void fire(Change change, PatchSet ps, Map<String, Short> approvals, Map<String, Short> oldApprovals, Account remover, Timestamp when) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        fire(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.approvals(remover, approvals, when), util.approvals(remover, oldApprovals, when), util.accountInfo(remover), when);
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException e) {
        log.error("Couldn't fire event", e);
    }
}
#method_after
public void fire(ChangeInfo change, RevisionInfo revision, Map<String, ApprovalInfo> approvals, Map<String, ApprovalInfo> oldApprovals, NotifyHandling notify, String message, AccountInfo remover, Timestamp when) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    Event event = new Event(change, revision, approvals, oldApprovals, notify, message, remover, when);
    for (VoteDeletedListener l : listeners) {
        try {
            l.onVoteDeleted(event);
        } catch (Exception e) {
            log.warn("Error in event listener", e);
        }
    }
}
#end_block

#method_before
@Before
public void setup() throws Exception {
    count = 1;
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    // Overwrite "Code-Review" label that is inherited from All-Projects.
    // This way changes to the "Code Review" label don't affect other tests.
    LabelType codeReview = category("Code-Review", value(2, "Looks good to me, approved"), value(1, "Looks good to me, but someone else must approve"), value(0, "No score"), value(-1, "I would prefer that you didn't submit this"), value(-2, "Do not submit"));
    cfg.getLabelSections().put(codeReview.getName(), codeReview);
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID all = SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(Util.codeReview().getName()), -2, 2, all, heads);
    Util.allow(cfg, Permission.forLabel(Util.verified().getName()), -1, 1, all, heads);
    saveProjectConfig(project, cfg);
}
#method_after
@Before
public void setup() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    // Overwrite "Code-Review" label that is inherited from All-Projects.
    // This way changes to the "Code Review" label don't affect other tests.
    LabelType codeReview = category("Code-Review", value(2, "Looks good to me, approved"), value(1, "Looks good to me, but someone else must approve"), value(0, "No score"), value(-1, "I would prefer that you didn't submit this"), value(-2, "Do not submit"));
    cfg.getLabelSections().put(codeReview.getName(), codeReview);
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(Util.codeReview().getName()), -2, 2, registeredUsers, heads);
    Util.allow(cfg, Permission.forLabel(Util.verified().getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
}
#end_block

#method_before
@Test
public void notSticky() throws Exception {
    assertNotSticky(EnumSet.of(REWORK, TRIVIAL_REBASE, NO_CODE_CHANGE));
}
#method_after
@Test
public void notSticky() throws Exception {
    assertNotSticky(EnumSet.of(REWORK, TRIVIAL_REBASE, NO_CODE_CHANGE, MERGE_FIRST_PARENT_UPDATE));
}
#end_block

#method_before
@Test
public void stickyOnTrivialRebase() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Code-Review").setCopyAllScoresOnTrivialRebase(true);
    saveProjectConfig(project, cfg);
    String changeId = createChange().getChangeId();
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    updateChange(changeId, TRIVIAL_REBASE);
    ChangeInfo c = detailedChange(changeId);
    assertVotes(c, admin, 2, 0, TRIVIAL_REBASE);
    assertVotes(c, user, -2, 0, TRIVIAL_REBASE);
    assertNotSticky(EnumSet.of(REWORK, NO_CODE_CHANGE));
}
#method_after
@Test
public void stickyOnTrivialRebase() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Code-Review").setCopyAllScoresOnTrivialRebase(true);
    saveProjectConfig(project, cfg);
    String changeId = createChange(TRIVIAL_REBASE);
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    updateChange(changeId, TRIVIAL_REBASE);
    ChangeInfo c = detailedChange(changeId);
    assertVotes(c, admin, 2, 0, TRIVIAL_REBASE);
    assertVotes(c, user, -2, 0, TRIVIAL_REBASE);
    assertNotSticky(EnumSet.of(REWORK, NO_CODE_CHANGE, MERGE_FIRST_PARENT_UPDATE));
    // check that votes are sticky when trivial rebase is done by cherry-pick
    testRepo.reset(getRemoteHead());
    changeId = createChange().getChangeId();
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    String cherryPickChangeId = cherryPick(changeId, TRIVIAL_REBASE);
    c = detailedChange(cherryPickChangeId);
    assertVotes(c, admin, 2, 0);
    assertVotes(c, user, -2, 0);
    // check that votes are not sticky when rework is done by cherry-pick
    testRepo.reset(getRemoteHead());
    changeId = createChange().getChangeId();
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    cherryPickChangeId = cherryPick(changeId, REWORK);
    c = detailedChange(cherryPickChangeId);
    assertVotes(c, admin, 0, 0);
    assertVotes(c, user, 0, 0);
}
#end_block

#method_before
@Test
public void stickyOnNoCodeChange() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Verified").setCopyAllScoresIfNoCodeChange(true);
    saveProjectConfig(project, cfg);
    String changeId = createChange().getChangeId();
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    updateChange(changeId, NO_CODE_CHANGE);
    ChangeInfo c = detailedChange(changeId);
    assertVotes(c, admin, 0, 1, NO_CODE_CHANGE);
    assertVotes(c, user, 0, -1, NO_CODE_CHANGE);
    assertNotSticky(EnumSet.of(REWORK, TRIVIAL_REBASE));
}
#method_after
@Test
public void stickyOnNoCodeChange() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Verified").setCopyAllScoresIfNoCodeChange(true);
    saveProjectConfig(project, cfg);
    String changeId = createChange(NO_CODE_CHANGE);
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    updateChange(changeId, NO_CODE_CHANGE);
    ChangeInfo c = detailedChange(changeId);
    assertVotes(c, admin, 0, 1, NO_CODE_CHANGE);
    assertVotes(c, user, 0, -1, NO_CODE_CHANGE);
    assertNotSticky(EnumSet.of(REWORK, TRIVIAL_REBASE, MERGE_FIRST_PARENT_UPDATE));
}
#end_block

#method_before
private ChangeInfo detailedChange(String changeId) throws Exception {
    return gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
}
#method_after
private ChangeInfo detailedChange(String changeId) throws Exception {
    return gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS, ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT));
}
#end_block

#method_before
private void assertNotSticky(Set<ChangeKind> changeKinds) throws Exception {
    for (ChangeKind changeKind : changeKinds) {
        testRepo.reset(getRemoteHead());
        String changeId = createChange().getChangeId();
        vote(admin, changeId, +2, 1);
        vote(user, changeId, -2, -1);
        updateChange(changeId, changeKind);
        ChangeInfo c = detailedChange(changeId);
        assertVotes(c, admin, 0, 0, changeKind);
        assertVotes(c, user, 0, 0, changeKind);
    }
}
#method_after
private void assertNotSticky(Set<ChangeKind> changeKinds) throws Exception {
    for (ChangeKind changeKind : changeKinds) {
        testRepo.reset(getRemoteHead());
        String changeId = createChange(changeKind);
        vote(admin, changeId, +2, 1);
        vote(user, changeId, -2, -1);
        updateChange(changeId, changeKind);
        ChangeInfo c = detailedChange(changeId);
        assertVotes(c, admin, 0, 0, changeKind);
        assertVotes(c, user, 0, 0, changeKind);
    }
}
#end_block

#method_before
private void updateChange(String changeId, ChangeKind kind) throws Exception {
    switch(kind) {
        case NO_CODE_CHANGE:
            noCodeChange(changeId);
            return;
        case REWORK:
            rework(changeId);
            return;
        case TRIVIAL_REBASE:
            trivialRebase(changeId);
            return;
        case NO_CHANGE:
        case MERGE_FIRST_PARENT_UPDATE:
        default:
            fail("unexpexted change kind: " + kind);
    }
}
#method_after
private void updateChange(String changeId, ChangeKind changeKind) throws Exception {
    switch(changeKind) {
        case NO_CODE_CHANGE:
            noCodeChange(changeId);
            return;
        case REWORK:
            rework(changeId);
            return;
        case TRIVIAL_REBASE:
            trivialRebase(changeId);
            return;
        case MERGE_FIRST_PARENT_UPDATE:
            updateFirstParent(changeId);
            return;
        case NO_CHANGE:
        default:
            fail("unexpected change kind: " + changeKind);
    }
}
#end_block

#method_before
private void noCodeChange(String changeId) throws Exception {
    TestRepository<?>.CommitBuilder commitBuilder = testRepo.amendRef("HEAD").insertChangeId(changeId.substring(1));
    commitBuilder.message("New subject " + count++).author(admin.getIdent()).committer(new PersonIdent(admin.getIdent(), testRepo.getDate()));
    commitBuilder.create();
    GitUtil.pushHead(testRepo, "refs/for/master", false);
    assertThat(getChangeKind(changeId)).isEqualTo(NO_CODE_CHANGE);
}
#method_after
private void noCodeChange(String changeId) throws Exception {
    TestRepository<?>.CommitBuilder commitBuilder = testRepo.amendRef("HEAD").insertChangeId(changeId.substring(1));
    commitBuilder.message("New subject " + System.nanoTime()).author(admin.getIdent()).committer(new PersonIdent(admin.getIdent(), testRepo.getDate()));
    commitBuilder.create();
    GitUtil.pushHead(testRepo, "refs/for/master", false);
    assertThat(getChangeKind(changeId)).isEqualTo(NO_CODE_CHANGE);
}
#end_block

#method_before
private void rework(String changeId) throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, "new content " + count++, changeId);
    push.to("refs/for/master").assertOkStatus();
    assertThat(getChangeKind(changeId)).isEqualTo(REWORK);
}
#method_after
private void rework(String changeId) throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, "new content " + System.nanoTime(), changeId);
    push.to("refs/for/master").assertOkStatus();
    assertThat(getChangeKind(changeId)).isEqualTo(REWORK);
}
#end_block

#method_before
private void trivialRebase(String changeId) throws Exception {
    setApiUser(admin);
    testRepo.reset(getRemoteHead());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "Other Change", "a" + count++ + ".txt", PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    ReviewInput in = new ReviewInput().label("Code-Review", 2).label("Verified", 1);
    revision.review(in);
    revision.submit();
    gApi.changes().id(changeId).current().rebase();
    assertThat(getChangeKind(changeId)).isEqualTo(TRIVIAL_REBASE);
}
#method_after
private void trivialRebase(String changeId) throws Exception {
    setApiUser(admin);
    testRepo.reset(getRemoteHead());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "Other Change", "a" + System.nanoTime() + ".txt", PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    ReviewInput in = new ReviewInput().label("Code-Review", 2).label("Verified", 1);
    revision.review(in);
    revision.submit();
    gApi.changes().id(changeId).current().rebase();
    assertThat(getChangeKind(changeId)).isEqualTo(TRIVIAL_REBASE);
}
#end_block

#method_before
private void assertVotes(ChangeInfo c, TestAccount user, String label, int expectedVote, ChangeKind changeKind) {
    Integer vote = null;
    for (ApprovalInfo approval : c.labels.get(label).all) {
        if (approval._accountId == user.id.get()) {
            vote = approval.value;
            break;
        }
    }
    assertThat(vote).named("label = " + label + "; changeKind = " + changeKind.name()).isEqualTo(expectedVote);
}
#method_after
private void assertVotes(ChangeInfo c, TestAccount user, int codeReviewVote, int verifiedVote) {
    assertVotes(c, user, codeReviewVote, verifiedVote, null);
}
#end_block

#method_before
private void assertVotes(ChangeInfo c, TestAccount user, String label, int expectedVote, ChangeKind changeKind) {
    Integer vote = null;
    for (ApprovalInfo approval : c.labels.get(label).all) {
        if (approval._accountId == user.id.get()) {
            vote = approval.value;
            break;
        }
    }
    assertThat(vote).named("label = " + label + "; changeKind = " + changeKind.name()).isEqualTo(expectedVote);
}
#method_after
private void assertVotes(ChangeInfo c, TestAccount user, String label, int expectedVote, ChangeKind changeKind) {
    Integer vote = 0;
    if (c.labels.get(label) != null && c.labels.get(label).all != null) {
        for (ApprovalInfo approval : c.labels.get(label).all) {
            if (approval._accountId == user.id.get()) {
                vote = approval.value;
                break;
            }
        }
    }
    String name = "label = " + label;
    if (changeKind != null) {
        name += "; changeKind = " + changeKind.name();
    }
    assertThat(vote).named(name).isEqualTo(expectedVote);
}
#end_block

#method_before
private AddReviewerResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    AddReviewerResult result = new AddReviewerResult(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.needsConfirmation = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#method_after
private AddReviewerResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    AddReviewerResult result = new AddReviewerResult(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws Exception {
    emailReviewers(rsrc.getChange(), added);
    if (!added.isEmpty()) {
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            reviewerAdded.fire(rsrc.getChange(), patchSet, account);
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws Exception {
    emailReviewers(rsrc.getChange(), added);
    if (!added.isEmpty()) {
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            reviewerAdded.fire(rsrc.getChange(), patchSet, account, ctx.getUser().asIdentifiedUser().getAccount(), ctx.getWhen());
        }
    }
}
#end_block

#method_before
@Deprecated
public void setChangeMessage(final ChangeMessage cm) {
    setChangeMessage(cm.getMessage());
}
#method_after
@Deprecated
public void setChangeMessage(final ChangeMessage cm) {
    setChangeMessage(cm.getMessage(), cm.getWrittenOn());
}
#end_block

#method_before
public void setChangeMessage(String cm) {
    changeMessage = cm;
}
#method_after
public void setChangeMessage(String cm, Timestamp t) {
    changeMessage = cm;
    timestamp = t;
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
    } else {
        projectState = null;
    }
    if (patchSet == null) {
        try {
            patchSet = changeData.currentPatchSet();
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), changeData.notes(), patchSet.getId());
        } catch (PatchSetInfoNotAvailableException | OrmException err) {
            patchSetInfo = null;
        }
    }
    authors = getAuthors();
    super.init();
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setChangeUrlHeader();
    setCommitIdHeader();
}
#method_after
@Override
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
    } else {
        projectState = null;
    }
    if (patchSet == null) {
        try {
            patchSet = changeData.currentPatchSet();
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), changeData.notes(), patchSet.getId());
        } catch (PatchSetInfoNotAvailableException | OrmException err) {
            patchSetInfo = null;
        }
    }
    authors = getAuthors();
    super.init();
    if (timestamp != null) {
        setHeader("Date", new Date(timestamp.getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setChangeUrlHeader();
    setCommitIdHeader();
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    if (filter == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(SC_NOT_IMPLEMENTED);
        return;
    }
    filter.doFilter(req, res, chain);
}
#method_after
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    if (filter.get() == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(SC_NOT_IMPLEMENTED);
        return;
    }
    filter.get().doFilter(req, res, chain);
}
#end_block

#method_before
private void install(Plugin plugin) {
    if (!plugin.getName().equals(pluginName)) {
        return;
    }
    filter = load(plugin);
}
#method_after
private void install(Plugin plugin) {
    if (!plugin.getName().equals(pluginName)) {
        return;
    }
    final GuiceFilter guiceFilter = load(plugin);
    plugin.add(new RegistrationHandle() {

        @Override
        public void remove() {
            filter.compareAndSet(guiceFilter, null);
        }
    });
    filter.set(guiceFilter);
}
#end_block

#method_before
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter guiceFilter;
        try {
            guiceFilter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, "/");
            guiceFilter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                guiceFilter.destroy();
                if (guiceFilter == filter) {
                    filter = null;
                }
            }
        });
        return guiceFilter;
    }
    return null;
}
#method_after
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter guiceFilter;
        try {
            guiceFilter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, "/");
            guiceFilter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                guiceFilter.destroy();
            }
        });
        return guiceFilter;
    }
    return null;
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    log.warn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getMessage();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    try {
        RevWalk rw = rp.getRevWalk();
        RevCommit commit = rw.parseCommit(commitId);
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    try {
        RevWalk rw = rp.getRevWalk();
        RevCommit commit = rw.parseCommit(commitId);
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commitId, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkState(tipChange != null, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commitId, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = notes.getChange().currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(notes);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (notes.getChange().getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = notes.getChange().currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    changeCtl = projectControl.controlFor(notes);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (notes.getChange().getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
@Override
public String getUrl() {
    String database = cfg.getString("database", null, "database");
    Boolean autoserver = cfg.getBoolean("database", "h2", "autoServer", false);
    if (database == null || database.isEmpty()) {
        database = "db/ReviewDB";
    }
    return "jdbc:h2:" + site.resolve(database).toUri().toString() + (autoserver ? ";AUTO_SERVER=TRUE" : "");
}
#method_after
@Override
public String getUrl() {
    String database = cfg.getString("database", null, "database");
    if (database == null || database.isEmpty()) {
        database = "db/ReviewDB";
    }
    return appendUrlOptions(cfg, createUrl(site.resolve(database)));
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    // Need create at least one user to be admin before create a "normal"
    // registered user, refer AccountManager#create()
    accountManager.authenticate(AuthRequest.forUser("admin")).getAccountId();
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID();
    setUpPermissions();
    Account.Id userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    user = userFactory.create(userId);
    Project.NameKey name = new Project.NameKey("project");
    InMemoryRepository inMemoryRepo = repoManager.createRepository(name);
    project = new ProjectConfig(name);
    project.load(inMemoryRepo);
    repo = new TestRepository<>(inMemoryRepo);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return user;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    // Need to create at least one user to be admin before creating a "normal"
    // registered user.
    // See AccountManager#create().
    accountManager.authenticate(AuthRequest.forUser("admin")).getAccountId();
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID();
    setUpPermissions();
    Account.Id userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    user = userFactory.create(userId);
    Project.NameKey name = new Project.NameKey("project");
    InMemoryRepository inMemoryRepo = repoManager.createRepository(name);
    project = new ProjectConfig(name);
    project.load(inMemoryRepo);
    repo = new TestRepository<>(inMemoryRepo);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return user;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
}
#end_block

#method_before
private void setUpPermissions() throws Exception {
    // Remove read permissions for all users besides admin, because by default
    // Anonymous user group have ALLOW READ permission in refs/*.
    // This method is idempotent, so is safe to call on every test setup.
    ProjectConfig pc = projectCache.checkedGet(allProjects).getConfig();
    for (AccessSection sec : pc.getAccessSections()) {
        sec.removePermission(Permission.READ);
    }
    allow(pc, Permission.READ, admins, "refs/*");
}
#method_after
private void setUpPermissions() throws Exception {
    // Remove read permissions for all users besides admin, because by default
    // Anonymous user group has ALLOW READ permission in refs/*.
    // This method is idempotent, so is safe to call on every test setup.
    ProjectConfig pc = projectCache.checkedGet(allProjects).getConfig();
    for (AccessSection sec : pc.getAccessSections()) {
        sec.removePermission(Permission.READ);
    }
    allow(pc, Permission.READ, admins, "refs/*");
}
#end_block

#method_before
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<>();
    for (AccountState a : args.accountQueryProvider.get().byWatchedProject(project)) {
        for (AccountProjectWatch w : a.getProjectWatches()) {
            if (add(matching, w, type)) {
                // We only want to prevent matching All-Projects if this filter hits
                projectWatchers.add(w.getAccountId());
            }
        }
    }
    for (AccountState a : args.accountQueryProvider.get().byWatchedProject(args.allProjectsName)) {
        for (AccountProjectWatch w : a.getProjectWatches()) {
            if (!projectWatchers.contains(w.getAccountId())) {
                add(matching, w, type);
            }
        }
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc);
                } catch (QueryParseException e) {
                    log.warn("Project {} has invalid notify {} filter \"{}\": {}", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage());
                }
            }
        }
    }
    return matching;
}
#method_after
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching;
    if (args.accountIndexes.getSearchIndex() != null) {
        matching = getWatchersFromIndex(type);
    } else {
        matching = getWatchersFromDb(type);
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc);
                } catch (QueryParseException e) {
                    log.warn("Project {} has invalid notify {} filter \"{}\": {}", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage());
                }
            }
        }
    }
    return matching;
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
@Override
public List<AccountInfo> apply(TopLevelResource rsrc) throws OrmException, BadRequestException, MethodNotAllowedException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (suggest && (!suggestConfig || query.length() < suggestFrom)) {
        return Collections.emptyList();
    }
    Set<FillOptions> fillOptions = EnumSet.of(FillOptions.ID);
    if (suggest || options.contains(ListAccountsOption.DETAILS)) {
        fillOptions.addAll(AccountLoader.DETAILED_OPTIONS);
    }
    if (suggest || options.contains(ListAccountsOption.ALL_EMAILS)) {
        fillOptions.add(FillOptions.SECONDARY_EMAILS);
    }
    accountLoader = accountLoaderFactory.create(fillOptions);
    AccountIndex searchIndex = indexes.getSearchIndex();
    if (searchIndex != null) {
        return queryFromIndex();
    }
    if (!suggest) {
        throw new MethodNotAllowedException();
    }
    if (start != null) {
        throw new MethodNotAllowedException("option start not allowed");
    }
    return queryFromDb();
}
#method_after
@Override
public List<AccountInfo> apply(TopLevelResource rsrc) throws OrmException, BadRequestException, MethodNotAllowedException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (suggest && (!suggestConfig || query.length() < suggestFrom)) {
        return Collections.emptyList();
    }
    Set<FillOptions> fillOptions = EnumSet.of(FillOptions.ID);
    if (options.contains(ListAccountsOption.DETAILS)) {
        fillOptions.addAll(AccountLoader.DETAILED_OPTIONS);
    }
    if (options.contains(ListAccountsOption.ALL_EMAILS)) {
        fillOptions.add(FillOptions.EMAIL);
        fillOptions.add(FillOptions.SECONDARY_EMAILS);
    }
    if (suggest) {
        fillOptions.addAll(AccountLoader.DETAILED_OPTIONS);
        fillOptions.add(FillOptions.EMAIL);
        fillOptions.add(FillOptions.SECONDARY_EMAILS);
    }
    accountLoader = accountLoaderFactory.create(fillOptions);
    AccountIndex searchIndex = indexes.getSearchIndex();
    if (searchIndex != null) {
        return queryFromIndex();
    }
    if (!suggest) {
        throw new MethodNotAllowedException();
    }
    if (start != null) {
        throw new MethodNotAllowedException("option start not allowed");
    }
    return queryFromDb();
}
#end_block

#method_before
public static List<String> getEmails(Collection<AccountExternalId> ids) {
    List<String> emails = new ArrayList<>();
    for (AccountExternalId id : ids) {
        if (id.isScheme(SCHEME_MAILTO)) {
            emails.add(id.getSchemeRest());
        }
    }
    return emails;
}
#method_after
public static Set<String> getEmails(Collection<AccountExternalId> ids) {
    Set<String> emails = new HashSet<>();
    for (AccountExternalId id : ids) {
        if (id.isScheme(SCHEME_MAILTO)) {
            emails.add(id.getSchemeRest());
        }
    }
    return emails;
}
#end_block

#method_before
public List<String> getSecondaryEmails(Account account, Collection<AccountExternalId> externalIds) {
    List<String> emails = AccountState.getEmails(externalIds);
    if (account.getPreferredEmail() != null) {
        emails.remove(account.getPreferredEmail());
    }
    Collections.sort(emails);
    return emails;
}
#method_after
public List<String> getSecondaryEmails(Account account, Collection<AccountExternalId> externalIds) {
    List<String> emails = new ArrayList<>(AccountState.getEmails(externalIds));
    if (account.getPreferredEmail() != null) {
        emails.remove(account.getPreferredEmail());
    }
    Collections.sort(emails);
    return emails;
}
#end_block

#method_before
private BatchMetaDataUpdate approve(ChangeControl control, PatchSet.Id psId, IdentifiedUser user, ChangeUpdate update, Timestamp timestamp) throws OrmException {
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(db, control, psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
    byKey.put(submit.getKey(), submit);
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(control, byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    logDebug("Adding submit label " + submit);
    db.patchSetApprovals().upsert(normalized.getNormalized());
    db.patchSetApprovals().delete(normalized.deleted());
    try {
        return saveToBatch(control, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private BatchMetaDataUpdate approve(ChangeControl control, PatchSet.Id psId, IdentifiedUser user, ChangeUpdate update, Timestamp timestamp) throws OrmException {
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(db, control, psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
    byKey.put(submit.getKey(), submit);
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(control, byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    logDebug("Adding submit label " + submit);
    db.patchSetApprovals().upsert(normalized.getNormalized());
    db.patchSetApprovals().update(zero(normalized.deleted()));
    try {
        return saveToBatch(control, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(changeRefsById(), db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                if (p.commit.name().equals(changes.get(0).currentPatchSet().getRevision().get())) {
                    // All PatchSets in push are currentPatchSet of target changes
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(changeRefsById(), db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, SetMultimap<ObjectId, Ref> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.put(ref.getObjectId(), ref);
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = HashMultimap.create();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
@BeforeClass
public static void setTimeForTesting() {
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#method_after
@BeforeClass
public static void setTimeForTesting() {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
}
#end_block

#method_before
@AfterClass
public static void restoreTime() {
    DateTimeUtils.setCurrentMillisSystem();
}
#method_after
@AfterClass
public static void restoreTime() {
    TestTimeUtil.useSystemTime();
}
#end_block

#method_before
@Test
public void testCreateNewChangeForAllNotInTarget() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    r = push.to("refs/for/master");
    r.assertOkStatus();
}
#method_after
@Test
public void testCreateNewChangeForAllNotInTarget() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    r = push.to("refs/for/master");
    r.assertOkStatus();
    gApi.projects().name(project.get()).branch("otherBranch").create(new BranchInput());
    PushOneCommit.Result r2 = push.to("refs/for/otherBranch");
    r2.assertOkStatus();
    assertTwoChangesWithSameRevision(r);
}
#end_block

#method_before
@Test
public void testPushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result rBase = pushTo("refs/heads/master");
    rBase.assertOkStatus();
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    PushResult pr = GitUtil.pushHead(testRepo, "refs/for/foo%base=" + rBase.getCommitId().name(), false, false);
    assertThat(pr.getMessages()).contains("changes: new: 1, refs: 1, done");
    List<ChangeInfo> changes = query(r.getCommitId().name());
    assertThat(changes).hasSize(2);
    ChangeInfo c1 = get(changes.get(0).id);
    ChangeInfo c2 = get(changes.get(1).id);
    assertThat(c1.project).isEqualTo(c2.project);
    assertThat(c1.branch).isNotEqualTo(c2.branch);
    assertThat(c1.changeId).isEqualTo(c2.changeId);
    assertThat(c1.currentRevision).isEqualTo(c2.currentRevision);
}
#method_after
@Test
public void testPushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result rBase = pushTo("refs/heads/master");
    rBase.assertOkStatus();
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    PushResult pr = GitUtil.pushHead(testRepo, "refs/for/foo%base=" + rBase.getCommitId().name(), false, false);
    assertThat(pr.getMessages()).contains("changes: new: 1, refs: 1, done");
    assertTwoChangesWithSameRevision(r);
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus() != Change.Status.MERGED) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
    }
    out.submittable = Submit.submittable(cd);
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus() != Change.Status.MERGED) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
    }
    out.submittable = Submit.submittable(cd);
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = repoManager.openRepository(ctl.getProject().getNameKey())) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo));
            }
        }
        return res;
    }
}
#end_block

#method_before
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    RevisionInfo rev = toRevisionInfo(ctl, in);
    accountLoader.fill();
    return rev;
}
#method_after
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = repoManager.openRepository(ctl.getProject().getNameKey())) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo);
        accountLoader.fill();
        return rev;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(db.get(), ctl.getChange(), in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, Repository repo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
@Test
public void unknownPermissionRemainsUnchanged() throws Exception {
    String refsFor = "refs/for/*";
    // Clone repository to forcefully add permission
    TestRepository<InMemoryRepository> allProjectsRepo = cloneProject(allProjects, admin);
    // Fetch permission ref
    GitUtil.fetch(allProjectsRepo, "refs/meta/config:cfg");
    allProjectsRepo.reset("cfg");
    // Load current permissions
    String config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    // Append and push unknown permission
    config += "[access \"" + refsFor + "\"]\n" + "\tunknownPermission = group Registered Users\n";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allProjectsRepo, "Subject", "project.config", config);
    push.to("refs/meta/config").assertOkStatus();
    // Verify that unknownPermission is present
    config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    assertThat(config).containsMatch("unknownPermission");
    // Make permission change through API
    ProjectAccessInput accessInput = newProjectAccessInput();
    AccessSectionInfo accessSectionInfo = createDefaultAccessSectionInfo();
    accessInput.add.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    accessInput.add.clear();
    accessInput.remove.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    // Verify that unknownPermission is still present
    config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    assertThat(config).containsMatch("unknownPermission");
}
#method_after
@Test
public void unknownPermissionRemainsUnchanged() throws Exception {
    String access = "access";
    String unknownPermission = "unknownPermission";
    String registeredUsers = "group Registered Users";
    String refsFor = "refs/for/*";
    // Clone repository to forcefully add permission
    TestRepository<InMemoryRepository> allProjectsRepo = cloneProject(allProjects, admin);
    // Fetch permission ref
    GitUtil.fetch(allProjectsRepo, "refs/meta/config:cfg");
    allProjectsRepo.reset("cfg");
    // Load current permissions
    String config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    // Append and push unknown permission
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString(access, refsFor, unknownPermission, registeredUsers);
    config = cfg.toText();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allProjectsRepo, "Subject", "project.config", config);
    push.to("refs/meta/config").assertOkStatus();
    // Verify that unknownPermission is present
    config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
    // Make permission change through API
    ProjectAccessInput accessInput = newProjectAccessInput();
    AccessSectionInfo accessSectionInfo = createDefaultAccessSectionInfo();
    accessInput.add.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    accessInput.add.clear();
    accessInput.remove.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    // Verify that unknownPermission is still present
    config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
}
#end_block

#method_before
public void remove(AccessSection section) {
    if (section != null) {
        AccessSection a = accessSections.get(section.getName());
        if (!a.hasMoreConfig()) {
            accessSections.remove(a);
        } else {
            a.setPermissions(new ArrayList<Permission>());
        }
    }
}
#method_after
public void remove(AccessSection section) {
    if (section != null) {
        AccessSection a = accessSections.get(section.getName());
        if (sectionsWithUnknownPermissions.contains(a)) {
            accessSections.remove(a);
        } else {
            a.setPermissions(new ArrayList<Permission>());
        }
    }
}
#end_block

#method_before
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName) && isValidRegex(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                } else {
                    as.setHasMoreConfig(true);
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#method_after
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<>();
    sectionsWithUnknownPermissions = new HashSet<>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName) && isValidRegex(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                } else {
                    sectionsWithUnknownPermissions.add(as);
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#end_block

#method_before
public Optional<ChangedLines> changedLines() throws OrmException {
    if (changedLines == null) {
        Optional<ChangedLines> cl = Optional.absent();
        Change c = change();
        if (c != null) {
            PatchSet ps = currentPatchSet();
            if (ps != null) {
                PatchList p;
                try {
                    p = patchListCache.get(c, ps);
                    cl = Optional.of(new ChangedLines(p.getInsertions(), p.getDeletions()));
                } catch (PatchListNotAvailableException e) {
                // Leave as absent.
                }
            }
        }
        changedLines = cl;
    }
    return changedLines;
}
#method_after
public Optional<ChangedLines> changedLines() throws OrmException {
    if (changedLines == null) {
        changedLines = computeChangedLines();
    }
    return changedLines;
}
#end_block

#method_before
@Override
protected Predicate<AccountState> defaultField(String query) throws QueryParseException {
    if ("self".equals(query)) {
        return new AccountIdPredicate(self());
    }
    if (query.matches("^[1-9][0-9]*$")) {
        return new AccountIdPredicate(Account.Id.parse(query));
    }
    throw error("User " + query + " not found");
}
#method_after
@Override
protected Predicate<AccountState> defaultField(String query) throws QueryParseException {
    if ("self".equalsIgnoreCase(query)) {
        return new AccountIdPredicate(self());
    }
    Integer id = Ints.tryParse(query);
    if (id != null) {
        return new AccountIdPredicate(new Account.Id(id));
    }
    throw error("User " + query + " not found");
}
#end_block

#method_before
@Operator
public Predicate<AccountState> email(String email) {
    return new EmailPredicate(email);
}
#method_after
@Operator
public Predicate<AccountState> email(String email) {
    return AccountPredicates.email(email);
}
#end_block

#method_before
@Override
protected Predicate<AccountState> defaultField(String query) throws QueryParseException {
    return account(query);
}
#method_after
@Override
protected Predicate<AccountState> defaultField(String query) throws QueryParseException {
    if ("self".equalsIgnoreCase(query)) {
        return AccountPredicates.id(self());
    }
    List<Predicate<AccountState>> preds = Lists.newArrayListWithCapacity(2);
    Integer id = Ints.tryParse(query);
    if (id != null) {
        preds.add(AccountPredicates.id(new Account.Id(id)));
    }
    preds.add(email(query));
    return Predicate.or(preds);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    sysInjector.injectMembers(this);
    if (!notesMigration.enabled()) {
        throw die("NoteDb is not enabled.");
    }
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    ListeningExecutorService executor = newExecutor();
    System.out.println("Rebuilding the NoteDb");
    final ImmutableMultimap<Project.NameKey, Change.Id> changesByProject = getChangesByProject();
    boolean ok;
    Stopwatch sw = Stopwatch.createStarted();
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        deleteRefs(RefNames.REFS_DRAFT_COMMENTS, allUsersRepo);
        List<ListenableFuture<Boolean>> futures = new ArrayList<>();
        List<Project.NameKey> projectNames = Ordering.usingToString().sortedCopy(changesByProject.keySet());
        for (final Project.NameKey project : projectNames) {
            ListenableFuture<Boolean> future = executor.submit(new Callable<Boolean>() {

                @Override
                public Boolean call() {
                    try (ReviewDb db = ReviewDbUtil.unwrapDb(schemaFactory.open())) {
                        return rebuilder.rebuildProject(db, changesByProject, project, allUsersRepo);
                    } catch (Exception e) {
                        log.error("Error rebuilding project " + project, e);
                        return false;
                    }
                }
            });
            futures.add(future);
        }
        try {
            ok = Iterables.all(Futures.allAsList(futures).get(), Predicates.equalTo(true));
        } catch (InterruptedException | ExecutionException e) {
            log.error("Error rebuilding projects", e);
            ok = false;
        }
    }
    double t = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Rebuild %d changes in %.01fs (%.01f/s)\n", changesByProject.size(), t, changesByProject.size() / t);
    return ok ? 0 : 1;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    sysInjector.injectMembers(this);
    if (!notesMigration.enabled()) {
        throw die("NoteDb is not enabled.");
    }
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    ListeningExecutorService executor = newExecutor();
    System.out.println("Rebuilding the NoteDb");
    final ImmutableMultimap<Project.NameKey, Change.Id> changesByProject = getChangesByProject();
    boolean ok;
    Stopwatch sw = Stopwatch.createStarted();
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        deleteRefs(RefNames.REFS_DRAFT_COMMENTS, allUsersRepo);
        List<ListenableFuture<Boolean>> futures = new ArrayList<>();
        List<Project.NameKey> projectNames = Ordering.usingToString().sortedCopy(changesByProject.keySet());
        for (final Project.NameKey project : projectNames) {
            ListenableFuture<Boolean> future = executor.submit(new Callable<Boolean>() {

                @Override
                public Boolean call() {
                    try (ReviewDb db = unwrapDb(schemaFactory.open())) {
                        return rebuilder.rebuildProject(db, changesByProject, project, allUsersRepo);
                    } catch (Exception e) {
                        log.error("Error rebuilding project " + project, e);
                        return false;
                    }
                }
            });
            futures.add(future);
        }
        try {
            ok = Iterables.all(Futures.allAsList(futures).get(), Predicates.equalTo(true));
        } catch (InterruptedException | ExecutionException e) {
            log.error("Error rebuilding projects", e);
            ok = false;
        }
    }
    double t = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Rebuild %d changes in %.01fs (%.01f/s)\n", changesByProject.size(), t, changesByProject.size() / t);
    return ok ? 0 : 1;
}
#end_block

#method_before
private ImmutableMultimap<Project.NameKey, Change.Id> getChangesByProject() throws OrmException {
    // Memorize all changes so we can close the db connection and allow
    // rebuilder threads to use the full connection pool.
    Multimap<Project.NameKey, Change.Id> changesByProject = ArrayListMultimap.create();
    try (ReviewDb db = schemaFactory.open()) {
        if (projects.isEmpty() && !changes.isEmpty()) {
            Iterable<Change> todo = ReviewDbUtil.unwrapDb(db).changes().get(Iterables.transform(changes, new Function<Integer, Change.Id>() {

                @Override
                public Change.Id apply(Integer in) {
                    return new Change.Id(in);
                }
            }));
            for (Change c : todo) {
                changesByProject.put(c.getProject(), c.getId());
            }
        } else {
            for (Change c : ReviewDbUtil.unwrapDb(db).changes().all()) {
                boolean include = false;
                if (projects.isEmpty() && changes.isEmpty()) {
                    include = true;
                } else if (!projects.isEmpty() && projects.contains(c.getProject().get())) {
                    include = true;
                } else if (!changes.isEmpty() && changes.contains(c.getId().get())) {
                    include = true;
                }
                if (include) {
                    changesByProject.put(c.getProject(), c.getId());
                }
            }
        }
        return ImmutableMultimap.copyOf(changesByProject);
    }
}
#method_after
private ImmutableMultimap<Project.NameKey, Change.Id> getChangesByProject() throws OrmException {
    // Memorize all changes so we can close the db connection and allow
    // rebuilder threads to use the full connection pool.
    Multimap<Project.NameKey, Change.Id> changesByProject = ArrayListMultimap.create();
    try (ReviewDb db = schemaFactory.open()) {
        if (projects.isEmpty() && !changes.isEmpty()) {
            Iterable<Change> todo = unwrapDb(db).changes().get(Iterables.transform(changes, new Function<Integer, Change.Id>() {

                @Override
                public Change.Id apply(Integer in) {
                    return new Change.Id(in);
                }
            }));
            for (Change c : todo) {
                changesByProject.put(c.getProject(), c.getId());
            }
        } else {
            for (Change c : unwrapDb(db).changes().all()) {
                boolean include = false;
                if (projects.isEmpty() && changes.isEmpty()) {
                    include = true;
                } else if (!projects.isEmpty() && projects.contains(c.getProject().get())) {
                    include = true;
                } else if (!changes.isEmpty() && changes.contains(c.getId().get())) {
                    include = true;
                }
                if (include) {
                    changesByProject.put(c.getProject(), c.getId());
                }
            }
        }
        return ImmutableMultimap.copyOf(changesByProject);
    }
}
#end_block

#method_before
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String msg) {
            System.err.println(msg);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return ui.yesno(def, msg);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) ReviewDbUtil.unwrapDb(schema.open());
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
}
#method_after
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String msg) {
            System.err.println(msg);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return ui.yesno(def, msg);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) unwrapDb(schema.open());
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteDraftChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteDraftChangeOp");
    Change change = ctx.getChange();
    id = change.getId();
    // Use local unwrap as we need to handle BatchUpdateReviewDb as well.
    ReviewDb db = unwrap(ctx.getDb());
    if (change.getStatus() != Change.Status.DRAFT) {
        throw new ResourceConflictException("Change is not a draft: " + id);
    }
    if (!allowDrafts) {
        throw new MethodNotAllowedException("Draft workflow is disabled");
    }
    if (!ctx.getControl().canDeleteDraft(ctx.getDb())) {
        throw new AuthException("Not permitted to delete this draft change");
    }
    List<PatchSet> patchSets = ImmutableList.copyOf(psUtil.byChange(ctx.getDb(), ctx.getNotes()));
    for (PatchSet ps : patchSets) {
        if (!ps.isDraft()) {
            throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
        }
        accountPatchReviewStore.get().clearReviewed(ps.getId());
    }
    // Only delete from ReviewDb here; deletion from NoteDb is handled in
    // BatchUpdate.
    db.patchComments().delete(db.patchComments().byChange(id));
    db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id));
    db.patchSets().delete(db.patchSets().byChange(id));
    db.changeMessages().delete(db.changeMessages().byChange(id));
    // Non-atomic operation on Accounts table; not much we can do to make it
    // atomic.
    starredChangesUtil.unstarAll(change.getProject(), id);
    ctx.deleteChange();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteDraftChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteDraftChangeOp");
    Change change = ctx.getChange();
    id = change.getId();
    ReviewDb db = unwrap(ctx.getDb());
    if (change.getStatus() != Change.Status.DRAFT) {
        throw new ResourceConflictException("Change is not a draft: " + id);
    }
    if (!allowDrafts) {
        throw new MethodNotAllowedException("Draft workflow is disabled");
    }
    if (!ctx.getControl().canDeleteDraft(ctx.getDb())) {
        throw new AuthException("Not permitted to delete this draft change");
    }
    List<PatchSet> patchSets = ImmutableList.copyOf(psUtil.byChange(ctx.getDb(), ctx.getNotes()));
    for (PatchSet ps : patchSets) {
        if (!ps.isDraft()) {
            throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
        }
        accountPatchReviewStore.get().clearReviewed(ps.getId());
    }
    // Only delete from ReviewDb here; deletion from NoteDb is handled in
    // BatchUpdate.
    db.patchComments().delete(db.patchComments().byChange(id));
    db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id));
    db.patchSets().delete(db.patchSets().byChange(id));
    db.changeMessages().delete(db.changeMessages().byChange(id));
    // Non-atomic operation on Accounts table; not much we can do to make it
    // atomic.
    starredChangesUtil.unstarAll(change.getProject(), id);
    ctx.deleteChange();
    return true;
}
#end_block

#method_before
@Override
public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    Result r = manager.stageAndApplyDelta(change);
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (!Objects.equals(oldNoteDbState, change.getNoteDbState())) {
                    throw new AbortUpdateException();
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
        manager.execute();
    } catch (AbortUpdateException e) {
    // Drop this rebuild; another thread completed it.
    }
    return r;
}
#method_after
@Override
public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    Result r = manager.stageAndApplyDelta(change);
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (!Objects.equals(oldNoteDbState, change.getNoteDbState())) {
                    throw new AbortUpdateException();
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
        if (!migration.failChangeWrites()) {
            manager.execute();
        } else {
            // results instead of reading from the repo.
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
    } catch (AbortUpdateException e) {
    // Drop this rebuild; another thread completed it.
    }
    return r;
}
#end_block

#method_before
public ChangeNotes createChecked(ReviewDb db, Change c) throws OrmException, NoSuchChangeException {
    ChangeNotes notes = create(db, c.getProject(), c.getId());
    if (notes.getChange() == null) {
        throw new NoSuchChangeException(c.getId());
    }
    return notes;
}
#method_after
public ChangeNotes createChecked(ReviewDb db, Change c) throws OrmException, NoSuchChangeException {
    return createChecked(db, c.getProject(), c.getId());
}
#end_block

#method_before
public ChangeNotes createChecked(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    ChangeNotes notes = create(db, project, changeId);
    if (notes.getChange() == null) {
        throw new NoSuchChangeException(changeId);
    }
    return notes;
}
#method_after
public ChangeNotes createChecked(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    Change change = ReviewDbUtil.unwrapDb(db).changes().get(changeId);
    if (change == null || !change.getProject().equals(project)) {
        throw new NoSuchChangeException(changeId);
    }
    return new ChangeNotes(args, change).load();
}
#end_block

#method_before
public CheckedFuture<ChangeNotes, OrmException> createAsync(final ListeningExecutorService executorService, final ReviewDb db, final Project.NameKey project, final Change.Id changeId) {
    return Futures.makeChecked(Futures.transformAsync(ReviewDbUtil.unwrapDb(db).changes().getAsync(changeId), new AsyncFunction<Change, ChangeNotes>() {

        @Override
        public ListenableFuture<ChangeNotes> apply(final Change change) {
            return executorService.submit(new Callable<ChangeNotes>() {

                @Override
                public ChangeNotes call() throws Exception {
                    checkArgument(change.getProject().equals(project), "passed project %s when creating ChangeNotes for %s," + " but actual project is %s", project, changeId, change.getProject());
                    return new ChangeNotes(args, change).load();
                }
            });
        }
    }), new Function<Exception, OrmException>() {

        @Override
        public OrmException apply(Exception e) {
            if (e instanceof OrmException) {
                return (OrmException) e;
            }
            return new OrmException(e);
        }
    });
}
#method_after
public CheckedFuture<ChangeNotes, OrmException> createAsync(final ListeningExecutorService executorService, final ReviewDb db, final Project.NameKey project, final Change.Id changeId) {
    return Futures.makeChecked(Futures.transformAsync(ReviewDbUtil.unwrapDb(db).changes().getAsync(changeId), new AsyncFunction<Change, ChangeNotes>() {

        @Override
        public ListenableFuture<ChangeNotes> apply(final Change change) {
            return executorService.submit(new Callable<ChangeNotes>() {

                @Override
                public ChangeNotes call() throws Exception {
                    checkArgument(change.getProject().equals(project), "passed project %s when creating ChangeNotes for %s," + " but actual project is %s", project, changeId, change.getProject());
                    // request scope for the rebuilder to open the db.
                    return new ChangeNotes(args, change, false, null).load();
                }
            });
        }
    }), new Function<Exception, OrmException>() {

        @Override
        public OrmException apply(Exception e) {
            if (e instanceof OrmException) {
                return (OrmException) e;
            }
            return new OrmException(e);
        }
    });
}
#end_block

#method_before
private void executeChangeOps(boolean parallel) throws UpdateException, RestApiException {
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread());
            tasks.add(task);
            futures.add(executor.submit(task));
        }
        Futures.allAsList(futures).get();
        if (notesMigration.writeChanges()) {
            executeNoteDbUpdates(tasks);
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#method_after
private void executeChangeOps(boolean parallel) throws UpdateException, RestApiException {
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        if (!ops.isEmpty() && notesMigration.failChangeWrites()) {
            // this is a programmer error.
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread());
            tasks.add(task);
            futures.add(executor.submit(task));
        }
        Futures.allAsList(futures).get();
        if (notesMigration.commitChangeWrites()) {
            executeNoteDbUpdates(tasks);
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    } catch (OrmException e) {
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#end_block

#method_before
private void call(ReviewDb db, Repository repo, RevWalk rw) throws Exception {
    try {
        ChangeContext ctx;
        NoteDbUpdateManager updateManager = null;
        boolean dirty = false;
        db.changes().beginTransaction(id);
        try {
            ctx = newChangeContext(db, repo, rw, id);
            // Call updateChange on each op.
            for (Op op : changeOps) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                return;
            }
            deleted = ctx.deleted;
            // Stage the NoteDb update and store its state in the Change.
            if (notesMigration.writeChanges()) {
                updateManager = stageNoteDbUpdate(ctx, deleted);
            }
            // Bump lastUpdatedOn or rowVersion and commit.
            Iterable<Change> cs = changesToUpdate(ctx);
            if (newChanges.containsKey(id)) {
                // Insert rather than upsert in case of a race on change IDs.
                db.changes().insert(cs);
            } else if (deleted) {
                db.changes().delete(cs);
            } else {
                db.changes().update(cs);
            }
            db.commit();
        } finally {
            db.rollback();
        }
        if (notesMigration.writeChanges()) {
            try {
                // Do not execute the NoteDbUpdateManager, as we don't want too much
                // contention on the underlying repo, and we would rather use a
                // single ObjectInserter/BatchRefUpdate later.
                // 
                // TODO(dborowitz): May or may not be worth trying to batch
                // together flushed inserters as well.
                noteDbResult = updateManager.stage().get(id);
            } catch (IOException ex) {
                // Ignore all errors trying to update NoteDb at this point. We've
                // already written the NoteDbChangeState to ReviewDb, which means
                // if the state is out of date it will be rebuilt the next time it
                // is needed.
                log.debug("Ignoring NoteDb update error after ReviewDb write", ex);
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void call(ReviewDb db, Repository repo, RevWalk rw) throws Exception {
    try {
        ChangeContext ctx;
        NoteDbUpdateManager updateManager = null;
        boolean dirty = false;
        db.changes().beginTransaction(id);
        try {
            ctx = newChangeContext(db, repo, rw, id);
            // Call updateChange on each op.
            for (Op op : changeOps) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                return;
            }
            deleted = ctx.deleted;
            // Stage the NoteDb update and store its state in the Change.
            if (notesMigration.commitChangeWrites()) {
                updateManager = stageNoteDbUpdate(ctx, deleted);
            }
            // Bump lastUpdatedOn or rowVersion and commit.
            Iterable<Change> cs = changesToUpdate(ctx);
            if (newChanges.containsKey(id)) {
                // Insert rather than upsert in case of a race on change IDs.
                db.changes().insert(cs);
            } else if (deleted) {
                db.changes().delete(cs);
            } else {
                db.changes().update(cs);
            }
            db.commit();
        } finally {
            db.rollback();
        }
        if (notesMigration.commitChangeWrites()) {
            try {
                // Do not execute the NoteDbUpdateManager, as we don't want too much
                // contention on the underlying repo, and we would rather use a
                // single ObjectInserter/BatchRefUpdate later.
                // 
                // TODO(dborowitz): May or may not be worth trying to batch
                // together flushed inserters as well.
                noteDbResult = updateManager.stage().get(id);
            } catch (IOException ex) {
                // Ignore all errors trying to update NoteDb at this point. We've
                // already written the NoteDbChangeState to ReviewDb, which means
                // if the state is out of date it will be rebuilt the next time it
                // is needed.
                log.debug("Ignoring NoteDb update error after ReviewDb write", ex);
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
@Test
public void validateTopLevelDomains() throws Exception {
    try (InputStream in = this.getClass().getResourceAsStream("tlds-alpha-by-domain.txt")) {
        if (in == null) {
            throw new Exception("TLD list not found");
        }
        BufferedReader r = new BufferedReader(new InputStreamReader(in));
        String tld;
        EmailValidator validator = EmailValidator.getInstance();
        while ((tld = r.readLine()) != null) {
            if (tld.startsWith("#") || tld.startsWith("XN--")) {
                // Ignore comments and non-latin domains
                continue;
            }
            String test = "test@example." + tld.toLowerCase();
            assert_().withFailureMessage("failed to validate TLD \"" + test + "\"").that(validator.isValid(test)).isTrue();
        }
    }
}
#method_after
@Test
public void validateTopLevelDomains() throws Exception {
    try (InputStream in = this.getClass().getResourceAsStream("tlds-alpha-by-domain.txt")) {
        if (in == null) {
            throw new Exception("TLD list not found");
        }
        BufferedReader r = new BufferedReader(new InputStreamReader(in));
        String tld;
        EmailValidator validator = EmailValidator.getInstance();
        while ((tld = r.readLine()) != null) {
            if (tld.startsWith("# ") || tld.startsWith("XN--")) {
                // Ignore comments and non-latin domains
                continue;
            }
            if (tld.startsWith(UNSUPPORTED_PREFIX)) {
                String test = "test@example." + tld.toLowerCase().substring(UNSUPPORTED_PREFIX.length());
                assert_().withFailureMessage("expected invalid TLD \"" + test + "\"").that(validator.isValid(test)).isFalse();
            } else {
                String test = "test@example." + tld.toLowerCase();
                assert_().withFailureMessage("failed to validate TLD \"" + test + "\"").that(validator.isValid(test)).isTrue();
            }
        }
    }
}
#end_block

#method_before
@VisibleForTesting
static QueryOptions convertOptions(QueryOptions opts) {
    opts = QueryOptions.convert(opts);
    return IndexedChangeQuery.createOptions(opts.config(), opts.start(), opts.limit(), opts.fields());
}
#method_after
@VisibleForTesting
static QueryOptions convertOptions(QueryOptions opts) {
    opts = opts.convertForBackend();
    return IndexedChangeQuery.createOptions(opts.config(), opts.start(), opts.limit(), opts.fields());
}
#end_block

#method_before
@Test
public void nonVotingReviewerStaysAfterSubmit() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String commit = r.getCommit().name();
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.approve());
    assertThat(getReviewers(changeId)).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(changeId).addReviewer(in);
    assertThat(getReviewers(changeId)).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.approve());
    gApi.changes().id(changeId).revision(commit).submit();
    assertThat(getReviewers(changeId)).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#method_after
@Test
public void nonVotingReviewerStaysAfterSubmit() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    String heads = "refs/heads/*";
    AccountGroup.UUID owners = SystemGroupBackend.getGroup(CHANGE_OWNER).getUUID();
    AccountGroup.UUID registered = SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, owners, heads);
    Util.allow(cfg, Permission.forLabel("Code-Review"), -2, +2, registered, heads);
    saveProjectConfig(project, cfg);
    // Set Code-Review+2 and Verified+1 as admin (change owner)
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String commit = r.getCommit().name();
    ReviewInput input = ReviewInput.approve();
    input.label(verified.getName(), 1);
    gApi.changes().id(changeId).revision(commit).review(input);
    // Reviewers should only be "admin"
    assertThat(getReviewers(changeId)).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
    // Add the user as reviewer
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(changeId).addReviewer(in);
    assertThat(getReviewers(changeId)).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    // Approve the change as user, then remove the approval
    // (only to confirm that the user does have Code-Review+2 permission)
    setApiUser(user);
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.approve());
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.noScore());
    // Submit the change
    setApiUser(admin);
    gApi.changes().id(changeId).revision(commit).submit();
    // User should still be on the change
    assertThat(getReviewers(changeId)).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#end_block

#method_before
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Failed"), value(0, "No score"), value(-1, "Passes"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), verified);
    cfg.getLabelSections().put(custom2.getName(), verified);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(options);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), custom1);
    cfg.getLabelSections().put(custom2.getName(), custom2);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(options);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
@Override
public Predicate<AccountState> rewrite(Predicate<AccountState> in, QueryOptions opts) throws QueryParseException {
    AccountIndex index = indexes.getSearchIndex();
    return new IndexedAccountQuery(index, in, opts);
}
#method_after
@Override
public Predicate<AccountState> rewrite(Predicate<AccountState> in, QueryOptions opts) throws QueryParseException {
    AccountIndex index = indexes.getSearchIndex();
    checkNotNull(index, "no active search index configured for accounts");
    return new IndexedAccountQuery(index, in, opts);
}
#end_block

#method_before
public List<QueryResult> queryChanges(List<Predicate<ChangeData>> queries) throws OrmException, QueryParseException {
    return queryChanges(null, queries);
}
#method_after
public List<QueryResult> queryChanges(List<Predicate<ChangeData>> queries) throws OrmException, QueryParseException {
    try {
        return queryChanges(null, queries);
    } catch (OrmException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), QueryParseException.class);
        throw e;
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountIndexRewriter.class);
    bind(AccountIndexCollection.class);
    listener().to(AccountIndexCollection.class);
    factory(AccountIndexer.Factory.class);
    bind(ChangeIndexRewriter.class);
    bind(ChangeIndexCollection.class);
    listener().to(ChangeIndexCollection.class);
    factory(ChangeIndexer.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountIndexRewriter.class);
    bind(AccountIndexCollection.class);
    listener().to(AccountIndexCollection.class);
    bind(ChangeIndexRewriter.class);
    bind(ChangeIndexCollection.class);
    listener().to(ChangeIndexCollection.class);
    factory(ChangeIndexer.Factory.class);
}
#end_block

#method_before
private ResultSet<ChangeData> readImpl() throws OrmException {
    ChangeDataSource source = source();
    if (source == null) {
        throw new OrmException("No ChangeDataSource: " + this);
    }
    List<ChangeData> r = new ArrayList<>();
    ChangeData last = null;
    int nextStart = 0;
    boolean skipped = false;
    for (ChangeData data : buffer(source, source.read())) {
        if (match(data)) {
            r.add(data);
        } else {
            skipped = true;
        }
        last = data;
        nextStart++;
    }
    if (skipped && last != null && source instanceof Paginated) {
        // If our source is a paginated source and we skipped at
        // least one of its results, we may not have filled the full
        // limit the caller wants.  Restart the source and continue.
        // 
        Paginated p = (Paginated) source;
        while (skipped && r.size() < p.getOptions().limit() + start) {
            skipped = false;
            ResultSet<ChangeData> next = p.restart(nextStart);
            for (ChangeData data : buffer(source, next)) {
                if (match(data)) {
                    r.add(data);
                } else {
                    skipped = true;
                }
                nextStart++;
            }
        }
    }
    if (start >= r.size()) {
        r = ImmutableList.of();
    } else if (start > 0) {
        r = ImmutableList.copyOf(r.subList(start, r.size()));
    }
    return new ListResultSet<>(r);
}
#method_after
private ResultSet<ChangeData> readImpl() throws OrmException {
    ChangeDataSource source = source();
    if (source == null) {
        throw new OrmException("No ChangeDataSource: " + this);
    }
    List<ChangeData> r = new ArrayList<>();
    ChangeData last = null;
    int nextStart = 0;
    boolean skipped = false;
    for (ChangeData data : buffer(source, source.read())) {
        if (match(data)) {
            r.add(data);
        } else {
            skipped = true;
        }
        last = data;
        nextStart++;
    }
    if (skipped && last != null && source instanceof Paginated) {
        // If our source is a paginated source and we skipped at
        // least one of its results, we may not have filled the full
        // limit the caller wants.  Restart the source and continue.
        // 
        @SuppressWarnings("unchecked")
        Paginated<ChangeData> p = (Paginated<ChangeData>) source;
        while (skipped && r.size() < p.getOptions().limit() + start) {
            skipped = false;
            ResultSet<ChangeData> next = p.restart(nextStart);
            for (ChangeData data : buffer(source, next)) {
                if (match(data)) {
                    r.add(data);
                } else {
                    skipped = true;
                }
                nextStart++;
            }
        }
    }
    if (start >= r.size()) {
        r = ImmutableList.of();
    } else if (start > 0) {
        r = ImmutableList.copyOf(r.subList(start, r.size()));
    }
    return new ListResultSet<>(r);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    globalConfig = dbInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    checkNotSlaveMode();
    disableLuceneAutomaticCommit();
    disableChangeCache();
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    sysInjector.injectMembers(this);
    try {
        boolean ok = true;
        for (IndexDefinition<?, ?, ?> def : indexDefs) {
            if (listIndices) {
                System.out.format("%s\n", def.getName());
            } else {
                ok &= reindex(def);
            }
        }
        return ok ? 0 : 1;
    } catch (Exception e) {
        throw die(e.getMessage(), e);
    } finally {
        sysManager.stop();
        dbManager.stop();
    }
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    globalConfig = dbInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    checkNotSlaveMode();
    disableLuceneAutomaticCommit();
    disableChangeCache();
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    sysInjector.injectMembers(this);
    try {
        boolean ok = list ? list() : reindex();
        return ok ? 0 : 1;
    } catch (Exception e) {
        throw die(e.getMessage(), e);
    } finally {
        sysManager.stop();
        dbManager.stop();
    }
}
#end_block

#method_before
private <K, V, I extends Index<K, V>> boolean reindex(IndexDefinition<K, V, I> def) throws IOException {
    I index = def.getIndexCollection().getSearchIndex();
    checkNotNull(index, "no active search index configured for %s", def.getName());
    index.markReady(false);
    index.deleteAll();
    SiteIndexer<K, V, I> siteIndexer = def.getSiteIndexer();
    siteIndexer.setProgressOut(System.err);
    siteIndexer.setVerboseOut(verbose ? System.out : NullOutputStream.INSTANCE);
    SiteIndexer.Result result = siteIndexer.indexAll(index);
    int n = result.doneCount() + result.failedCount();
    double t = result.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Reindexed %d documents in %s index in %.01fs (%.01f/s)\n", n, def.getName(), t, n / t);
    if (result.success()) {
        index.markReady(true);
    }
    return result.success();
}
#method_after
private boolean reindex() throws IOException {
    boolean ok = true;
    for (IndexDefinition<?, ?, ?> def : indexDefs) {
        ok &= reindex(def);
    }
    return ok;
}
#end_block

#method_before
private Injector createSysInjector() {
    Map<String, Integer> versions = new HashMap<>();
    if (changesVersion != null) {
        versions.put(ChangeSchemaDefinitions.INSTANCE.getName(), changesVersion);
    }
    List<Module> modules = Lists.newArrayList();
    Module indexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            indexModule = LuceneIndexModule.singleVersionWithExplicitVersions(versions, threads);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(indexModule);
    // Scan changes from git instead of relying on the secondary index, as we
    // will have just deleted the old (possibly corrupt) index.
    modules.add(ScanningChangeCacheImpl.module());
    modules.add(dbInjector.getInstance(BatchProgramModule.class));
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    Map<String, Integer> versions = new HashMap<>();
    if (changesVersion != null) {
        versions.put(ChangeSchemaDefinitions.INSTANCE.getName(), changesVersion);
    }
    List<Module> modules = new ArrayList<>();
    Module indexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            indexModule = LuceneIndexModule.singleVersionWithExplicitVersions(versions, threads);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(indexModule);
    modules.add(dbInjector.getInstance(BatchProgramModule.class));
    modules.add(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ChangeResource.Factory.class);
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private static Directory dir(Schema<AccountState> schema, Config cfg, SitePaths sitePaths, String base) throws IOException {
    if (LuceneIndexModule.isInMemoryTest(cfg)) {
        Path indexDir = base != null ? Paths.get(base) : LuceneVersionManager.getDir(sitePaths, ACCOUNTS + "_", schema);
        return FSDirectory.open(indexDir);
    } else {
        return new RAMDirectory();
    }
}
#method_after
private static Directory dir(Schema<AccountState> schema, Config cfg, SitePaths sitePaths) throws IOException {
    if (LuceneIndexModule.isInMemoryTest(cfg)) {
        return new RAMDirectory();
    }
    Path indexDir = LuceneVersionManager.getDir(sitePaths, ACCOUNTS + "_", schema);
    return FSDirectory.open(indexDir);
}
#end_block

#method_before
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), refName), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(orm);
        op.updateSuperProjects(branches);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(orm);
        op.updateSuperProjects(branches);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commitId, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.change);
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkState(tipChange != null, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commitId, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkState(tipChange != null, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<ChangeNotes, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(notesFactory.createAsync(changeUpdateExector, db, project.getNameKey(), request.ontoChange));
    }
    for (CheckedFuture<ChangeNotes, OrmException> f : futures) {
        ChangeNotes notes = f.checkedGet();
        if (notes.getChange() != null) {
            replaceByChange.get(notes.getChangeId()).change = notes.getChange();
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<ChangeNotes, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(notesFactory.createAsync(changeUpdateExector, db, project.getNameKey(), request.ontoChange));
    }
    for (CheckedFuture<ChangeNotes, OrmException> f : futures) {
        ChangeNotes notes = f.checkedGet();
        if (notes.getChange() != null) {
            replaceByChange.get(notes.getChangeId()).notes = notes;
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = notes.getChange().currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(notes);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (notes.getChange().getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = notes.getChange().currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), notes.getChangeId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#method_after
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, notes.getChange().currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, change.getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    bu.addOp(change.getId(), replaceOp);
    if (progress != null) {
        bu.addOp(change.getId(), new ChangeProgressOp(progress));
    }
}
#method_after
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.change.getId();
            if (!req.validate(true)) {
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        bu.execute();
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        bu.execute();
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, ChangeNotes> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, ChangeNotes> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.notes());
    }
    return r;
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    final List<String> idList = receiveEvent.commit.getFooterLines(FooterConstants.CHANGE_ID);
    List<CommitValidationMessage> messages = new LinkedList<>();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = receiveEvent.commit.getShortMessage();
            String changeIdPrefix = FooterConstants.CHANGE_ID.getName() + ":";
            if (shortMsg.startsWith(changeIdPrefix) && shortMsg.substring(changeIdPrefix.length()).trim().matches("^I[0-9a-f]{8,}.*$")) {
                throw new CommitValidationException("missing subject; Change-Id must be in commit message footer");
            } else {
                String errMsg = "missing Change-Id in commit message footer";
                messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
                throw new CommitValidationException(errMsg, messages);
            }
        }
    } else if (idList.size() > 1) {
        throw new CommitValidationException("multiple Change-Id lines in commit message footer", messages);
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message footer";
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new LinkedList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        if (!CHANGE_ID.matcher(v).matches()) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
private CommitValidationMessage getMissingChangeIdErrorMsg(final String errMsg, final RevCommit c) {
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().indexOf(changeId) >= 0) {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == -1) {
            sb.append('\n');
            sb.append('\n');
            sb.append("Hint: A potential Change-Id was found, but it was not in the ");
            sb.append("footer (last paragraph) of the commit message.");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert Change-Id, install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#method_after
private CommitValidationMessage getMissingChangeIdErrorMsg(final String errMsg, final RevCommit c) {
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().indexOf(CHANGE_ID_PREFIX) >= 0) {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(CHANGE_ID_PREFIX) == -1) {
            sb.append('\n');
            sb.append('\n');
            sb.append("Hint: A potential ");
            sb.append(FooterConstants.CHANGE_ID.getName());
            sb.append("Change-Id was found, but it was not in the ");
            sb.append("footer (last paragraph) of the commit message.");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert ");
    sb.append(FooterConstants.CHANGE_ID.getName());
    sb.append(", install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#end_block

#method_before
private static String getGerritUrl(String canonicalWebUrl) {
    if (canonicalWebUrl != null) {
        return CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl);
    } else {
        return "http://" + getGerritHost(canonicalWebUrl);
    }
}
#method_after
private static String getGerritUrl(String canonicalWebUrl) {
    if (canonicalWebUrl != null) {
        return CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl);
    }
    return "http://" + getGerritHost(canonicalWebUrl);
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws AuthException, BadRequestException, OrmException, IOException {
    if (input == null || (input.add == null && input.remove == null)) {
        updatedHashtags = ImmutableSortedSet.of();
        return;
    }
    if (!ctx.getChangeControl().canEditHashtags()) {
        throw new AuthException("Editing hashtags not permitted");
    }
    ChangeUpdate update = ctx.getChangeUpdate();
    ChangeNotes notes = update.getChangeNotes().load();
    Set<String> existingHashtags = notes.getHashtags();
    Set<String> updated = new HashSet<>();
    toAdd = new HashSet<>(extractTags(input.add));
    toRemove = new HashSet<>(extractTags(input.remove));
    try {
        for (HashtagValidationListener validator : validationListeners) {
            validator.validateHashtags(update.getChange(), toAdd, toRemove);
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    if (existingHashtags != null && !existingHashtags.isEmpty()) {
        updated.addAll(existingHashtags);
        toAdd.removeAll(existingHashtags);
        toRemove.retainAll(existingHashtags);
    }
    if (updated()) {
        updated.addAll(toAdd);
        updated.removeAll(toRemove);
        update.setHashtags(updated);
    }
    change = update.getChange();
    updatedHashtags = ImmutableSortedSet.copyOf(updated);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, BadRequestException, OrmException, IOException {
    if (!notesMigration.readChanges()) {
        throw new BadRequestException("Cannot add hashtags; NoteDb is disabled");
    }
    if (input == null || (input.add == null && input.remove == null)) {
        updatedHashtags = ImmutableSortedSet.of();
        return false;
    }
    if (!ctx.getControl().canEditHashtags()) {
        throw new AuthException("Editing hashtags not permitted");
    }
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    ChangeNotes notes = update.getNotes().load();
    Set<String> existingHashtags = notes.getHashtags();
    Set<String> updated = new HashSet<>();
    toAdd = new HashSet<>(extractTags(input.add));
    toRemove = new HashSet<>(extractTags(input.remove));
    try {
        for (HashtagValidationListener validator : validationListeners) {
            validator.validateHashtags(update.getChange(), toAdd, toRemove);
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    updated.addAll(existingHashtags);
    toAdd.removeAll(existingHashtags);
    toRemove.retainAll(existingHashtags);
    if (updated()) {
        updated.addAll(toAdd);
        updated.removeAll(toRemove);
        update.setHashtags(updated);
        addMessage(ctx, update);
    }
    updatedHashtags = ImmutableSortedSet.copyOf(updated);
    return true;
}
#end_block

#method_before
@Override
protected ProjectAccess updateProjectConfig(ProjectControl ctl, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    gitRefUpdated.fire(config.getProject().getNameKey(), RefNames.REFS_CONFIG, base, commit.getId(), user.getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#method_after
@Override
protected ProjectAccess updateProjectConfig(CurrentUser user, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    gitRefUpdated.fire(config.getProject().getNameKey(), RefNames.REFS_CONFIG, base, commit.getId(), user.asIdentifiedUser().getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#end_block

#method_before
@Override
public Response<?> apply(ProjectResource project, Input input) throws OrmException, IOException, ResourceConflictException {
    input = Input.init(input);
    try (Repository r = repoManager.openRepository(project.getNameKey())) {
        BatchRefUpdate batchUpdate = r.getRefDatabase().newBatchUpdate();
        for (String branch : input.branches) {
            batchUpdate.addCommand(createDeleteCommand(project, r, branch));
        }
        try (RevWalk rw = new RevWalk(r)) {
            batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        }
        StringBuilder errorMessages = new StringBuilder();
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() == Result.OK) {
                postDeletion(project, command);
            } else {
                appendAndLogErrorMessage(errorMessages, command);
            }
        }
        if (errorMessages.length() > 0) {
            throw new ResourceConflictException(errorMessages.toString());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ProjectResource project, DeleteBranchesInput input) throws OrmException, IOException, ResourceConflictException {
    if (input == null) {
        input = new DeleteBranchesInput();
    }
    if (input.branches == null) {
        input.branches = Lists.newArrayListWithCapacity(1);
    }
    try (Repository r = repoManager.openRepository(project.getNameKey())) {
        BatchRefUpdate batchUpdate = r.getRefDatabase().newBatchUpdate();
        for (String branch : input.branches) {
            batchUpdate.addCommand(createDeleteCommand(project, r, branch));
        }
        try (RevWalk rw = new RevWalk(r)) {
            batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        }
        StringBuilder errorMessages = new StringBuilder();
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() == Result.OK) {
                postDeletion(project, command);
            } else {
                appendAndLogErrorMessage(errorMessages, command);
            }
        }
        if (errorMessages.length() > 0) {
            throw new ResourceConflictException(errorMessages.toString());
        }
    }
    return Response.none();
}
#end_block

#method_before
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#method_after
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        case LOCK_FAILURE:
        case NOT_ATTEMPTED:
        case OK:
        case REJECTED_MISSING_OBJECT:
        case REJECTED_NOCREATE:
        case REJECTED_NODELETE:
        case REJECTED_NONFASTFORWARD:
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#end_block

#method_before
private void postDeletion(ProjectResource project, ReceiveCommand cmd) throws OrmException {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
    Branch.NameKey branchKey = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
    ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(branchKey);
    dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
}
#method_after
private void postDeletion(ProjectResource project, ReceiveCommand cmd) {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, BranchInput input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new BranchInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = RefUtil.getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = RefUtil.getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (RefUtil.InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches) throws SubmoduleException {
    try {
        // These (repo/branch) will be updated later with all the given
        // individual submodule subscriptions
        Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : db.submoduleSubscriptions().bySubmodule(updatedBranch)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
        updatedSubscribers.addAll(updatedBranches);
        // Update subscribers.
        for (Branch.NameKey dest : targets.keySet()) {
            try {
                if (!updatedSubscribers.add(dest)) {
                    log.error("Possible circular subscription involving " + dest);
                } else {
                    updateGitlinks(db, dest, targets.get(dest));
                }
            } catch (SubmoduleException e) {
                log.warn("Cannot update gitlinks for " + dest, e);
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
protected void updateSuperProjects(Collection<Branch.NameKey> updatedBranches) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    logDebug("Updating superprojects");
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    for (Branch.NameKey updatedBranch : updatedBranches) {
        logDebug("Now processing " + updatedBranch);
        Set<Branch.NameKey> checkedTargets = new HashSet<>();
        Set<Branch.NameKey> targetsToProcess = new HashSet<>();
        targetsToProcess.add(updatedBranch);
        while (!targetsToProcess.isEmpty()) {
            Set<Branch.NameKey> newTargets = new HashSet<>();
            for (Branch.NameKey b : targetsToProcess) {
                try {
                    Collection<SubmoduleSubscription> subs = superProjectSubscriptionsForSubmoduleBranch(b);
                    for (SubmoduleSubscription sub : subs) {
                        Branch.NameKey dst = sub.getSuperProject();
                        targets.put(dst, sub);
                        newTargets.add(dst);
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Cannot find superprojects for " + b, e);
                }
            }
            logDebug("adding to done " + targetsToProcess);
            checkedTargets.addAll(targetsToProcess);
            logDebug("completely done with " + checkedTargets);
            Set<Branch.NameKey> intersection = new HashSet<>(checkedTargets);
            intersection.retainAll(newTargets);
            if (!intersection.isEmpty()) {
                throw new SubmoduleException("Possible circular subscription involving " + updatedBranch);
            }
            targetsToProcess = newTargets;
        }
    }
    for (Branch.NameKey dst : targets.keySet()) {
        try {
            updateGitlinks(dst, targets.get(dst));
        } catch (SubmoduleException e) {
            throw new SubmoduleException("Cannot update gitlinks for " + dst, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Updated git submodules\n\n");
    boolean sameAuthorForAll = true;
    try (Repository pdb = repoManager.openRepository(subscriber.getParentKey())) {
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try (Repository subrepo = repoManager.openRepository(s.getSubmodule().getParentKey());
                RevWalk rw = CodeReviewCommit.newRevWalk(subrepo)) {
                Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
                if (ref == null) {
                    ed.add(new DeletePath(s.getPath()));
                    continue;
                }
                final ObjectId updateTo = ref.getObjectId();
                RevCommit newCommit = rw.parseCommit(updateTo);
                if (author == null) {
                    author = newCommit.getAuthorIdent();
                } else if (!author.equals(newCommit.getAuthorIdent())) {
                    sameAuthorForAll = false;
                }
                DirCacheEntry dce = dc.getEntry(s.getPath());
                ObjectId oldId;
                if (dce != null) {
                    if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                        log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                        continue;
                    }
                    oldId = dce.getObjectId();
                } else {
                    // This submodule did not exist before. We do not want to add
                    // the full submodule history to the commit message, so omit it.
                    oldId = updateTo;
                }
                ed.add(new PathEdit(s.getPath()) {

                    @Override
                    public void apply(DirCacheEntry ent) {
                        ent.setFileMode(FileMode.GITLINK);
                        ent.setObjectId(updateTo);
                    }
                });
                if (verboseSuperProject) {
                    msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                    msgbuf.append(" " + s.getSubmodule().getShortName());
                    msgbuf.append(" " + updateTo.getName());
                    msgbuf.append("\n\n");
                    try {
                        rw.markStart(newCommit);
                        rw.markUninteresting(rw.parseCommit(oldId));
                        for (RevCommit c : rw) {
                            msgbuf.append(c.getFullMessage() + "\n\n");
                        }
                    } catch (IOException e) {
                        logAndThrowSubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                    }
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber));
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.resetRetain(subOr.canMergeFlag);
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#method_after
private static DirCache readTree(final Ref branch, RevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, rw.getObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#end_block

#method_before
@Override
public Response<String> apply(ProjectResource resource, PutDescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new PutDescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try {
        MetaDataUpdate md = updateFactory.create(resource.getNameKey());
        try {
            ProjectConfig config = ProjectConfig.read(md);
            Project project = config.getProject();
            project.setDescription(Strings.emptyToNull(input.description));
            String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
            if (!msg.endsWith("\n")) {
                msg += "\n";
            }
            md.setAuthor(user);
            md.setMessage(msg);
            ObjectId baseRev = config.getRevision();
            ObjectId commitRev = config.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equals(baseRev, commitRev)) {
                gitRefUpdated.fire(resource.getNameKey(), RefNames.REFS_CONFIG, baseRev, commitRev, user.getAccount());
            }
            cache.evict(ctl.getProject());
            gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
            return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
        } finally {
            md.close();
        }
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public Response<String> apply(ProjectResource resource, DescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new DescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try (MetaDataUpdate md = updateFactory.create(resource.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription(Strings.emptyToNull(input.description));
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(user);
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
        return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    bind(EventDispatcher.class).to(ChangeHookRunner.class);
    bind(EventSource.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private static Path hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    return path.resolve(value != null ? value : name);
}
#method_after
private static Optional<Path> hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    Path p = path.resolve(value != null ? value : name);
    return Files.exists(p) ? Optional.of(p) : Optional.<Path>absent();
}
#end_block

#method_before
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#method_after
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    if (!refUpdateHook.isPresent()) {
        return null;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#end_block

#method_before
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#method_after
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    dispatcher.get().postEvent(project, event);
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, final Map<String, Short> oldApprovals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval, oldApprovals);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null && approval.getValue() != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            if (oldApprovals != null && !oldApprovals.isEmpty()) {
                Short oldValue = oldApprovals.get(approval.getKey());
                if (oldValue != null) {
                    addArg(args, "--" + lt.getName() + "-oldValue", Short.toString(oldValue));
                }
            }
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    dispatcher.get().postEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(Branch.NameKey refName, ObjectId oldId, ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    dispatcher.get().postEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    dispatcher.get().postEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    dispatcher.get().postEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, String claName) {
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
    if (!claSignedHook.isPresent()) {
        return;
    }
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    a.value = Short.toString(approval.getValue());
    return a;
}
#method_after
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval, Map<String, Short> oldApprovals) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    if (oldApprovals != null && !oldApprovals.isEmpty()) {
        if (oldApprovals.get(approval.getKey()) != null) {
            a.oldValue = Short.toString(oldApprovals.get(approval.getKey()));
        }
    }
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    if (approval.getValue() != null) {
        a.value = Short.toString(approval.getValue());
    }
    return a;
}
#end_block

#method_before
private synchronized void runHook(Path hook, List<String> args) {
    if (Files.exists(hook)) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (project != null && hook.isPresent()) {
        hookQueue.execute(new AsyncHookTask(project, hook.get(), args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Project.NameKey project, Path hook, List<String> args) {
    if (!Files.exists(hook)) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#method_after
private HookResult runSyncHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (!hook.isPresent()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook.get(), args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.get().toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.get().toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
    }
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#method_after
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
    }
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#end_block

#method_before
private void checkLabels(RevisionResource revision, boolean strict, Map<String, Short> labels) throws BadRequestException, AuthException {
    ChangeControl ctl = revision.getControl();
    Iterator<Map.Entry<String, Short>> itr = labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType lt = revision.getControl().getLabelTypes().byLabel(ent.getKey());
        if (lt == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
            } else {
                itr.remove();
                continue;
            }
        }
        if (ent.getValue() == null || ent.getValue() == 0) {
            // Later null/0 will be deleted and revoke the label.
            continue;
        }
        if (lt.getValue(ent.getValue()) == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue()));
            } else {
                itr.remove();
                continue;
            }
        }
        String name = lt.getName();
        PermissionRange range = ctl.getRange(Permission.forLabel(name));
        if (range == null || !range.contains(ent.getValue())) {
            if (strict) {
                throw new AuthException(String.format("Applying label \"%s\": %d is restricted", ent.getKey(), ent.getValue()));
            } else if (range == null || range.isEmpty()) {
                ent.setValue((short) 0);
            } else {
                ent.setValue((short) range.squash(ent.getValue()));
            }
        }
    }
}
#method_after
private void checkLabels(RevisionResource revision, boolean strict, Map<String, Short> labels) throws BadRequestException, AuthException {
    ChangeControl ctl = revision.getControl();
    Iterator<Map.Entry<String, Short>> itr = labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType lt = revision.getControl().getLabelTypes().byLabel(ent.getKey());
        if (lt == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
            }
            itr.remove();
            continue;
        }
        if (ent.getValue() == null || ent.getValue() == 0) {
            // Later null/0 will be deleted and revoke the label.
            continue;
        }
        if (lt.getValue(ent.getValue()) == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue()));
            }
            itr.remove();
            continue;
        }
        String name = lt.getName();
        PermissionRange range = ctl.getRange(Permission.forLabel(name));
        if (range == null || !range.contains(ent.getValue())) {
            if (strict) {
                throw new AuthException(String.format("Applying label \"%s\": %d is restricted", ent.getKey(), ent.getValue()));
            } else if (range == null || range.isEmpty()) {
                ent.setValue((short) 0);
            } else {
                ent.setValue((short) range.squash(ent.getValue()));
            }
        }
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    if (change.getLastUpdatedOn().before(ctx.getWhen())) {
        change.setLastUpdatedOn(ctx.getWhen());
    }
    ps = ctx.getDb().patchSets().get(psId);
    ctx.getChangeUpdate().setPatchSetId(psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    if (dirty) {
        ctx.getDb().changes().update(Collections.singleton(change));
    }
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getUser().asIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, change, ps, user.getAccountId(), message, comments).sendAsync();
    }
    commentAdded.fire(change, ps, user.getAccount(), message.getMessage(), categories, ctx.getWhen());
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, notes, ps, user, message, comments).sendAsync();
    }
    commentAdded.fire(notes.getChange(), ps, user.getAccount(), message.getMessage(), approvals, oldApprovals, ctx.getWhen());
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(ctx.getWhen());
                setCommentRevId(e, patchListCache, ctx.getChange(), ps);
                ups.add(e);
            }
            break;
    }
    plcUtil.deleteComments(ctx.getDb(), ctx.getChangeUpdate(), del);
    plcUtil.upsertComments(ctx.getDb(), ctx.getChangeUpdate(), ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = new ArrayList<>();
    List<PatchLineComment> ups = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            e.setTag(in.tag);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                ups.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, ups);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    plcUtil.deleteComments(ctx.getDb(), u, del);
    plcUtil.putComments(ctx.getDb(), u, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private Set<CommentSetEntry> readExistingComments(ChangeContext ctx) throws OrmException {
    Set<CommentSetEntry> r = new HashSet<>();
    for (PatchLineComment c : plcUtil.publishedByChange(ctx.getDb(), ctx.getChangeNotes())) {
        r.add(CommentSetEntry.create(c));
    }
    return r;
}
#method_after
private Set<CommentSetEntry> readExistingComments(ChangeContext ctx) throws OrmException {
    Set<CommentSetEntry> r = new HashSet<>();
    for (PatchLineComment c : plcUtil.publishedByChange(ctx.getDb(), ctx.getNotes())) {
        r.add(CommentSetEntry.create(c));
    }
    return r;
}
#end_block

#method_before
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getChangeNotes(), user.getAccountId())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#method_after
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = new HashMap<>();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getNotes(), user.getAccountId())) {
        c.setTag(in.tag);
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#end_block

#method_before
private Map<String, PatchLineComment> patchSetDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByPatchSetAuthor(ctx.getDb(), psId, user.getAccountId(), ctx.getChangeNotes())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#method_after
private Map<String, PatchLineComment> patchSetDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = new HashMap<>();
    for (PatchLineComment c : plcUtil.draftByPatchSetAuthor(ctx.getDb(), psId, user.getAccountId(), ctx.getNotes())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#end_block

#method_before
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> labels = in.labels;
    if (labels == null) {
        labels = Collections.emptyMap();
    }
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ups = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    ChangeUpdate update = ctx.getChangeUpdate();
    LabelTypes labelTypes = ctx.getChangeControl().getLabelTypes();
    for (Map.Entry<String, Short> ent : labels.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                }
                del.add(c);
                update.putApproval(ent.getKey(), (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            categories.put(normName, c.getValue());
            update.putApproval(ent.getKey(), ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), TimeUtil.nowTs());
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            categories.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), ReviewerState.REVIEWER);
            update.putApproval(ent.getKey(), ent.getValue());
        }
    }
    if (!del.isEmpty() || !ups.isEmpty()) {
        if (ctx.getChange().getStatus().isClosed()) {
            throw new ResourceConflictException("change is closed");
        }
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = new ArrayList<>();
    List<PatchSetApproval> ups = new ArrayList<>();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    if ((!del.isEmpty() || !ups.isEmpty()) && ctx.getChange().getStatus().isClosed()) {
        throw new ResourceConflictException("change is closed");
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getChangeControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, TimeUtil.nowTs());
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
}
#method_after
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#end_block

#method_before
private Map<String, PatchSetApproval> scanLabels(ChangeContext ctx, List<PatchSetApproval> del) throws OrmException {
    LabelTypes labelTypes = ctx.getChangeControl().getLabelTypes();
    Map<String, PatchSetApproval> current = Maps.newHashMap();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctx.getChangeControl(), psId, user.getAccountId())) {
        if (a.isSubmit()) {
            continue;
        }
        LabelType lt = labelTypes.byLabel(a.getLabelId());
        if (lt != null) {
            current.put(lt.getName(), a);
        } else {
            del.add(a);
        }
    }
    return current;
}
#method_after
private Map<String, PatchSetApproval> scanLabels(ChangeContext ctx, List<PatchSetApproval> del) throws OrmException {
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, PatchSetApproval> current = new HashMap<>();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctx.getControl(), psId, user.getAccountId())) {
        if (a.isLegacySubmit()) {
            continue;
        }
        LabelType lt = labelTypes.byLabel(a.getLabelId());
        if (lt != null) {
            current.put(lt.getName(), a);
        } else {
            del.add(a);
        }
    }
    return current;
}
#end_block

#method_before
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
    return true;
}
#method_after
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setTag(in.tag);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#end_block

#method_before
public void setMessageSender(final MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#method_after
public void setMessageSender(MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSubmoduleSubscriptions(db, branches);
        op.updateSuperProjects(db, branches);
    } catch (SubmoduleException e) {
        log.error("Can't update submodule subscriptions " + "or update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(orm);
        op.updateSuperProjects(branches);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(change.getSubject()));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (RestApiException err) {
        log.error("Can't insert change/patchset for " + project.getName() + ". " + err.getMessage(), err);
        String rejection = "internal server error";
        if (err.getCause() != null) {
            rejection += ": " + err.getCause().getMessage();
        }
        reject(magicBranch.cmd, rejection);
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            checkState(NEW_PATCHSET.matcher(replace.inputCommand.getRefName()).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), replace.inputCommand.getRefName());
            try {
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            log.error("Error submit changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.enabled()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#method_after
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.readChanges()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try {
        mergeOpProvider.get().merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    } catch (NoSuchChangeException e) {
        throw new OrmException(e);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commitId, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.change);
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkState(tipChange != null, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<Change, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(db.changes().getAsync(request.ontoChange));
    }
    for (CheckedFuture<Change, OrmException> f : futures) {
        Change c = f.checkedGet();
        if (c != null) {
            replaceByChange.get(c.getId()).change = c;
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<ChangeNotes, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(notesFactory.createAsync(changeUpdateExector, db, project.getNameKey(), request.ontoChange));
    }
    for (CheckedFuture<ChangeNotes, OrmException> f : futures) {
        ChangeNotes notes = f.checkedGet();
        if (notes.getChange() != null) {
            replaceByChange.get(notes.getChangeId()).change = notes.getChange();
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private boolean newEdit() {
    newPatchSet = new PatchSet(change.currentPatchSetId());
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(change, user);
    } catch (IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(newPatchSet.getId())) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), newPatchSet.getId()));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(user.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    newPatchSet.setGroups(groups);
    if (rp.getPushCertificate() != null) {
        newPatchSet.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
}
#method_after
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    Change.Id id = onto.getId();
                    final ReplaceRequest req = new ReplaceRequest(id, c, cmd, false);
                    req.change = onto;
                    if (req.validate(true)) {
                        req.addOps(bu, null);
                        bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                            @Override
                            public PatchSet get() {
                                return req.replaceOp.getPatchSet();
                            }
                        }));
                        bu.addOp(id, new ChangeProgressOp(closeProgress));
                    }
                    break;
                }
            }
        }
        bu.execute();
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
private static boolean isHead(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#method_after
private static boolean isHead(ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#method_after
private static boolean isConfig(ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource req, Input input) throws UpdateException, RestApiException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    Op op = new Op(ctl, input != null ? input : new Input());
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getChange().getId(), op);
        u.execute();
    }
    return Strings.isNullOrEmpty(op.newTopicName) ? Response.<String>none() : Response.ok(op.newTopicName);
}
#method_after
@Override
public Response<String> apply(ChangeResource req, Input input) throws UpdateException, RestApiException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    Op op = new Op(input != null ? input : new Input());
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getId(), op);
        u.execute();
    }
    return Strings.isNullOrEmpty(op.newTopicName) ? Response.<String>none() : Response.ok(op.newTopicName);
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    newTopicName = Strings.nullToEmpty(input.topic);
    oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (oldTopicName.equals(newTopicName)) {
        return;
    }
    String summary;
    if (oldTopicName.isEmpty()) {
        summary = "Topic set to " + newTopicName;
    } else if (newTopicName.isEmpty()) {
        summary = "Topic " + oldTopicName + " removed";
    } else {
        summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
    }
    change.setTopic(Strings.emptyToNull(newTopicName));
    ChangeUtil.updated(change);
    ctx.getDb().changes().update(Collections.singleton(change));
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), caller.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    cmsg.setMessage(summary);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), cmsg);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    newTopicName = Strings.nullToEmpty(input.topic);
    oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (oldTopicName.equals(newTopicName)) {
        return false;
    }
    String summary;
    if (oldTopicName.isEmpty()) {
        summary = "Topic set to " + newTopicName;
    } else if (newTopicName.isEmpty()) {
        summary = "Topic " + oldTopicName + " removed";
    } else {
        summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
    }
    change.setTopic(Strings.emptyToNull(newTopicName));
    update.setTopic(change.getTopic());
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    cmsg.setMessage(summary);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (change != null) {
        topicEdited.fire(change, caller.getAccount(), oldTopicName);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (change != null) {
        topicEdited.fire(change, ctx.getUser().asIdentifiedUser().getAccount(), oldTopicName);
    }
}
#end_block

#method_before
public ConfigInfo apply(ProjectControl ctrl, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = ctrl.getProject().getNameKey();
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.get().create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.createNewChangeForAllNotInTarget != null) {
            p.setCreateNewChangeForAllNotInTarget(input.createNewChangeForAllNotInTarget);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (serverEnableSignedPush) {
            if (input.enableSignedPush != null) {
                p.setEnableSignedPush(input.enableSignedPush);
            }
            if (input.requireSignedPush != null) {
                p.setRequireSignedPush(input.requireSignedPush);
            }
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(ctrl.getProjectState(), projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId baseRev = projectConfig.getRevision();
            ObjectId commitRev = projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equals(baseRev, commitRev)) {
                gitRefUpdated.fire(projectName, RefNames.REFS_CONFIG, baseRev, commitRev, user.get().asIdentifiedUser().getAccount());
            }
            projectCache.evict(projectConfig.getProject());
            gitMgr.setProjectDescription(projectName, p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                log.warn(String.format("Failed to update config of project %s.", projectName), e);
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(serverEnableSignedPush, state.controlFor(user.get()), config, pluginConfigEntries, cfgFactory, allProjects, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, ConfigInput input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    return apply(rsrc.getControl(), input);
}
#end_block

#method_before
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        v.setValue(projectConfigEntry.preUpdate(v.getValue()));
                        value = v.getValue().value;
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                // $FALL-THROUGH$
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntryType.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        v.setValue(projectConfigEntry.preUpdate(v.getValue()));
                        value = v.getValue().value;
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                // $FALL-THROUGH$
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeAbandonedListener.class).to(ChangeHookApiListener.class);
    bind(ChangeMergedListener.class).to(ChangeHookApiListener.class);
    bind(ChangeRestoredListener.class).to(ChangeHookApiListener.class);
    bind(CommentAddedListener.class).to(ChangeHookApiListener.class);
    bind(DraftPublishedListener.class).to(ChangeHookApiListener.class);
    bind(GitReferenceUpdatedListener.class).to(ChangeHookApiListener.class);
    bind(HashtagsEditedListener.class).to(ChangeHookApiListener.class);
    bind(MergeFailedListener.class).to(ChangeHookApiListener.class);
    bind(NewProjectCreatedListener.class).to(ChangeHookApiListener.class);
    bind(ReviewerAddedListener.class).to(ChangeHookApiListener.class);
    bind(RevisionCreatedListener.class).to(ChangeHookApiListener.class);
    bind(TopicEditedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(ChangeHookValidator.class);
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), AgreementSignupListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ChangeAbandonedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ChangeMergedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ChangeRestoredListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), CommentAddedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), DraftPublishedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), HashtagsEditedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ReviewerAddedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), RevisionCreatedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), TopicEditedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(ChangeHookValidator.class);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser user = receiveEvent.user;
    String refname = receiveEvent.refName;
    ObjectId old = receiveEvent.commit.getParent(0);
    if (receiveEvent.command.getRefName().startsWith(REFS_CHANGES)) {
        /*
          * If the ref-update hook tries to distinguish behavior between pushes to
          * refs/heads/... and refs/for/..., make sure we send it the correct refname.
          * Also, if this is targetting refs/for/, make sure we behave the same as
          * what a push to refs/for/ would behave; in particular, setting oldrev to
          * 0000000000000000000000000000000000000000.
          */
        refname = refname.replace(R_HEADS, "refs/for/refs/heads/");
        old = ObjectId.zeroId();
    }
    HookResult result = hooks.doRefUpdateHook(receiveEvent.project, refname, user.getAccount(), old, receiveEvent.commit);
    if (result != null && result.getExitValue() != 0) {
        throw new CommitValidationException(result.toString().trim());
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser user = receiveEvent.user;
    String refname = receiveEvent.refName;
    ObjectId old = ObjectId.zeroId();
    if (receiveEvent.commit.getParentCount() > 0) {
        old = receiveEvent.commit.getParent(0);
    }
    if (receiveEvent.command.getRefName().startsWith(REFS_CHANGES)) {
        /*
        * If the ref-update hook tries to distinguish behavior between pushes to
        * refs/heads/... and refs/for/..., make sure we send it the correct
        * refname.
        * Also, if this is targetting refs/for/, make sure we behave the same as
        * what a push to refs/for/ would behave; in particular, setting oldrev
        * to 0000000000000000000000000000000000000000.
        */
        refname = refname.replace(R_HEADS, "refs/for/refs/heads/");
        old = ObjectId.zeroId();
    }
    HookResult result = hooks.doRefUpdateHook(receiveEvent.project, refname, user.getAccount(), old, receiveEvent.commit);
    if (result != null && result.getExitValue() != 0) {
        throw new CommitValidationException(result.toString().trim());
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public void onRevisionCreated(RevisionCreatedListener.Event ev) {
    try {
        hooks.doPatchsetCreatedHook(getChange(ev.getChange()), getPatchSet(ev.getRevision()), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onRevisionCreated(RevisionCreatedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doPatchsetCreatedHook(notes.getChange(), getPatchSet(notes, ev.getRevision()), db.get());
    } catch (OrmException e) {
        log.error("PatchsetCreated hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onDraftPublished(DraftPublishedListener.Event ev) {
    try {
        hooks.doDraftPublishedHook(getChange(ev.getChange()), getPatchSet(ev.getRevision()), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onDraftPublished(DraftPublishedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doDraftPublishedHook(notes.getChange(), getPatchSet(notes, ev.getRevision()), db.get());
    } catch (OrmException e) {
        log.error("DraftPublished hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onCommentAdded(CommentAddedListener.Event ev) {
    Map<String, Short> approvals = new HashMap<String, Short>();
    for (Entry<String, ApprovalInfo> e : ev.getApprovals().entrySet()) {
        approvals.put(e.getKey(), e.getValue().value.shortValue());
    }
    try {
        hooks.doCommentAddedHook(getChange(ev.getChange()), getAccount(ev.getAuthor()), getPatchSet(ev.getRevision()), ev.getComment(), approvals, db.get());
    } catch (OrmException e) {
        log.warn("CommentAdded hook failed to fun" + ev.getChange()._number, e);
    }
}
#method_after
@Override
public void onCommentAdded(CommentAddedListener.Event ev) {
    Map<String, Short> approvals = convertApprovalsMap(ev.getApprovals());
    Map<String, Short> oldApprovals = convertApprovalsMap(ev.getOldApprovals());
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doCommentAddedHook(notes.getChange(), getAccount(ev.getAuthor()), getPatchSet(notes, ev.getRevision()), ev.getComment(), approvals, oldApprovals, db.get());
    } catch (OrmException e) {
        log.error("CommentAdded hook failed to fun" + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onChangeMerged(ChangeMergedListener.Event ev) {
    try {
        hooks.doChangeMergedHook(getChange(ev.getChange()), getAccount(ev.getMerger()), getPatchSet(ev.getRevision()), db.get(), ev.getNewRevisionId());
    } catch (OrmException e) {
        log.error("ChangeMerged hook failed to run " + ev.getChange()._number, e);
    }
}
#method_after
@Override
public void onChangeMerged(ChangeMergedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doChangeMergedHook(notes.getChange(), getAccount(ev.getMerger()), getPatchSet(notes, ev.getRevision()), db.get(), ev.getNewRevisionId());
    } catch (OrmException e) {
        log.error("ChangeMerged hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event ev) {
    try {
        hooks.doChangeAbandonedHook(getChange(ev.getChange()), getAccount(ev.getAbandoner()), getPatchSet(ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doChangeAbandonedHook(notes.getChange(), getAccount(ev.getAbandoner()), getPatchSet(notes, ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
        log.error("ChangeAbandoned hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onChangeRestored(ChangeRestoredListener.Event ev) {
    try {
        hooks.doChangeRestoredHook(getChange(ev.getChange()), getAccount(ev.getRestorer()), getPatchSet(ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onChangeRestored(ChangeRestoredListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doChangeRestoredHook(notes.getChange(), getAccount(ev.getRestorer()), getPatchSet(notes, ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
        log.error("ChangeRestored hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onReviewerAdded(ReviewerAddedListener.Event ev) {
    try {
        Change change = getChange(ev.getChange());
        PatchSet patch = db.get().patchSets().get(change.currentPatchSetId());
        hooks.doReviewerAddedHook(change, getAccount(ev.getReviewer()), patch, db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onReviewerAdded(ReviewerAddedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doReviewerAddedHook(notes.getChange(), getAccount(ev.getReviewer()), psUtil.current(db.get(), notes), db.get());
    } catch (OrmException e) {
        log.error("ReviewerAdded hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onTopicEdited(TopicEditedListener.Event ev) {
    try {
        hooks.doTopicChangedHook(getChange(ev.getChange()), getAccount(ev.getEditor()), ev.getOldTopic(), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onTopicEdited(TopicEditedListener.Event ev) {
    try {
        hooks.doTopicChangedHook(getNotes(ev.getChange()).getChange(), getAccount(ev.getEditor()), ev.getOldTopic(), db.get());
    } catch (OrmException e) {
        log.error("TopicChanged hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onHashtagsEdited(HashtagsEditedListener.Event ev) {
    try {
        hooks.doHashtagsChangedHook(getChange(ev.getChange()), getAccount(ev.getEditor()), new HashSet<String>(ev.getAddedHashtags()), new HashSet<String>(ev.getRemovedHashtags()), new HashSet<String>(ev.getHashtags()), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onHashtagsEdited(HashtagsEditedListener.Event ev) {
    try {
        hooks.doHashtagsChangedHook(getNotes(ev.getChange()).getChange(), getAccount(ev.getEditor()), new HashSet<>(ev.getAddedHashtags()), new HashSet<>(ev.getRemovedHashtags()), new HashSet<>(ev.getHashtags()), db.get());
    } catch (OrmException e) {
        log.error("HashtagsChanged hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
private PatchSet getPatchSet(RevisionInfo info) throws OrmException {
    return db.get().patchSets().get(PatchSet.Id.fromRef(info.ref));
}
#method_after
private PatchSet getPatchSet(ChangeNotes notes, RevisionInfo info) throws OrmException {
    return psUtil.get(db.get(), notes, PatchSet.Id.fromRef(info.ref));
}
#end_block

#method_before
public PatchSetInserter setGroups(Iterable<String> groups) {
    this.groups = groups;
    return this;
}
#method_after
public PatchSetInserter setGroups(List<String> groups) {
    checkNotNull(groups, "groups may not be null");
    this.groups = groups;
    return this;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    init();
    validate(ctx);
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, getPatchSetId().toRefName(), ReceiveCommand.Type.CREATE));
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    init();
    validate(ctx);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, getPatchSetId().toRefName(), ReceiveCommand.Type.CREATE));
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException {
    ChangeControl ctl = ctx.getChangeControl();
    change = ctx.getChange();
    Change.Id id = change.getId();
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
    }
    patchSet = new PatchSet(psId);
    patchSet.setCreatedOn(ctx.getWhen());
    patchSet.setUploader(firstNonNull(uploader, ctl.getChange().getOwner()));
    patchSet.setRevision(new RevId(commit.name()));
    patchSet.setDraft(draft);
    if (groups != null) {
        patchSet.setGroups(groups);
    } else {
        patchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getChange().getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    // TODO(dborowitz): Throw ResourceConflictException instead of using
    // AtomicUpdate.
    change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isClosed() && !allowClosed) {
                return null;
            }
            if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                return null;
            }
            if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
                change.setStatus(Change.Status.NEW);
            }
            change.setCurrentPatchSet(patchSetInfo);
            ChangeUtil.updated(change);
            return change;
        }
    });
    if (change == null) {
        throw new ChangeModifiedException(String.format("Change %s was modified", id));
    }
    approvalCopier.copy(db, ctl, patchSet);
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, ctx.getChangeUpdate(), changeMessage);
    }
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), change.getStatus().name().toLowerCase()));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail) {
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
            cm.setFrom(ctx.getUser().getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage);
            cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
            cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new patch set on change " + change.getId(), err);
        }
    }
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail) {
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(ctx.getUser().getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage);
            cm.addReviewers(oldReviewers.byState(REVIEWER));
            cm.addExtraCC(oldReviewers.byState(CC));
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new patch set on change " + change.getId(), err);
        }
    }
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
    }
}
#end_block

#method_before
private void validate(RepoContext ctx) throws ResourceConflictException, IOException {
    CommitValidators cv = commitValidatorsFactory.create(refControl, sshInfo, ctx.getRepository());
    String refName = getPatchSetId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), refControl.getProjectControl().getProject(), refControl.getRefName(), commit, ctx.getUser().asIdentifiedUser());
    try {
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws ResourceConflictException, IOException {
    CommitValidators cv = commitValidatorsFactory.create(origCtl.getRefControl(), sshInfo, ctx.getRepository());
    String refName = getPatchSetId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), origCtl.getProjectControl().getProject(), origCtl.getRefControl().getRefName(), commit, ctx.getUser().asIdentifiedUser());
    try {
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#end_block

#method_before
@Override
public void enterAgreement(final String agreementName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        @Override
        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(agreementName);
            if (ca == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (ca.getAutoVerify() == null) {
                throw new Failure(new IllegalStateException("cannot enter a non-autoVerify agreement"));
            } else if (ca.getAutoVerify().getUUID() == null) {
                throw new Failure(new NoSuchEntityException());
            }
            AccountGroup group = groupCache.get(ca.getAutoVerify().getUUID());
            if (group == null) {
                throw new Failure(new NoSuchEntityException());
            }
            Account account = user.get().getAccount();
            // ToDo claSigned.fireClaSigned() instead of
            // hooks.doClaSignupHook(account, ca.getName());
            final AccountGroupMember.Key key = new AccountGroupMember.Key(account.getId(), group.getId());
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                auditService.dispatchAddAccountsToGroup(account.getId(), Collections.singleton(m));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
@Override
public void enterAgreement(final String agreementName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        @Override
        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(agreementName);
            if (ca == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (ca.getAutoVerify() == null) {
                throw new Failure(new IllegalStateException("cannot enter a non-autoVerify agreement"));
            } else if (ca.getAutoVerify().getUUID() == null) {
                throw new Failure(new NoSuchEntityException());
            }
            AccountGroup group = groupCache.get(ca.getAutoVerify().getUUID());
            if (group == null) {
                throw new Failure(new NoSuchEntityException());
            }
            Account account = user.get().getAccount();
            agreementSignup.fire(account, ca.getName());
            final AccountGroupMember.Key key = new AccountGroupMember.Key(account.getId(), group.getId());
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                auditService.dispatchAddAccountsToGroup(account.getId(), Collections.singleton(m));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
@Override
public PostResult apply(ChangeResource rsrc, AddReviewerInput input) throws AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(reviewerFactory.create(rsrc, accountId));
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#method_after
@Override
public PostResult apply(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, OrmException, RestApiException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(reviewerFactory.create(rsrc, accountId));
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#end_block

#method_before
private PostResult putAccount(ReviewerResource rsrc) throws OrmException, IOException {
    Account member = rsrc.getUser().getAccount();
    ChangeControl control = rsrc.getControl();
    PostResult result = new PostResult();
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc, result, ImmutableMap.of(member.getId(), control));
    }
    return result;
}
#method_after
private PostResult putAccount(ReviewerResource rsrc) throws OrmException, UpdateException, RestApiException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    PostResult result = new PostResult();
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc.getChangeResource(), result, ImmutableMap.of(member.getId(), control));
    }
    return result;
}
#end_block

#method_before
private PostResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws BadRequestException, UnprocessableEntityException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    PostResult result = new PostResult();
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = Maps.newHashMap();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#method_after
private PostResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    PostResult result = new PostResult();
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#end_block

#method_before
private void addReviewers(ChangeResource rsrc, PostResult result, Map<Account.Id, ChangeControl> reviewers) throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeUpdate update = updateFactory.create(rsrc.getControl());
    List<PatchSetApproval> added;
    db.changes().beginTransaction(rsrc.getChange().getId());
    try {
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getChange().getId(), db);
        added = approvalsUtil.addReviewers(db, rsrc.getNotes(), update, rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(rsrc.getChange().getId());
    result.reviewers = Lists.newArrayListWithCapacity(added.size());
    for (PatchSetApproval psa : added) {
        // New reviewers have value 0, don't bother normalizing.
        result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
    }
    accountLoaderFactory.create(true).fill(result.reviewers);
    indexFuture.checkedGet();
    emailReviewers(rsrc.getChange(), added);
    if (!added.isEmpty()) {
        PatchSet patchSet = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            reviewerAdded.fire(rsrc.getChange(), patchSet, account);
        }
    }
}
#method_after
private void addReviewers(ChangeResource rsrc, PostResult result, Map<Account.Id, ChangeControl> reviewers) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc, reviewers);
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, op);
        bu.execute();
        result.reviewers = Lists.newArrayListWithCapacity(op.added.size());
        for (PatchSetApproval psa : op.added) {
            // New reviewers have value 0, don't bother normalizing.
            result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
        }
        // We don't do this inside Op, since the accounts are in a different
        // table.
        accountLoaderFactory.create(true).fill(result.reviewers);
    }
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource rsrc) {
    try {
        return new UiAction.Description().setTitle(String.format("Publish revision %d", rsrc.getPatchSet().getPatchSetId())).setVisible(rsrc.getPatchSet().isDraft() && rsrc.getControl().canPublish(dbProvider.get()));
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource rsrc) {
    try {
        return new UiAction.Description().setLabel("Publish").setTitle(String.format("Publish revision %d", rsrc.getPatchSet().getPatchSetId())).setVisible(rsrc.getPatchSet().isDraft() && rsrc.getControl().canPublish(dbProvider.get()));
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws RestApiException, OrmException {
    if (!ctx.getChangeControl().canPublish(ctx.getDb())) {
        throw new AuthException("Cannot publish this draft patch set");
    }
    saveChange(ctx);
    savePatchSet(ctx);
    addReviewers(ctx);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    if (!ctx.getControl().canPublish(ctx.getDb())) {
        throw new AuthException("Cannot publish this draft patch set");
    }
    if (patchSet == null) {
        patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
        if (patchSet == null) {
            throw new ResourceNotFoundException(psId.toString());
        }
    }
    saveChange(ctx);
    savePatchSet(ctx);
    addReviewers(ctx);
    return true;
}
#end_block

#method_before
private void saveChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    wasDraftChange = change.getStatus() == Change.Status.DRAFT;
    if (wasDraftChange) {
        change.setStatus(Change.Status.NEW);
        ChangeUtil.updated(change);
        ctx.getDb().changes().update(Collections.singleton(change));
    }
}
#method_after
private void saveChange(ChangeContext ctx) {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    wasDraftChange = change.getStatus() == Change.Status.DRAFT;
    if (wasDraftChange) {
        change.setStatus(Change.Status.NEW);
        update.setStatus(change.getStatus());
    }
}
#end_block

#method_before
private void savePatchSet(ChangeContext ctx) throws RestApiException, OrmException {
    patchSet = ctx.getDb().patchSets().get(psId);
    if (!patchSet.isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    patchSet.setDraft(false);
    // Force ETag invalidation if not done already
    if (!wasDraftChange) {
        ChangeUtil.updated(change);
        ctx.getDb().changes().update(Collections.singleton(change));
    }
    ctx.getDb().patchSets().update(Collections.singleton(patchSet));
}
#method_after
private void savePatchSet(ChangeContext ctx) throws RestApiException, OrmException {
    if (!patchSet.isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    psUtil.publish(ctx.getDb(), ctx.getUpdate(psId), patchSet);
}
#end_block

#method_before
private void addReviewers(ChangeContext ctx) throws OrmException {
    LabelTypes labelTypes = ctx.getChangeControl().getLabelTypes();
    Collection<Account.Id> oldReviewers = approvalsUtil.getReviewers(ctx.getDb(), ctx.getChangeNotes()).values();
    List<FooterLine> footerLines = commit.getFooterLines();
    recipients = getRecipientsFromFooters(accountResolver, patchSet, footerLines);
    recipients.remove(ctx.getUser().getAccountId());
    approvalsUtil.addReviewers(ctx.getDb(), ctx.getChangeUpdate(), labelTypes, change, patchSet, patchSetInfo, recipients.getReviewers(), oldReviewers);
}
#method_after
private void addReviewers(ChangeContext ctx) throws OrmException, IOException {
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Collection<Account.Id> oldReviewers = approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all();
    RevCommit commit = ctx.getRevWalk().parseCommit(ObjectId.fromString(patchSet.getRevision().get()));
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    List<FooterLine> footerLines = commit.getFooterLines();
    recipients = getRecipientsFromFooters(accountResolver, patchSet.isDraft(), footerLines);
    recipients.remove(ctx.getUser().getAccountId());
    approvalsUtil.addReviewers(ctx.getDb(), ctx.getUpdate(psId), labelTypes, change, patchSet, patchSetInfo, recipients.getReviewers(), oldReviewers);
}
#end_block

#method_before
private void sendCreateChange(Context ctx) throws EmailException {
    CreateChangeSender cm = createChangeSenderFactory.create(change.getId());
    cm.setFrom(ctx.getUser().getAccountId());
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#method_after
private void sendCreateChange(Context ctx) throws EmailException {
    CreateChangeSender cm = createChangeSenderFactory.create(ctx.getProject(), change.getId());
    cm.setFrom(ctx.getUser().getAccountId());
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#end_block

#method_before
private void sendReplacePatchSet(Context ctx) throws EmailException, OrmException {
    Account.Id accountId = ctx.getUser().getAccountId();
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), accountId, ctx.getWhen(), psId);
    msg.setMessage("Uploaded patch set " + psId.get() + ".");
    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
    cm.setFrom(accountId);
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.setChangeMessage(msg);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#method_after
private void sendReplacePatchSet(Context ctx) throws EmailException, OrmException {
    Account.Id accountId = ctx.getUser().getAccountId();
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), accountId, ctx.getWhen(), psId);
    msg.setMessage("Uploaded patch set " + psId.get() + ".");
    ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
    cm.setFrom(accountId);
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.setChangeMessage(msg);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#end_block

#method_before
@Override
public Change getChange() {
    return change;
}
#method_after
public Change getChange() {
    checkState(change != null, "getChange() only valid after creating change");
    return change;
}
#end_block

#method_before
public ChangeInserter setDraft(boolean draft) {
    change.setStatus(draft ? Change.Status.DRAFT : Change.Status.NEW);
    patchSet.setDraft(draft);
    return this;
}
#method_after
public ChangeInserter setDraft(boolean draft) {
    checkState(change == null, "setDraft(boolean) only valid before creating change");
    return setStatus(draft ? Change.Status.DRAFT : Change.Status.NEW);
}
#end_block

#method_before
public ChangeInserter setGroups(Iterable<String> groups) {
    patchSet.setGroups(groups);
    return this;
}
#method_after
public ChangeInserter setGroups(List<String> groups) {
    checkNotNull(groups, "groups may not be empty");
    checkState(patchSet == null, "setGroups(Iterable<String>) only valid before creating change");
    this.groups = groups;
    return this;
}
#end_block

#method_before
public PatchSet getPatchSet() {
    return patchSet;
}
#method_after
public PatchSet getPatchSet() {
    checkState(patchSet != null, "getPatchSet() only valid after creating change");
    return patchSet;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws InvalidChangeOperationException, IOException {
    validate(ctx);
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, patchSet.getId());
    change.setCurrentPatchSet(patchSetInfo);
    if (!updateRef) {
        return;
    }
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, patchSet.getRefName()));
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    validate(ctx);
    if (!updateRef) {
        return;
    }
    if (updateRefCommand == null) {
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, psId.toRefName()));
    } else {
        ctx.addRefUpdate(updateRefCommand);
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getChangeControl();
    ChangeUpdate update = ctx.getChangeUpdate();
    if (patchSet.getGroups() == null) {
        patchSet.setGroups(GroupCollector.getDefaultGroups(patchSet));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    db.changes().insert(Collections.singleton(change));
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getChangeControl(), approvals);
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), patchSet.getCreatedOn(), patchSet.getId());
        changeMessage.setMessage(message);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, draft, newGroups, null);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), patchSet.getCreatedOn(), patchSet.getId());
        changeMessage.setMessage(message);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
        ReviewDb db = ctx.getDb();
        if (approvals != null && !approvals.isEmpty()) {
            commentAdded.fire(change, patchSet, user.getAccount(), null, approvals, ctx.getWhen());
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException, NoSuchChangeException {
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
        if (approvals != null && !approvals.isEmpty()) {
            ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), change, ctx.getUser());
            List<LabelType> labels = changeControl.getLabelTypes().getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getUser().asIdentifiedUser().getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#end_block

#method_before
private void validate(RepoContext ctx) throws IOException, InvalidChangeOperationException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    CommitValidators cv = commitValidatorsFactory.create(refControl, new NoSshInfo(), ctx.getRepository());
    String refName = patchSet.getId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, user);
    try {
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new InvalidChangeOperationException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        CommitValidators cv = commitValidatorsFactory.create(refControl, new NoSshInfo(), ctx.getRepository());
        String refName = psId.toRefName();
        CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, ctx.getUser().asIdentifiedUser());
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, final AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    if (!control.canAbandon(dbProvider.get())) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message, caller.getAccount());
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    if (!control.canAbandon(dbProvider.get())) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message);
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#end_block

#method_before
public Change abandon(ChangeControl control, final String msgTxt, final Account account) throws RestApiException, UpdateException {
    Op op = new Op(msgTxt, account);
    Change c = control.getChange();
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), c.getProject(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(c.getId(), op).execute();
    }
    return op.change;
}
#method_after
public Change abandon(ChangeControl control, String msgTxt) throws RestApiException, UpdateException {
    CurrentUser user = control.getUser();
    Account account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null;
    Op op = new Op(msgTxt, account);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), user, TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return op.change;
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    if (change == null || !change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = ctx.getDb().patchSets().get(change.currentPatchSetId());
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.getDb().changes().update(Collections.singleton(change));
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
private ChangeMessage newMessage(ReviewDb db) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), account != null ? account.getId() : null, change.getLastUpdatedOn(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), account != null ? account.getId() : null, ctx.getWhen(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeAbandoned.fire(change, patchSet, account, msgTxt);
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(ctx.getProject(), change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeAbandoned.fire(change, patchSet, account, msgTxt);
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canRestore(dbProvider.get())) {
        throw new AuthException("restore not permitted");
    }
    Op op = new Op(input);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getChange().getId(), op).execute();
    }
    return json.create(ChangeJson.NO_OPTIONS).format(op.change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canRestore(dbProvider.get())) {
        throw new AuthException("restore not permitted");
    }
    Op op = new Op(input);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getId(), op).execute();
    }
    return json.create(ChangeJson.NO_OPTIONS).format(op.change);
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    caller = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    if (change == null || change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    patchSet = ctx.getDb().patchSets().get(change.currentPatchSetId());
    change.setStatus(Status.NEW);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.getDb().changes().update(Collections.singleton(change));
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    if (change == null || change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Status.NEW);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
private ChangeMessage newMessage(ReviewDb db) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Restored");
    if (!Strings.nullToEmpty(input.message).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(input.message.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), caller.getAccountId(), change.getLastUpdatedOn(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Restored");
    if (!Strings.nullToEmpty(input.message).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(input.message.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change.getId());
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeRestored.fire(change, patchSet, caller.getAccount(), Strings.emptyToNull(input.message));
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(ctx.getProject(), change.getId());
        cm.setFrom(ctx.getUser().getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeRestored.fire(change, patchSet, ctx.getUser().asIdentifiedUser().getAccount(), Strings.emptyToNull(input.message));
}
#end_block

#method_before
@VisibleForTesting
public void start() throws IOException {
    if (dbInjector == null) {
        dbInjector = createDbInjector(MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    initIndexType();
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setDbCfgInjector(dbInjector, cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    if (!consoleLog) {
        manager.add(ErrorLogFile.start(getSitePath(), config));
    }
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#method_after
@VisibleForTesting
public void start() throws IOException {
    if (dbInjector == null) {
        dbInjector = createDbInjector(true, /* enableMetrics */
        MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    if (!slave) {
        initIndexType();
    }
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setDbCfgInjector(dbInjector, cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    if (!consoleLog) {
        manager.add(ErrorLogFile.start(getSitePath(), config));
    }
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.Module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless, slave));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new EventBroker.Module());
    modules.add(new AccountPatchReviewStoreImpl.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private AbstractModule createIndexModule() {
    if (slave) {
        return new DummyIndexModule();
    }
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : new LuceneIndexModule();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#method_after
private AbstractModule createIndexModule() {
    if (slave) {
        return new DummyIndexModule();
    }
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : LuceneIndexModule.latestVersionWithOnlineUpgrade();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave, sysInjector.getInstance(DownloadConfig.class)));
    if (indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave, sysInjector.getInstance(DownloadConfig.class)));
    if (!slave && indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    // StaticModule contains a "/*" wildcard, place it last.
    modules.add(sysInjector.getInstance(StaticModule.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(rsrc.getBranchKey());
                dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case RENAMED:
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#end_block

#method_before
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    modules.add(secureStore);
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#method_after
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    modules.add(secureStore);
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    modules.add(new DropWizardMetricMaker.ApiModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#end_block

#method_before
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath == null) {
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new SchemaModule());
    modules.add(new LocalDiskRepositoryManager.Module());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath == null) {
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new SchemaModule());
    modules.add(new ConfigNotesMigration.Module());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(false));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    switch(indexType) {
        case LUCENE:
            modules.add(new LuceneIndexModule());
            break;
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new EventBroker.Module());
    modules.add(new AccountPatchReviewStoreImpl.Module());
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, false, false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    if (sshInjector != null) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    modules.add(H2CacheBasedWebSession.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    if (sshInjector != null) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    modules.add(H2CacheBasedWebSession.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    // StaticModule contains a "/*" wildcard, place it last.
    modules.add(sysInjector.getInstance(StaticModule.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()), true);
}
#method_after
public ChangeInfo format(Project.NameKey project, Change.Id id) throws OrmException, NoSuchChangeException {
    ChangeNotes notes;
    try {
        notes = notesFactory.createChecked(db.get(), project, id);
    } catch (OrmException | NoSuchChangeException e) {
        if (!has(CHECK)) {
            throw e;
        }
        return checkOnly(changeDataFactory.create(db.get(), project, id));
    }
    return format(changeDataFactory.create(db.get(), notes));
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        } else {
            return toChangeInfo(cd, limitToPsId);
        }
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.propagateIfPossible(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.propagateIfPossible(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    ensureLoaded(FluentIterable.from(in).transformAndConcat(new Function<QueryResult, List<ChangeData>>() {

        @Override
        public List<ChangeData> apply(QueryResult in) {
            return in.changes();
        }
    }));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    Map<Change.Id, ChangeInfo> out = Maps.newHashMap();
    for (QueryResult r : in) {
        List<ChangeInfo> infos = toChangeInfo(out, r.changes());
        if (!infos.isEmpty() && r.moreChanges()) {
            infos.get(infos.size() - 1)._moreChanges = true;
        }
        res.add(infos);
    }
    accountLoader.fill();
    return res;
}
#method_after
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    ensureLoaded(FluentIterable.from(in).transformAndConcat(new Function<QueryResult, List<ChangeData>>() {

        @Override
        public List<ChangeData> apply(QueryResult in) {
            return in.changes();
        }
    }));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    Map<Change.Id, ChangeInfo> out = new HashMap<>();
    for (QueryResult r : in) {
        List<ChangeInfo> infos = toChangeInfo(out, r.changes());
        if (!infos.isEmpty() && r.moreChanges()) {
            infos.get(infos.size() - 1)._moreChanges = true;
        }
        res.add(infos);
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    out.submittable = submit.submittable(cd);
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus() != Change.Status.MERGED) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
    }
    out.submittable = Submit.submittable(cd);
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    if (cd.getSubmitRecords() != null) {
        return cd.getSubmitRecords();
    }
    cd.setSubmitRecords(new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate());
    return cd.getSubmitRecords();
}
#method_after
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    // TODO(dborowitz): Handle this better at the ChangeData level.
    if (submitRecords == null) {
        submitRecords = new HashMap<>();
    }
    List<SubmitRecord> records = submitRecords.get(cd.getId());
    if (records == null) {
        records = new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate();
        submitRecords.put(cd.getId(), records);
    }
    return records;
}
#end_block

#method_before
private Map<String, LabelWithStatus> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelWithStatus p = labels.get(r.label);
            if (p == null || p.status().compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        default:
                            break;
                    }
                }
                n.optional = r.status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, LabelWithStatus.create(n, r.status));
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelWithStatus p = labels.get(r.label);
            if (p == null || p.status().compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        case IMPOSSIBLE:
                        case MAY:
                        case NEED:
                        default:
                            break;
                    }
                }
                n.optional = r.status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, LabelWithStatus.create(n, r.status));
            }
        }
    }
    return labels;
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = Sets.newHashSet();
    allUsers.addAll(cd.reviewers().values());
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                date = psa.getGranted();
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, date));
        }
    }
}
#method_after
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().all());
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, tag, date));
        }
    }
}
#end_block

#method_before
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = Sets.newHashSet();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Set<String> labelNames = Sets.newHashSet();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (String name : labelNames) {
        LabelType type = labelTypes.byLabel(name);
        LabelWithStatus l = LabelWithStatus.create(new LabelInfo(), null);
        if (detailed) {
            setLabelValues(type, l);
        }
        labels.put(type.getName(), l);
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        if (detailed) {
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.date = psa.getGranted();
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Set<String> labelNames = new HashSet<>();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (String name : labelNames) {
        LabelType type = labelTypes.byLabel(name);
        LabelWithStatus l = LabelWithStatus.create(new LabelInfo(), null);
        if (detailed) {
            setLabelValues(type, l);
        }
        labels.put(type.getName(), l);
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        if (detailed) {
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#end_block

#method_before
private ApprovalInfo approvalInfo(Account.Id id, Integer value, Timestamp date) {
    ApprovalInfo ai = new ApprovalInfo(id.get());
    ai.value = value;
    ai.date = date;
    accountLoader.put(ai);
    return ai;
}
#method_after
private ApprovalInfo approvalInfo(Account.Id id, Integer value, String tag, Timestamp date) {
    ApprovalInfo ai = getApprovalInfo(id, value, tag, date);
    accountLoader.put(ai);
    return ai;
}
#end_block

#method_before
private void setLabelValues(LabelType type, LabelWithStatus l) {
    l.label().defaultValue = type.getDefaultValue();
    l.label().values = Maps.newLinkedHashMap();
    for (LabelValue v : type.getValues()) {
        l.label().values.put(v.formatValue(), v.getText());
    }
    if (isOnlyZero(l.label().values.keySet())) {
        l.label().values = null;
    }
}
#method_after
private void setLabelValues(LabelType type, LabelWithStatus l) {
    l.label().defaultValue = type.getDefaultValue();
    l.label().values = new LinkedHashMap<>();
    for (LabelValue v : type.getValues()) {
        l.label().values.put(v.formatValue(), v.getText());
    }
    if (isOnlyZero(l.label().values.keySet())) {
        l.label().values = null;
    }
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            result.add(cmi);
        }
    }
    return result;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = Maps.newLinkedHashMap();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#end_block

#method_before
public RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(new ChangeResource(ctl), in));
    }
    if (has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(db, in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws IOException {
    Project.NameKey project = ctl.getChange().getProject();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
        }
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = Maps.newLinkedHashMap();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#method_after
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#end_block

#method_before
private static void addCommand(FetchInfo fetchInfo, String commandName, String c) {
    if (fetchInfo.commands == null) {
        fetchInfo.commands = Maps.newTreeMap();
    }
    fetchInfo.commands.put(commandName, c);
}
#method_after
private static void addCommand(FetchInfo fetchInfo, String commandName, String c) {
    if (fetchInfo.commands == null) {
        fetchInfo.commands = new TreeMap<>();
    }
    fetchInfo.commands.put(commandName, c);
}
#end_block

#method_before
private static void addApproval(LabelInfo label, ApprovalInfo approval) {
    if (label.all == null) {
        label.all = Lists.newArrayList();
    }
    label.all.add(approval);
}
#method_after
private static void addApproval(LabelInfo label, ApprovalInfo approval) {
    if (label.all == null) {
        label.all = new ArrayList<>();
    }
    label.all.add(approval);
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, final AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message, caller.getAccount());
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    if (!control.canAbandon(dbProvider.get())) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message);
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#end_block

#method_before
public Change abandon(ChangeControl control, final String msgTxt, final Account account) throws RestApiException, UpdateException {
    Op op = new Op(msgTxt, account);
    Change c = control.getChange();
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), c.getProject(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(c.getId(), op).execute();
    }
    return op.change;
}
#method_after
public Change abandon(ChangeControl control, String msgTxt) throws RestApiException, UpdateException {
    CurrentUser user = control.getUser();
    Account account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null;
    Op op = new Op(msgTxt, account);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), user, TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return op.change;
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    if (change == null || !change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = ctx.getDb().patchSets().get(change.currentPatchSetId());
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.getDb().changes().update(Collections.singleton(change));
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
private ChangeMessage newMessage(ReviewDb db) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), account != null ? account.getId() : null, change.getLastUpdatedOn(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), account != null ? account.getId() : null, ctx.getWhen(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    try {
        changeAbandoned.fire(change, patchSet, account, msgTxt);
    } catch (PatchListNotAvailableException | GpgException | IOException e) {
        throw new OrmException(e);
    }
    hooks.doChangeAbandonedHook(change, account, patchSet, Strings.emptyToNull(msgTxt), ctx.getDb());
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(ctx.getProject(), change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeAbandoned.fire(change, patchSet, account, msgTxt);
    hooks.doChangeAbandonedHook(change, account, patchSet, Strings.emptyToNull(msgTxt), ctx.getDb());
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(ChangeResource resource) {
    return new UiAction.Description().setLabel("Abandon").setTitle("Abandon the change").setVisible(resource.getChange().getStatus().isOpen() && resource.getChange().getStatus() != Change.Status.DRAFT && resource.getControl().canAbandon());
}
#method_after
@Override
public UiAction.Description getDescription(ChangeResource resource) {
    boolean canAbandon = false;
    try {
        canAbandon = resource.getControl().canAbandon(dbProvider.get());
    } catch (OrmException e) {
        log.error("Cannot check canAbandon status. Assuming false.", e);
    }
    return new UiAction.Description().setLabel("Abandon").setTitle("Abandon the change").setVisible(resource.getChange().getStatus().isOpen() && resource.getChange().getStatus() != Change.Status.DRAFT && canAbandon);
}
#end_block

#method_before
public void fire(ChangeInfo change, RevisionInfo revision, AccountInfo abandoner, String reason) {
    Event e = new Event(change, revision, abandoner, reason);
    for (ChangeAbandonedListener l : listeners) {
        l.onChangeAbandoned(e);
    }
}
#method_after
public void fire(ChangeInfo change, RevisionInfo revision, AccountInfo abandoner, String reason) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    Event e = new Event(change, revision, abandoner, reason);
    for (ChangeAbandonedListener l : listeners) {
        l.onChangeAbandoned(e);
    }
}
#end_block

#method_before
public void fire(Change change, PatchSet ps, Account abandoner, String reason) throws OrmException, PatchListNotAvailableException, GpgException, IOException {
    ChangeJson changeJson = changeJsonFactory.create(ChangeJson.NO_OPTIONS);
    ChangeInfo changeInfo = changeJson.format(change);
    ChangeData cd = changeDataFactory.create(db.get(), change);
    ChangeControl ctl = cd.changeControl();
    RevisionInfo revisionInfo = changeJson.toRevisionInfo(ctl, ps);
    AccountInfo ai = new AccountInfo(abandoner.getId().get());
    ai.email = abandoner.getPreferredEmail();
    ai.name = abandoner.getFullName();
    ai.username = abandoner.getUserName();
    fire(changeInfo, revisionInfo, ai, reason);
}
#method_after
public void fire(Change change, PatchSet ps, Account abandoner, String reason) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        fire(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(abandoner), reason);
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException e) {
        log.error("Couldn't fire event", e);
    }
}
#end_block

#method_before
public Map<String, Ref> filter(Map<String, Ref> refs, boolean filterTagsSeparately) {
    if (projectCtl.getProjectState().isAllUsers()) {
        refs = addUsersSelfSymref(refs);
    }
    if (projectCtl.allRefsAreVisible(ImmutableSet.of(REFS_CONFIG))) {
        return fastHideRefsMetaConfig(refs);
    }
    Account.Id userId;
    boolean viewMetadata;
    if (projectCtl.getUser().isIdentifiedUser()) {
        IdentifiedUser user = projectCtl.getUser().asIdentifiedUser();
        userId = user.getAccountId();
        viewMetadata = user.getCapabilities().canAccessDatabase();
        userEditPrefix = RefNames.refsEditPrefix(userId);
    } else {
        userId = null;
        viewMetadata = false;
    }
    Map<String, Ref> result = new HashMap<>();
    List<Ref> deferredTags = new ArrayList<>();
    for (Ref ref : refs.values()) {
        String name = ref.getName();
        Change.Id changeId;
        Account.Id accountId;
        if (name.startsWith(REFS_CACHE_AUTOMERGE) || (!showMetadata && isMetadata(name))) {
            continue;
        } else if (RefNames.isRefsEdit(name)) {
            // Edits are visible only to the owning user, if change is visible.
            if (viewMetadata || visibleEdit(name)) {
                result.put(name, ref);
            }
        } else if ((changeId = Change.Id.fromRef(name)) != null) {
            // Change ref is visible only if the change is visible.
            if (viewMetadata || visible(changeId)) {
                result.put(name, ref);
            }
        } else if ((accountId = Account.Id.fromRef(name)) != null) {
            // Account ref is visible only to corresponding account.
            if (viewMetadata || accountId.equals(userId)) {
                result.put(name, ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            result.put(name, ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && (!result.isEmpty() || filterTagsSeparately)) {
        TagMatcher tags = tagCache.get(projectName).matcher(tagCache, db, filterTagsSeparately ? filter(db.getAllRefs()).values() : result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#method_after
public Map<String, Ref> filter(Map<String, Ref> refs, boolean filterTagsSeparately) {
    if (projectCtl.getProjectState().isAllUsers() && projectCtl.getUser().isIdentifiedUser()) {
        Ref userRef = refs.get(RefNames.refsUsers(projectCtl.getUser().getAccountId()));
        if (userRef != null) {
            SymbolicRef refsUsersSelf = new SymbolicRef(RefNames.REFS_USERS_SELF, userRef);
            refs = new HashMap<>(refs);
            refs.put(refsUsersSelf.getName(), refsUsersSelf);
        }
    }
    if (projectCtl.allRefsAreVisible(ImmutableSet.of(RefNames.REFS_CONFIG))) {
        Map<String, Ref> r = Maps.newHashMap(refs);
        if (!projectCtl.controlForRef(RefNames.REFS_CONFIG).isVisible()) {
            r.remove(RefNames.REFS_CONFIG);
        }
        return r;
    }
    Account.Id userId;
    boolean viewMetadata;
    if (projectCtl.getUser().isIdentifiedUser()) {
        IdentifiedUser user = projectCtl.getUser().asIdentifiedUser();
        userId = user.getAccountId();
        viewMetadata = user.getCapabilities().canAccessDatabase();
        userEditPrefix = RefNames.refsEditPrefix(userId);
    } else {
        userId = null;
        viewMetadata = false;
    }
    Map<String, Ref> result = new HashMap<>();
    List<Ref> deferredTags = new ArrayList<>();
    for (Ref ref : refs.values()) {
        String name = ref.getName();
        Change.Id changeId;
        Account.Id accountId;
        if (name.startsWith(REFS_CACHE_AUTOMERGE) || (!showMetadata && isMetadata(name))) {
            continue;
        } else if (RefNames.isRefsEdit(name)) {
            // Edits are visible only to the owning user, if change is visible.
            if (viewMetadata || visibleEdit(name)) {
                result.put(name, ref);
            }
        } else if ((changeId = Change.Id.fromRef(name)) != null) {
            // Change ref is visible only if the change is visible.
            if (viewMetadata || visible(changeId)) {
                result.put(name, ref);
            }
        } else if ((accountId = Account.Id.fromRef(name)) != null) {
            // Account ref is visible only to corresponding account.
            if (viewMetadata || (accountId.equals(userId) && projectCtl.controlForRef(name).isVisible())) {
                result.put(name, ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            result.put(name, ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && (!result.isEmpty() || filterTagsSeparately)) {
        TagMatcher tags = tagCache.get(projectName).matcher(tagCache, db, filterTagsSeparately ? filter(db.getAllRefs()).values() : result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = NoteDbMode.readWrite() ? c.reviewers.get(REVIEWER) : c.reviewers.get(CC);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    sender.clear();
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = NoteDbMode.readWrite() ? c.reviewers.get(REVIEWER) : c.reviewers.get(CC);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    if (input.notify.compareTo(NotifyHandling.NONE) > 0) {
        try {
            ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(changeMessage);
            cm.setNotify(input.notify);
            cm.send();
        } catch (Exception e) {
            log.error("Cannot email update for change " + change.getId(), e);
        }
    }
    try {
        hooks.doCommentAddedHook(change, user.getAccount(), ps, changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    if (input.notify.compareTo(NotifyHandling.NONE) > 0) {
        try {
            ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(changeMessage);
            cm.setNotify(input.notify);
            cm.send();
        } catch (Exception e) {
            log.error("Cannot email update for change " + change.getId(), e);
        }
    }
    try {
        hooks.doCommentAddedHook(change, user.getAccount(), ps, changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook invocation failed", e);
    }
}
#end_block

#method_before
public <T> List<T> getTaskInfos(TaskInfoFactory<T> factory) {
    List<T> taskInfos = Lists.newArrayList();
    for (Executor exe : queues) {
        for (Task<?> task : exe.getTasks()) {
            taskInfos.add(factory.getTaskInfo(task));
        }
    }
    return taskInfos;
}
#method_after
public <T> List<T> getTaskInfos(TaskInfoFactory<T> factory) {
    List<T> taskInfos = new ArrayList<>();
    for (Executor exe : queues) {
        for (Task<?> task : exe.getTasks()) {
            taskInfos.add(factory.getTaskInfo(task));
        }
    }
    return taskInfos;
}
#end_block

#method_before
public Task<?> getTask(final int id) {
    Task<?> result = null;
    for (final Executor e : queues) {
        final Task<?> t = e.getTask(id);
        if (t != null) {
            if (result != null) {
                // Don't return the task if we have a duplicate. Lie instead.
                return null;
            } else {
                result = t;
            }
        }
    }
    return result;
}
#method_after
public Task<?> getTask(final int id) {
    Task<?> result = null;
    for (final Executor e : queues) {
        final Task<?> t = e.getTask(id);
        if (t != null) {
            if (result != null) {
                // Don't return the task if we have a duplicate. Lie instead.
                return null;
            }
            result = t;
        }
    }
    return result;
}
#end_block

#method_before
public State getState() {
    if (isCancelled()) {
        return State.CANCELLED;
    } else if (isDone() && !isPeriodic()) {
        return State.DONE;
    } else if (running.get()) {
        return State.RUNNING;
    }
    final long delay = getDelay(TimeUnit.MILLISECONDS);
    if (delay <= 0) {
        return State.READY;
    } else {
        return State.SLEEPING;
    }
}
#method_after
public State getState() {
    if (isCancelled()) {
        return State.CANCELLED;
    } else if (isDone() && !isPeriodic()) {
        return State.DONE;
    } else if (running.get()) {
        return State.RUNNING;
    }
    final long delay = getDelay(TimeUnit.MILLISECONDS);
    if (delay <= 0) {
        return State.READY;
    }
    return State.SLEEPING;
}
#end_block

#method_before
@Override
public boolean cancel(boolean mayInterruptIfRunning) {
    if (task.cancel(mayInterruptIfRunning)) {
        // 
        if (runnable instanceof CancelableRunnable) {
            if (running.compareAndSet(false, true)) {
                ((CancelableRunnable) runnable).cancel();
            } else if (runnable instanceof CancelledWhileRunning) {
                ((CancelledWhileRunning) runnable).setCancelledWhileRunning();
            }
        }
        executor.remove(this);
        executor.purge();
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean cancel(boolean mayInterruptIfRunning) {
    if (task.cancel(mayInterruptIfRunning)) {
        // 
        if (runnable instanceof CancelableRunnable) {
            if (running.compareAndSet(false, true)) {
                ((CancelableRunnable) runnable).cancel();
            } else if (runnable instanceof CanceledWhileRunning) {
                ((CanceledWhileRunning) runnable).setCanceledWhileRunning();
            }
        }
        executor.remove(this);
        executor.purge();
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    // is wrapped into a ListenableFutureTask.
    if (runnable instanceof ListenableFutureTask<?>) {
        String errorMessage;
        try {
            for (Field field : ListenableFutureTask.class.getSuperclass().getDeclaredFields()) {
                if (field.getType().isAssignableFrom(Callable.class)) {
                    field.setAccessible(true);
                    return ((Callable<?>) field.get(runnable)).toString();
                }
            }
            errorMessage = "Cannot find wrapped Callable field";
        } catch (SecurityException | IllegalArgumentException | IllegalAccessException e) {
            errorMessage = "Cannot call toString on Callable field";
        }
        log.debug("Cannot get a proper name for ListenableFutureTask: {}", errorMessage);
    }
    return runnable.toString();
}
#method_after
@Override
public String toString() {
    // is wrapped into a TrustedListenableFutureTask.
    try {
        if (runnable.getClass().isAssignableFrom(Class.forName("com.google.common.util.concurrent.TrustedListenableFutureTask"))) {
            Class<?> trustedFutureInterruptibleTask = Class.forName("com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask");
            for (Field field : runnable.getClass().getDeclaredFields()) {
                if (field.getType().isAssignableFrom(trustedFutureInterruptibleTask)) {
                    field.setAccessible(true);
                    Object innerObj = field.get(runnable);
                    for (Field innerField : innerObj.getClass().getDeclaredFields()) {
                        if (innerField.getType().isAssignableFrom(Callable.class)) {
                            innerField.setAccessible(true);
                            return ((Callable<?>) innerField.get(innerObj)).toString();
                        }
                    }
                }
            }
        }
    } catch (ClassNotFoundException | IllegalArgumentException | IllegalAccessException e) {
        log.debug("Cannot get a proper name for TrustedListenableFutureTask: {}", e.getMessage());
    }
    return runnable.toString();
}
#end_block

#method_before
@Override
public void cancel() {
    repLog.info("Replication {} was cancelled", getURI());
    cancelledByReplication();
    pool.pushWasCancelled(this);
}
#method_after
@Override
public void cancel() {
    repLog.info("Replication {} was canceled", getURI());
    canceledByReplication();
    pool.pushWasCanceled(this);
}
#end_block

#method_before
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    MDC.put(ID_MDC_KEY, IdGenerator.format(id));
    if (!pool.requestRunway(this)) {
        if (!cancelled) {
            repLog.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    repLog.info("Replication to " + uri + " started...");
    Timer1.Context context = metrics.start(config.getName());
    try {
        long startedAt = context.getStartTime();
        long delay = NANOSECONDS.toMillis(startedAt - createdAt);
        metrics.record(config.getName(), delay, retryCount);
        git = gitManager.openRepository(projectName);
        runImpl();
        long elapsed = NANOSECONDS.toMillis(context.stop());
        repLog.info("Replication to " + uri + " completed in " + (elapsed) + "ms, " + (delay) + "ms delay, " + retryCount + " retries");
    } catch (RepositoryNotFoundException e) {
        stateLog.error("Cannot replicate " + projectName + "; Local repository error: " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        // Tried to replicate to a remote via anonymous git:// but the repository
        // does not exist.  In this case NoRemoteRepositoryException is not
        // raised.
        String msg = e.getMessage();
        if (msg.contains("access denied") || msg.contains("no such repository")) {
            createRepository();
        } else {
            repLog.error("Cannot replicate " + projectName + "; Remote repository error: " + msg);
        }
    } catch (NoRemoteRepositoryException e) {
        createRepository();
    } catch (NotSupportedException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            repLog.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else if (e instanceof LockFailureException) {
            lockRetryCount++;
            // The LockFailureException message contains both URI and reason
            // for this failure.
            repLog.error("Cannot replicate to " + e.getMessage());
            // The remote push operation should be retried.
            if (lockRetryCount <= maxLockRetries) {
                if (canceledWhileRunning.get()) {
                    logCanceledWhileRunningException(e);
                } else {
                    pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
                }
            } else {
                repLog.error("Giving up after " + lockRetryCount + " of this error during replication to " + e.getMessage());
            }
        } else {
            if (canceledWhileRunning.get()) {
                logCanceledWhileRunningException(e);
            } else {
                repLog.error("Cannot replicate to " + uri, e);
                // The remote push operation should be retried.
                pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
            }
        }
    } catch (IOException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException | Error e) {
        stateLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#method_after
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    MDC.put(ID_MDC_KEY, IdGenerator.format(id));
    if (!pool.requestRunway(this)) {
        if (!canceled) {
            repLog.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    repLog.info("Replication to " + uri + " started...");
    Timer1.Context context = metrics.start(config.getName());
    try {
        long startedAt = context.getStartTime();
        long delay = NANOSECONDS.toMillis(startedAt - createdAt);
        metrics.record(config.getName(), delay, retryCount);
        git = gitManager.openRepository(projectName);
        runImpl();
        long elapsed = NANOSECONDS.toMillis(context.stop());
        repLog.info("Replication to " + uri + " completed in " + (elapsed) + "ms, " + (delay) + "ms delay, " + retryCount + " retries");
    } catch (RepositoryNotFoundException e) {
        stateLog.error("Cannot replicate " + projectName + "; Local repository error: " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        // Tried to replicate to a remote via anonymous git:// but the repository
        // does not exist.  In this case NoRemoteRepositoryException is not
        // raised.
        String msg = e.getMessage();
        if (msg.contains("access denied") || msg.contains("no such repository")) {
            createRepository();
        } else {
            repLog.error("Cannot replicate " + projectName + "; Remote repository error: " + msg);
        }
    } catch (NoRemoteRepositoryException e) {
        createRepository();
    } catch (NotSupportedException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            repLog.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else if (e instanceof LockFailureException) {
            lockRetryCount++;
            // The LockFailureException message contains both URI and reason
            // for this failure.
            repLog.error("Cannot replicate to " + e.getMessage());
            // The remote push operation should be retried.
            if (lockRetryCount <= maxLockRetries) {
                if (canceledWhileRunning.get()) {
                    logCanceledWhileRunningException(e);
                } else {
                    pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
                }
            } else {
                repLog.error("Giving up after " + lockRetryCount + " of this error during replication to " + e.getMessage());
            }
        } else {
            if (canceledWhileRunning.get()) {
                logCanceledWhileRunningException(e);
            } else {
                repLog.error("Cannot replicate to " + uri, e);
                // The remote push operation should be retried.
                pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
            }
        }
    } catch (IOException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException | Error e) {
        stateLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#end_block

#method_before
private void logCanceledWhileRunningException(TransportException e) {
    repLog.info("Cannot replicate to " + uri + " it was canceled while running", e);
}
#method_after
private void logCanceledWhileRunningException(TransportException e) {
    repLog.info("Cannot replicate to " + uri + "." + " It was canceled while running", e);
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        try (ReviewDb db = schema.open()) {
            local = new VisibleRefFilter(tagCache, changeCache, git, pc, db, true).filter(local, true);
        } catch (OrmException e) {
            stateLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#method_after
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = new HashMap<>();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        try (ReviewDb db = schema.open()) {
            local = new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, git, pc, db, true).filter(local, true);
        } catch (OrmException e) {
            stateLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#end_block

#method_before
private List<RemoteRefUpdate> doPushAll(Transport tn, Map<String, Ref> local) throws NotSupportedException, TransportException, IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    Map<String, Ref> remote = listRemote(tn);
    for (Ref src : local.values()) {
        if (!canPushRef(src.getName(), noPerms)) {
            continue;
        }
        RefSpec spec = matchSrc(src.getName());
        if (spec != null) {
            Ref dst = remote.get(spec.getDestination());
            if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                // Doesn't exist yet, or isn't the same value, request to push.
                push(cmds, spec, src);
            }
        }
    }
    if (config.isMirror()) {
        for (Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> doPushAll(Transport tn, Map<String, Ref> local) throws NotSupportedException, TransportException, IOException {
    List<RemoteRefUpdate> cmds = new ArrayList<>();
    boolean noPerms = !pool.isReplicatePermissions();
    Map<String, Ref> remote = listRemote(tn);
    for (Ref src : local.values()) {
        if (!canPushRef(src.getName(), noPerms)) {
            continue;
        }
        RefSpec spec = matchSrc(src.getName());
        if (spec != null) {
            Ref dst = remote.get(spec.getDestination());
            if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                // Doesn't exist yet, or isn't the same value, request to push.
                push(cmds, spec, src);
            }
        }
    }
    if (config.isMirror()) {
        for (Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#end_block

#method_before
private List<RemoteRefUpdate> doPushDelta(Map<String, Ref> local) throws IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    for (String src : delta) {
        RefSpec spec = matchSrc(src);
        if (spec != null) {
            // If the ref still exists locally, send it, otherwise delete it.
            Ref srcRef = local.get(src);
            if (srcRef != null && canPushRef(src, noPerms)) {
                push(cmds, spec, srcRef);
            } else if (config.isMirror()) {
                delete(cmds, spec);
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> doPushDelta(Map<String, Ref> local) throws IOException {
    List<RemoteRefUpdate> cmds = new ArrayList<>();
    boolean noPerms = !pool.isReplicatePermissions();
    for (String src : delta) {
        RefSpec spec = matchSrc(src);
        if (spec != null) {
            // If the ref still exists locally, send it, otherwise delete it.
            Ref srcRef = local.get(src);
            // Second try to ensure that the ref is truly not found locally
            if (srcRef == null) {
                srcRef = git.exactRef(src);
            }
            if (srcRef != null && canPushRef(src, noPerms)) {
                push(cmds, spec, srcRef);
            } else if (config.isMirror()) {
                delete(cmds, spec);
            }
        }
    }
    return cmds;
}
#end_block

#method_before
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#method_after
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!shouldReplicate(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#end_block

#method_before
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.cancelledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#method_after
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.canceledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#end_block

#method_before
boolean requestRunway(PushOne op) {
    synchronized (stateLock) {
        if (op.wasCancelled()) {
            return false;
        }
        pending.remove(op.getURI());
        if (inFlight.containsKey(op.getURI())) {
            return false;
        }
        inFlight.put(op.getURI(), op);
    }
    return true;
}
#method_after
boolean requestRunway(PushOne op) {
    synchronized (stateLock) {
        if (op.wasCanceled()) {
            return false;
        }
        pending.remove(op.getURI());
        if (inFlight.containsKey(op.getURI())) {
            return false;
        }
        inFlight.put(op.getURI(), op);
    }
    return true;
}
#end_block

#method_before
PushOne notifyFinished(PushOne op) {
    synchronized (stateLock) {
        return inFlight.remove(op.getURI());
    }
}
#method_after
void notifyFinished(PushOne op) {
    synchronized (stateLock) {
        inFlight.remove(op.getURI());
    }
}
#end_block

#method_before
boolean wouldPushProject(Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    String[] projects = config.getProjects();
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    if (!shouldReplicate(project)) {
        return false;
    }
    // by default push all projects
    List<String> projects = config.getProjects();
    if (projects.isEmpty()) {
        return true;
    }
    return (new ReplicationFilter(projects)).matches(project);
}
#end_block

#method_before
boolean isSingleProjectMatch() {
    String[] projects = config.getProjects();
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#method_after
boolean isSingleProjectMatch() {
    List<String> projects = config.getProjects();
    boolean ret = (projects.size() == 1);
    if (ret) {
        String projectMatch = projects.get(0);
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#end_block

#method_before
String[] getAdminUrls() {
    return config.getAdminUrls();
}
#method_after
ImmutableList<String> getAdminUrls() {
    return config.getAdminUrls();
}
#end_block

#method_before
String[] getUrls() {
    return config.getUrls();
}
#method_after
ImmutableList<String> getUrls() {
    return config.getUrls();
}
#end_block

#method_before
String[] getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#method_after
ImmutableList<String> getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#end_block

#method_before
String[] getProjects() {
    return config.getProjects();
}
#method_after
ImmutableList<String> getProjects() {
    return config.getProjects();
}
#end_block

#method_before
private List<ChangeData> getForOpenChange(Change c, CurrentUser user) throws OrmException, IOException, AuthException {
    ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), c, user);
    if (cs.furtherHiddenChanges()) {
        throw new AuthException("topic includes hidden change");
    }
    return cs.changes().asList();
}
#method_after
private List<ChangeData> getForOpenChange(Change c, CurrentUser user) throws OrmException, IOException, AuthException {
    ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), c, user);
    if (cs.furtherHiddenChanges()) {
        throw new AuthException("change would be submitted with a change that you cannot see");
    }
    return cs.changes().asList();
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is hidden");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<ChangeInfo> submittedTogether() throws RestApiException {
    try {
        return (List<ChangeInfo>) submittedTogether.apply(change);
    } catch (Exception e) {
        throw new RestApiException("Cannot query submittedTogether", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<ChangeInfo> submittedTogether() throws RestApiException {
    try {
        return (List<ChangeInfo>) submittedTogether.apply(change);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot query submittedTogether", e);
    }
}
#end_block

#method_before
private SubmitType submitType(ChangeData cd, boolean visible) throws OrmException {
    // changes that would be submitted together with the visible ones.
    if (visible) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (!str.isOk()) {
            logErrorAndThrow("Failed to get submit type for " + cd.getId() + ": " + str.errorMessage);
        }
        return str.type;
    } else {
        return cd.changeControl().getProject().getSubmitType();
    }
}
#method_after
private SubmitType submitType(ChangeData cd, boolean visible) throws OrmException {
    // would be submitted together with the visible ones.
    if (!visible) {
        return cd.changeControl().getProject().getSubmitType();
    }
    SubmitTypeRecord str = cd.submitTypeRecord();
    if (!str.isOk()) {
        logErrorAndThrow("Failed to get submit type for " + cd.getId() + ": " + str.errorMessage);
    }
    return str.type;
}
#end_block

#method_before
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    List<ChangeData> visibleChanges = new ArrayList<>();
    List<ChangeData> nonVisibleChanges = new ArrayList<>();
    Multimap<Project.NameKey, ChangeData> pc = byProject(Iterables.concat(changes.changes(), changes.nonVisibleChanges()));
    for (Project.NameKey project : pc.keySet()) {
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
            for (ChangeData cd : pc.get(project)) {
                checkState(cd.hasChangeControl(), "completeChangeSet forgot to set changeControl for current user" + " at ChangeData creation time");
                boolean visible = changes.ids().contains(cd.getId());
                if (visible && !cd.changeControl().isVisible(db, cd)) {
                    // We thought the change was visible, but it isn't.
                    // This can happen if the ACL changes during the
                    // completeChangeSet computation, example.
                    visible = false;
                }
                List<ChangeData> dest = visible ? visibleChanges : nonVisibleChanges;
                if (submitType(cd, visible) == SubmitType.CHERRY_PICK) {
                    dest.add(cd);
                    continue;
                }
                // Get the underlying git commit object
                PatchSet ps = cd.currentPatchSet();
                String objIdStr = ps.getRevision().get();
                RevCommit commit = rw.parseCommit(ObjectId.fromString(objIdStr));
                // Collect unmerged ancestors
                Branch.NameKey destBranch = cd.change().getDest();
                repo.getRefDatabase().refresh();
                Ref ref = repo.getRefDatabase().getRef(destBranch.get());
                rw.reset();
                rw.sort(RevSort.TOPO);
                rw.markStart(commit);
                if (ref != null) {
                    RevCommit head = rw.parseCommit(ref.getObjectId());
                    rw.markUninteresting(head);
                }
                List<String> hashes = new ArrayList<>();
                // Always include the input, even if merged. This allows
                // SubmitStrategyOp to correct the situation later, assuming it gets
                // returned by byCommitsOnBranchNotMerged below.
                hashes.add(objIdStr);
                for (RevCommit c : rw) {
                    if (!c.equals(commit)) {
                        hashes.add(c.name());
                    }
                }
                if (!hashes.isEmpty()) {
                    Iterable<ChangeData> destChanges = query().byCommitsOnBranchNotMerged(repo, db, cd.change().getDest(), hashes);
                    for (ChangeData chd : destChanges) {
                        chd.changeControl(user);
                        dest.add(chd);
                    }
                }
            }
        }
    }
    return new ChangeSet(visibleChanges, nonVisibleChanges);
}
#method_after
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    List<ChangeData> visibleChanges = new ArrayList<>();
    List<ChangeData> nonVisibleChanges = new ArrayList<>();
    Multimap<Project.NameKey, ChangeData> pc = byProject(Iterables.concat(changes.changes(), changes.nonVisibleChanges()));
    for (Project.NameKey project : pc.keySet()) {
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
            for (ChangeData cd : pc.get(project)) {
                checkState(cd.hasChangeControl(), "completeChangeSet forgot to set changeControl for current user" + " at ChangeData creation time");
                boolean visible = changes.ids().contains(cd.getId());
                if (visible && !cd.changeControl().isVisible(db, cd)) {
                    // We thought the change was visible, but it isn't.
                    // This can happen if the ACL changes during the
                    // completeChangeSet computation, for example.
                    visible = false;
                }
                List<ChangeData> dest = visible ? visibleChanges : nonVisibleChanges;
                if (submitType(cd, visible) == SubmitType.CHERRY_PICK) {
                    dest.add(cd);
                    continue;
                }
                // Get the underlying git commit object
                PatchSet ps = cd.currentPatchSet();
                String objIdStr = ps.getRevision().get();
                RevCommit commit = rw.parseCommit(ObjectId.fromString(objIdStr));
                // Collect unmerged ancestors
                Branch.NameKey destBranch = cd.change().getDest();
                repo.getRefDatabase().refresh();
                Ref ref = repo.getRefDatabase().getRef(destBranch.get());
                rw.reset();
                rw.sort(RevSort.TOPO);
                rw.markStart(commit);
                if (ref != null) {
                    RevCommit head = rw.parseCommit(ref.getObjectId());
                    rw.markUninteresting(head);
                }
                List<String> hashes = new ArrayList<>();
                // Always include the input, even if merged. This allows
                // SubmitStrategyOp to correct the situation later, assuming it gets
                // returned by byCommitsOnBranchNotMerged below.
                hashes.add(objIdStr);
                for (RevCommit c : rw) {
                    if (!c.equals(commit)) {
                        hashes.add(c.name());
                    }
                }
                if (!hashes.isEmpty()) {
                    Iterable<ChangeData> destChanges = query().byCommitsOnBranchNotMerged(repo, db, cd.change().getDest(), hashes);
                    for (ChangeData chd : destChanges) {
                        chd.changeControl(user);
                        dest.add(chd);
                    }
                }
            }
        }
    }
    return new ChangeSet(visibleChanges, nonVisibleChanges);
}
#end_block

#method_before
private ChangeSet completeChangeSetIncludingTopics(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    Set<String> topicsTraversed = new HashSet<>();
    boolean done = false;
    ChangeSet newCs = completeChangeSetWithoutTopic(db, changes, user);
    while (!done) {
        List<ChangeData> visibleChanges = new ArrayList<>();
        List<ChangeData> nonVisibleChanges = new ArrayList<>();
        done = true;
        for (boolean visible : ImmutableList.of(true, false)) {
            for (ChangeData cd : visible ? newCs.changes() : newCs.nonVisibleChanges()) {
                if (visible) {
                    visibleChanges.add(cd);
                } else {
                    nonVisibleChanges.add(cd);
                }
                String topic = cd.change().getTopic();
                if (Strings.isNullOrEmpty(topic) || topicsTraversed.contains(topic)) {
                    continue;
                }
                for (ChangeData topicCd : query().byTopicOpen(topic)) {
                    topicCd.changeControl(user);
                    if (visible && topicCd.changeControl().isVisible(db, topicCd)) {
                        visibleChanges.add(topicCd);
                    } else {
                        nonVisibleChanges.add(topicCd);
                    }
                }
                done = false;
                topicsTraversed.add(topic);
            }
        }
        changes = new ChangeSet(visibleChanges, nonVisibleChanges);
        newCs = completeChangeSetWithoutTopic(db, changes, user);
    }
    return newCs;
}
#method_after
private ChangeSet completeChangeSetIncludingTopics(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    Set<String> topicsSeen = new HashSet<>();
    Set<String> visibleTopicsSeen = new HashSet<>();
    int oldSeen;
    int seen = 0;
    do {
        oldSeen = seen;
        changes = completeChangeSetWithoutTopic(db, changes, user);
        changes = topicClosure(db, changes, user, topicsSeen, visibleTopicsSeen);
        seen = topicsSeen.size() + visibleTopicsSeen.size();
    } while (seen != oldSeen);
    return changes;
}
#end_block

#method_before
private void initTopicLink(ChangeInfo info) {
    if (info.topic() != null && !info.topic().isEmpty()) {
        text.setText(info.topic());
        text.setTargetHistoryToken(PageLinks.toChangeQuery(PageLinks.op("topic", info.topic()) + "+" + "is:open"));
    }
}
#method_after
private void initTopicLink(ChangeInfo info) {
    if (info.topic() != null && !info.topic().isEmpty()) {
        String topic = info.topic();
        text.setText(topic);
        text.setTargetHistoryToken(PageLinks.topicQuery(info.status(), topic));
    }
}
#end_block

#method_before
private NoteDbChangeState execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    NoteDbChangeState newState = NoteDbChangeState.applyDelta(change, manager.stage().get(changeId));
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (!oldNoteDbState.equals(change.getNoteDbState())) {
                    throw new AbortUpdateException();
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
        manager.execute();
    } catch (AbortUpdateException e) {
    // Drop this rebuild; another thread completed it.
    }
    return newState;
}
#method_after
private NoteDbChangeState execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    NoteDbChangeState newState = NoteDbChangeState.applyDelta(change, manager.stage());
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (!Objects.equals(oldNoteDbState, change.getNoteDbState())) {
                    throw new AbortUpdateException();
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
        manager.execute();
    } catch (AbortUpdateException e) {
    // Drop this rebuild; another thread completed it.
    }
    return newState;
}
#end_block

#method_before
@Override
public NoteDbChangeState rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    Change change = new Change(bundle.getChange());
    buildUpdates(manager, bundle);
    return NoteDbChangeState.applyDelta(change, manager.stage().get(change.getId()));
}
#method_after
@Override
public NoteDbChangeState rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    Change change = new Change(bundle.getChange());
    buildUpdates(manager, bundle);
    return NoteDbChangeState.applyDelta(change, manager.stage());
}
#end_block

#method_before
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, false)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        // which would be bad.
        switch(wr.type) {
            case SYMLINK:
            case REGULAR_FILE:
            case EXECUTABLE_FILE:
                writeBlobText(req, res, wr);
                break;
            case TREE:
                writeTreeText(req, res, wr);
                break;
            case GITLINK:
            default:
                renderTextError(req, res, SC_NOT_FOUND, "Not a file");
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, false)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        // which would be bad.
        switch(wr.type) {
            case SYMLINK:
            case REGULAR_FILE:
            case EXECUTABLE_FILE:
                writeBlobText(req, res, wr);
                break;
            case TREE:
                writeTreeText(req, res, wr);
                break;
            default:
                renderTextError(req, res, SC_NOT_FOUND, "Not a file");
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    String recursiveStr = req.getParameter("recursive");
    boolean recursive = (recursiveStr != null) && (recursiveStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(recursiveStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, recursive)) {
        if (wr == null || wr.type != FileType.TREE) {
            res.setStatus(SC_NOT_FOUND);
        }
        renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class);
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    String recursiveStr = req.getParameter("recursive");
    boolean recursive = (recursiveStr != null) && (recursiveStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(recursiveStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, recursive)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        switch(wr.type) {
            case TREE:
                renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class);
                break;
            default:
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
private static WalkResult forPath(RevWalk rw, GitilesView view, boolean recursive) throws IOException {
    if (recursive) {
        return recursivePath(rw, view);
    }
    RevTree root = getRoot(view, rw);
    String path = view.getPathPart();
    try (TreeWalk tw = new TreeWalk(rw.getObjectReader())) {
        tw.addTree(root);
        tw.setRecursive(false);
        if (path.isEmpty()) {
            return new WalkResult(tw, path, root, root, FileType.TREE, ImmutableList.<Boolean>of());
        }
        AutoDiveFilter f = new AutoDiveFilter(path);
        tw.setFilter(f);
        while (tw.next()) {
            if (f.isDone(tw)) {
                FileType type = FileType.forEntry(tw);
                ObjectId id = tw.getObjectId(0);
                if (type == FileType.TREE) {
                    tw.enterSubtree();
                    tw.setRecursive(false);
                }
                return new WalkResult(tw, path, root, id, type, f.hasSingleTree);
            } else if (tw.isSubtree()) {
                tw.enterSubtree();
            }
        }
    } catch (IOException | RuntimeException e) {
    // Fallthrough.
    }
    return null;
}
#method_after
private static WalkResult forPath(RevWalk rw, GitilesView view, boolean recursive) throws IOException {
    if (recursive) {
        return recursivePath(rw, view);
    }
    RevTree root = getRoot(view, rw);
    String path = view.getPathPart();
    TreeWalk tw = new TreeWalk(rw.getObjectReader());
    try {
        tw.addTree(root);
        tw.setRecursive(false);
        if (path.isEmpty()) {
            return new WalkResult(tw, path, root, root, FileType.TREE, ImmutableList.<Boolean>of());
        }
        AutoDiveFilter f = new AutoDiveFilter(path);
        tw.setFilter(f);
        while (tw.next()) {
            if (f.isDone(tw)) {
                FileType type = FileType.forEntry(tw);
                ObjectId id = tw.getObjectId(0);
                if (type == FileType.TREE) {
                    tw.enterSubtree();
                    tw.setRecursive(false);
                }
                return new WalkResult(tw, path, root, id, type, f.hasSingleTree);
            } else if (tw.isSubtree()) {
                tw.enterSubtree();
            }
        }
    } catch (IOException | RuntimeException e) {
    // Fallthrough.
    }
    tw.close();
    return null;
}
#end_block

#method_before
public Builder setRepositoryPrefix(String prefix) {
    switch(type) {
        case HOST_INDEX:
            this.repositoryPrefix = prefix != null ? Strings.emptyToNull(maybeTrimLeadingAndTrailingSlash(prefix)) : null;
            return this;
        case ARCHIVE:
        case BLAME:
        case DESCRIBE:
        case DIFF:
        case DOC:
        case LOG:
        case PATH:
        case REFS:
        case REPOSITORY_INDEX:
        case REVISION:
        case ROOTED_DOC:
        case SHOW:
        default:
            throw new IllegalStateException(String.format("cannot set repository prefix on %s view", type));
    }
}
#method_after
public Builder setRepositoryPrefix(String prefix) {
    switch(type) {
        case HOST_INDEX:
            this.repositoryPrefix = prefix != null ? Strings.emptyToNull(maybeTrimLeadingAndTrailingSlash(prefix)) : null;
            return this;
        default:
            throw new IllegalStateException(String.format("cannot set repository prefix on %s view", type));
    }
}
#end_block

#method_before
public Builder setRepositoryName(String repositoryName) {
    if (type == Type.HOST_INDEX) {
        throw new IllegalStateException(String.format("cannot set repository name on %s view", type));
    }
    this.repositoryName = checkNotNull(repositoryName);
    return this;
}
#method_after
public Builder setRepositoryName(String repositoryName) {
    switch(type) {
        case HOST_INDEX:
            throw new IllegalStateException(String.format("cannot set repository name on %s view", type));
        default:
            this.repositoryName = checkNotNull(repositoryName);
            return this;
    }
}
#end_block

#method_before
public Builder setRevision(Revision revision) {
    switch(type) {
        case HOST_INDEX:
        case REPOSITORY_INDEX:
        case REFS:
        case DESCRIBE:
            throw new IllegalStateException(String.format("cannot set revision on %s view", type));
        case ARCHIVE:
        case BLAME:
        case DIFF:
        case DOC:
        case LOG:
        case PATH:
        case REVISION:
        case ROOTED_DOC:
        case SHOW:
        default:
            this.revision = checkNotNull(revision);
            return this;
    }
}
#method_after
public Builder setRevision(Revision revision) {
    switch(type) {
        case HOST_INDEX:
        case REPOSITORY_INDEX:
        case REFS:
        case DESCRIBE:
            throw new IllegalStateException(String.format("cannot set revision on %s view", type));
        default:
            this.revision = checkNotNull(revision);
            return this;
    }
}
#end_block

#method_before
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            break;
        case ARCHIVE:
        case BLAME:
        case DESCRIBE:
        case DOC:
        case HOST_INDEX:
        case PATH:
        case REFS:
        case REPOSITORY_INDEX:
        case REVISION:
        case ROOTED_DOC:
        case SHOW:
        default:
            revision = firstNonNull(revision, Revision.NULL);
            checkState(revision == Revision.NULL, "cannot set old revision on %s view", type);
            break;
    }
    this.oldRevision = revision;
    return this;
}
#method_after
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            break;
        default:
            revision = firstNonNull(revision, Revision.NULL);
            checkState(revision == Revision.NULL, "cannot set old revision on %s view", type);
            break;
    }
    this.oldRevision = revision;
    return this;
}
#end_block

#method_before
public Builder setPathPart(String path) {
    switch(type) {
        case PATH:
        case DIFF:
        case SHOW:
            checkState(path != null, "cannot set null path on %s view", type);
            break;
        case BLAME:
        case ARCHIVE:
        case DESCRIBE:
        case REFS:
        case LOG:
        case DOC:
        case ROOTED_DOC:
            break;
        case HOST_INDEX:
        case REPOSITORY_INDEX:
        case REVISION:
        default:
            checkState(path == null, "cannot set path on %s view", type);
            break;
    }
    this.path = path != null ? maybeTrimLeadingAndTrailingSlash(path) : null;
    return this;
}
#method_after
public Builder setPathPart(String path) {
    switch(type) {
        case PATH:
        case DIFF:
        case SHOW:
            checkState(path != null, "cannot set null path on %s view", type);
            break;
        case BLAME:
        case ARCHIVE:
        case DESCRIBE:
        case REFS:
        case LOG:
        case DOC:
        case ROOTED_DOC:
            break;
        default:
            checkState(path == null, "cannot set path on %s view", type);
            break;
    }
    this.path = path != null ? maybeTrimLeadingAndTrailingSlash(path) : null;
    return this;
}
#end_block

#method_before
public Builder setExtension(String extension) {
    if (type != Type.ARCHIVE) {
        checkState(extension == null, "cannot set extension on %s view", type);
    }
    this.extension = extension;
    return this;
}
#method_after
public Builder setExtension(String extension) {
    switch(type) {
        default:
            checkState(extension == null, "cannot set extension on %s view", type);
        // $FALL-THROUGH$
        case ARCHIVE:
            this.extension = extension;
            break;
    }
    return this;
}
#end_block

#method_before
public String getRevisionRange() {
    if (oldRevision == Revision.NULL) {
        switch(type) {
            case LOG:
            case DIFF:
                // tree/commit.
                return revision.getName() + "^!";
            case ARCHIVE:
            case BLAME:
            case DESCRIBE:
            case DOC:
            case HOST_INDEX:
            case PATH:
            case REFS:
            case REPOSITORY_INDEX:
            case REVISION:
            case ROOTED_DOC:
            case SHOW:
            default:
                // revision.
                return null;
        }
    } else if (type == Type.DIFF && isFirstParent(revision, oldRevision)) {
        return revision.getName() + "^!";
    } else {
        return oldRevision.getName() + ".." + revision.getName();
    }
}
#method_after
public String getRevisionRange() {
    if (oldRevision == Revision.NULL) {
        switch(type) {
            case LOG:
            case DIFF:
                // tree/commit.
                return revision.getName() + "^!";
            default:
                // revision.
                return null;
        }
    } else if (type == Type.DIFF && isFirstParent(revision, oldRevision)) {
        return revision.getName() + "^!";
    } else {
        return oldRevision.getName() + ".." + revision.getName();
    }
}
#end_block

#method_before
private Builder copyWithPath(boolean isLeaf) {
    Builder copy;
    switch(type) {
        case DIFF:
            copy = diff();
            break;
        case LOG:
            copy = log();
            break;
        case BLAME:
            copy = isLeaf ? blame() : path();
            break;
        case ARCHIVE:
        case DESCRIBE:
        case DOC:
        case HOST_INDEX:
        case PATH:
        case REFS:
        case REPOSITORY_INDEX:
        case REVISION:
        case ROOTED_DOC:
        case SHOW:
        default:
            copy = path();
            break;
    }
    return copy.copyFrom(this);
}
#method_after
private Builder copyWithPath(boolean isLeaf) {
    Builder copy;
    switch(type) {
        case DIFF:
            copy = diff();
            break;
        case LOG:
            copy = log();
            break;
        case BLAME:
            copy = isLeaf ? blame() : path();
            break;
        default:
            copy = path();
            break;
    }
    return copy.copyFrom(this);
}
#end_block

#method_before
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    String prefix = ViewFilter.getView(req).getRepositoryPrefix();
    Set<String> branches = parseShowBranch(req);
    Map<String, RepositoryDescription> descs = list(req, res, prefix, branches);
    if (descs == null) {
        return;
    }
    try (Writer writer = startRenderText(req, res)) {
        for (RepositoryDescription repo : descs.values()) {
            for (String name : branches) {
                String ref = repo.branches.get(name);
                if (ref == null) {
                    // Print stub (forty '-' symbols)
                    ref = "----------------------------------------";
                }
                writer.write(ref);
                writer.write(' ');
            }
            writer.write(GitilesUrls.NAME_ESCAPER.apply(stripPrefix(prefix, repo.name)));
            writer.write('\n');
        }
    }
}
#method_after
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    String prefix = ViewFilter.getView(req).getRepositoryPrefix();
    Set<String> branches = parseShowBranch(req);
    Map<String, RepositoryDescription> descs = list(req, res, prefix, branches);
    if (descs == null) {
        return;
    }
    Writer writer = startRenderText(req, res);
    for (RepositoryDescription repo : descs.values()) {
        for (String name : branches) {
            String ref = repo.branches.get(name);
            if (ref == null) {
                // Print stub (forty '-' symbols)
                ref = "----------------------------------------";
            }
            writer.write(ref);
            writer.write(' ');
        }
        writer.write(GitilesUrls.NAME_ESCAPER.apply(stripPrefix(prefix, repo.name)));
        writer.write('\n');
    }
    writer.flush();
    writer.close();
}
#end_block

#method_before
public Builder setRepositoryPrefix(String prefix) {
    switch(type) {
        case HOST_INDEX:
            this.repositoryPrefix = prefix != null ? Strings.emptyToNull(maybeTrimLeadingAndTrailingSlash(prefix)) : null;
            return this;
        case ARCHIVE:
        case BLAME:
        case DESCRIBE:
        case DIFF:
        case DOC:
        case LOG:
        case PATH:
        case REFS:
        case REPOSITORY_INDEX:
        case REVISION:
        case ROOTED_DOC:
        case SHOW:
        default:
            throw new IllegalStateException(String.format("cannot set repository prefix on %s view", type));
    }
}
#method_after
public Builder setRepositoryPrefix(String prefix) {
    if (type == Type.HOST_INDEX) {
        this.repositoryPrefix = prefix != null ? Strings.emptyToNull(maybeTrimLeadingAndTrailingSlash(prefix)) : null;
        return this;
    }
    throw new IllegalStateException(String.format("cannot set repository prefix on %s view", type));
}
#end_block

#method_before
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            break;
        case ARCHIVE:
        case BLAME:
        case DESCRIBE:
        case DOC:
        case HOST_INDEX:
        case PATH:
        case REFS:
        case REPOSITORY_INDEX:
        case REVISION:
        case ROOTED_DOC:
        case SHOW:
        default:
            revision = firstNonNull(revision, Revision.NULL);
            checkState(revision == Revision.NULL, "cannot set old revision on %s view", type);
            break;
    }
    this.oldRevision = revision;
    return this;
}
#method_after
public Builder setOldRevision(Revision revision) {
    if (type != Type.DIFF && type != Type.LOG) {
        revision = firstNonNull(revision, Revision.NULL);
        checkState(revision == Revision.NULL, "cannot set old revision on %s view", type);
    }
    this.oldRevision = revision;
    return this;
}
#end_block

#method_before
public String getRevisionRange() {
    if (oldRevision == Revision.NULL) {
        switch(type) {
            case LOG:
            case DIFF:
                // tree/commit.
                return revision.getName() + "^!";
            case ARCHIVE:
            case BLAME:
            case DESCRIBE:
            case DOC:
            case HOST_INDEX:
            case PATH:
            case REFS:
            case REPOSITORY_INDEX:
            case REVISION:
            case ROOTED_DOC:
            case SHOW:
            default:
                // revision.
                return null;
        }
    } else if (type == Type.DIFF && isFirstParent(revision, oldRevision)) {
        return revision.getName() + "^!";
    } else {
        return oldRevision.getName() + ".." + revision.getName();
    }
}
#method_after
public String getRevisionRange() {
    if (oldRevision == Revision.NULL) {
        if (type == Type.LOG || type == Type.DIFF) {
            // tree/commit.
            return revision.getName() + "^!";
        }
        // revision.
        return null;
    } else if (type == Type.DIFF && isFirstParent(revision, oldRevision)) {
        return revision.getName() + "^!";
    } else {
        return oldRevision.getName() + ".." + revision.getName();
    }
}
#end_block

#method_before
public Map<String, Object> toSoyData(ObjectId treeId, TreeWalk tw) throws MissingObjectException, IOException {
    ReadmeHelper readme = new ReadmeHelper(reader, view, MarkdownConfig.get(cfg), rootTree, requestUri);
    List<Object> entries = Lists.newArrayList();
    GitilesView.Builder urlBuilder = GitilesView.path().copyFrom(view);
    while (tw.next()) {
        FileType type = FileType.forEntry(tw);
        String name = tw.getNameString();
        switch(view.getType()) {
            case PATH:
                urlBuilder.setPathPart(view.getPathPart() + "/" + name);
                break;
            case REVISION:
                // Got here from a tag pointing at a tree.
                urlBuilder.setPathPart(name);
                break;
            case ARCHIVE:
            case BLAME:
            case DESCRIBE:
            case DIFF:
            case DOC:
            case HOST_INDEX:
            case LOG:
            case REFS:
            case REPOSITORY_INDEX:
            case ROOTED_DOC:
            case SHOW:
            default:
                throw new IllegalStateException(String.format("Cannot render TreeSoyData from %s view", view.getType()));
        }
        String url = urlBuilder.toUrl();
        if (type == FileType.TREE) {
            name += "/";
            url += "/";
        }
        Map<String, String> entry = Maps.newHashMapWithExpectedSize(4);
        entry.put("type", type.toString());
        entry.put("name", name);
        entry.put("url", url);
        if (type == FileType.SYMLINK) {
            String target = new String(reader.open(tw.getObjectId(0)).getCachedBytes(), UTF_8);
            entry.put("targetName", getTargetDisplayName(target));
            String targetUrl = resolveTargetUrl(view, target);
            if (targetUrl != null) {
                entry.put("targetUrl", targetUrl);
            }
        } else {
            readme.considerEntry(tw);
        }
        entries.add(entry);
    }
    Map<String, Object> data = Maps.newHashMapWithExpectedSize(3);
    data.put("sha", treeId.name());
    data.put("entries", entries);
    if (view.getType() == GitilesView.Type.PATH && view.getRevision().getPeeledType() == OBJ_COMMIT) {
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("archiveUrl", GitilesView.archive().copyFrom(view).setPathPart(Strings.emptyToNull(view.getPathPart())).setExtension(archiveFormat.getDefaultSuffix()).toUrl());
        data.put("archiveType", archiveFormat.getShortName());
    }
    if (readme.isPresent()) {
        data.put("readmePath", readme.getPath());
        data.put("readmeHtml", readme.render());
    }
    return data;
}
#method_after
public Map<String, Object> toSoyData(ObjectId treeId, TreeWalk tw) throws MissingObjectException, IOException {
    ReadmeHelper readme = new ReadmeHelper(reader, view, MarkdownConfig.get(cfg), rootTree, requestUri);
    List<Object> entries = Lists.newArrayList();
    GitilesView.Builder urlBuilder = GitilesView.path().copyFrom(view);
    while (tw.next()) {
        FileType type = FileType.forEntry(tw);
        String name = tw.getNameString();
        GitilesView.Type viewType = view.getType();
        if (viewType == GitilesView.Type.PATH) {
            urlBuilder.setPathPart(view.getPathPart() + "/" + name);
        } else if (viewType == GitilesView.Type.REVISION) {
            // Got here from a tag pointing at a tree.
            urlBuilder.setPathPart(name);
        } else {
            throw new IllegalStateException(String.format("Cannot render TreeSoyData from %s view", viewType));
        }
        String url = urlBuilder.toUrl();
        if (type == FileType.TREE) {
            name += "/";
            url += "/";
        }
        Map<String, String> entry = Maps.newHashMapWithExpectedSize(4);
        entry.put("type", type.toString());
        entry.put("name", name);
        entry.put("url", url);
        if (type == FileType.SYMLINK) {
            String target = new String(reader.open(tw.getObjectId(0)).getCachedBytes(), UTF_8);
            entry.put("targetName", getTargetDisplayName(target));
            String targetUrl = resolveTargetUrl(view, target);
            if (targetUrl != null) {
                entry.put("targetUrl", targetUrl);
            }
        } else {
            readme.considerEntry(tw);
        }
        entries.add(entry);
    }
    Map<String, Object> data = Maps.newHashMapWithExpectedSize(3);
    data.put("sha", treeId.name());
    data.put("entries", entries);
    if (view.getType() == GitilesView.Type.PATH && view.getRevision().getPeeledType() == OBJ_COMMIT) {
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("archiveUrl", GitilesView.archive().copyFrom(view).setPathPart(Strings.emptyToNull(view.getPathPart())).setExtension(archiveFormat.getDefaultSuffix()).toUrl());
        data.put("archiveType", archiveFormat.getShortName());
    }
    if (readme.isPresent()) {
        data.put("readmePath", readme.getPath());
        data.put("readmeHtml", readme.render());
    }
    return data;
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    String recursiveStr = req.getParameter("recursive");
    boolean recursive = (recursiveStr != null) && (recursiveStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(recursiveStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, recursive)) {
        if (wr == null || wr.type != FileType.TREE) {
            res.setStatus(SC_NOT_FOUND);
        }
        renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class);
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    String recursiveStr = req.getParameter("recursive");
    boolean recursive = (recursiveStr != null) && (recursiveStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(recursiveStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, recursive)) {
        if (wr == null || wr.type != FileType.TREE) {
            res.setStatus(SC_NOT_FOUND);
        } else {
            renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class);
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
private static WalkResult forPath(RevWalk rw, GitilesView view, boolean recursive) throws IOException {
    if (recursive) {
        return recursivePath(rw, view);
    }
    RevTree root = getRoot(view, rw);
    String path = view.getPathPart();
    try (TreeWalk tw = new TreeWalk(rw.getObjectReader())) {
        tw.addTree(root);
        tw.setRecursive(false);
        if (path.isEmpty()) {
            return new WalkResult(tw, path, root, root, FileType.TREE, ImmutableList.<Boolean>of());
        }
        AutoDiveFilter f = new AutoDiveFilter(path);
        tw.setFilter(f);
        while (tw.next()) {
            if (f.isDone(tw)) {
                FileType type = FileType.forEntry(tw);
                ObjectId id = tw.getObjectId(0);
                if (type == FileType.TREE) {
                    tw.enterSubtree();
                    tw.setRecursive(false);
                }
                return new WalkResult(tw, path, root, id, type, f.hasSingleTree);
            } else if (tw.isSubtree()) {
                tw.enterSubtree();
            }
        }
    } catch (IOException | RuntimeException e) {
    // Fallthrough.
    }
    return null;
}
#method_after
private static WalkResult forPath(RevWalk rw, GitilesView view, boolean recursive) throws IOException {
    if (recursive) {
        return recursivePath(rw, view);
    }
    RevTree root = getRoot(view, rw);
    String path = view.getPathPart();
    TreeWalk tw = new TreeWalk(rw.getObjectReader());
    try {
        tw.addTree(root);
        tw.setRecursive(false);
        if (path.isEmpty()) {
            return new WalkResult(tw, path, root, root, FileType.TREE, ImmutableList.<Boolean>of());
        }
        AutoDiveFilter f = new AutoDiveFilter(path);
        tw.setFilter(f);
        while (tw.next()) {
            if (f.isDone(tw)) {
                FileType type = FileType.forEntry(tw);
                ObjectId id = tw.getObjectId(0);
                if (type == FileType.TREE) {
                    tw.enterSubtree();
                    tw.setRecursive(false);
                }
                return new WalkResult(tw, path, root, id, type, f.hasSingleTree);
            } else if (tw.isSubtree()) {
                tw.enterSubtree();
            }
        }
    } catch (IOException | RuntimeException e) {
    // Fallthrough.
    }
    tw.close();
    return null;
}
#end_block

#method_before
@Override
protected void doHead(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Optional<FormatType> format = getFormat(req);
    if (!format.isPresent()) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    String prefix = view.getRepositoryPrefix();
    if (prefix != null) {
        Map<String, RepositoryDescription> descs = list(req, res, prefix, Collections.<String>emptySet());
        if (descs == null) {
            return;
        }
    }
    switch(format.get()) {
        case HTML:
        case JSON:
        case TEXT:
            res.setStatus(HttpServletResponse.SC_OK);
            res.setContentType(format.get().getMimeType());
            break;
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#method_after
@Override
protected void doHead(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Optional<FormatType> format = getFormat(req);
    if (!format.isPresent()) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    String prefix = view.getRepositoryPrefix();
    if (prefix != null) {
        Map<String, RepositoryDescription> descs = list(req, res, prefix, Collections.<String>emptySet());
        if (descs == null) {
            return;
        }
    }
    switch(format.get()) {
        case HTML:
        case JSON:
        case TEXT:
            res.setStatus(HttpServletResponse.SC_OK);
            res.setContentType(format.get().getMimeType());
            break;
        case DEFAULT:
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#end_block

#method_before
private static RevWalk newWalk(Repository repo, GitilesView view, GitilesAccess access) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    setTreeFilter(walk, view, access);
    List<RevFilter> filters = new ArrayList<>(3);
    if (isTrue(Iterables.getFirst(view.getParameters().get("no-merges"), null))) {
        filters.add(RevFilter.NO_MERGES);
    }
    String author = Iterables.getFirst(view.getParameters().get("author"), null);
    if (author != null) {
        filters.add(IdentRevFilter.author(author));
    }
    String committer = Iterables.getFirst(view.getParameters().get("committer"), null);
    if (committer != null) {
        filters.add(IdentRevFilter.committer(committer));
    }
    if (filters.size() > 1) {
        walk.setRevFilter(AndRevFilter.create(filters));
    } else if (filters.size() == 1) {
        walk.setRevFilter(filters.get(0));
    }
    return walk;
}
#method_after
private static RevWalk newWalk(Repository repo, GitilesView view, GitilesAccess access) throws MissingObjectException, IOException {
    RevWalk walk = new RevWalk(repo);
    try {
        walk.markStart(walk.parseCommit(view.getRevision().getId()));
        if (view.getOldRevision() != Revision.NULL) {
            walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
        }
    } catch (IncorrectObjectTypeException iote) {
        return null;
    }
    setTreeFilter(walk, view, access);
    List<RevFilter> filters = new ArrayList<>(3);
    if (isTrue(Iterables.getFirst(view.getParameters().get("no-merges"), null))) {
        filters.add(RevFilter.NO_MERGES);
    }
    String author = Iterables.getFirst(view.getParameters().get("author"), null);
    if (author != null) {
        filters.add(IdentRevFilter.author(author));
    }
    String committer = Iterables.getFirst(view.getParameters().get("committer"), null);
    if (committer != null) {
        filters.add(IdentRevFilter.committer(committer));
    }
    if (filters.size() > 1) {
        walk.setRevFilter(AndRevFilter.create(filters));
    } else if (filters.size() == 1) {
        walk.setRevFilter(filters.get(0));
    }
    return walk;
}
#end_block

#method_before
private static Paginator newPaginator(Repository repo, GitilesView view, GitilesAccess access) throws IOException {
    if (view == null) {
        return null;
    }
    try (RevWalk walk = newWalk(repo, view, access)) {
        Optional<ObjectId> start;
        try {
            start = getStart(view.getParameters(), walk.getObjectReader());
        } catch (IOException e) {
            throw e;
        }
        if (start == null) {
            return null;
        }
        return new Paginator(walk, getLimit(view), start.orNull());
    } catch (IncorrectObjectTypeException e) {
        return null;
    }
}
#method_after
private static Paginator newPaginator(Repository repo, GitilesView view, GitilesAccess access) throws IOException {
    if (view == null) {
        return null;
    }
    try (RevWalk walk = newWalk(repo, view, access)) {
        if (walk == null) {
            return null;
        }
        Optional<ObjectId> start = getStart(view.getParameters(), walk.getObjectReader());
        if (start == null) {
            return null;
        }
        return new Paginator(walk, getLimit(view), start.orNull());
    }
}
#end_block

#method_before
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, false)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        // which would be bad.
        switch(wr.type) {
            case SYMLINK:
            case REGULAR_FILE:
            case EXECUTABLE_FILE:
                writeBlobText(req, res, wr);
                break;
            case TREE:
                writeTreeText(req, res, wr);
                break;
            default:
                renderTextError(req, res, SC_NOT_FOUND, "Not a file");
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, false)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        // which would be bad.
        switch(wr.type) {
            case SYMLINK:
            case REGULAR_FILE:
            case EXECUTABLE_FILE:
                writeBlobText(req, res, wr);
                break;
            case TREE:
                writeTreeText(req, res, wr);
                break;
            case GITLINK:
            default:
                renderTextError(req, res, SC_NOT_FOUND, "Not a file");
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    String recursiveStr = req.getParameter("recursive");
    boolean recursive = (recursiveStr != null) && (recursiveStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(recursiveStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, recursive)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        switch(wr.type) {
            case TREE:
                renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class);
                break;
            default:
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    String recursiveStr = req.getParameter("recursive");
    boolean recursive = (recursiveStr != null) && (recursiveStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(recursiveStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, recursive)) {
        if (wr == null || wr.type != FileType.TREE) {
            res.setStatus(SC_NOT_FOUND);
        } else {
            renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class);
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change = createChange("Change 1", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    // Change 2 is a fast-forward, no need to merge.
    submit(change2.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteLog().get(0);
    assertThat(headAfterFirstSubmit.getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertPersonEquals(admin.getIdent(), headAfterFirstSubmit.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), headAfterFirstSubmit.getCommitterIdent());
    // We need to merge changes 3 and 4.
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    RevCommit headAfterSecondSubmit = getRemoteLog().get(0);
    assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent());
    // First change stays untouched.
    assertNew(change.getChangeId());
    // The two submit operations should have resulted in two ref-update events
    // and three change-merged events.
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit, headAfterFirstSubmit, headAfterSecondSubmit);
    assertChangeMergedEvents(change2.getChangeId(), headAfterFirstSubmit.name(), change3.getChangeId(), headAfterSecondSubmit.name(), change4.getChangeId(), headAfterSecondSubmit.name());
}
#method_after
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change = createChange("Change 1", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    PushOneCommit.Result change4 = createChange("Change 4", "e", "e");
    PushOneCommit.Result change5 = createChange("Change 5", "f", "f");
    // Change 2 is a fast-forward, no need to merge.
    submit(change2.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteLog().get(0);
    assertThat(headAfterFirstSubmit.getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertPersonEquals(admin.getIdent(), headAfterFirstSubmit.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), headAfterFirstSubmit.getCommitterIdent());
    // We need to merge changes 3, 4 and 5.
    approve(change3.getChangeId());
    approve(change4.getChangeId());
    submit(change5.getChangeId());
    RevCommit headAfterSecondSubmit = getRemoteLog().get(0);
    assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change5.getCommit().getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent());
    // First change stays untouched.
    assertNew(change.getChangeId());
    // The two submit operations should have resulted in two ref-update events
    // and three change-merged events.
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit, headAfterFirstSubmit, headAfterSecondSubmit);
    assertChangeMergedEvents(change2.getChangeId(), headAfterFirstSubmit.name(), change3.getChangeId(), headAfterSecondSubmit.name(), change4.getChangeId(), headAfterSecondSubmit.name(), change5.getChangeId(), headAfterSecondSubmit.name());
}
#end_block

#method_before
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    // Submit a change so that the remote head advances
    PushOneCommit.Result change = createChange("Change 1", "b", "b");
    submit(change.getChangeId());
    // The remote head should now be a merge of the previous head
    // and "Change 1"
    RevCommit headAfterFirstSubmit = getRemoteLog().get(0);
    assertThat(headAfterFirstSubmit.getParent(1).getShortMessage()).isEqualTo(change.getCommit().getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId());
    // Submit two changes at the same time
    PushOneCommit.Result change2 = createChange("Change 2", "c", "c");
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    approve(change2.getChangeId());
    submit(change3.getChangeId());
    // Submitting change 3 should result in change 2 also being submitted
    assertMerged(change2.getChangeId());
    // The remote head should now be a merge of the new head after
    // the previous submit, and "Change 3".
    RevCommit headAfterSecondSubmit = getRemoteLog().get(0);
    assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(headAfterFirstSubmit.getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getId()).isEqualTo(headAfterFirstSubmit.getId());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent());
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit, headAfterFirstSubmit, headAfterSecondSubmit);
    assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name(), change2.getChangeId(), headAfterSecondSubmit.name(), change3.getChangeId(), headAfterSecondSubmit.name());
}
#method_after
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    // Submit a change so that the remote head advances
    PushOneCommit.Result change = createChange("Change 1", "b", "b");
    submit(change.getChangeId());
    // The remote head should now be a merge of the previous head
    // and "Change 1"
    RevCommit headAfterFirstSubmit = getRemoteLog().get(0);
    assertThat(headAfterFirstSubmit.getParent(1).getShortMessage()).isEqualTo(change.getCommit().getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId());
    // Submit three changes at the same time
    PushOneCommit.Result change2 = createChange("Change 2", "c", "c");
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    PushOneCommit.Result change4 = createChange("Change 4", "e", "e");
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    // Submitting change 4 should result in changes 2 and 3 also being submitted
    assertMerged(change2.getChangeId());
    assertMerged(change3.getChangeId());
    // The remote head should now be a merge of the new head after
    // the previous submit, and "Change 4".
    RevCommit headAfterSecondSubmit = getRemoteLog().get(0);
    assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(headAfterFirstSubmit.getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getId()).isEqualTo(headAfterFirstSubmit.getId());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent());
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit, headAfterFirstSubmit, headAfterSecondSubmit);
    assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name(), change2.getChangeId(), headAfterSecondSubmit.name(), change3.getChangeId(), headAfterSecondSubmit.name(), change4.getChangeId(), headAfterSecondSubmit.name());
}
#end_block

#method_before
private List<ChangeNotes> scanNoteDb(Repository repo, ReviewDb db, Project.NameKey project) throws OrmException, IOException {
    Set<Change.Id> ids = scan(repo);
    List<ChangeNotes> changeNotes = new ArrayList<>(ids.size());
    db = unwrap(db);
    for (Change.Id id : ids) {
        Change change = db.changes().get(id);
        if (change == null) {
            log.warn("skipping change {} found in project {} but not in ReviewDb", id.get(), project.get());
            continue;
        } else if (!change.getProject().equals(project)) {
            log.error("skipping change {} found in project {} because ReviewDb change has project {}", id, project, change.getProject());
            continue;
        }
        changeNotes.add(new ChangeNotes(args, change).load());
    }
    return changeNotes;
}
#method_after
private List<ChangeNotes> scanNoteDb(Repository repo, ReviewDb db, Project.NameKey project) throws OrmException, IOException {
    Set<Change.Id> ids = scan(repo);
    List<ChangeNotes> changeNotes = new ArrayList<>(ids.size());
    db = unwrap(db);
    for (Change.Id id : ids) {
        Change change = db.changes().get(id);
        if (change == null) {
            log.warn("skipping change {} found in project {} " + "but not in ReviewDb", id, project);
            continue;
        } else if (!change.getProject().equals(project)) {
            log.error("skipping change {} found in project {} " + "because ReviewDb change has project {}", id, project, change.getProject());
            continue;
        }
        log.debug("adding change {} found in project {}", id, project);
        changeNotes.add(new ChangeNotes(args, change).load());
    }
    return changeNotes;
}
#end_block

#method_before
@Override
public void close() {
    MoreExecutors.shutdownAndAwaitTermination(executor, Long.MAX_VALUE, TimeUnit.SECONDS);
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void close() {
    MoreExecutors.shutdownAndAwaitTermination(executor, Long.MAX_VALUE, TimeUnit.SECONDS);
    try {
        openIndex.close();
    } finally {
        closedIndex.close();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watched.projects").to(GetWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects").to(PostWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects:delete").to(DeleteWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#end_block

#method_before
public void setMessageSender(final MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#method_after
public void setMessageSender(MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName()) || MagicBranch.isMagicBranchWithAutoClose(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c);
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSuperProjects(db, branches, "receiveID");
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), refName), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(orm);
        op.updateSuperProjects(branches);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = new ArrayList<>();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.enabled()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#method_after
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.readChanges()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    Account.Id me = user.getAccountId();
    List<FooterLine> footerLines = commit.getFooterLines();
    MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ReplaceOp replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.addOp(change.getId(), replaceOp);
        bu.execute();
    }
    if (replaceOp.getRejectMessage() != null) {
        reject(inputCommand, replaceOp.getRejectMessage());
        return null;
    }
    groups = replaceOp.getGroups();
    // TODO(ekempin): mark changes as merged inside of ReplaceOp
    if (replaceOp.getMergedIntoRef() != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, replaceOp.getMergedIntoRef());
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    PatchSet newPatchSet = replaceOp.getPatchSet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ReplaceOp replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.addOp(change.getId(), replaceOp);
        bu.execute();
    }
    if (replaceOp.getRejectMessage() != null) {
        reject(inputCommand, replaceOp.getRejectMessage());
        return null;
    }
    groups = replaceOp.getGroups();
    // TODO(ekempin): mark changes as merged inside of ReplaceOp
    if (replaceOp.getMergedIntoRef() != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, replaceOp.getMergedIntoRef());
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    PatchSet newPatchSet = replaceOp.getPatchSet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit, user.getAccount());
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommitId);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (ReplaceRequest req : toClose) {
            PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommitId);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ctx.saveChange();
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
private static boolean isHead(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#method_after
private static boolean isHead(ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#method_after
private static boolean isConfig(ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#end_block

#method_before
private RequestState requestState(Thread caller) throws OrmException, IOException {
    if (caller == Thread.currentThread()) {
        return new RequestState(db, repo, rp.getRevWalk());
    } else {
        return new RequestState(project.getNameKey());
    }
}
#method_after
private RequestState requestState(Thread caller) throws OrmException, IOException {
    if (caller == Thread.currentThread()) {
        return new RequestState(db, repo, rp.getRevWalk());
    }
    return new RequestState(project.getNameKey());
}
#end_block

#method_before
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    assertThat(actual).hasSize(expected.length);
    assertThat(Iterables.transform(actual, new Function<ChangeInfo, String>() {

        @Override
        public String apply(ChangeInfo input) {
            return input.changeId != null ? input.changeId : "null";
        }
    })).containsExactly((Object[]) expected).inOrder();
}
#method_after
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    EnumSet<SubmittedTogetherOption> o = EnumSet.noneOf(SubmittedTogetherOption.class);
    assertSubmittedTogether(chId, o, expected);
}
#end_block

#method_before
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    assertThat(actual).hasSize(expected.length);
    assertThat(Iterables.transform(actual, new Function<ChangeInfo, String>() {

        @Override
        public String apply(ChangeInfo input) {
            return input.changeId != null ? input.changeId : "null";
        }
    })).containsExactly((Object[]) expected).inOrder();
}
#method_after
protected void assertSubmittedTogether(String chId, EnumSet<SubmittedTogetherOption> o, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether(o);
    assertThat(actual).hasSize(expected.length);
    assertThat(Iterables.transform(actual, new Function<ChangeInfo, String>() {

        @Override
        public String apply(ChangeInfo input) {
            return input.changeId != null ? input.changeId : input.subject;
        }
    })).containsExactly((Object[]) expected).inOrder();
}
#end_block

#method_before
public ChangeSet completeChangeSet(ReviewDb db, Change change, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    ChangeData cd = changeDataFactory.create(db, change.getProject(), change.getId());
    cd.changeControl(user);
    if (Submit.wholeTopicEnabled(cfg)) {
        return completeChangeSetIncludingTopics(db, new ChangeSet(cd), user);
    }
    return completeChangeSetWithoutTopic(db, new ChangeSet(cd), user);
}
#method_after
public ChangeSet completeChangeSet(ReviewDb db, Change change, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    ChangeData cd = changeDataFactory.create(db, change.getProject(), change.getId());
    cd.changeControl(user);
    if (Submit.wholeTopicEnabled(cfg)) {
        return completeChangeSetIncludingTopics(db, new ChangeSet(cd, db, null), user);
    }
    return completeChangeSetWithoutTopic(db, new ChangeSet(cd, db, null), user);
}
#end_block

#method_before
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    List<ChangeData> ret = new ArrayList<>();
    boolean furtherHiddenChanges = false;
    Multimap<Project.NameKey, Change.Id> pc = changes.changesByProject();
    for (Project.NameKey project : pc.keySet()) {
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
            for (Change.Id cId : pc.get(project)) {
                ChangeData cd = changeDataFactory.create(db, project, cId);
                cd.changeControl(user);
                SubmitTypeRecord str = cd.submitTypeRecord();
                if (cd.currentPatchSet().isDraft()) {
                    furtherHiddenChanges = true;
                    continue;
                }
                if (!str.isOk()) {
                    logErrorAndThrow("Failed to get submit type for " + cd.getId() + ": " + str.errorMessage);
                }
                if (str.type == SubmitType.CHERRY_PICK) {
                    ret.add(cd);
                    continue;
                }
                // Get the underlying git commit object
                PatchSet ps = cd.currentPatchSet();
                String objIdStr = ps.getRevision().get();
                RevCommit commit = rw.parseCommit(ObjectId.fromString(objIdStr));
                // Collect unmerged ancestors
                Branch.NameKey destBranch = cd.change().getDest();
                repo.getRefDatabase().refresh();
                Ref ref = repo.getRefDatabase().getRef(destBranch.get());
                rw.reset();
                rw.sort(RevSort.TOPO);
                rw.markStart(commit);
                if (ref != null) {
                    RevCommit head = rw.parseCommit(ref.getObjectId());
                    rw.markUninteresting(head);
                }
                List<String> hashes = new ArrayList<>();
                // Always include the input, even if merged. This allows
                // SubmitStrategyOp to correct the situation later, assuming it gets
                // returned by byCommitsOnBranchNotMerged below.
                hashes.add(objIdStr);
                for (RevCommit c : rw) {
                    if (!c.equals(commit)) {
                        hashes.add(c.name());
                    }
                }
                if (!hashes.isEmpty()) {
                    Iterable<ChangeData> destChanges = query().byCommitsOnBranchNotMerged(repo, db, cd.change().getDest(), hashes);
                    for (ChangeData chd : destChanges) {
                        ret.add(chd);
                    }
                }
            }
        }
    }
    return new ChangeSet(ret, furtherHiddenChanges);
}
#method_after
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    List<ChangeData> ret = new ArrayList<>();
    Multimap<Project.NameKey, Change.Id> pc = changes.changesByProject();
    for (Project.NameKey project : pc.keySet()) {
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
            for (Change.Id cId : pc.get(project)) {
                ChangeData cd = changeDataFactory.create(db, project, cId);
                SubmitTypeRecord str = cd.submitTypeRecord();
                if (!str.isOk()) {
                    logErrorAndThrow("Failed to get submit type for " + cd.getId() + ": " + str.errorMessage);
                }
                if (str.type == SubmitType.CHERRY_PICK) {
                    ret.add(cd);
                    continue;
                }
                // Get the underlying git commit object
                PatchSet ps = cd.currentPatchSet();
                String objIdStr = ps.getRevision().get();
                RevCommit commit = rw.parseCommit(ObjectId.fromString(objIdStr));
                // Collect unmerged ancestors
                Branch.NameKey destBranch = cd.change().getDest();
                repo.getRefDatabase().refresh();
                Ref ref = repo.getRefDatabase().getRef(destBranch.get());
                rw.reset();
                rw.sort(RevSort.TOPO);
                rw.markStart(commit);
                if (ref != null) {
                    RevCommit head = rw.parseCommit(ref.getObjectId());
                    rw.markUninteresting(head);
                }
                List<String> hashes = new ArrayList<>();
                // Always include the input, even if merged. This allows
                // SubmitStrategyOp to correct the situation later, assuming it gets
                // returned by byCommitsOnBranchNotMerged below.
                hashes.add(objIdStr);
                for (RevCommit c : rw) {
                    if (!c.equals(commit)) {
                        hashes.add(c.name());
                    }
                }
                if (!hashes.isEmpty()) {
                    Iterable<ChangeData> destChanges = query().byCommitsOnBranchNotMerged(repo, db, cd.change().getDest(), hashes);
                    for (ChangeData chd : destChanges) {
                        ret.add(chd);
                    }
                }
            }
        }
    }
    return new ChangeSet(ret, db, user);
}
#end_block

#method_before
private ChangeSet completeChangeSetIncludingTopics(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    Set<String> topicsTraversed = new HashSet<>();
    boolean done = false;
    ChangeSet newCs = completeChangeSetWithoutTopic(db, changes, user);
    while (!done) {
        List<ChangeData> chgs = new ArrayList<>();
        done = true;
        for (ChangeData cd : newCs.changes()) {
            chgs.add(cd);
            String topic = cd.change().getTopic();
            if (!Strings.isNullOrEmpty(topic) && !topicsTraversed.contains(topic)) {
                chgs.addAll(query().byTopicOpen(topic));
                done = false;
                topicsTraversed.add(topic);
            }
        }
        changes = new ChangeSet(chgs, newCs.isComplete());
        newCs = completeChangeSetWithoutTopic(db, changes, user);
    }
    return newCs;
}
#method_after
private ChangeSet completeChangeSetIncludingTopics(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    Set<String> topicsTraversed = new HashSet<>();
    boolean done = false;
    while (!done) {
        done = true;
        List<ChangeData> newChgs = new ArrayList<>();
        for (ChangeData cd : changes.changes()) {
            newChgs.add(cd);
            String topic = cd.change().getTopic();
            if (!Strings.isNullOrEmpty(topic) && !topicsTraversed.contains(topic)) {
                newChgs.addAll(query().byTopicOpen(topic));
                done = false;
                topicsTraversed.add(topic);
            }
        }
        changes = completeChangeSetWithoutTopic(db, new ChangeSet(newChgs, db, null), null);
    }
    return completeChangeSetWithoutTopic(db, changes, user);
}
#end_block

#method_before
private InternalChangeQuery query() {
    // Request fields required for completing the ChangeSet without having to
    // touch the database. This provides reasonable performance when loading the
    // change screen; callers that care about reading the latest value of these
    // fields should clear them explicitly using reloadChanges().
    Set<String> fields = ImmutableSet.of(ChangeField.CHANGE.getName(), ChangeField.PATCH_SET.getName());
    return queryProvider.get().setRequestedFields(fields);
}
#method_after
private InternalChangeQuery query() {
    // Request fields required for completing the ChangeSet without having to
    // touch the database. This provides reasonable performance when loading the
    // change screen; callers that care about reading the latest value of these
    // fields should clear them explicitly using reloadChanges().
    Set<String> fields = ImmutableSet.of(ChangeField.CHANGE.getName(), ChangeField.PATCH_SET.getName(), ChangeField.REVIEWER.getName());
    return queryProvider.get().setRequestedFields(fields);
}
#end_block

#method_before
@Override
public List<ChangeInfo> apply(ChangeResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    try {
        boolean addHiddenDummy = false;
        Change c = resource.getChange();
        List<ChangeData> cds;
        if (c.getStatus().isOpen()) {
            ChangeSet cs = getForOpenChange(c, resource.getControl().getUser());
            cds = cs.changes().asList();
            addHiddenDummy = !cs.isComplete();
        } else if (c.getStatus().asChangeStatus() == ChangeStatus.MERGED) {
            cds = getForMergedChange(c);
        } else {
            cds = getForAbandonedChange();
        }
        if (cds.size() <= 1 && !addHiddenDummy) {
            cds = Collections.emptyList();
        } else {
            // Skip sorting for singleton lists, to avoid WalkSorter opening the
            // repo just to fill out the commit field in PatchSetData.
            cds = sort(cds);
        }
        List<ChangeInfo> ret = json.create(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT)).formatChangeDatas(cds);
        if (addHiddenDummy) {
            ChangeInfo i = new ChangeInfo();
            i.subject = "Some Changes are hidden";
            ret.add(i);
        }
        return ret;
    } catch (OrmException | IOException e) {
        log.error("Error on getting a ChangeSet", e);
        throw e;
    }
}
#method_after
@Override
public List<ChangeInfo> apply(ChangeResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    try {
        boolean addHiddenDummy = false;
        Change c = resource.getChange();
        List<ChangeData> cds;
        if (c.getStatus().isOpen()) {
            ChangeSet cs = getForOpenChange(c, resource.getControl().getUser());
            cds = cs.changes().asList();
            addHiddenDummy = !cs.isComplete();
        } else if (c.getStatus().asChangeStatus() == ChangeStatus.MERGED) {
            cds = getForMergedChange(c);
        } else {
            cds = getForAbandonedChange();
        }
        addHiddenDummy &= options.contains(SubmittedTogetherOption.DUMMY);
        if (cds.size() <= 1 && !addHiddenDummy) {
            cds = Collections.emptyList();
        } else {
            // Skip sorting for singleton lists, to avoid WalkSorter opening the
            // repo just to fill out the commit field in PatchSetData.
            cds = sort(cds);
        }
        List<ChangeInfo> ret = json.create(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT)).formatChangeDatas(cds);
        if (addHiddenDummy) {
            ChangeInfo i = new ChangeInfo();
            i.subject = "Some changes are not visible";
            i.project = null;
            i.branch = null;
            i.submittable = false;
            i.mergeable = false;
            i.changeId = null;
            i._number = 0;
            i.currentRevision = "0";
            i.status = ChangeStatus.NEW;
            RevisionInfo ri = new RevisionInfo();
            ri.commit = new CommitInfo();
            ri.commit.subject = "Some changes are not visible";
            Map<String, RevisionInfo> revs = new LinkedHashMap<>();
            i.revisions = revs;
            i.revisions.put("0", ri);
            ret.add(i);
        }
        return ret;
    } catch (OrmException | IOException e) {
        log.error("Error on getting a ChangeSet", e);
        throw e;
    }
}
#end_block

#method_before
@Test
public void testHiddenDraftChange() throws Exception {
    setApiUser(admin);
    RevCommit initialHead = getRemoteHead();
    // Create two independent commits and push.
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    String id1 = getChangeId(c1_1);
    pushHead(testRepo, "refs/drafts/master/" + name("connectingTopic"), false);
    testRepo.reset(initialHead);
    setApiUser(user);
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master/" + name("connectingTopic"), false);
    String draftId = "null";
    if (isSubmitWholeTopicEnabled()) {
        setApiUser(admin);
        assertSubmittedTogether(id1, draftId);
        assertSubmittedTogether(id2, draftId);
        setApiUser(user);
        assertSubmittedTogether(id2, draftId);
    } else {
        setApiUser(admin);
        assertSubmittedTogether(id1, draftId);
        assertSubmittedTogether(id2);
        setApiUser(user);
        assertSubmittedTogether(id2);
    }
}
#method_after
@Test
public void testHiddenDraftChange() throws Exception {
    setApiUser(admin);
    RevCommit initialHead = getRemoteHead();
    // Create two independent commits and push.
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    String id1 = getChangeId(c1_1);
    pushHead(testRepo, "refs/drafts/master/" + name("connectingTopic"), false);
    testRepo.reset(initialHead);
    setApiUser(user);
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master/" + name("connectingTopic"), false);
    String draftId = "Some changes are not visible";
    EnumSet<SubmittedTogetherOption> o1 = EnumSet.noneOf(SubmittedTogetherOption.class);
    EnumSet<SubmittedTogetherOption> o2 = EnumSet.of(SubmittedTogetherOption.DUMMY);
    if (isSubmitWholeTopicEnabled()) {
        setApiUser(admin);
        assertSubmittedTogether(id1, o1, id2, id1);
        assertSubmittedTogether(id2, o1, id2, id1);
        assertSubmittedTogether(id1, o2, id2, id1);
        assertSubmittedTogether(id2, o2, id2, id1);
        setApiUser(user);
        assertSubmittedTogether(id2, o1);
        assertSubmittedTogether(id2, o2, id2, draftId);
    } else {
        setApiUser(admin);
        assertSubmittedTogether(id1, o1);
        assertSubmittedTogether(id2, o1);
        assertSubmittedTogether(id1, o2);
        assertSubmittedTogether(id2, o2);
        setApiUser(user);
        assertSubmittedTogether(id2, o1);
        assertSubmittedTogether(id2, o2);
    }
}
#end_block

#method_before
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithRebase() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertRebase(testRepo, false);
    RevCommit headAfterSecondSubmit = getRemoteHead();
    assertThat(headAfterSecondSubmit.getParent(0)).isEqualTo(headAfterFirstSubmit);
    assertApproved(change2.getChangeId());
    assertCurrentRevision(change2.getChangeId(), 2, headAfterSecondSubmit);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getCommitterIdent());
    ImmutableList<RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2);
    RefUpdateAttribute refUpdate = ((RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(initialHead.name());
    assertThat(refUpdate.newRev).isEqualTo(change.getCommit().name());
    refUpdate = ((RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name());
}
#method_after
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithRebase() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertRebase(testRepo, false);
    RevCommit headAfterSecondSubmit = getRemoteHead();
    assertThat(headAfterSecondSubmit.getParent(0)).isEqualTo(headAfterFirstSubmit);
    assertApproved(change2.getChangeId());
    assertCurrentRevision(change2.getChangeId(), 2, headAfterSecondSubmit);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getCommitterIdent());
    ImmutableList<RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2);
    RefUpdateAttribute refUpdate = ((RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(initialHead.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterFirstSubmit.name());
    refUpdate = ((RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name());
}
#end_block

#method_before
@Test
public void submitWithRebaseMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content");
    submit(change1.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    assertThat(headAfterFirstSubmit.name()).isEqualTo(change1.getCommit().name());
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    assertThat(change2.getCommit().getParent(0)).isNotEqualTo(change1.getCommit());
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "third content");
    approve(change2.getChangeId());
    submit(change3.getChangeId());
    assertRebase(testRepo, false);
    assertApproved(change2.getChangeId());
    assertApproved(change3.getChangeId());
    RevCommit headAfterSecondSubmit = parse(getRemoteHead());
    assertThat(headAfterSecondSubmit.getShortMessage()).isEqualTo("Change 3");
    assertThat(headAfterSecondSubmit).isNotEqualTo(change3.getCommit());
    assertCurrentRevision(change3.getChangeId(), 2, headAfterSecondSubmit);
    RevCommit parent = parse(headAfterSecondSubmit.getParent(0));
    assertThat(parent.getShortMessage()).isEqualTo("Change 2");
    assertThat(parent).isNotEqualTo(change2.getCommit());
    assertCurrentRevision(change2.getChangeId(), 2, parent);
    RevCommit grandparent = parse(parent.getParent(0));
    assertThat(grandparent).isEqualTo(change1.getCommit());
    assertCurrentRevision(change1.getChangeId(), 1, grandparent);
    ImmutableList<RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2);
    RefUpdateAttribute refUpdate = ((RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(initialHead.name());
    assertThat(refUpdate.newRev).isEqualTo(change1.getCommit().name());
    refUpdate = ((RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name());
}
#method_after
@Test
public void submitWithRebaseMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content");
    submit(change1.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    assertThat(headAfterFirstSubmit.name()).isEqualTo(change1.getCommit().name());
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    assertThat(change2.getCommit().getParent(0)).isNotEqualTo(change1.getCommit());
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "third content");
    approve(change2.getChangeId());
    submit(change3.getChangeId());
    assertRebase(testRepo, false);
    assertApproved(change2.getChangeId());
    assertApproved(change3.getChangeId());
    RevCommit headAfterSecondSubmit = parse(getRemoteHead());
    assertThat(headAfterSecondSubmit.getShortMessage()).isEqualTo("Change 3");
    assertThat(headAfterSecondSubmit).isNotEqualTo(change3.getCommit());
    assertCurrentRevision(change3.getChangeId(), 2, headAfterSecondSubmit);
    RevCommit parent = parse(headAfterSecondSubmit.getParent(0));
    assertThat(parent.getShortMessage()).isEqualTo("Change 2");
    assertThat(parent).isNotEqualTo(change2.getCommit());
    assertCurrentRevision(change2.getChangeId(), 2, parent);
    RevCommit grandparent = parse(parent.getParent(0));
    assertThat(grandparent).isEqualTo(change1.getCommit());
    assertCurrentRevision(change1.getChangeId(), 1, grandparent);
    ImmutableList<RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2);
    RefUpdateAttribute refUpdate = ((RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(initialHead.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterFirstSubmit.name());
    refUpdate = ((RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name());
}
#end_block

#method_before
public ChangeMergedEvent getOneChangeMerged(String project, String branch, final String changeNumber) throws Exception {
    String key = key(ChangeMergedEvent.TYPE, project, branch.startsWith(R_HEADS) ? branch : R_HEADS + branch);
    assertThat(recordedEvents).containsKey(key);
    List<RefEvent> events = FluentIterable.from(recordedEvents.get(key)).filter(new Predicate<RefEvent>() {

        @Override
        public boolean apply(RefEvent input) {
            assertThat(input).isInstanceOf(ChangeMergedEvent.class);
            ChangeMergedEvent e = (ChangeMergedEvent) input;
            return e.change.get().number.equals(changeNumber);
        }
    }).toList();
    assertThat(events).hasSize(1);
    return (ChangeMergedEvent) (events.get(0));
}
#method_after
public ChangeMergedEvent getOneChangeMerged(String project, String branch, final String changeNumber) throws Exception {
    String key = key(ChangeMergedEvent.TYPE, project, branch.startsWith(R_HEADS) ? branch : R_HEADS + branch);
    assertThat(recordedEvents).containsKey(key);
    List<RefEvent> events = FluentIterable.from(recordedEvents.get(key)).filter(new Predicate<RefEvent>() {

        @Override
        public boolean apply(RefEvent input) {
            assertThat(input).isInstanceOf(ChangeMergedEvent.class);
            ChangeMergedEvent e = (ChangeMergedEvent) input;
            return e.change.get().number.equals(changeNumber);
        }
    }).toList();
    assertThat(events).hasSize(1);
    return (ChangeMergedEvent) events.get(0);
}
#end_block

#method_before
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    // Submit a change so that the remote head advances
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    submit(change2.getChangeId());
    // The remote head should now be a merge of the previous head
    // and "Change 2"
    RevCommit headAfterFirstSubmit = getRemoteLog().get(0);
    assertThat(headAfterFirstSubmit.getParent(1).getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId());
    // Submit two changes at the same time
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    // Submitting change 4 should result in change 3 also being submitted
    assertMerged(change3.getChangeId());
    // The remote head should now be a merge of the new head after
    // the previous submit, and "Change 4".
    RevCommit headAfterSecondSubmit = getRemoteLog().get(0);
    assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(headAfterFirstSubmit.getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getId()).isEqualTo(headAfterFirstSubmit.getId());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent());
    // The two submit operations should have resulted in two ref-update events
    List<RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2);
    RefUpdateAttribute refUpdate = ((RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get();
    assertThat(refUpdate).isNotNull();
    assertThat(refUpdate.oldRev).isEqualTo(initialHead.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterFirstSubmit.name());
    refUpdate = ((RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get();
    assertThat(refUpdate).isNotNull();
    assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name());
}
#method_after
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    // Submit a change so that the remote head advances
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    submit(change2.getChangeId());
    // The remote head should now be a merge of the previous head
    // and "Change 2"
    RevCommit headAfterFirstSubmit = getRemoteLog().get(0);
    assertThat(headAfterFirstSubmit.getParent(1).getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId());
    // Submit two changes at the same time
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    // Submitting change 4 should result in change 3 also being submitted
    assertMerged(change3.getChangeId());
    // The remote head should now be a merge of the new head after
    // the previous submit, and "Change 4".
    RevCommit headAfterSecondSubmit = getRemoteLog().get(0);
    assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(headAfterFirstSubmit.getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getId()).isEqualTo(headAfterFirstSubmit.getId());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent());
    // The two submit operations should have resulted in two ref-update events
    List<RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2);
    RefUpdateAttribute refUpdate = ((RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(initialHead.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterFirstSubmit.name());
    refUpdate = ((RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name());
}
#end_block

#method_before
@Test
public void submitTwoChangesWithFastForward() throws Exception {
    RevCommit originalHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    PushOneCommit.Result change2 = createChange();
    String id1 = change.getChangeId();
    String id2 = change2.getChangeId();
    approve(id1);
    submit(id2);
    RevCommit updatedHead = getRemoteHead();
    assertThat(updatedHead.getId()).isEqualTo(change2.getCommit());
    assertThat(updatedHead.getParent(0).getId()).isEqualTo(change.getCommit());
    assertSubmitter(change.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), updatedHead.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), updatedHead.getCommitterIdent());
    assertSubmittedTogether(id1, id2, id1);
    assertSubmittedTogether(id2, id2, id1);
    RefUpdateAttribute refUpdate = getOneRefUpdate(project.get() + "-refs/heads/master");
    assertThat(refUpdate).isNotNull();
    assertThat(refUpdate.oldRev).isEqualTo(originalHead.name());
    assertThat(refUpdate.newRev).isEqualTo(updatedHead.name());
}
#method_after
@Test
public void submitTwoChangesWithFastForward() throws Exception {
    RevCommit originalHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    PushOneCommit.Result change2 = createChange();
    String id1 = change.getChangeId();
    String id2 = change2.getChangeId();
    approve(id1);
    submit(id2);
    RevCommit updatedHead = getRemoteHead();
    assertThat(updatedHead.getId()).isEqualTo(change2.getCommit());
    assertThat(updatedHead.getParent(0).getId()).isEqualTo(change.getCommit());
    assertSubmitter(change.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), updatedHead.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), updatedHead.getCommitterIdent());
    assertSubmittedTogether(id1, id2, id1);
    assertSubmittedTogether(id2, id2, id1);
    RefUpdatedEvent refUpdate = eventRecorder.getOneRefUpdate(project.get(), "refs/heads/master");
    assertThat(refUpdate.refUpdate.get().oldRev).isEqualTo(originalHead.name());
    assertThat(refUpdate.refUpdate.get().newRev).isEqualTo(updatedHead.name());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    changeMergedEvents = new HashMap<>();
    refUpdatedEvents = HashMultimap.create();
    eventListenerRegistration = eventListeners.add(new UserScopedEventListener() {

        @Override
        public void onEvent(Event event) {
            if (event instanceof ChangeMergedEvent) {
                ChangeMergedEvent e = (ChangeMergedEvent) event;
                ChangeAttribute c = e.change.get();
                PatchSetAttribute ps = e.patchSet.get();
                log.debug("Merged {},{} as {}", ps.number, c.number, e.newRev);
                changeMergedEvents.put(e.change.get().number, e.newRev);
            } else if (event instanceof RefUpdatedEvent) {
                RefUpdatedEvent e = (RefUpdatedEvent) event;
                RefUpdateAttribute r = e.refUpdate.get();
                log.debug("Branch {} ref updated from {} to {}", r.refName, r.oldRev, r.newRev);
                refUpdatedEvents.put(r.project + "-" + r.refName, r);
            }
        }

        @Override
        public CurrentUser getUser() {
            return factory.create(user.id);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    eventRecorder = eventRecorderFactory.create(user);
}
#end_block

#method_before
@After
public void cleanup() {
    eventListenerRegistration.remove();
    db.close();
}
#method_after
@After
public void cleanup() {
    eventRecorder.close();
    db.close();
}
#end_block

#method_before
protected void submit(String changeId, SubmitInput input, Class<? extends RestApiException> expectedExceptionType, String expectedExceptionMsg, boolean checkMergeResult) throws Exception {
    approve(changeId);
    if (expectedExceptionType == null) {
        assertSubmittable(changeId);
    }
    try {
        gApi.changes().id(changeId).current().submit(input);
        if (expectedExceptionType != null) {
            fail("Expected exception of type " + expectedExceptionType.getSimpleName());
        }
    } catch (RestApiException e) {
        if (expectedExceptionType == null) {
            throw e;
        }
        // us the stack trace.
        if (!expectedExceptionType.isAssignableFrom(e.getClass()) || !e.getMessage().equals(expectedExceptionMsg)) {
            throw new AssertionError("Expected exception of type " + expectedExceptionType.getSimpleName() + " with message: \"" + expectedExceptionMsg + "\" but got exception of type " + e.getClass().getSimpleName() + " with message \"" + e.getMessage() + "\"", e);
        }
        return;
    }
    ChangeInfo change = gApi.changes().id(changeId).info();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    if (checkMergeResult) {
        checkMergeResult(change);
    }
}
#method_after
protected void submit(String changeId, SubmitInput input, Class<? extends RestApiException> expectedExceptionType, String expectedExceptionMsg, boolean checkMergeResult) throws Exception {
    approve(changeId);
    if (expectedExceptionType == null) {
        assertSubmittable(changeId);
    }
    try {
        gApi.changes().id(changeId).current().submit(input);
        if (expectedExceptionType != null) {
            fail("Expected exception of type " + expectedExceptionType.getSimpleName());
        }
    } catch (RestApiException e) {
        if (expectedExceptionType == null) {
            throw e;
        }
        // us the stack trace.
        if (!expectedExceptionType.isAssignableFrom(e.getClass()) || !e.getMessage().equals(expectedExceptionMsg)) {
            throw new AssertionError("Expected exception of type " + expectedExceptionType.getSimpleName() + " with message: \"" + expectedExceptionMsg + "\" but got exception of type " + e.getClass().getSimpleName() + " with message \"" + e.getMessage() + "\"", e);
        }
        return;
    }
    ChangeInfo change = gApi.changes().id(changeId).info();
    assertMerged(change.changeId);
    if (checkMergeResult) {
        checkMergeResult(change);
    }
}
#end_block

#method_before
private void checkMergeResult(ChangeInfo change) throws Exception {
    // Get the revision of the branch after the submit to compare with the
    // newRev of the ChangeMergedEvent.
    BranchInfo branch = gApi.projects().name(change.project).branch(change.branch).get();
    assertThat(changeMergedEvents).isNotEmpty();
    String newRev = changeMergedEvents.get(Integer.toString(change._number));
    assertThat(newRev).isNotNull();
    assertThat(branch.revision).isEqualTo(newRev);
}
#method_after
private void checkMergeResult(ChangeInfo change) throws Exception {
    // Get the revision of the branch after the submit to compare with the
    // newRev of the ChangeMergedEvent.
    BranchInfo branch = gApi.projects().name(change.project).branch(change.branch).get();
    ChangeMergedEvent event = eventRecorder.getOneChangeMerged(change.project, change.branch, Integer.toString(change._number));
    assertThat(event.newRev).isNotNull();
    assertThat(branch.revision).isEqualTo(event.newRev);
}
#end_block

#method_before
private String problemsForSubmittingChangeset(ChangeSet cs, Project.NameKey project, IdentifiedUser identifiedUser) {
    try {
        @SuppressWarnings("resource")
        ReviewDb db = dbProvider.get();
        for (ChangeData c : cs.changes()) {
            ChangeControl changeControl = c.changeControl(identifiedUser);
            if (!changeControl.isVisible(db)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!changeControl.canSubmit()) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            // Recheck mergeability rather than using value stored in the index,
            // which may be stale.
            // TODO(dborowitz): This is ugly; consider providing a way to not read
            // stored fields from the index in the first place.
            c.setMergeable(null);
            Boolean mergeable = c.isMergeable();
            if (mergeable == null) {
                log.error("Ephemeral error checking if change is submittable");
                return CLICK_FAILURE_TOOLTIP;
            }
            if (!mergeable) {
                return CLICK_FAILURE_OTHER_TOOLTIP;
            }
            MergeOp.checkSubmitRule(c);
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#method_after
private String problemsForSubmittingChangeset(ChangeSet cs, IdentifiedUser identifiedUser) {
    try {
        @SuppressWarnings("resource")
        ReviewDb db = dbProvider.get();
        for (ChangeData c : cs.changes()) {
            ChangeControl changeControl = c.changeControl(identifiedUser);
            if (!changeControl.isVisible(db)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!changeControl.canSubmit()) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            // Recheck mergeability rather than using value stored in the index,
            // which may be stale.
            // TODO(dborowitz): This is ugly; consider providing a way to not read
            // stored fields from the index in the first place.
            c.setMergeable(null);
            Boolean mergeable = c.isMergeable();
            if (mergeable == null) {
                log.error("Ephemeral error checking if change is submittable");
                return CLICK_FAILURE_TOOLTIP;
            }
            if (!mergeable) {
                return CLICK_FAILURE_OTHER_TOOLTIP;
            }
            MergeOp.checkSubmitRule(c);
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    Boolean enabled;
    try {
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.completeChangeSet(db, cd.change());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cs, resource.getProject(), resource.getUser());
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
        ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
        return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    Boolean enabled;
    try {
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.completeChangeSet(db, cd.change(), resource.getControl().getUser());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cs, resource.getUser());
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
        ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
        return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
}
#end_block

#method_before
@Override
public int compareTo(ProjectHolder other) {
    return other.size < this.size ? -1 : 1;
}
#method_after
@Override
public int compareTo(ProjectHolder other) {
    return ComparisonChain.start().compare(other.size, size).compare(other.name.get(), name.get()).result();
}
#end_block

#method_before
@Override
public Result indexAll(ChangeIndex index) {
    ProgressMonitor pm = new TextProgressMonitor();
    pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    SortedSet<ProjectHolder> projects = new TreeSet<>();
    int changeCount = 0;
    Stopwatch sw = Stopwatch.createStarted();
    for (Project.NameKey project : projectCache.all()) {
        try (Repository repo = repoManager.openRepository(project)) {
            int size = ChangeNotes.Factory.scan(repo).size();
            changeCount += size;
            projects.add(new ProjectHolder(project, size));
        } catch (IOException e) {
            log.error("Error collecting projects", e);
            return new Result(sw, false, 0, 0);
        }
        pm.update(1);
    }
    pm.endTask();
    setTotalWork(changeCount);
    return indexAll(index, projects);
}
#method_after
@Override
public Result indexAll(ChangeIndex index) {
    ProgressMonitor pm = new TextProgressMonitor();
    pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    SortedSet<ProjectHolder> projects = new TreeSet<>();
    int changeCount = 0;
    Stopwatch sw = Stopwatch.createStarted();
    for (Project.NameKey name : projectCache.all()) {
        try (Repository repo = repoManager.openRepository(name)) {
            int size = ChangeNotes.Factory.scan(repo).size();
            changeCount += size;
            projects.add(new ProjectHolder(name, size));
        } catch (IOException e) {
            log.error("Error collecting projects", e);
            return new Result(sw, false, 0, 0);
        }
        pm.update(1);
    }
    pm.endTask();
    setTotalWork(changeCount);
    return indexAll(index, projects);
}
#end_block

#method_before
public SiteIndexer.Result indexAll(ChangeIndex index, Iterable<ProjectHolder> projects) {
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", (projects instanceof Collection) ? ((Collection<?>) projects).size() : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, totalWork >= 0 ? totalWork : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = new ArrayList<>();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final ProjectHolder project : projects) {
        ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(executor, index), project.name, doneTask, failedTask, verboseWriter));
        addErrorListener(future, "project " + project, projTask, ok);
        futures.add(future);
    }
    try {
        mpm.waitFor(Futures.transformAsync(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
    } catch (ExecutionException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    // If too many changes failed, maybe there was a bug in the indexer. Don't
    // trust the results. This is not an exact percentage since we bump the same
    // failure counter if a project can't be read, but close enough.
    int nFailed = failedTask.getCount();
    int nTotal = nFailed + doneTask.getCount();
    double pctFailed = ((double) nFailed) / nTotal * 100;
    if (pctFailed > 10) {
        log.error("Failed {}/{} changes ({}%); not marking new index as ready", nFailed, nTotal, Math.round(pctFailed));
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#method_after
public SiteIndexer.Result indexAll(ChangeIndex index, Iterable<ProjectHolder> projects) {
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", (projects instanceof Collection) ? ((Collection<?>) projects).size() : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, totalWork >= 0 ? totalWork : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = new ArrayList<>();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final ProjectHolder project : projects) {
        ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(executor, index), project.name, doneTask, failedTask, verboseWriter));
        addErrorListener(future, "project " + project.name, projTask, ok);
        futures.add(future);
    }
    try {
        mpm.waitFor(Futures.transformAsync(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
    } catch (ExecutionException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    // If too many changes failed, maybe there was a bug in the indexer. Don't
    // trust the results. This is not an exact percentage since we bump the same
    // failure counter if a project can't be read, but close enough.
    int nFailed = failedTask.getCount();
    int nTotal = nFailed + doneTask.getCount();
    double pctFailed = ((double) nFailed) / nTotal * 100;
    if (pctFailed > 10) {
        log.error("Failed {}/{} changes ({}%); not marking new index as ready", nFailed, nTotal, Math.round(pctFailed));
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#end_block

#method_before
private Map<String, Ref> visibleTags(ProjectControl control, Repository repo, Map<String, Ref> tags) {
    return new VisibleRefFilter(tagCache, changeCache, repo, control, dbProvider.get(), false).filter(tags, true);
}
#method_after
private Map<String, Ref> visibleTags(ProjectControl control, Repository repo, Map<String, Ref> tags) {
    return new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, control, dbProvider.get(), false).filter(tags, true);
}
#end_block

#method_before
boolean isMergedIntoVisibleRef(Repository repo, ReviewDb db, RevWalk rw, RevCommit commit, Collection<Ref> unfilteredRefs) throws IOException {
    VisibleRefFilter filter = new VisibleRefFilter(tagCache, changeCache, repo, this, db, true);
    Map<String, Ref> m = Maps.newHashMapWithExpectedSize(unfilteredRefs.size());
    for (Ref r : unfilteredRefs) {
        m.put(r.getName(), r);
    }
    Map<String, Ref> refs = filter.filter(m, true);
    return !refs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, refs.values());
}
#method_after
boolean isMergedIntoVisibleRef(Repository repo, ReviewDb db, RevWalk rw, RevCommit commit, Collection<Ref> unfilteredRefs) throws IOException {
    VisibleRefFilter filter = new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, this, db, true);
    Map<String, Ref> m = Maps.newHashMapWithExpectedSize(unfilteredRefs.size());
    for (Ref r : unfilteredRefs) {
        m.put(r.getName(), r);
    }
    Map<String, Ref> refs = filter.filter(m, true);
    return !refs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, refs.values());
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    Account userAccount;
    try {
        userAccount = accountResolver.find(userName);
    } catch (OrmException e) {
        throw die(e);
    }
    if (userAccount == null) {
        stdout.print("No single user could be found when searching for: " + userName + '\n');
        stdout.flush();
        return;
    }
    IdentifiedUser user = userFactory.create(userAccount.getId());
    ProjectControl userProjectControl = projectControl.forUser(user);
    try (Repository repo = repoManager.openRepository(userProjectControl.getProject().getNameKey())) {
        try {
            Map<String, Ref> refsMap = new VisibleRefFilter(tagCache, changeCache, repo, userProjectControl, db, true).filter(repo.getRefDatabase().getRefs(ALL), false);
            for (final String ref : refsMap.keySet()) {
                if (!onlyRefsHeads || ref.startsWith(RefNames.REFS_HEADS)) {
                    stdout.println(ref);
                }
            }
        } catch (IOException e) {
            throw new Failure(1, "fatal: Error reading refs: '" + projectControl.getProject().getNameKey(), e);
        }
    } catch (RepositoryNotFoundException e) {
        throw die("'" + projectControl.getProject().getNameKey() + "': not a git archive");
    } catch (IOException e) {
        throw die("Error opening: '" + projectControl.getProject().getNameKey());
    }
}
#method_after
@Override
protected void run() throws Failure {
    Account userAccount;
    try {
        userAccount = accountResolver.find(userName);
    } catch (OrmException e) {
        throw die(e);
    }
    if (userAccount == null) {
        stdout.print("No single user could be found when searching for: " + userName + '\n');
        stdout.flush();
        return;
    }
    IdentifiedUser user = userFactory.create(userAccount.getId());
    ProjectControl userProjectControl = projectControl.forUser(user);
    try (Repository repo = repoManager.openRepository(userProjectControl.getProject().getNameKey())) {
        try {
            Map<String, Ref> refsMap = new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, userProjectControl, db, true).filter(repo.getRefDatabase().getRefs(ALL), false);
            for (final String ref : refsMap.keySet()) {
                if (!onlyRefsHeads || ref.startsWith(RefNames.REFS_HEADS)) {
                    stdout.println(ref);
                }
            }
        } catch (IOException e) {
            throw new Failure(1, "fatal: Error reading refs: '" + projectControl.getProject().getNameKey(), e);
        }
    } catch (RepositoryNotFoundException e) {
        throw die("'" + projectControl.getProject().getNameKey() + "': not a git archive");
    } catch (IOException e) {
        throw die("Error opening: '" + projectControl.getProject().getNameKey());
    }
}
#end_block

#method_before
@Override
public UploadPack create(Context req, final Repository repo) throws ServiceNotAuthorizedException {
    // Set the request context, but don't bother unsetting, since we don't
    // have an easy way to run code when this instance is done being used.
    // Each operation is run in its own thread, so we don't need to recover
    // its original context anyway.
    threadContext.setContext(req);
    current.set(req);
    try {
        ProjectControl ctl = projectControlFactory.controlFor(req.project, userProvider.get());
        if (!ctl.canRunUploadPack()) {
            throw new ServiceNotAuthorizedException();
        }
        UploadPack up = new UploadPack(repo);
        up.setPackConfig(transferConfig.getPackConfig());
        up.setTimeout(transferConfig.getTimeout());
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, ctl, dbProvider.get(), true));
        List<PreUploadHook> hooks = Lists.newArrayList(preUploadHooks);
        hooks.add(uploadValidatorsFactory.create(ctl.getProject(), repo, "localhost-test"));
        up.setPreUploadHook(PreUploadHookChain.newChain(hooks));
        return up;
    } catch (NoSuchProjectException | IOException e) {
        throw new RuntimeException(e);
    }
}
#method_after
@Override
public UploadPack create(Context req, final Repository repo) throws ServiceNotAuthorizedException {
    // Set the request context, but don't bother unsetting, since we don't
    // have an easy way to run code when this instance is done being used.
    // Each operation is run in its own thread, so we don't need to recover
    // its original context anyway.
    threadContext.setContext(req);
    current.set(req);
    try {
        ProjectControl ctl = projectControlFactory.controlFor(req.project, userProvider.get());
        if (!ctl.canRunUploadPack()) {
            throw new ServiceNotAuthorizedException();
        }
        UploadPack up = new UploadPack(repo);
        up.setPackConfig(transferConfig.getPackConfig());
        up.setTimeout(transferConfig.getTimeout());
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, ctl, dbProvider.get(), true));
        List<PreUploadHook> hooks = Lists.newArrayList(preUploadHooks);
        hooks.add(uploadValidatorsFactory.create(ctl.getProject(), repo, "localhost-test"));
        up.setPreUploadHook(PreUploadHookChain.newChain(hooks));
        return up;
    } catch (NoSuchProjectException | IOException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private Set<Change.Id> visibleChanges() {
    if (!showMetadata) {
        return Collections.emptySet();
    }
    Project project = projectCtl.getProject();
    try {
        Set<Change.Id> visibleChanges = new HashSet<>();
        for (ChangeData cd : changeCache.getChangeData(reviewDb, project.getNameKey())) {
            if (projectCtl.controlForIndexedChange(cd.change()).isVisible(reviewDb, cd)) {
                visibleChanges.add(cd.getId());
            }
        }
        return visibleChanges;
    } catch (OrmException e) {
        log.error("Cannot load changes for project " + project.getName() + ", assuming no changes are visible", e);
        return Collections.emptySet();
    }
}
#method_after
private Set<Change.Id> visibleChanges() {
    if (!showMetadata) {
        return Collections.emptySet();
    } else if (changeCache == null) {
        return visibleChangesByScan();
    }
    return visibleChangesBySearch();
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db, true));
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPostUploadHook(uploadMetrics);
    List<PreUploadHook> allPreUploadHooks = Lists.newArrayList(preUploadHooks);
    allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString()));
    up.setPreUploadHook(PreUploadHookChain.newChain(allPreUploadHooks));
    try {
        up.upload(in, out, err);
        session.setPeerAgent(up.getPeerUserAgent());
    } catch (UploadValidationException e) {
        // internal server error to the client.
        if (!e.isOutput()) {
            up.sendMessage(e.getMessage());
        }
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, projectControl, db, true));
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPostUploadHook(uploadMetrics);
    List<PreUploadHook> allPreUploadHooks = Lists.newArrayList(preUploadHooks);
    allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString()));
    up.setPreUploadHook(PreUploadHookChain.newChain(allPreUploadHooks));
    try {
        up.upload(in, out, err);
        session.setPeerAgent(up.getPeerUserAgent());
    } catch (UploadValidationException e) {
        // internal server error to the client.
        if (!e.isOutput()) {
            up.sendMessage(e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    if (!pc.canRunUploadPack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    }
    // We use getRemoteHost() here instead of getRemoteAddr() because REMOTE_ADDR
    // may have been overridden by a proxy server -- we'll try to avoid this.
    UploadValidators uploadValidators = uploadValidatorsFactory.create(pc.getProject(), repo, request.getRemoteHost());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(up.getPreUploadHook(), uploadValidators)));
    up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, pc, db.get(), true));
    next.doFilter(request, response);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    if (!pc.canRunUploadPack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    }
    // We use getRemoteHost() here instead of getRemoteAddr() because REMOTE_ADDR
    // may have been overridden by a proxy server -- we'll try to avoid this.
    UploadValidators uploadValidators = uploadValidatorsFactory.create(pc.getProject(), repo, request.getRemoteHost());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(up.getPreUploadHook(), uploadValidators)));
    up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, pc, db.get(), true));
    next.doFilter(request, response);
}
#end_block

#method_before
private void assertRefs(String... expectedWithMeta) throws Exception {
    List<String> expected = new ArrayList<>(expectedWithMeta.length);
    for (String r : expectedWithMeta) {
        if (notesMigration.writeChanges() || !r.endsWith(RefNames.META_SUFFIX)) {
            expected.add(r);
        }
    }
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try (Repository repo = repoManager.openRepository(project)) {
        ProjectControl ctl = projectControlFactory.controlFor(project, userProvider.get());
        VisibleRefFilter filter = new VisibleRefFilter(tagCache, changeCache, repo, ctl, new DisabledReviewDb(), true);
        Map<String, Ref> all = repo.getAllRefs();
        assertThat(filter.filter(all, false).keySet()).containsExactlyElementsIn(expected);
    } finally {
        enableDb(ctx);
    }
}
#method_after
private void assertRefs(String... expectedWithMeta) throws Exception {
    try (Repository repo = repoManager.openRepository(project)) {
        assertRefs(repo, new VisibleRefFilter(tagCache, notesFactory, changeCache, repo, projectControl(), new DisabledReviewDb(), true), true, expectedWithMeta);
    }
}
#end_block

#method_before
private void assertRefs(String... expectedWithMeta) throws Exception {
    List<String> expected = new ArrayList<>(expectedWithMeta.length);
    for (String r : expectedWithMeta) {
        if (notesMigration.writeChanges() || !r.endsWith(RefNames.META_SUFFIX)) {
            expected.add(r);
        }
    }
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try (Repository repo = repoManager.openRepository(project)) {
        ProjectControl ctl = projectControlFactory.controlFor(project, userProvider.get());
        VisibleRefFilter filter = new VisibleRefFilter(tagCache, changeCache, repo, ctl, new DisabledReviewDb(), true);
        Map<String, Ref> all = repo.getAllRefs();
        assertThat(filter.filter(all, false).keySet()).containsExactlyElementsIn(expected);
    } finally {
        enableDb(ctx);
    }
}
#method_after
private void assertRefs(Repository repo, VisibleRefFilter filter, boolean disableDb, String... expectedWithMeta) throws Exception {
    List<String> expected = new ArrayList<>(expectedWithMeta.length);
    for (String r : expectedWithMeta) {
        if (notesMigration.writeChanges() || !r.endsWith(RefNames.META_SUFFIX)) {
            expected.add(r);
        }
    }
    AcceptanceTestRequestScope.Context ctx = null;
    if (disableDb) {
        ctx = disableDb();
    }
    try {
        Map<String, Ref> all = repo.getAllRefs();
        assertThat(filter.filter(all, false).keySet()).containsExactlyElementsIn(expected);
    } finally {
        if (disableDb) {
            enableDb(ctx);
        }
    }
}
#end_block

#method_before
@Test
public void gitLink() {
    MarkdownToHtml md = MarkdownToHtml.builder().setGitilesView(view).setConfig(new MarkdownConfig(config)).setFilePath("index.md").build();
    String url;
    url = "git://example.com/repo.git";
    assertThat(md.href(url)).isEqualTo(url);
    assertThat(md.href("git:example.com/repo.git")).isEqualTo("#zSoyz");
    assertThat(md.href("git://")).isEqualTo("#zSoyz");
}
#method_after
@Test
public void gitLink() {
    MarkdownToHtml md = MarkdownToHtml.builder().setGitilesView(view).setConfig(new MarkdownConfig(config)).setFilePath("index.md").build();
    String url;
    url = "git://example.com/repo.git";
    assertThat(md.href(url)).isEqualTo(url);
    assertThat(md.href("git:example.com/repo.git")).isEqualTo("#zSoyz");
    assertThat(md.href("git://")).isEqualTo("#zSoyz");
    assertThat(md.href("git://example.com/../root")).isEqualTo("#zSoyz");
    assertThat(md.href("git://example.com/root/..")).isEqualTo("#zSoyz");
}
#end_block

#method_before
public static ObjectId parseBaseRevision(Repository repo, Project.NameKey projectName, String baseRevision) throws InvalidRevisionException {
    try {
        final ObjectId revid = repo.resolve(baseRevision);
        if (revid == null) {
            throw new InvalidRevisionException();
        }
        return revid;
    } catch (IOException err) {
        log.error("Cannot resolve \"" + baseRevision + "\" in project \"" + projectName.get() + "\"", err);
        throw new InvalidRevisionException();
    } catch (RevisionSyntaxException err) {
        log.error("Invalid revision syntax \"" + baseRevision + "\"", err);
        throw new InvalidRevisionException();
    }
}
#method_after
public static ObjectId parseBaseRevision(Repository repo, Project.NameKey projectName, String baseRevision) throws InvalidRevisionException {
    try {
        ObjectId revid = repo.resolve(baseRevision);
        if (revid == null) {
            throw new InvalidRevisionException();
        }
        return revid;
    } catch (IOException err) {
        log.error("Cannot resolve \"" + baseRevision + "\" in project \"" + projectName.get() + "\"", err);
        throw new InvalidRevisionException();
    } catch (RevisionSyntaxException err) {
        log.error("Invalid revision syntax \"" + baseRevision + "\"", err);
        throw new InvalidRevisionException();
    }
}
#end_block

#method_before
public static String getRefPrefix(final String refName) {
    final int i = refName.lastIndexOf('/');
    if (i > Constants.R_HEADS.length() - 1) {
        return refName.substring(0, i);
    }
    return Constants.R_HEADS;
}
#method_after
public static String getRefPrefix(String refName) {
    int i = refName.lastIndexOf('/');
    if (i > Constants.R_HEADS.length() - 1) {
        return refName.substring(0, i);
    }
    return Constants.R_HEADS;
}
#end_block

#method_before
private void initAllUsers(Repository git) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git)) {
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage("Initialized Gerrit Code Review " + Version.getVersion());
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription("Individual user settings and preferences.");
        AccessSection users = config.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true);
        grant(config, users, Permission.READ, false, true, registered);
        grant(config, users, Permission.PUSH, false, true, registered);
        AccessSection defaults = config.getAccessSection(RefNames.REFS_USERS_DEFAULT, true);
        defaults.getPermission(Permission.READ, true).setExclusiveGroup(true);
        grant(config, defaults, Permission.READ, admin);
        defaults.getPermission(Permission.PUSH, true).setExclusiveGroup(true);
        grant(config, defaults, Permission.PUSH, admin);
        defaults.getPermission(Permission.CREATE, true).setExclusiveGroup(true);
        grant(config, defaults, Permission.CREATE, admin);
        config.commit(md);
    }
}
#method_after
private void initAllUsers(Repository git) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git)) {
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage("Initialized Gerrit Code Review " + Version.getVersion());
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription("Individual user settings and preferences.");
        AccessSection users = config.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true);
        LabelType cr = AllProjectsCreator.initCodeReviewLabel(config);
        grant(config, users, Permission.READ, false, true, registered);
        grant(config, users, Permission.PUSH, false, true, registered);
        grant(config, users, Permission.SUBMIT, false, true, registered);
        grant(config, users, cr, -2, 2, registered);
        AccessSection defaults = config.getAccessSection(RefNames.REFS_USERS_DEFAULT, true);
        defaults.getPermission(Permission.READ, true).setExclusiveGroup(true);
        grant(config, defaults, Permission.READ, admin);
        defaults.getPermission(Permission.PUSH, true).setExclusiveGroup(true);
        grant(config, defaults, Permission.PUSH, admin);
        defaults.getPermission(Permission.CREATE, true).setExclusiveGroup(true);
        grant(config, defaults, Permission.CREATE, admin);
        config.commit(md);
    }
}
#end_block

#method_before
@Test
public void pushToUserBranchForReview() throws Exception {
    // change something in the user preferences to ensure that the user branch
    // is created
    GeneralPreferencesInfo input = new GeneralPreferencesInfo();
    input.changesPerPage = GeneralPreferencesInfo.defaults().changesPerPage + 10;
    gApi.accounts().self().setPreferences(input);
    String userRefName = RefNames.refsUsers(admin.id);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRefName + ":userRef");
    allUsersRepo.reset("userRef");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allUsersRepo);
    PushOneCommit.Result r = push.to(MagicBranch.NEW_CHANGE + userRefName);
    r.assertOkStatus();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(userRefName);
    push = pushFactory.create(db, admin.getIdent(), allUsersRepo);
    r = push.to(MagicBranch.NEW_CHANGE + RefNames.REFS_USERS_SELF);
    r.assertOkStatus();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(userRefName);
}
#method_after
@Test
public void pushToUserBranchForReview() throws Exception {
    // change something in the user preferences to ensure that the user branch
    // is created
    GeneralPreferencesInfo input = new GeneralPreferencesInfo();
    input.changesPerPage = GeneralPreferencesInfo.defaults().changesPerPage + 10;
    gApi.accounts().self().setPreferences(input);
    String userRefName = RefNames.refsUsers(admin.id);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRefName + ":userRef");
    allUsersRepo.reset("userRef");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allUsersRepo);
    PushOneCommit.Result r = push.to(MagicBranch.NEW_CHANGE + userRefName);
    r.assertOkStatus();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(userRefName);
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).current().submit();
    push = pushFactory.create(db, admin.getIdent(), allUsersRepo);
    r = push.to(MagicBranch.NEW_CHANGE + RefNames.REFS_USERS_SELF);
    r.assertOkStatus();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(userRefName);
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).current().submit();
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try (Repository git = repoManager.openRepository(allUsersName);
        MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git)) {
        ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        config.getAccessSection(RefNames.REFS_USERS + "*", true).remove(new Permission(Permission.READ));
        GroupReference registered = SystemGroupBackend.getGroup(REGISTERED_USERS);
        AccessSection users = config.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true);
        grant(config, users, Permission.READ, true, registered);
        grant(config, users, Permission.PUSH, true, registered);
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        config.commit(md);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try (Repository git = repoManager.openRepository(allUsersName);
        MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git)) {
        ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        config.getAccessSection(RefNames.REFS_USERS + "*", true).remove(new Permission(Permission.READ));
        GroupReference registered = SystemGroupBackend.getGroup(REGISTERED_USERS);
        AccessSection users = config.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true);
        grant(config, users, Permission.READ, true, registered);
        grant(config, users, Permission.PUSH, true, registered);
        grant(config, users, Permission.SUBMIT, true, registered);
        for (LabelType lt : getLabelTypes(config)) {
            if ("Code-Review".equals(lt.getName()) || "Verified".equals(lt.getName())) {
                grant(config, users, lt, lt.getMin().getValue(), lt.getMax().getValue(), registered);
            }
        }
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage(COMMIT_MSG);
        config.commit(md);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#end_block

#method_before
private Iterable<String> getUsernames(CurrentUser user) {
    if (user.isIdentifiedUser()) {
        Set<String> emails = user.asIdentifiedUser().getEmailAddresses();
        if (user.getUserName() == null) {
            return emails;
        } else if (emails.isEmpty()) {
            return ImmutableSet.of(user.getUserName());
        }
    }
    if (user.getUserName() != null) {
        return ImmutableSet.of(user.getUserName());
    }
    return ImmutableSet.of();
}
#method_after
private Iterable<String> getUsernames(CurrentUser user) {
    if (user.isIdentifiedUser()) {
        Set<String> emails = user.asIdentifiedUser().getEmailAddresses();
        if (user.getUserName() == null) {
            return emails;
        } else if (emails.isEmpty()) {
            return ImmutableSet.of(user.getUserName());
        }
        return Iterables.concat(emails, ImmutableSet.of(user.getUserName()));
    }
    if (user.getUserName() != null) {
        return ImmutableSet.of(user.getUserName());
    }
    return ImmutableSet.of();
}
#end_block

#method_before
private List<String> getUsernames(CurrentUser user) {
    List<String> r;
    if (user.isIdentifiedUser()) {
        Set<String> emails = user.asIdentifiedUser().getEmailAddresses();
        r = new ArrayList<>(emails.size() + 1);
        r.addAll(emails);
    } else {
        r = new ArrayList<>(1);
    }
    if (user.getUserName() != null) {
        r.add(user.getUserName());
    }
    return r;
}
#method_after
private Iterable<String> getUsernames(CurrentUser user) {
    if (user.isIdentifiedUser()) {
        Set<String> emails = user.asIdentifiedUser().getEmailAddresses();
        if (user.getUserName() == null) {
            return emails;
        } else if (emails.isEmpty()) {
            return ImmutableSet.of(user.getUserName());
        }
        Iterables.concat(emails, ImmutableSet.of(user.getUserName()));
    }
    if (user.getUserName() != null) {
        return ImmutableSet.of(user.getUserName());
    }
    return ImmutableSet.of();
}
#end_block

#method_before
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, CurrentUser user) {
    if (isRE(ref)) {
        ref = RefControl.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    boolean perUser = false;
    Map<AccessSection, Project.NameKey> sectionToProject = Maps.newLinkedHashMap();
    for (SectionMatcher sm : matcherList) {
        // 
        if (sm.matcher instanceof RefPatternMatcher.ExpandParameters) {
            if (!((RefPatternMatcher.ExpandParameters) sm.matcher).matchPrefix(ref)) {
                continue;
            }
            perUser = true;
            if (sm.match(ref, user)) {
                sectionToProject.put(sm.section, sm.project);
                break;
            }
        } else if (sm.match(ref, null)) {
            sectionToProject.put(sm.section, sm.project);
        }
    }
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    sorter.sort(ref, sections);
    Set<SeenRule> seen = new HashSet<>();
    Set<String> exclusiveGroupPermissions = new HashSet<>();
    HashMap<String, List<PermissionRule>> permissions = new HashMap<>();
    HashMap<String, List<PermissionRule>> overridden = new HashMap<>();
    Map<PermissionRule, ProjectRef> ruleProps = Maps.newIdentityHashMap();
    for (AccessSection section : sections) {
        Project.NameKey project = sectionToProject.get(section);
        for (Permission permission : section.getPermissions()) {
            boolean exclusivePermissionExists = exclusiveGroupPermissions.contains(permission.getName());
            for (PermissionRule rule : permission.getRules()) {
                SeenRule s = SeenRule.create(section, permission, rule);
                boolean addRule;
                if (rule.isBlock()) {
                    addRule = true;
                } else {
                    addRule = seen.add(s) && !rule.isDeny() && !exclusivePermissionExists;
                }
                HashMap<String, List<PermissionRule>> p = null;
                if (addRule) {
                    p = permissions;
                } else if (!rule.isDeny() && !exclusivePermissionExists) {
                    p = overridden;
                }
                if (p != null) {
                    List<PermissionRule> r = p.get(permission.getName());
                    if (r == null) {
                        r = new ArrayList<>(2);
                        p.put(permission.getName(), r);
                    }
                    r.add(rule);
                    ruleProps.put(rule, ProjectRef.create(project, section.getName()));
                }
            }
            if (permission.getExclusiveGroup()) {
                exclusiveGroupPermissions.add(permission.getName());
            }
        }
    }
    return new PermissionCollection(permissions, overridden, ruleProps, perUser);
}
#method_after
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, CurrentUser user) {
    if (isRE(ref)) {
        ref = RefControl.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    boolean perUser = false;
    Map<AccessSection, Project.NameKey> sectionToProject = new LinkedHashMap<>();
    for (SectionMatcher sm : matcherList) {
        // 
        if (sm.matcher instanceof RefPatternMatcher.ExpandParameters) {
            if (!((RefPatternMatcher.ExpandParameters) sm.matcher).matchPrefix(ref)) {
                continue;
            }
            perUser = true;
            if (sm.match(ref, user)) {
                sectionToProject.put(sm.section, sm.project);
                break;
            }
        } else if (sm.match(ref, null)) {
            sectionToProject.put(sm.section, sm.project);
        }
    }
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    sorter.sort(ref, sections);
    Set<SeenRule> seen = new HashSet<>();
    Set<String> exclusiveGroupPermissions = new HashSet<>();
    HashMap<String, List<PermissionRule>> permissions = new HashMap<>();
    HashMap<String, List<PermissionRule>> overridden = new HashMap<>();
    Map<PermissionRule, ProjectRef> ruleProps = Maps.newIdentityHashMap();
    for (AccessSection section : sections) {
        Project.NameKey project = sectionToProject.get(section);
        for (Permission permission : section.getPermissions()) {
            boolean exclusivePermissionExists = exclusiveGroupPermissions.contains(permission.getName());
            for (PermissionRule rule : permission.getRules()) {
                SeenRule s = SeenRule.create(section, permission, rule);
                boolean addRule;
                if (rule.isBlock()) {
                    addRule = true;
                } else {
                    addRule = seen.add(s) && !rule.isDeny() && !exclusivePermissionExists;
                }
                HashMap<String, List<PermissionRule>> p = null;
                if (addRule) {
                    p = permissions;
                } else if (!rule.isDeny() && !exclusivePermissionExists) {
                    p = overridden;
                }
                if (p != null) {
                    List<PermissionRule> r = p.get(permission.getName());
                    if (r == null) {
                        r = new ArrayList<>(2);
                        p.put(permission.getName(), r);
                    }
                    r.add(rule);
                    ruleProps.put(rule, ProjectRef.create(project, section.getName()));
                }
            }
            if (permission.getExclusiveGroup()) {
                exclusiveGroupPermissions.add(permission.getName());
            }
        }
    }
    return new PermissionCollection(permissions, overridden, ruleProps, perUser);
}
#end_block

#method_before
private Capable verifyActiveContributorAgreement() {
    if (!(user.isIdentifiedUser())) {
        return new Capable("Must be logged in to verify Contributor Agreement");
    }
    final IdentifiedUser iUser = user.asIdentifiedUser();
    List<AccountGroup.UUID> okGroupIds = Lists.newArrayList();
    for (ContributorAgreement ca : contributorAgreements) {
        List<AccountGroup.UUID> groupIds;
        groupIds = okGroupIds;
        for (PermissionRule rule : ca.getAccepted()) {
            if ((rule.getAction() == Action.ALLOW) && (rule.getGroup() != null) && (rule.getGroup().getUUID() != null)) {
                groupIds.add(new AccountGroup.UUID(rule.getGroup().getUUID().get()));
            }
        }
    }
    if (iUser.getEffectiveGroups().containsAnyOf(okGroupIds)) {
        return Capable.OK;
    }
    final StringBuilder msg = new StringBuilder();
    msg.append(" A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#method_after
private Capable verifyActiveContributorAgreement() {
    if (!(user.isIdentifiedUser())) {
        return new Capable("Must be logged in to verify Contributor Agreement");
    }
    final IdentifiedUser iUser = user.asIdentifiedUser();
    List<AccountGroup.UUID> okGroupIds = new ArrayList<>();
    for (ContributorAgreement ca : contributorAgreements) {
        List<AccountGroup.UUID> groupIds;
        groupIds = okGroupIds;
        for (PermissionRule rule : ca.getAccepted()) {
            if ((rule.getAction() == Action.ALLOW) && (rule.getGroup() != null) && (rule.getGroup().getUUID() != null)) {
                groupIds.add(new AccountGroup.UUID(rule.getGroup().getUUID().get()));
            }
        }
    }
    if (iUser.getEffectiveGroups().containsAnyOf(okGroupIds)) {
        return Capable.OK;
    }
    final StringBuilder msg = new StringBuilder();
    msg.append(" A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#end_block

#method_before
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getUser().isIdentifiedUser()) {
        Collection<Account.Id> results = changeData(db, cd).reviewers().values();
        return results.contains(getUser().getAccountId());
    }
    return false;
}
#method_after
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getUser().isIdentifiedUser()) {
        Collection<Account.Id> results = changeData(db, cd).reviewers().all();
        return results.contains(getUser().getAccountId());
    }
    return false;
}
#end_block

#method_before
public static String refsDraftComments(Account.Id accountId, Change.Id changeId) {
    StringBuilder r = buildRefsPrefix(REFS_DRAFT_COMMENTS, accountId.get());
    r.append(changeId.get());
    return r.toString();
}
#method_after
public static String refsDraftComments(Change.Id changeId, Account.Id accountId) {
    StringBuilder r = buildRefsPrefix(REFS_DRAFT_COMMENTS, changeId.get());
    r.append(accountId.get());
    return r.toString();
}
#end_block

#method_before
public static String refsDraftCommentsPrefix(Account.Id accountId) {
    return buildRefsPrefix(REFS_DRAFT_COMMENTS, accountId.get()).toString();
}
#method_after
public static String refsDraftCommentsPrefix(Change.Id changeId) {
    return buildRefsPrefix(REFS_DRAFT_COMMENTS, changeId.get()).toString();
}
#end_block

#method_before
public Collection<SubmoduleSubscription> subscribedTo(Branch.NameKey src) {
    logDebug("Checking for a subscription of " + src);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    if (subscriptions == null) {
        return ret;
    }
    for (SubmoduleSubscription s : subscriptions) {
        if (s.getSubmodule().equals(src)) {
            logDebug("Found " + s);
            ret.add(s);
        }
    }
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> subscribedTo(Branch.NameKey src) {
    logDebug("Checking for a subscription of " + src);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    for (SubmoduleSubscription s : subscriptions) {
        if (s.getSubmodule().equals(src)) {
            logDebug("Found " + s);
            ret.add(s);
        }
    }
    return ret;
}
#end_block

#method_before
protected void prepareRelativeSubmoduleConfigEntry(Config config, String subscribeToRepoPrefix, String subscribeToRepo, String subscribeToBranch) {
    subscribeToRepo = name(subscribeToRepo);
    // The submodule subscription module checks for gerrit.canonicalWebUrl to
    // detect if it's configured for automatic updates. It doesn't matter if
    // it serves from that URL.
    String url = subscribeToRepoPrefix + subscribeToRepo;
    config.setString("submodule", subscribeToRepo, "path", subscribeToRepo);
    config.setString("submodule", subscribeToRepo, "url", url);
    if (subscribeToBranch != null) {
        config.setString("submodule", subscribeToRepo, "branch", subscribeToBranch);
    }
}
#method_after
protected void prepareRelativeSubmoduleConfigEntry(Config config, String subscribeToRepoPrefix, String subscribeToRepo, String subscribeToBranch) {
    subscribeToRepo = name(subscribeToRepo);
    String url = subscribeToRepoPrefix + subscribeToRepo;
    config.setString("submodule", subscribeToRepo, "path", subscribeToRepo);
    config.setString("submodule", subscribeToRepo, "url", url);
    if (subscribeToBranch != null) {
        config.setString("submodule", subscribeToRepo, "branch", subscribeToBranch);
    }
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc) throws IOException {
    try {
        ChangeEdit edit = rsrc.getChangeEdit();
        return Response.ok(fileContentUtil.getContent(rsrc.getControl().getProjectControl().getProjectState(), base ? ObjectId.fromString(edit.getRevision().get()) : ObjectId.fromString(edit.getBasePatchSet().getRevision().get()), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc) throws IOException {
    try {
        ChangeEdit edit = rsrc.getChangeEdit();
        return Response.ok(fileContentUtil.getContent(rsrc.getControl().getProjectControl().getProjectState(), base ? ObjectId.fromString(edit.getBasePatchSet().getRevision().get()) : ObjectId.fromString(edit.getRevision().get()), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#end_block

#method_before
public static void get(PatchSet.Id id, String path, boolean base, HttpCallback<NativeString> cb) {
    RestApi api;
    if (id.get() != 0) {
        // Read from a published revision, when change edit doesn't
        // exist for the caller, or is not currently active.
        api = ChangeApi.revision(id).view("files").id(path).view("content");
    } else if (Patch.COMMIT_MSG.equals(path)) {
        api = editMessage(id.getParentKey().get());
    } else {
        api = editFile(id.getParentKey().get(), path);
    }
    api.addParameter("base", base).get(cb);
}
#method_after
public static void get(PatchSet.Id id, String path, boolean base, HttpCallback<NativeString> cb) {
    RestApi api;
    if (id.get() != 0) {
        // Read from a published revision, when change edit doesn't
        // exist for the caller, or is not currently active.
        api = ChangeApi.revision(id).view("files").id(path).view("content");
    } else if (Patch.COMMIT_MSG.equals(path)) {
        api = editMessage(id.getParentKey().get()).addParameter("base", base);
    } else {
        api = editFile(id.getParentKey().get(), path).addParameter("base", base);
    }
    api.get(cb);
}
#end_block

#method_before
@Test
public void starUnstarChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.accounts().self().starChange(triplet);
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).contains(StarredChangesUtil.DEFAULT_LABEL);
    gApi.accounts().self().unstarChange(triplet);
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).isNull();
}
#method_after
@Test
public void starUnstarChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.accounts().self().starChange(triplet);
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).contains(DEFAULT_LABEL);
    gApi.accounts().self().unstarChange(triplet);
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).isNull();
}
#end_block

#method_before
@Test
public void starUnstarChangeWithLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    assertThat(gApi.accounts().self().getStars(triplet)).isEmpty();
    assertThat(gApi.accounts().self().getStarredChanges()).isEmpty();
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "red", "blue"))));
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).containsExactly("blue", "red", StarredChangesUtil.DEFAULT_LABEL).inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("blue", "red", StarredChangesUtil.DEFAULT_LABEL).inOrder();
    List<ChangeInfo> starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    ChangeInfo starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isTrue();
    assertThat(starredChange.stars).containsExactly("blue", "red", StarredChangesUtil.DEFAULT_LABEL).inOrder();
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList("yellow")), new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "blue"))));
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).containsExactly("red", "yellow").inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("red", "yellow").inOrder();
    starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isNull();
    assertThat(starredChange.stars).containsExactly("red", "yellow").inOrder();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get stars of another account");
    gApi.accounts().id(Integer.toString((admin.id.get()))).getStars(triplet);
}
#method_after
@Test
public void starUnstarChangeWithLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    assertThat(gApi.accounts().self().getStars(triplet)).isEmpty();
    assertThat(gApi.accounts().self().getStarredChanges()).isEmpty();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "red", "blue")));
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    List<ChangeInfo> starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    ChangeInfo starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isTrue();
    assertThat(starredChange.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of("yellow"), ImmutableSet.of(DEFAULT_LABEL, "blue")));
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).containsExactly("red", "yellow").inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("red", "yellow").inOrder();
    starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isNull();
    assertThat(starredChange.stars).containsExactly("red", "yellow").inOrder();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get stars of another account");
    gApi.accounts().id(Integer.toString((admin.id.get()))).getStars(triplet);
}
#end_block

#method_before
@Test
public void starWithInvalidLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("invalid labels: another invalid label, invalid label");
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "invalid label", "blue", "another invalid label"))));
}
#method_after
@Test
public void starWithInvalidLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("invalid labels: another invalid label, invalid label");
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "invalid label", "blue", "another invalid label")));
}
#end_block

#method_before
@Test
public void starWithDefaultAndIgnoreLabel() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("The labels " + StarredChangesUtil.DEFAULT_LABEL + " and " + StarredChangesUtil.IGNORE_LABEL + " are mutually exclusive." + " Only one of them can be set.");
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "blue", StarredChangesUtil.IGNORE_LABEL))));
}
#method_after
@Test
public void starWithDefaultAndIgnoreLabel() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("The labels " + DEFAULT_LABEL + " and " + IGNORE_LABEL + " are mutually exclusive." + " Only one of them can be set.");
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "blue", IGNORE_LABEL)));
}
#end_block

#method_before
@Test
public void ignoreChange() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    setApiUser(user);
    gApi.accounts().self().setStars(r.getChangeId(), new StarsInput(ImmutableSet.of(StarredChangesUtil.IGNORE_LABEL)));
    sender.clear();
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).abandon();
    assertThat(sender.getMessages()).hasSize(0);
}
#method_after
@Test
public void ignoreChange() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    TestAccount user2 = accounts.user2();
    in = new AddReviewerInput();
    in.reviewer = user2.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    setApiUser(user);
    gApi.accounts().self().setStars(r.getChangeId(), new StarsInput(ImmutableSet.of(IGNORE_LABEL)));
    sender.clear();
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).abandon();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    assertThat(messages.get(0).rcpt()).containsExactly(user2.emailAddress);
}
#end_block

#method_before
@Test
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    // Add an existing key again
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
}
#method_after
@Test
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    assertSequenceNumbers(info);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    // Add an existing key (the request succeeds, but the key isn't added again)
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    // Add another new key
    String newKey2 = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
    assertSequenceNumbers(info);
    // Delete second key
    gApi.accounts().self().deleteSshKey(2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(1).seq).isEqualTo(3);
}
#end_block

#method_before
protected void bccStarredBy() {
    if (!NotifyHandling.ALL.equals(notify)) {
        return;
    }
    try {
        // BCC anyone who has starred this change
        // and remove anyone who has ignored this change.
        // 
        Multimap<Account.Id, String> stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
        for (Map.Entry<Account.Id, Collection<String>> e : stars.asMap().entrySet()) {
            if (e.getValue().contains(StarredChangesUtil.DEFAULT_LABEL)) {
                super.add(RecipientType.BCC, e.getKey());
            }
            if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) {
                AccountState accountState = args.accountCache.get(e.getKey());
                if (accountState != null) {
                    super.removeUser(accountState.getAccount());
                }
            }
        }
    } catch (OrmException | NoSuchChangeException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot BCC users that starred updated change", err);
    }
}
#method_after
protected void bccStarredBy() {
    if (!NotifyHandling.ALL.equals(notify)) {
        return;
    }
    try {
        // BCC anyone who has starred this change
        // and remove anyone who has ignored this change.
        // 
        Multimap<Account.Id, String> stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
        for (Map.Entry<Account.Id, Collection<String>> e : stars.asMap().entrySet()) {
            if (e.getValue().contains(StarredChangesUtil.DEFAULT_LABEL)) {
                super.add(RecipientType.BCC, e.getKey());
            }
            if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) {
                AccountState accountState = args.accountCache.get(e.getKey());
                if (accountState != null) {
                    removeUser(accountState.getAccount());
                }
            }
        }
    } catch (OrmException | NoSuchChangeException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot BCC users that starred updated change", err);
    }
}
#end_block

#method_before
public static StarField parse(String s) {
    int p = s.indexOf(SEPARATOR);
    if (p >= 0) {
        try {
            Account.Id accountId = Account.Id.parse(s.substring(0, p));
            String label = s.substring(p + 1);
            return create(accountId, label);
        } catch (NumberFormatException e) {
            return null;
        }
    }
    return null;
}
#method_after
public static StarField parse(String s) {
    int p = s.indexOf(SEPARATOR);
    if (p >= 0) {
        Integer id = Ints.tryParse(s.substring(0, p));
        if (id == null) {
            return null;
        }
        Account.Id accountId = new Account.Id(id);
        String label = s.substring(p + 1);
        return create(accountId, label);
    }
    return null;
}
#end_block

#method_before
public ImmutableSortedSet<String> star(Account.Id accountId, Project.NameKey project, Change.Id changeId, Set<String> labelsToAdd, Set<String> labelsToRemove) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        if (labelsToAdd != null) {
            labels.addAll(labelsToAdd);
        }
        if (labelsToRemove != null) {
            labels.removeAll(labelsToRemove);
        }
        if (labels.isEmpty()) {
            deleteRef(repo, refName, oldObjectId);
        } else {
            if (labels.contains(DEFAULT_LABEL) && labels.contains(IGNORE_LABEL)) {
                throw IllegalLabelException.mutuallyExclusiveLabels(DEFAULT_LABEL, IGNORE_LABEL);
            }
            updateLabels(repo, refName, oldObjectId, labels);
        }
        indexer.index(dbProvider.get(), project, changeId);
        return ImmutableSortedSet.copyOf(labels);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public ImmutableSortedSet<String> star(Account.Id accountId, Project.NameKey project, Change.Id changeId, Set<String> labelsToAdd, Set<String> labelsToRemove) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        if (labelsToAdd != null) {
            labels.addAll(labelsToAdd);
        }
        if (labelsToRemove != null) {
            labels.removeAll(labelsToRemove);
        }
        if (labels.isEmpty()) {
            deleteRef(repo, refName, oldObjectId);
        } else {
            checkMutuallyExclusiveLabels(labels);
            updateLabels(repo, refName, oldObjectId, labels);
        }
        indexer.index(dbProvider.get(), project, changeId);
        return ImmutableSortedSet.copyOf(labels);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public ImmutableMultimap<Account.Id, String> byChange(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        ImmutableMultimap.Builder<Account.Id, String> builder = new ImmutableMultimap.Builder<>();
        for (String refPart : getRefNames(repo, RefNames.refsStarredChangesPrefix(changeId))) {
            Account.Id accountId = Account.Id.parse(refPart);
            builder.putAll(accountId, readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)));
        }
        return builder.build();
    } catch (IOException e) {
        throw new OrmException(String.format("Get accounts that starred change %d failed", changeId.get()), e);
    }
}
#method_after
public ImmutableMultimap<Account.Id, String> byChange(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        ImmutableMultimap.Builder<Account.Id, String> builder = new ImmutableMultimap.Builder<>();
        for (String refPart : getRefNames(repo, RefNames.refsStarredChangesPrefix(changeId))) {
            Integer id = Ints.tryParse(refPart);
            if (id == null) {
                continue;
            }
            Account.Id accountId = new Account.Id(id);
            builder.putAll(accountId, readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)));
        }
        return builder.build();
    } catch (IOException e) {
        throw new OrmException(String.format("Get accounts that starred change %d failed", changeId.get()), e);
    }
}
#end_block

#method_before
private static void validateLabels(Set<String> labels) {
    if (labels == null) {
        return;
    }
    SortedSet<String> invalidLabels = new TreeSet<>();
    for (String label : labels) {
        if (CharMatcher.WHITESPACE.matchesAnyOf(label)) {
            invalidLabels.add(label);
        }
    }
    if (!invalidLabels.isEmpty()) {
        throw IllegalLabelException.invalidLabels(invalidLabels);
    }
}
#method_after
private static void validateLabels(Set<String> labels) {
    if (labels == null) {
        return;
    }
    SortedSet<String> invalidLabels = new TreeSet<>();
    for (String label : labels) {
        if (CharMatcher.whitespace().matchesAnyOf(label)) {
            invalidLabels.add(label);
        }
    }
    if (!invalidLabels.isEmpty()) {
        throw IllegalLabelException.invalidLabels(invalidLabels);
    }
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    RevCommit commit = receiveEvent.commit;
    final List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    List<CommitValidationMessage> messages = new LinkedList<>();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            String sha1 = commit.getId().name().substring(0, SHA1_LENGTH);
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && shortMsg.substring(CHANGE_ID_PREFIX.length()).trim().matches(SHA1_PATTERN)) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String sha1 = commit.getId().name().substring(0, SHA1_LENGTH);
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    }
    String v = idList.get(idList.size() - 1).trim();
    if (!v.matches(SHA1_PATTERN)) {
        String sha1 = commit.getId().name().substring(0, SHA1_LENGTH);
        String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
        messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
        throw new CommitValidationException(errMsg, messages);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new LinkedList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    }
    String v = idList.get(idList.size() - 1).trim();
    if (!CHANGE_ID.matcher(v).matches()) {
        String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
        messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
        throw new CommitValidationException(errMsg, messages);
    }
    return Collections.emptyList();
}
#end_block

#method_before
private static boolean isSingleQuery(String query) {
    return (NUMERIC_ID.test(query) || CHANGE_ID.test(query) || COMMIT_SHA1.test(query));
}
#method_after
private static boolean isSingleQuery(String query) {
    return NUMERIC_ID.test(query) || CHANGE_ID.test(query) || COMMIT_SHA1.test(query);
}
#end_block

#method_before
private static boolean isSingleQuery(String query) {
    if (query.matches("^[1-9][0-9]*$")) {
        // 
        return true;
    }
    if (query.matches(CHANGE_ID_PATTERN) || query.matches(UNIQUE_CHANGE_ID_PATTERN)) {
        // Newer style Change-Id and Unique Change Id in format [project]~[ref]~[changeId]
        return true;
    }
    if (query.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$")) {
        // 
        return true;
    }
    return false;
}
#method_after
private static boolean isSingleQuery(String query) {
    return NUMERIC_ID.test(query) || CHANGE_ID.test(query) || CHANGE_ID_TRIPLET.test(query) || COMMIT_SHA1.test(query);
}
#end_block

#method_before
@Override
public CurrentUser getUser() {
    boolean signedIn = isSignedIn();
    if (user == null || (signedIn && user == anonymousUser)) {
        if (signedIn) {
            user = identified.create(val.getAccountId());
        } else {
            user = anonymousUser = anonymousProvider.get();
        }
    }
    return user;
}
#method_after
@Override
public CurrentUser getUser() {
    if (user == null) {
        if (isSignedIn()) {
            user = identified.create(val.getAccountId());
        } else {
            user = anonymousProvider.get();
        }
    }
    return user;
}
#end_block

#method_before
@Override
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null, null);
    saveCookie();
}
#method_after
@Override
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null, null);
    saveCookie();
    user = identified.create(val.getAccountId());
}
#end_block

#method_before
@Override
public void logout() {
    if (val != null) {
        manager.destroy(key);
        key = null;
        val = null;
        saveCookie();
    }
}
#method_after
@Override
public void logout() {
    if (val != null) {
        manager.destroy(key);
        key = null;
        val = null;
        saveCookie();
        user = anonymousProvider.get();
    }
}
#end_block

#method_before
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch, MergeOpRepoManager orm) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(branch)) {
        logDebug("Checking subscribe section " + s);
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s, orm);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm);
            m.load();
            for (SubmoduleSubscription ss : m.subscribedTo(branch)) {
                logDebug("Checking SubmoduleSubscription " + ss);
                if (projectCache.get(ss.getSubmodule().getParentKey()) != null) {
                    logDebug("adding SubmoduleSubscription " + ss);
                    ret.add(ss);
                }
            }
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch, MergeOpRepoManager orm) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(branch)) {
        logDebug("Checking subscribe section " + s);
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s, orm);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm);
            m.load();
            for (SubmoduleSubscription ss : m.subscribedTo(branch)) {
                logDebug("Checking SubmoduleSubscription " + ss);
                if (projectCache.get(ss.getSubmodule().getParentKey()) != null) {
                    logDebug("Adding SubmoduleSubscription " + ss);
                    ret.add(ss);
                }
            }
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#end_block

#method_before
void load() throws IOException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try {
        orm.openRepo(project, false);
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
    OpenRepo or = orm.getRepo(project);
    ObjectId id = or.repo.resolve(branch.get());
    if (id == null) {
        throw new IOException("Cannot open branch " + branch.get());
    }
    RevCommit commit = or.rw.parseCommit(id);
    TreeWalk tw = TreeWalk.forPath(or.repo, GIT_MODULES, commit.getTree());
    if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
        return;
    }
    try {
        BlobBasedConfig bbc = new BlobBasedConfig(null, or.repo, commit, GIT_MODULES);
        subscriptions = new SubmoduleSectionParser(bbc, thisServer, branch).parseAllSections();
    } catch (ConfigInvalidException e) {
        throw new IOException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#method_after
void load() throws IOException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try {
        orm.openRepo(project, false);
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
    OpenRepo or = orm.getRepo(project);
    ObjectId id = or.repo.resolve(branch.get());
    if (id == null) {
        throw new IOException("Cannot open branch " + branch.get());
    }
    RevCommit commit = or.rw.parseCommit(id);
    TreeWalk tw = TreeWalk.forPath(or.repo, GIT_MODULES, commit.getTree());
    if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
        return;
    }
    try {
        BlobBasedConfig bbc = new BlobBasedConfig(null, or.repo, commit, GIT_MODULES);
        subscriptions = new SubmoduleSectionParser(bbc, canonicalWebUrl, branch).parseAllSections();
    } catch (ConfigInvalidException e) {
        throw new IOException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#end_block

#method_before
private SubmoduleSubscription parse(final String id) {
    final String url = bbc.getString("submodule", id, "url");
    final String path = bbc.getString("submodule", id, "path");
    String branch = bbc.getString("submodule", id, "branch");
    try {
        if (url != null && url.length() > 0 && path != null && path.length() > 0 && branch != null && branch.length() > 0) {
            // All required fields filled.
            String project;
            if (branch.equals(".")) {
                branch = superProjectBranch.get();
            }
            // relative URL
            if (url.startsWith("../")) {
                // prefix with a slash for easier relative path walks
                project = '/' + superProjectBranch.getParentKey().get();
                String hostPart = url;
                while (hostPart.startsWith("../")) {
                    int lastSlash = project.lastIndexOf('/');
                    if (lastSlash < 0) {
                        // too many levels up, ignore for now
                        return null;
                    }
                    project = project.substring(0, lastSlash);
                    hostPart = hostPart.substring(3);
                }
                project = project + "/" + hostPart;
                // remove leading '/'
                project = project.substring(1);
            } else {
                // It is actually an URI. It could be ssh://localhost/project-a.
                URI targetServerURI = new URI(url);
                URI thisServerURI = new URI(thisServer);
                if (!targetServerURI.getHost().equalsIgnoreCase(thisServerURI.getHost())) {
                    return null;
                }
                String p1 = targetServerURI.getPath();
                String p2 = thisServerURI.getPath();
                if (!p1.startsWith(p2)) {
                    // http://server/other-teams-gerrit/
                    return null;
                }
                // skip common part
                project = p1.substring(p2.length());
            }
            while (project.startsWith("/")) {
                project = project.substring(1);
            }
            if (project.endsWith(Constants.DOT_GIT_EXT)) {
                project = // 
                project.substring(// 
                0, project.length() - Constants.DOT_GIT_EXT.length());
            }
            Project.NameKey projectKey = new Project.NameKey(project);
            return new SubmoduleSubscription(superProjectBranch, new Branch.NameKey(projectKey, branch), path);
        }
    } catch (URISyntaxException e) {
    // Error in url syntax (in fact it is uri syntax)
    }
    return null;
}
#method_after
private SubmoduleSubscription parse(final String id) {
    final String url = bbc.getString("submodule", id, "url");
    final String path = bbc.getString("submodule", id, "path");
    String branch = bbc.getString("submodule", id, "branch");
    try {
        if (url != null && url.length() > 0 && path != null && path.length() > 0 && branch != null && branch.length() > 0) {
            // All required fields filled.
            String project;
            if (branch.equals(".")) {
                branch = superProjectBranch.get();
            }
            // relative URL
            if (url.startsWith("../")) {
                // prefix with a slash for easier relative path walks
                project = '/' + superProjectBranch.getParentKey().get();
                String hostPart = url;
                while (hostPart.startsWith("../")) {
                    int lastSlash = project.lastIndexOf('/');
                    if (lastSlash < 0) {
                        // too many levels up, ignore for now
                        return null;
                    }
                    project = project.substring(0, lastSlash);
                    hostPart = hostPart.substring(3);
                }
                project = project + "/" + hostPart;
                // remove leading '/'
                project = project.substring(1);
            } else {
                // It is actually an URI. It could be ssh://localhost/project-a.
                URI targetServerURI = new URI(url);
                URI thisServerURI = new URI(canonicalWebUrl);
                String thisHost = thisServerURI.getHost();
                String targetHost = targetServerURI.getHost();
                if (thisHost == null || targetHost == null || !targetHost.equalsIgnoreCase(thisHost)) {
                    return null;
                }
                String p1 = targetServerURI.getPath();
                String p2 = thisServerURI.getPath();
                if (!p1.startsWith(p2)) {
                    // http://server/other-teams-gerrit/
                    return null;
                }
                // skip common part
                project = p1.substring(p2.length());
            }
            while (project.startsWith("/")) {
                project = project.substring(1);
            }
            if (project.endsWith(Constants.DOT_GIT_EXT)) {
                project = // 
                project.substring(// 
                0, project.length() - Constants.DOT_GIT_EXT.length());
            }
            Project.NameKey projectKey = new Project.NameKey(project);
            return new SubmoduleSubscription(superProjectBranch, new Branch.NameKey(projectKey, branch), path);
        }
    } catch (URISyntaxException e) {
    // Error in url syntax (in fact it is uri syntax)
    }
    return null;
}
#end_block

#method_before
@Test
public void testFollowMasterBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = localpath-to-a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "localpath-to-a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testFollowMasterBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = localpath-to-a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "localpath-to-a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testFollowMatchingBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = .\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testFollowMatchingBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = .\n");
    Branch.NameKey targetBranch1 = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res1 = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch1).parseAllSections();
    Set<SubmoduleSubscription> expected1 = Sets.newHashSet(new SubmoduleSubscription(targetBranch1, new Branch.NameKey(p, "master"), "a"));
    assertThat(res1).containsExactlyElementsIn(expected1);
    Branch.NameKey targetBranch2 = new Branch.NameKey(new Project.NameKey("project"), "somebranch");
    Set<SubmoduleSubscription> res2 = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch2).parseAllSections();
    Set<SubmoduleSubscription> expected2 = Sets.newHashSet(new SubmoduleSubscription(targetBranch2, new Branch.NameKey(p, "somebranch"), "a"));
    assertThat(res2).containsExactlyElementsIn(expected2);
}
#end_block

#method_before
@Test
public void testFollowAnotherBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = anotherbranch\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "anotherbranch"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testFollowAnotherBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = anotherbranch\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "anotherbranch"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithAnotherURI() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithAnotherURI() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithSlashesInProjectName() throws Exception {
    Project.NameKey p = createProject("project/with/slashes/a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"project/with/slashes/a\"]\n" + "path = a\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithSlashesInProjectName() throws Exception {
    Project.NameKey p = createProject("project/with/slashes/a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"project/with/slashes/a\"]\n" + "path = a\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithSlashesInPath() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a/b/c/d/e\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a/b/c/d/e"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithSlashesInPath() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a/b/c/d/e\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a/b/c/d/e"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithMoreSections() throws Exception {
    Project.NameKey p1 = createProject("a");
    Project.NameKey p2 = createProject("b");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p1.get() + "\n" + // follow any branch including the master branch
    "branch = .\n" + "[submodule \"b\"]\n" + "    path = b\n" + "    url = http://localhost:80/" + p2.get() + "\n" + "    branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p2, "master"), "b"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithMoreSections() throws Exception {
    Project.NameKey p1 = createProject("a");
    Project.NameKey p2 = createProject("b");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "     path = a\n" + "     url = ssh://localhost/" + p1.get() + "\n" + "     branch = .\n" + "[submodule \"b\"]\n" + "		path = b\n" + "		url = http://localhost:80/" + p2.get() + "\n" + "		branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p2, "master"), "b"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithSubProjectFound() throws Exception {
    Project.NameKey p1 = createProject("a/b");
    Project.NameKey p2 = createProject("b");
    Config cfg = new Config();
    String gitmodules = "\n" + "[submodule \"a/b\"]\n" + "path = a/b\n" + "url = ssh://localhost/" + p1.get() + "\n" + "branch = .\n" + "[submodule \"b\"]\n" + "path = b\n" + "url = http://localhost/" + p2.get() + "\n" + "branch = .\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p2, "master"), "b"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a/b"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithSubProjectFound() throws Exception {
    Project.NameKey p1 = createProject("a/b");
    Project.NameKey p2 = createProject("b");
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a/b\"]\n" + "path = a/b\n" + "url = ssh://localhost/" + p1.get() + "\n" + "branch = .\n" + "[submodule \"b\"]\n" + "path = b\n" + "url = http://localhost/" + p2.get() + "\n" + "branch = .\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p2, "master"), "b"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a/b"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithAnInvalidSection() throws Exception {
    Project.NameKey p1 = createProject("a");
    Project.NameKey p2 = createProject("b");
    Project.NameKey p3 = createProject("d");
    Project.NameKey p4 = createProject("e");
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a\"]\n" + "    path = a\n" + "    url = ssh://localhost/" + p1.get() + "\n" + "    branch = .\n" + "[submodule \"b\"]\n" + // path missing
    "    url = http://localhost:80/" + p2.get() + "\n" + "    branch = master\n" + "[submodule \"c\"]\n" + "    path = c\n" + // url missing
    "    branch = .\n" + "[submodule \"d\"]\n" + "    path = d-parent/the-d-folder\n" + "    url = ssh://localhost/" + p3.get() + "\n" + // branch missing
    "[submodule \"e\"]\n" + "    path = e\n" + "    url = ssh://localhost/" + p4.get() + "\n" + "    branch = refs/heads/master\n");
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p4, "master"), "e"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithAnInvalidSection() throws Exception {
    Project.NameKey p1 = createProject("a");
    Project.NameKey p2 = createProject("b");
    Project.NameKey p3 = createProject("d");
    Project.NameKey p4 = createProject("e");
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a\"]\n" + "    path = a\n" + "    url = ssh://localhost/" + p1.get() + "\n" + "    branch = .\n" + "[submodule \"b\"]\n" + // path missing
    "    url = http://localhost:80/" + p2.get() + "\n" + "    branch = master\n" + "[submodule \"c\"]\n" + "    path = c\n" + // url missing
    "    branch = .\n" + "[submodule \"d\"]\n" + "    path = d-parent/the-d-folder\n" + "    url = ssh://localhost/" + p3.get() + "\n" + // branch missing
    "[submodule \"e\"]\n" + "    path = e\n" + "    url = ssh://localhost/" + p4.get() + "\n" + "    branch = refs/heads/master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p4, "master"), "e"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithSectionOfNonexistingProject() throws Exception {
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://non-localhost/a\n" + // Project "a" doesn't exist
    "branch = .\\n");
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    assertThat(res).isEmpty();
}
#method_after
@Test
public void testWithSectionOfNonexistingProject() throws Exception {
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://non-localhost/a\n" + // Project "a" doesn't exist
    "branch = .\\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    assertThat(res).isEmpty();
}
#end_block

#method_before
@Test
public void testWithSectionToOtherServer() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]" + "path = a" + "url = ssh://non-localhost/" + p1.get() + "\n" + "branch = .");
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    assertThat(res).isEmpty();
}
#method_after
@Test
public void testWithSectionToOtherServer() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]" + "path = a" + "url = ssh://non-localhost/" + p1.get() + "\n" + "branch = .");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    assertThat(res).isEmpty();
}
#end_block

#method_before
@Test
public void testWithRelativeURI() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ../" + p1.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithRelativeURI() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = ../" + p1.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithDeepRelativeURI() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ../../" + p1.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("nested/project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithDeepRelativeURI() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = ../../" + p1.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("nested/project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
private void index(Change.Id id, String operation) throws IOException, OrmException {
    AtomicInteger changeIdLock = getAndIncrementChangeIdLock(id);
    synchronized (changeIdLock) {
        if ("index".equals(operation)) {
            try (ReviewDb db = schemaFactory.open()) {
                Change change = db.changes().get(id);
                if (change == null) {
                    indexer.delete(id);
                    return;
                }
                indexer.index(db, change);
            }
            logger.debug("Change {} successfully indexed", id);
        } else if ("delete".equals(operation)) {
            indexer.delete(id);
            logger.debug("Change {} successfully deleted from index", id);
        }
    }
    if (changeIdLock.decrementAndGet() == 0) {
        removeChangeIdLock(id);
    }
}
#method_after
private void index(Change.Id id, String operation) throws IOException, OrmException {
    AtomicInteger changeIdLock = getAndIncrementChangeIdLock(id);
    synchronized (changeIdLock) {
        if ("index".equals(operation)) {
            try (ReviewDb db = schemaFactory.open()) {
                Change change = db.changes().get(id);
                if (change == null) {
                    indexer.delete(id);
                    return;
                }
                indexer.index(db, change);
            }
            logger.debug("Change {} successfully indexed", id);
        }
        if ("delete".equals(operation)) {
            indexer.delete(id);
            logger.debug("Change {} successfully deleted from index", id);
        }
    }
    if (changeIdLock.decrementAndGet() == 0) {
        removeChangeIdLock(id);
    }
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    hooks.doRefUpdatedHook(name, u, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    hooks.doRefUpdatedHook(name, u, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#end_block

#method_before
public void setMessageSender(final MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#method_after
public void setMessageSender(MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSubmoduleSubscriptions(db, branches);
        op.updateSuperProjects(db, branches);
    } catch (SubmoduleException e) {
        log.error("Can't update submodule subscriptions " + "or update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user);
        op.updateSuperProjects(db, branches, "receiveID", orm);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(change.getSubject()));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (RestApiException err) {
        log.error("Can't insert change/patchset for " + project.getName() + ". " + err.getMessage(), err);
        String rejection = "internal server error";
        if (err.getCause() != null) {
            rejection += ": " + err.getCause().getMessage();
        }
        reject(magicBranch.cmd, rejection);
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = new ArrayList<>();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), user.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.enabled()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#method_after
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.readChanges()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
CheckedFuture<Void, RestApiException> insertChange() throws IOException {
    rp.getRevWalk().parseBody(commit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, RestApiException, UpdateException {
            if (caller == Thread.currentThread()) {
                insertChange(ReceiveCommits.this.db);
            } else {
                try (ReviewDb threadLocalDb = schemaFactory.open()) {
                    insertChange(threadLocalDb);
                }
            }
            synchronized (newProgress) {
                newProgress.update(1);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<Void, RestApiException> insertChange() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, RestApiException, UpdateException, RepositoryNotFoundException, IOException, NoSuchChangeException {
            try (RequestState state = requestState(caller)) {
                insertChange(state);
            }
            synchronizedIncrement(newProgress);
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private void insertChange(ReviewDb threadLocalDb) throws OrmException, RestApiException, UpdateException {
    final PatchSet ps = ins.setGroups(groups).getPatchSet();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(ps.getPatchSetId(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(threadLocalDb, change.getProject(), user, change.getCreatedOn())) {
        bu.setRepository(repo, rp.getRevWalk(), oi);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(ins.getChange().getId(), hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        bu.execute();
    }
    created = true;
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    Account.Id me = user.getAccountId();
    List<FooterLine> footerLines = commit.getFooterLines();
    MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try {
        mergeOpProvider.get().merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    } catch (NoSuchChangeException e) {
        throw new OrmException(e);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException, NoSuchChangeException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false, new SubmitInput());
    }
    addMessage("");
    Change c = notesFactory.createChecked(db, project.getNameKey(), rsrc.getChange().getId()).getChange();
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<Change, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(db.changes().getAsync(request.ontoChange));
    }
    for (CheckedFuture<Change, OrmException> f : futures) {
        Change c = f.checkedGet();
        if (c != null) {
            replaceByChange.get(c.getId()).change = c;
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<ChangeNotes, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(notesFactory.createAsync(changeUpdateExector, db, project.getNameKey(), request.ontoChange));
    }
    for (CheckedFuture<ChangeNotes, OrmException> f : futures) {
        ChangeNotes notes = f.checkedGet();
        if (notes.getChange() != null) {
            replaceByChange.get(notes.getChangeId()).change = notes.getChange();
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private boolean newEdit() {
    newPatchSet = new PatchSet(change.currentPatchSetId());
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(change, user);
    } catch (IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(newPatchSet.getId())) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), newPatchSet.getId()));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(user.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    newPatchSet.setGroups(groups);
    if (rp.getPushCertificate() != null) {
        newPatchSet.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
}
#method_after
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, RestApiException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, NoSuchChangeException, ResourceConflictException {
            try {
                if (magicBranch != null && magicBranch.edit) {
                    return upsertEdit();
                } else if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    try (ReviewDb db = schemaFactory.open()) {
                        return insertPatchSet(db);
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, RestApiException> insertPatchSet() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
            try {
                if (magicBranch != null && magicBranch.edit) {
                    return upsertEdit();
                }
                try (RequestState state = requestState(caller)) {
                    return insertPatchSet(state);
                }
            } catch (OrmException | IOException e) {
                log.error("Failed to insert patch set", e);
                throw e;
            } finally {
                synchronizedIncrement(replaceProgress);
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return psId;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, ResourceConflictException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    Timestamp ts = TimeUtil.nowTs();
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        if (newPatchSet.getGroups() == null) {
            newPatchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
        }
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals, ts);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit, user.getAccount());
    revisionCreated.fire(change, newPatchSet, user.getAccountId());
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        changeMerged.fire(change, newPatchSet, user.getAccount(), newCommit.getName());
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        commentAdded.fire(change, newPatchSet, user.getAccount(), null, approvals, ts);
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ReplaceOp replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.addOp(change.getId(), replaceOp);
        bu.execute();
    }
    if (replaceOp.getRejectMessage() != null) {
        reject(inputCommand, replaceOp.getRejectMessage());
        return null;
    }
    groups = replaceOp.getGroups();
    // TODO(ekempin): mark changes as merged inside of ReplaceOp
    if (replaceOp.getMergedIntoRef() != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, replaceOp.getMergedIntoRef());
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    PatchSet newPatchSet = replaceOp.getPatchSet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit, user.getAccount());
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
CheckedFuture<Void, RestApiException> updateGroups() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                updateGroups(db);
            } else {
                try (ReviewDb db = schemaFactory.open()) {
                    updateGroups(db);
                }
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
private void updateGroups(RequestState state) throws RestApiException, UpdateException {
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.addOp(psId.getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
                List<String> oldGroups = ps.getGroups();
                if (oldGroups == null) {
                    if (groups == null) {
                        return false;
                    }
                } else if (sameGroups(oldGroups, groups)) {
                    return false;
                }
                psUtil.setGroups(ctx.getDb(), ctx.getUpdate(psId), ps, groups);
                return true;
            }
        });
        bu.execute();
    }
}
#end_block

#method_before
CheckedFuture<Void, RestApiException> updateGroups() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                updateGroups(db);
            } else {
                try (ReviewDb db = schemaFactory.open()) {
                    updateGroups(db);
                }
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<Void, RestApiException> updateGroups() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            try (RequestState state = requestState(caller)) {
                updateGroups(state);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (ReplaceRequest req : toClose) {
            PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommitId);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    changeMerged.fire(change, result.newPatchSet, user.getAccount(), commit.getName());
    hooks.doChangeMergedHook(change, user.getAccount(), result.newPatchSet, db, commit.getName());
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(ReceiveCommand cmd, PatchSet.Id psi, ObjectId commitId) throws OrmException, IOException, UpdateException, RestApiException {
    String refName = cmd.getRefName();
    Change.Id cid = psi.getParentKey();
    Change change;
    try {
        change = notesFactory.createChecked(db, project.getNameKey(), cid).getChange();
    } catch (NoSuchChangeException e) {
        log.warn(project.getName() + " change " + cid + " is missing");
        return null;
    }
    ChangeControl ctl = projectControl.controlFor(db, change);
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psi);
    if (ps == null) {
        log.warn(project.getName() + " patch set " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    RevCommit commit = rp.getRevWalk().parseCommit(commitId);
    rp.getRevWalk().parseBody(commit);
    PatchSetInfo info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    markChangeMergedByPush(db, info, refName);
    hooks.doChangeMergedHook(change, user.getAccount(), ps, db, commit.getName());
    sendMergedEmail(ps, info);
    return change.getKey();
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceRequest result) {
    final Change.Id id = result.change.getId();
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(id);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final PatchSet ps, final PatchSetInfo info) {
    sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                MergedSender cm = mergedSenderFactory.create(project.getNameKey(), ps.getId().getParentKey());
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(ps, info);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
private static boolean isHead(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#method_after
private static boolean isHead(ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#method_after
private static boolean isConfig(ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches) throws SubmoduleException {
    try {
        // These (repo/branch) will be updated later with all the given
        // individual submodule subscriptions
        Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : db.submoduleSubscriptions().bySubmodule(updatedBranch)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
        updatedSubscribers.addAll(updatedBranches);
        // Update subscribers.
        for (Branch.NameKey dest : targets.keySet()) {
            try {
                if (!updatedSubscribers.add(dest)) {
                    log.error("Possible circular subscription involving " + dest);
                } else {
                    updateGitlinks(db, dest, targets.get(dest));
                }
            } catch (SubmoduleException e) {
                log.warn("Cannot update gitlinks for " + dest, e);
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch, orm)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest), orm);
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Updated git submodules\n\n");
    boolean sameAuthorForAll = true;
    try (Repository pdb = repoManager.openRepository(subscriber.getParentKey())) {
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try (Repository subrepo = repoManager.openRepository(s.getSubmodule().getParentKey());
                RevWalk rw = CodeReviewCommit.newRevWalk(subrepo)) {
                Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
                if (ref == null) {
                    ed.add(new DeletePath(s.getPath()));
                    continue;
                }
                final ObjectId updateTo = ref.getObjectId();
                RevCommit newCommit = rw.parseCommit(updateTo);
                if (author == null) {
                    author = newCommit.getAuthorIdent();
                } else if (!author.equals(newCommit.getAuthorIdent())) {
                    sameAuthorForAll = false;
                }
                DirCacheEntry dce = dc.getEntry(s.getPath());
                ObjectId oldId;
                if (dce != null) {
                    if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                        log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                        continue;
                    }
                    oldId = dce.getObjectId();
                } else {
                    // This submodule did not exist before. We do not want to add
                    // the full submodule history to the commit message, so omit it.
                    oldId = updateTo;
                }
                ed.add(new PathEdit(s.getPath()) {

                    @Override
                    public void apply(DirCacheEntry ent) {
                        ent.setFileMode(FileMode.GITLINK);
                        ent.setObjectId(updateTo);
                    }
                });
                if (verboseSuperProject) {
                    msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                    msgbuf.append(" " + s.getSubmodule().getShortName());
                    msgbuf.append(" " + updateTo.getName());
                    msgbuf.append("\n\n");
                    try {
                        rw.markStart(newCommit);
                        rw.markUninteresting(rw.parseCommit(oldId));
                        for (RevCommit c : rw) {
                            msgbuf.append(c.getFullMessage() + "\n\n");
                        }
                    } catch (IOException e) {
                        logAndThrowSubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                    }
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber));
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates, MergeOpRepoManager orm) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId, orm);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#method_after
private static DirCache readTree(final Ref branch, RevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, rw.getObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#end_block

#method_before
public Repository getRepository() throws IOException {
    initRepository();
    return repo;
}
#method_after
@Override
public Repository getRepository() throws IOException {
    return BatchUpdate.this.getRepository();
}
#end_block

#method_before
public ObjectInserter getInserter() throws IOException {
    initRepository();
    return inserter;
}
#method_after
public ObjectInserter getInserter() throws IOException {
    return BatchUpdate.this.getObjectInserter();
}
#end_block

#method_before
public void addRefUpdate(ReceiveCommand cmd) throws IOException {
    getBatchRefUpdate().addCommand(cmd);
}
#method_after
public void addRefUpdate(ReceiveCommand cmd) throws IOException {
    initRepository();
    commands.add(cmd);
}
#end_block

#method_before
public Change getChange() {
    return update.getChange();
}
#method_after
public Change getChange() {
    Change c = ctl.getChange();
    checkNotNull(c);
    return c;
}
#end_block

#method_before
@SuppressWarnings("unused")
public void updateChange(ChangeContext ctx) throws Exception {
}
#method_after
@SuppressWarnings("unused")
public boolean updateChange(ChangeContext ctx) throws Exception {
    return false;
}
#end_block

#method_before
public void execute() throws UpdateException, RestApiException {
    try {
        executeRefUpdates();
        executeChangeOps();
        reindexChanges();
        if (batchRefUpdate != null) {
            // Fire ref update events only after all mutations are finished, since
            // callers may assume a patch set ref being created means the change was
            // created, or a branch advancing meaning some changes were closed.
            gitRefUpdated.fire(project, batchRefUpdate, user.getAccountId());
        }
        executePostOps();
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#method_after
static void execute(Collection<BatchUpdate> updates, Listener listener) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    try {
        Order order = getOrder(updates);
        switch(order) {
            case REPO_BEFORE_DB:
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates();
                }
                listener.afterRefUpdates();
                for (BatchUpdate u : updates) {
                    u.executeChangeOps();
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (BatchUpdate u : updates) {
                    u.executeChangeOps();
                }
                listener.afterUpdateChanges();
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates();
                }
                listener.afterRefUpdates();
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        List<CheckedFuture<?, IOException>> indexFutures = new ArrayList<>();
        for (BatchUpdate u : updates) {
            indexFutures.addAll(u.indexFutures);
        }
        ChangeIndexer.allAsList(indexFutures).get();
        for (BatchUpdate u : updates) {
            if (u.batchRefUpdate != null) {
                // Fire ref update events only after all mutations are finished, since
                // callers may assume a patch set ref being created means the change
                // was created, or a branch advancing meaning some changes were
                // closed.
                u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getUser().isIdentifiedUser() ? u.getUser().getAccountId() : null);
            }
        }
        for (BatchUpdate u : updates) {
            u.executePostOps();
        }
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    // Convert other common non-REST exception types with user-visible
    // messages to corresponding REST exception types
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    } catch (NoSuchChangeException | NoSuchRefException | NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
public BatchUpdate setRepository(Repository repo, RevWalk revWalk, ObjectInserter inserter) {
    checkState(this.repo == null, "repo already set");
    closeRepo = false;
    this.repo = checkNotNull(repo, "repo");
    this.revWalk = checkNotNull(revWalk, "revWalk");
    this.inserter = checkNotNull(inserter, "inserter");
    return this;
}
#method_after
public BatchUpdate setRepository(Repository repo, RevWalk revWalk, ObjectInserter inserter) {
    checkState(this.repo == null, "repo already set");
    closeRepo = false;
    this.repo = checkNotNull(repo, "repo");
    this.revWalk = checkNotNull(revWalk, "revWalk");
    this.inserter = checkNotNull(inserter, "inserter");
    commands = new ChainedReceiveCommands(repo);
    return this;
}
#end_block

#method_before
private void initRepository() throws IOException {
    if (repo == null) {
        this.repo = repoManager.openRepository(project);
        closeRepo = true;
        inserter = repo.newObjectInserter();
        revWalk = new RevWalk(inserter.newReader());
    }
}
#method_after
private void initRepository() throws IOException {
    if (repo == null) {
        this.repo = repoManager.openRepository(project);
        closeRepo = true;
        inserter = repo.newObjectInserter();
        revWalk = new RevWalk(inserter.newReader());
        commands = new ChainedReceiveCommands(repo);
    }
}
#end_block

#method_before
public BatchUpdate insertChange(InsertChangeOp op) {
    Change c = op.getChange();
    checkArgument(!newChanges.containsKey(c.getId()), "only one op allowed to create change %s", c.getId());
    newChanges.put(c.getId(), c);
    ops.get(c.getId()).add(0, op);
    return this;
}
#method_after
public BatchUpdate insertChange(InsertChangeOp op) {
    Context ctx = new Context();
    Change c = op.createChange(ctx);
    checkArgument(!newChanges.containsKey(c.getId()), "only one op allowed to create change %s", c.getId());
    newChanges.put(c.getId(), c);
    ops.get(c.getId()).add(0, op);
    return this;
}
#end_block

#method_before
public void execute() throws UpdateException, RestApiException {
    try {
        executeRefUpdates();
        executeChangeOps();
        reindexChanges();
        if (batchRefUpdate != null) {
            // Fire ref update events only after all mutations are finished, since
            // callers may assume a patch set ref being created means the change was
            // created, or a branch advancing meaning some changes were closed.
            gitRefUpdated.fire(project, batchRefUpdate, user.getAccountId());
        }
        executePostOps();
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#method_after
public void execute() throws UpdateException, RestApiException {
    execute(Listener.NONE);
}
#end_block

#method_before
private void executeRefUpdates() throws IOException, UpdateException, RestApiException {
    try {
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
    if (repo == null || batchRefUpdate == null || batchRefUpdate.getCommands().isEmpty()) {
        return;
    }
    inserter.flush();
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#method_after
private void executeRefUpdates() throws IOException, UpdateException {
    if (commands == null || commands.isEmpty()) {
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#end_block

#method_before
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            try {
                ctx = newChangeContext(id);
                for (Op op : e.getValue()) {
                    op.updateChange(ctx);
                }
                db.commit();
            } finally {
                db.rollback();
            }
            ctx.getChangeUpdate().commit();
            indexFutures.add(indexer.indexAsync(id));
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            NoteDbUpdateManager updateManager = null;
            boolean dirty = false;
            try {
                ctx = newChangeContext(id);
                // Call updateChange on each op.
                for (Op op : e.getValue()) {
                    dirty |= op.updateChange(ctx);
                }
                if (!dirty) {
                    return;
                }
                // Stage the NoteDb update and store its state in the Change.
                if (!ctx.deleted && notesMigration.writeChanges()) {
                    updateManager = stageNoteDbUpdate(ctx);
                }
                // Bump lastUpdatedOn or rowVersion and commit.
                Iterable<Change> cs = changesToUpdate(ctx);
                if (newChanges.containsKey(id)) {
                    // Insert rather than upsert in case of a race on change IDs.
                    db.changes().insert(cs);
                } else if (ctx.deleted) {
                    db.changes().delete(cs);
                } else {
                    db.changes().update(cs);
                }
                db.commit();
            } finally {
                db.rollback();
            }
            // Execute NoteDb updates after committing ReviewDb updates.
            if (notesMigration.writeChanges()) {
                if (updateManager != null) {
                    updateManager.execute();
                }
                if (ctx.deleted) {
                    new ChangeDelete(plcUtil, getRepository(), ctx.getNotes()).delete();
                }
            }
            // Reindex changes.
            if (ctx.deleted) {
                indexFutures.add(indexer.deleteAsync(id));
            } else {
                indexFutures.add(indexer.indexAsync(ctx.getProject(), id));
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
private ChangeContext newChangeContext(Change.Id id) throws Exception {
    Change c = newChanges.get(id);
    if (c == null) {
        c = db.changes().get(id);
    }
    // - attempting to read a change that doesn't exist yet
    return new ChangeContext(changeControlFactory.controlFor(c, user));
}
#method_after
private ChangeContext newChangeContext(Change.Id id) throws Exception {
    Change c = newChanges.get(id);
    if (c == null) {
        c = unwrap(db).changes().get(id);
    }
    // Pass in preloaded change to controlFor, to avoid:
    // - reading from a db that does not belong to this update
    // - attempting to read a change that doesn't exist yet
    ChangeNotes notes = changeNotesFactory.createForNew(c);
    ChangeContext ctx = new ChangeContext(changeControlFactory.controlFor(notes, user), new BatchUpdateReviewDb(db));
    return ctx;
}
#end_block

#method_before
private void updateRef(String notesBranch) throws IOException, MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, ConcurrentRefUpdateException {
    if (baseCommit != null && oursCommit.getTree().equals(baseCommit.getTree())) {
        // Avoid saving this commit as it has no new information.
        return;
    }
    int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
    RefUpdate refUpdate = createRefUpdate(notesBranch, oursCommit, baseCommit);
    for (; ; ) {
        Result result = refUpdate.update();
        if (result == Result.LOCK_FAILURE) {
            if (--remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException e) {
                // ignore
                }
            } else {
                throw new ConcurrentRefUpdateException("Failed to lock the ref: " + notesBranch, refUpdate.getRef(), result);
            }
        } else if (result == Result.REJECTED) {
            RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
            NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
            NoteMapMerger merger = new NoteMapMerger(db, getNoteMerger(), MergeStrategy.RESOLVE);
            NoteMap merged = merger.merge(base, ours, theirs);
            RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
            refUpdate = createRefUpdate(notesBranch, mergeCommit, theirsCommit);
            remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        } else if (result == Result.IO_FAILURE) {
            throw new IOException("Couldn't update " + notesBranch + ". " + result.name());
        } else {
            AccountInfo gerrit = new AccountInfo(null);
            gerrit.name = gerritIdent.getName();
            gerrit.email = gerritIdent.getEmailAddress();
            gitRefUpdated.fire(project, refUpdate, gerrit);
            break;
        }
    }
}
#method_after
private void updateRef(String notesBranch) throws IOException, MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, ConcurrentRefUpdateException {
    if (baseCommit != null && oursCommit.getTree().equals(baseCommit.getTree())) {
        // Avoid saving this commit as it has no new information.
        return;
    }
    int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
    RefUpdate refUpdate = createRefUpdate(notesBranch, oursCommit, baseCommit);
    for (; ; ) {
        Result result = refUpdate.update();
        if (result == Result.LOCK_FAILURE) {
            if (--remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException e) {
                // ignore
                }
            } else {
                throw new ConcurrentRefUpdateException("Failed to lock the ref: " + notesBranch, refUpdate.getRef(), result);
            }
        } else if (result == Result.REJECTED) {
            RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
            NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
            NoteMapMerger merger = new NoteMapMerger(db, getNoteMerger(), MergeStrategy.RESOLVE);
            NoteMap merged = merger.merge(base, ours, theirs);
            RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
            refUpdate = createRefUpdate(notesBranch, mergeCommit, theirsCommit);
            remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        } else if (result == Result.IO_FAILURE) {
            throw new IOException("Couldn't update " + notesBranch + ". " + result.name());
        } else {
            gitRefUpdated.fire(project, refUpdate, (AccountInfo) null);
            break;
        }
    }
}
#end_block

#method_before
public MetaDataUpdate create(Project.NameKey name, Repository repository, IdentifiedUser user, BatchRefUpdate batch) {
    MetaDataUpdate md = factory.create(name, repository, batch);
    md.getCommitBuilder().setAuthor(createPersonIdent(user));
    md.getCommitBuilder().setCommitter(serverIdent);
    return md;
}
#method_after
public MetaDataUpdate create(Project.NameKey name, Repository repository, IdentifiedUser user, BatchRefUpdate batch) {
    MetaDataUpdate md = factory.create(name, repository, batch);
    md.getCommitBuilder().setCommitter(serverIdent);
    md.setAuthor(user);
    return md;
}
#end_block

#method_before
public void setAuthor(IdentifiedUser user) {
    this.user = user;
    getCommitBuilder().setAuthor(user.newCommitterIdent(getCommitBuilder().getCommitter().getWhen(), getCommitBuilder().getCommitter().getTimeZone()));
}
#method_after
public void setAuthor(IdentifiedUser author) {
    this.author = author;
    getCommitBuilder().setAuthor(author.newCommitterIdent(getCommitBuilder().getCommitter().getWhen(), getCommitBuilder().getCommitter().getTimeZone()));
}
#end_block

#method_before
public void close() {
    getRepository().close();
}
#method_after
@Override
public void close() {
    getRepository().close();
}
#end_block

#method_before
void fireGitRefUpdatedEvent(RefUpdate ru) {
    gitRefUpdated.fire(projectName, ru, user.getAccount());
}
#method_after
void fireGitRefUpdatedEvent(RefUpdate ru) {
    gitRefUpdated.fire(projectName, ru, author == null ? null : author.getAccount());
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(ProjectUtil.stripGitSuffix(name));
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = normalizeBranchNames(input.branches);
    if (input.owners == null || input.owners.isEmpty()) {
        args.ownerIds = new ArrayList<>(projectOwnerGroups.create(args.getProject()).get());
    } else {
        args.ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            args.ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProject(args);
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(projectControl, in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(ProjectUtil.stripGitSuffix(name));
    String parentName = MoreObjects.firstNonNull(Strings.emptyToNull(input.parent), allProjects.get());
    args.newParent = projectsCollection.get().parse(parentName).getControl();
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = normalizeBranchNames(input.branches);
    if (input.owners == null || input.owners.isEmpty()) {
        args.ownerIds = new ArrayList<>(projectOwnerGroups.create(args.getProject()).get());
    } else {
        args.ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            args.ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProject(args);
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(projectControl, in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#end_block

#method_before
private void createProjectConfig(CreateProjectArgs args) throws IOException, ConfigInvalidException {
    MetaDataUpdate md = metaDataUpdateFactory.create(args.getProject());
    try {
        ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(args.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(args.submitType, repositoryCfg.getDefaultSubmitType(args.getProject())));
        newProject.setUseContributorAgreements(args.contributorAgreements);
        newProject.setUseSignedOffBy(args.signedOffBy);
        newProject.setUseContentMerge(args.contentMerge);
        newProject.setCreateNewChangeForAllNotInTarget(args.newChangeForAllNotInTarget);
        newProject.setRequireChangeID(args.changeIdRequired);
        newProject.setMaxObjectSizeLimit(args.maxObjectSizeLimit);
        if (args.newParent != null) {
            newProject.setParentName(args.newParent.getProject().getNameKey());
        }
        if (!args.ownerIds.isEmpty()) {
            AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : args.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(args.getProject());
    repoManager.setProjectDescription(args.getProject(), args.projectDescription);
}
#method_after
private void createProjectConfig(CreateProjectArgs args) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(args.getProject())) {
        ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(args.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(args.submitType, repositoryCfg.getDefaultSubmitType(args.getProject())));
        newProject.setUseContributorAgreements(args.contributorAgreements);
        newProject.setUseSignedOffBy(args.signedOffBy);
        newProject.setUseContentMerge(args.contentMerge);
        newProject.setCreateNewChangeForAllNotInTarget(args.newChangeForAllNotInTarget);
        newProject.setRequireChangeID(args.changeIdRequired);
        newProject.setMaxObjectSizeLimit(args.maxObjectSizeLimit);
        if (args.newParent != null) {
            newProject.setParentName(args.newParent.getProject().getNameKey());
        }
        if (!args.ownerIds.isEmpty()) {
            AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : args.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    }
    projectCache.onCreateProject(args.getProject());
    repoManager.setProjectDescription(args.getProject(), args.projectDescription);
}
#end_block

#method_before
private void createEmptyCommits(Repository repo, Project.NameKey project, List<String> refs) throws IOException {
    try (ObjectInserter oi = repo.newObjectInserter()) {
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[] {}));
        cb.setAuthor(metaDataUpdateFactory.getUserPersonIdent());
        cb.setCommitter(serverIdent);
        cb.setMessage("Initial empty repository\n");
        ObjectId id = oi.insert(cb);
        oi.flush();
        for (String ref : refs) {
            RefUpdate ru = repo.updateRef(ref);
            ru.setNewObjectId(id);
            Result result = ru.update();
            switch(result) {
                case NEW:
                    referenceUpdated.fire(project, ru, ReceiveCommand.Type.CREATE, currentUser.get().getAccountId());
                    break;
                default:
                    {
                        throw new IOException(String.format("Failed to create ref \"%s\": %s", ref, result.name()));
                    }
            }
        }
    } catch (IOException e) {
        log.error("Cannot create empty commit for " + project.get(), e);
        throw e;
    }
}
#method_after
private void createEmptyCommits(Repository repo, Project.NameKey project, List<String> refs) throws IOException {
    try (ObjectInserter oi = repo.newObjectInserter()) {
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[] {}));
        cb.setAuthor(metaDataUpdateFactory.getUserPersonIdent());
        cb.setCommitter(serverIdent);
        cb.setMessage("Initial empty repository\n");
        ObjectId id = oi.insert(cb);
        oi.flush();
        for (String ref : refs) {
            RefUpdate ru = repo.updateRef(ref);
            ru.setNewObjectId(id);
            Result result = ru.update();
            switch(result) {
                case NEW:
                    referenceUpdated.fire(project, ru, ReceiveCommand.Type.CREATE, currentUser.get().getAccountId());
                    break;
                case FAST_FORWARD:
                case FORCED:
                case IO_FAILURE:
                case LOCK_FAILURE:
                case NOT_ATTEMPTED:
                case NO_CHANGE:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(String.format("Failed to create ref \"%s\": %s", ref, result.name()));
                    }
            }
        }
    } catch (IOException e) {
        log.error("Cannot create empty commit for " + project.get(), e);
        throw e;
    }
}
#end_block

#method_before
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#method_after
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        case LOCK_FAILURE:
        case NOT_ATTEMPTED:
        case OK:
        case REJECTED_MISSING_OBJECT:
        case REJECTED_NOCREATE:
        case REJECTED_NODELETE:
        case REJECTED_NONFASTFORWARD:
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#end_block

#method_before
private void postDeletion(ProjectResource project, ReceiveCommand cmd) throws OrmException {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
    Branch.NameKey branchKey = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
    hooks.doRefUpdatedHook(branchKey, cmd.getOldId(), cmd.getNewId(), identifiedUser.get().getAccount());
    ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(branchKey);
    dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
}
#method_after
private void postDeletion(ProjectResource project, ReceiveCommand cmd) {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
    Branch.NameKey branchKey = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
    hooks.doRefUpdatedHook(branchKey, cmd.getOldId(), cmd.getNewId(), identifiedUser.get().getAccount());
}
#end_block

#method_before
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                hooks.doRefUpdatedHook(rsrc.getBranchKey(), u, identifiedUser.get().getAccount());
                ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(rsrc.getBranchKey());
                dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                hooks.doRefUpdatedHook(rsrc.getBranchKey(), u, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case RENAMED:
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#end_block

#method_before
@Test
public void testPushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId());
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.: my test message");
    }
}
#method_after
@Test
public void testPushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId());
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nmy test message");
    }
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap());
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg = msg + ": " + magicBranch.message;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String branchMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        branchMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, change.getDest().get(), commit);
        mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getUser().getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    approvalsUtil.addApprovals(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    recipients.add(oldRecipients);
    String approvalMessage = renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String message = approvalMessage;
    String kindMessage = changeKindMessage(changeKind);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message = message + kindMessage;
    }
    if (!Strings.isNullOrEmpty(branchMessage)) {
        message = message + ": " + branchMessage;
    }
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), patchSetId);
    msg.setMessage(message);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedIntoRef == null) {
        resetChange(ctx, msg);
    }
    ctx.saveChange();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, change.getDest().get(), commit);
        mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getUser().getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    approvalsUtil.addApprovals(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    StringBuilder message = new StringBuilder(approvalMessage);
    String kindMessage = changeKindMessage(changeKind);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), patchSetId);
    msg.setMessage(message.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedIntoRef == null) {
        resetChange(ctx, msg);
    }
    ctx.saveChange();
    return true;
}
#end_block

#method_before
@Override
public Block getBlock() {
    return new TocBlock();
}
#method_after
@Override
public Block getBlock() {
    return block;
}
#end_block

#method_before
private static IframeBlock iframe(String html) {
    IframeBlock iframe = new IframeBlock();
    Matcher m = ATTR.matcher(html);
    while (m.find()) {
        String att = m.group(1).toLowerCase();
        String val = m.group(3);
        switch(att) {
            case "src":
                if (!HtmlBuilder.isValidHttpUri(val)) {
                    return null;
                }
                iframe.src = val;
                break;
            case "height":
                if (!HtmlBuilder.isValidCssDimension(val)) {
                    return null;
                }
                iframe.height = val;
                break;
            case "width":
                if (!HtmlBuilder.isValidCssDimension(val)) {
                    return null;
                }
                iframe.width = val;
                break;
            case "frameborder":
                iframe.border = !"0".equals(val);
                break;
        }
    }
    return iframe.src != null ? iframe : null;
}
#method_after
private static IframeBlock iframe(String html) {
    IframeBlock iframe = new IframeBlock();
    Matcher m = ATTR.matcher(html);
    while (m.find()) {
        String att = m.group(1).toLowerCase();
        String val = attributeValue(m);
        switch(att) {
            case "src":
                if (!HtmlBuilder.isValidHttpUri(val)) {
                    return null;
                }
                iframe.src = val;
                break;
            case "height":
                if (!HtmlBuilder.isValidCssDimension(val)) {
                    return null;
                }
                iframe.height = val;
                break;
            case "width":
                if (!HtmlBuilder.isValidCssDimension(val)) {
                    return null;
                }
                iframe.width = val;
                break;
            case "frameborder":
                iframe.border = !"0".equals(val);
                break;
        }
    }
    return iframe.src != null ? iframe : null;
}
#end_block

#method_before
public void visit(TableBlock node) {
    table = new TableState();
    wrapChildren("table", node);
    table = null;
}
#method_after
public void visit(TableBlock node) {
    wrapChildren("table", node);
}
#end_block

#method_before
private void visit(TableRow node) {
    mustBeInsideTable(node);
    table.startRow();
    wrapChildren("tr", node);
}
#method_after
private void visit(TableRow node) {
    wrapChildren("tr", node);
}
#end_block

#method_before
private void visit(TableCell cell) {
    mustBeInsideTable(cell);
    String tag = cell.isHeader() ? "th" : "td";
    html.open(tag);
    TableCell.Alignment alignment = cell.getAlignment();
    if (alignment != null) {
        html.attribute("align", toHtml(alignment));
    }
    // TODO(sop) colspan
    // if (node.getColSpan() > 1) {
    // html.attribute("colspan", Integer.toString(node.getColSpan()));
    // }
    visitChildren(cell);
    html.close(tag);
    table.done(cell);
}
#method_after
private void visit(TableCell cell) {
    String tag = cell.isHeader() ? "th" : "td";
    html.open(tag);
    TableCell.Alignment alignment = cell.getAlignment();
    if (alignment != null) {
        html.attribute("align", toHtml(alignment));
    }
    visitChildren(cell);
    html.close(tag);
}
#end_block

#method_before
private static String toHtml(TableCell.Alignment alignment) {
    switch(alignment) {
        case LEFT:
            return "left";
        case CENTER:
            return "center";
        case RIGHT:
            return "right";
        default:
            throw new IllegalStateException("unsupported alignment " + alignment);
    }
}
#method_after
private static String toHtml(TableCell.Alignment alignment) {
    switch(alignment) {
        case LEFT:
            return "left";
        case CENTER:
            return "center";
        case RIGHT:
            return "right";
        default:
            throw new IllegalArgumentException("unsupported alignment " + alignment);
    }
}
#end_block

#method_before
private void visit(SmartQuoted node) {
    switch(node.getType()) {
        case DOUBLE:
            html.entity("&ldquo;");
            visitChildren(node);
            html.entity("&rdquo;");
            break;
        case SINGLE:
            html.entity("&lsquo;");
            visitChildren(node);
            html.entity("&rsquo;");
            break;
        default:
            checkState(false, "unsupported quote %s", node.getType());
    }
}
#method_after
private void visit(SmartQuoted node) {
    switch(node.getType()) {
        case DOUBLE:
            html.entity("&ldquo;");
            visitChildren(node);
            html.entity("&rdquo;");
            break;
        case SINGLE:
            html.entity("&lsquo;");
            visitChildren(node);
            html.entity("&rsquo;");
            break;
        default:
            throw new IllegalArgumentException("unsupported quote " + node.getType());
    }
}
#end_block

#method_before
@Override
public void visit(CustomNode node) {
    if (node instanceof NamedAnchor) {
        visit((NamedAnchor) node);
    } else if (node instanceof SmartQuoted) {
        visit((SmartQuoted) node);
    } else if (node instanceof Strikethrough) {
        wrapChildren("del", node);
    } else if (node instanceof TableBody) {
        wrapChildren("tbody", node);
    } else if (node instanceof TableCell) {
        visit((TableCell) node);
    } else if (node instanceof TableHead) {
        wrapChildren("thead", node);
    } else if (node instanceof TableRow) {
        visit((TableRow) node);
    } else {
        checkState(false, "cannot render %s", node.getClass());
    }
}
#method_after
@Override
public void visit(CustomNode node) {
    if (node instanceof NamedAnchor) {
        visit((NamedAnchor) node);
    } else if (node instanceof SmartQuoted) {
        visit((SmartQuoted) node);
    } else if (node instanceof Strikethrough) {
        wrapChildren("del", node);
    } else if (node instanceof TableBody) {
        wrapChildren("tbody", node);
    } else if (node instanceof TableCell) {
        visit((TableCell) node);
    } else if (node instanceof TableHead) {
        wrapChildren("thead", node);
    } else if (node instanceof TableRow) {
        visit((TableRow) node);
    } else {
        throw new IllegalArgumentException("cannot render " + node.getClass());
    }
}
#end_block

#method_before
@Override
public void visit(CustomBlock node) {
    if (node instanceof BlockNote) {
        visit((BlockNote) node);
    } else if (node instanceof IframeBlock) {
        visit((IframeBlock) node);
    } else if (node instanceof MultiColumnBlock) {
        visit((MultiColumnBlock) node);
    } else if (node instanceof MultiColumnBlock.Column) {
        visit((MultiColumnBlock.Column) node);
    } else if (node instanceof TableBlock) {
        visit((TableBlock) node);
    } else if (node instanceof TocBlock) {
        toc.format();
    } else {
        checkState(false, "cannot render %s", node.getClass());
    }
}
#method_after
@Override
public void visit(CustomBlock node) {
    if (node instanceof BlockNote) {
        visit((BlockNote) node);
    } else if (node instanceof IframeBlock) {
        visit((IframeBlock) node);
    } else if (node instanceof MultiColumnBlock) {
        visit((MultiColumnBlock) node);
    } else if (node instanceof MultiColumnBlock.Column) {
        visit((MultiColumnBlock.Column) node);
    } else if (node instanceof TableBlock) {
        visit((TableBlock) node);
    } else if (node instanceof TocBlock) {
        toc.format();
    } else {
        throw new IllegalArgumentException("cannot render " + node.getClass());
    }
}
#end_block

#method_before
@Override
public void extend(Parser.Builder builder) {
    builder.customBlockParserFactory(new DivParserFactory());
}
#method_after
@Override
public void extend(Parser.Builder builder) {
    builder.customBlockParserFactory(new NoteParserFactory());
}
#end_block

#method_before
protected TestRepository<?> createProjectWithPush(String name, Project.NameKey parent) throws Exception {
    Project.NameKey project = createProject(name, parent);
    grant(Permission.PUSH, project, "refs/heads/*");
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/*");
    return cloneProject(project);
}
#method_after
protected TestRepository<?> createProjectWithPush(String name, @Nullable Project.NameKey parent) throws Exception {
    Project.NameKey project = createProject(name, parent);
    grant(Permission.PUSH, project, "refs/heads/*");
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/*");
    return cloneProject(project);
}
#end_block

#method_before
@Test
public void testCircularSubscriptionIsDetected() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    allowSubmoduleSubscription("super-project", "refs/heads/master", "subscribed-to-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(subRepo, "master", "super-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
    assertThat(hasSubmodule(subRepo, "master", "super-project")).isFalse();
}
#method_after
@Test
public void testCircularSubscriptionIsDetected() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    allowSubmoduleSubscription("super-project", "refs/heads/master", "subscribed-to-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(subRepo, "master", "super-project", "master");
    pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    assertThat(hasSubmodule(subRepo, "master", "super-project")).isFalse();
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#end_block

#method_before
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch, MergeOpRepoManager orm) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    ProjectState state = projectStateFactory.create(cfg);
    for (SubscribeSection s : state.getInheritedSubscribeSections(branch)) {
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s, orm);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm);
            m.load();
            ret.addAll(m.subscribedTo(branch));
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch, MergeOpRepoManager orm) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(branch)) {
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s, orm);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm);
            m.load();
            ret.addAll(m.subscribedTo(branch));
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch, orm)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest), orm);
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    for (Branch.NameKey updatedBranch : updatedBranches) {
        logDebug("Now processing " + updatedBranch);
        Set<Branch.NameKey> checkedTargets = new HashSet<>();
        Set<Branch.NameKey> targetsToProcess = new HashSet<>();
        targetsToProcess.add(updatedBranch);
        while (!targetsToProcess.isEmpty()) {
            Set<Branch.NameKey> newTargets = new HashSet<>();
            for (Branch.NameKey b : targetsToProcess) {
                try {
                    Collection<SubmoduleSubscription> subs = superProjectSubscriptionsForSubmoduleBranch(b, orm);
                    for (SubmoduleSubscription sub : subs) {
                        Branch.NameKey dst = sub.getSuperProject();
                        targets.put(dst, sub);
                        newTargets.add(dst);
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Cannot find superprojects for " + b, e);
                }
            }
            logDebug("adding to done " + targetsToProcess);
            checkedTargets.addAll(targetsToProcess);
            logDebug("completely done with " + checkedTargets);
            Set<Branch.NameKey> intersection = new HashSet<>(checkedTargets);
            intersection.retainAll(newTargets);
            if (!intersection.isEmpty()) {
                throw new SubmoduleException("Possible circular subscription involving " + updatedBranch);
            }
            targetsToProcess = newTargets;
        }
    }
    for (Branch.NameKey dst : targets.keySet()) {
        try {
            updateGitlinks(dst, targets.get(dst), orm);
        } catch (SubmoduleException e) {
            throw new SubmoduleException("Cannot update gitlinks for " + dst, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates, MergeOpRepoManager orm) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId, orm);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates, MergeOpRepoManager orm) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    for (Branch.NameKey updatedBranch : updatedBranches) {
        logDebug("Now processing " + updatedBranch);
        Set<Branch.NameKey> checkedTargets = new HashSet<>();
        Set<Branch.NameKey> targetsToProcess = new HashSet<>();
        targetsToProcess.add(updatedBranch);
        while (!targetsToProcess.isEmpty()) {
            Set<Branch.NameKey> newTargets = new HashSet<>();
            for (Branch.NameKey b : targetsToProcess) {
                try {
                    Collection<SubmoduleSubscription> subs = superProjectSubscriptionsForSubmoduleBranch(b, orm);
                    for (SubmoduleSubscription sub : subs) {
                        Branch.NameKey dst = sub.getSuperProject();
                        targets.put(dst, sub);
                        newTargets.add(dst);
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Cannot find superprojects for" + b, e);
                }
            }
            logDebug("adding to done " + targetsToProcess);
            checkedTargets.addAll(targetsToProcess);
            logDebug("completely done with " + checkedTargets);
            Set<Branch.NameKey> intersection = new HashSet<>(checkedTargets);
            intersection.retainAll(newTargets);
            if (!intersection.isEmpty()) {
                throw new SubmoduleException("Possible circular subscription involving " + updatedBranch);
            }
            targetsToProcess = newTargets;
        }
    }
    for (Branch.NameKey dst : targets.keySet()) {
        try {
            updateGitlinks(dst, targets.get(dst), orm);
        } catch (SubmoduleException e) {
            throw new SubmoduleException("Cannot update gitlinks for " + dst, e);
        }
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    for (Branch.NameKey updatedBranch : updatedBranches) {
        logDebug("Now processing " + updatedBranch);
        Set<Branch.NameKey> checkedTargets = new HashSet<>();
        Set<Branch.NameKey> targetsToProcess = new HashSet<>();
        targetsToProcess.add(updatedBranch);
        while (!targetsToProcess.isEmpty()) {
            Set<Branch.NameKey> newTargets = new HashSet<>();
            for (Branch.NameKey b : targetsToProcess) {
                try {
                    Collection<SubmoduleSubscription> subs = superProjectSubscriptionsForSubmoduleBranch(b, orm);
                    for (SubmoduleSubscription sub : subs) {
                        Branch.NameKey dst = sub.getSuperProject();
                        targets.put(dst, sub);
                        newTargets.add(dst);
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Cannot find superprojects for " + b, e);
                }
            }
            logDebug("adding to done " + targetsToProcess);
            checkedTargets.addAll(targetsToProcess);
            logDebug("completely done with " + checkedTargets);
            Set<Branch.NameKey> intersection = new HashSet<>(checkedTargets);
            intersection.retainAll(newTargets);
            if (!intersection.isEmpty()) {
                throw new SubmoduleException("Possible circular subscription involving " + updatedBranch);
            }
            targetsToProcess = newTargets;
        }
    }
    for (Branch.NameKey dst : targets.keySet()) {
        try {
            updateGitlinks(dst, targets.get(dst), orm);
        } catch (SubmoduleException e) {
            throw new SubmoduleException("Cannot update gitlinks for " + dst, e);
        }
    }
}
#end_block

#method_before
@Test
public void GetDiffPreferences() throws Exception {
    RestResponse r = adminRestSession.get("/config/server/preferences.diff");
    r.assertOK();
    DiffPreferencesInfo result = newGson().fromJson(r.getReader(), DiffPreferencesInfo.class);
    System.out.println("Context" + result.context);
    assertEquals(result, DiffPreferencesInfo.defaults());
}
#method_after
@Test
public void GetDiffPreferences() throws Exception {
    DiffPreferencesInfo result = get();
    assertPrefsEqual(result, DiffPreferencesInfo.defaults());
}
#end_block

#method_before
public void SetDiffPreferences() throws Exception {
    int defaultLineLength = DiffPreferencesInfo.defaults().lineLength;
    int newLineLength = defaultLineLength + 10;
    DiffPreferencesInfo update = new DiffPreferencesInfo();
    update.lineLength = newLineLength;
    RestResponse r = adminRestSession.put("/config/server/preferences.diff", update);
    r.assertOK();
    DiffPreferencesInfo result = newGson().fromJson(r.getReader(), DiffPreferencesInfo.class);
    assertThat(result.lineLength).named("lineLength").isEqualTo(newLineLength);
    r = adminRestSession.get("/config/server/preferences.diff");
    r.assertOK();
    result = newGson().fromJson(r.getReader(), DiffPreferencesInfo.class);
    assertThat(result.lineLength).named("lineLength").isEqualTo(newLineLength);
    DiffPreferencesInfo expectedDPI = DiffPreferencesInfo.defaults();
    expectedDPI.lineLength = newLineLength;
    assertEquals(result, expectedDPI);
}
#method_after
@Test
public void SetDiffPreferences() throws Exception {
    int newLineLength = DiffPreferencesInfo.defaults().lineLength + 10;
    DiffPreferencesInfo update = new DiffPreferencesInfo();
    update.lineLength = newLineLength;
    DiffPreferencesInfo result = put(update);
    assertThat(result.lineLength).named("lineLength").isEqualTo(newLineLength);
    result = get();
    DiffPreferencesInfo expected = DiffPreferencesInfo.defaults();
    expected.lineLength = newLineLength;
    assertPrefsEqual(result, expected);
}
#end_block

#method_before
@Override
public Object apply(ConfigResource configResource, DiffPreferencesInfo in) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    if (in == null) {
        throw new BadRequestException("input must be provided");
    }
    if (!in.hasSetFields()) {
        throw new BadRequestException("unsupported option");
    }
    return writeToGit(readFromGit(gitManager, allUsersName, in));
}
#method_after
@Override
public Object apply(ConfigResource configResource, DiffPreferencesInfo in) throws BadRequestException, Exception {
    if (in == null) {
        throw new BadRequestException("input must be provided");
    }
    if (!hasSetFields(in)) {
        throw new BadRequestException("unsupported option");
    }
    return writeToGit(readFromGit(gitManager, allUsersName, in));
}
#end_block

#method_before
@Override
public Object apply(ConfigResource configResource) throws BadRequestException, ResourceConflictException, Exception {
    return readFromGit(gitManager, allUsersName, null);
}
#method_after
@Override
public DiffPreferencesInfo apply(ConfigResource configResource) throws BadRequestException, ResourceConflictException, Exception {
    return readFromGit(gitManager, allUsersName, null);
}
#end_block

#method_before
static DiffPreferencesInfo readFromGit(Account.Id id, GitRepositoryManager gitMgr, AllUsersName allUsersName, DiffPreferencesInfo in) throws IOException, ConfigInvalidException, RepositoryNotFoundException {
    try (Repository git = gitMgr.openRepository(allUsersName)) {
        // Load all users prefs.
        VersionedAccountPreferences dp = VersionedAccountPreferences.forDefault();
        dp.load(git);
        DiffPreferencesInfo allUserPrefs = new DiffPreferencesInfo();
        loadSection(dp.getConfig(), UserConfigSections.DIFF, null, allUserPrefs, DiffPreferencesInfo.defaults(), in);
        // Load user prefs
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(id);
        p.load(git);
        DiffPreferencesInfo prefs = new DiffPreferencesInfo();
        loadSection(p.getConfig(), UserConfigSections.DIFF, null, prefs, DiffPreferencesInfo.updateDefaults(allUserPrefs), in);
        return prefs;
    }
}
#method_after
static DiffPreferencesInfo readFromGit(Account.Id id, GitRepositoryManager gitMgr, AllUsersName allUsersName, DiffPreferencesInfo in) throws IOException, ConfigInvalidException, RepositoryNotFoundException {
    try (Repository git = gitMgr.openRepository(allUsersName)) {
        // Load all users prefs.
        VersionedAccountPreferences dp = VersionedAccountPreferences.forDefault();
        dp.load(git);
        DiffPreferencesInfo allUserPrefs = new DiffPreferencesInfo();
        loadSection(dp.getConfig(), UserConfigSections.DIFF, null, allUserPrefs, DiffPreferencesInfo.defaults(), in);
        // Load user prefs
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(id);
        p.load(git);
        DiffPreferencesInfo prefs = new DiffPreferencesInfo();
        loadSection(p.getConfig(), UserConfigSections.DIFF, null, prefs, updateDefaults(allUserPrefs), in);
        return prefs;
    }
}
#end_block

#method_before
@Override
public void run() throws UnloggedFailure, OrmException {
    Account account;
    if (name.isEmpty()) {
        throw new UnloggedFailure(1, "You need to tell me who to find:  LastName,\\\\ Firstname, email@address.com, account id or an user name.  " + "Be sure to double-escape spaces, for example: \"show-account Last,\\\\ First\"");
    }
    Set<Id> idList = accountResolver.findAll(name);
    if (idList.isEmpty()) {
        throw new UnloggedFailure(1, "No accounts found for your query: \"" + name + "\"" + " Tip: Try double-escaping spaces, for example: \"show-account Last,\\\\ First\"");
    } else {
        stdout.println("Found " + idList.size() + " result" + (idList.size() > 1 ? "s" : "") + ": for query: \"" + name + "\"");
        stdout.println();
    }
    for (Id id : idList) {
        account = accountResolver.find(id.toString());
        if (account == null) {
            throw new UnloggedFailure("Account " + id.toString() + " does not exist.");
        }
        stdout.println("Full name:         " + account.getFullName());
        stdout.println("Account Id:        " + id.toString());
        stdout.println("Preferred Email:   " + account.getPreferredEmail());
        stdout.println("User Name:         " + account.getUserName());
        stdout.println("Active:            " + account.isActive());
        stdout.println("Registered on:     " + account.getRegisteredOn());
        try (final ReviewDb db = schema.open()) {
            stdout.println("");
            stdout.println("External Ids:");
            stdout.println(String.format("%-50s %s", "Email Address:", "External Id:"));
            for (AccountExternalId accountExternalId : db.accountExternalIds().byAccount(account.getId())) {
                stdout.println(String.format("%-50s %s", (accountExternalId.getEmailAddress() == null ? "" : accountExternalId.getEmailAddress()), accountExternalId.getExternalId()));
            }
            if (showKeys) {
                stdout.println("");
                stdout.println("Public Keys:");
                List<SshKeyInfo> sshKeys;
                try {
                    sshKeys = getSshKeys.get().apply(new AccountResource(userFactory.create(id)));
                } catch (AuthException | IOException | ConfigInvalidException e) {
                    stdout.println("Error getting ssh key info!");
                    e.printStackTrace();
                    sshKeys = null;
                }
                if (sshKeys == null || sshKeys.isEmpty()) {
                    stdout.println("None");
                } else {
                    stdout.println(String.format("%-9s %s", "Status:", "Key:"));
                    for (SshKeyInfo sshKey : sshKeys) {
                        stdout.println(String.format("%-9s %s", (sshKey.valid ? "Active" : "Inactive"), sshKey.sshPublicKey));
                    }
                }
            }
        }
        if (showGroups) {
            stdout.println();
            stdout.println("Member of groups" + (filterGroups == null ? "" : " (Filtering on \"" + filterGroups + "\")") + ":");
            List<GroupInfo> groupInfos = accountGetGroups.get().apply(new AccountResource(userFactory.create(id)));
            Collections.sort(groupInfos, new CustomComparator());
            for (GroupInfo groupInfo : groupInfos) {
                if (null == filterGroups || groupInfo.name.toLowerCase().contains(filterGroups.toLowerCase())) {
                    stdout.println(groupInfo.name);
                }
            }
        }
        stdout.println("");
    }
}
#method_after
@Override
public void run() throws UnloggedFailure, OrmException {
    Account account;
    if (name.isEmpty()) {
        throw new UnloggedFailure(1, "You need to tell me who to find:  LastName,\\\\ Firstname, email@address.com, account id or an user name.  " + "Be sure to double-escape spaces, for example: \"show-account Last,\\\\ First\"");
    }
    Set<Id> idList = accountResolver.findAll(name);
    if (idList.isEmpty()) {
        throw new UnloggedFailure(1, "No accounts found for your query: \"" + name + "\"" + " Tip: Try double-escaping spaces, for example: \"show-account Last,\\\\ First\"");
    } else {
        stdout.println("Found " + idList.size() + " result" + (idList.size() > 1 ? "s" : "") + ": for query: \"" + name + "\"");
        stdout.println();
    }
    for (Id id : idList) {
        account = accountResolver.find(id.toString());
        if (account == null) {
            throw new UnloggedFailure("Account " + id.toString() + " does not exist.");
        }
        stdout.println("Full name:         " + account.getFullName());
        stdout.println("Account Id:        " + id.toString());
        stdout.println("Preferred Email:   " + account.getPreferredEmail());
        stdout.println("User Name:         " + account.getUserName());
        stdout.println("Active:            " + account.isActive());
        stdout.println("Registered on:     " + account.getRegisteredOn());
        try (final ReviewDb db = schema.open()) {
            stdout.println("");
            stdout.println("External Ids:");
            stdout.println(String.format("%-50s %s", "Email Address:", "External Id:"));
            for (AccountExternalId accountExternalId : db.accountExternalIds().byAccount(account.getId())) {
                stdout.println(String.format("%-50s %s", (accountExternalId.getEmailAddress() == null ? "" : accountExternalId.getEmailAddress()), accountExternalId.getExternalId()));
            }
            if (showKeys) {
                stdout.println("");
                stdout.println("Public Keys:");
                List<SshKeyInfo> sshKeys;
                try {
                    sshKeys = getSshKeys.get().apply(new AccountResource(userFactory.create(id)));
                } catch (AuthException | IOException | ConfigInvalidException e) {
                    throw new UnloggedFailure(1, "Error getting sshkeys: " + e.getMessage(), e);
                }
                if (sshKeys == null || sshKeys.isEmpty()) {
                    stdout.println("None");
                } else {
                    stdout.println(String.format("%-9s %s", "Status:", "Key:"));
                    for (SshKeyInfo sshKey : sshKeys) {
                        stdout.println(String.format("%-9s %s", (sshKey.valid ? "Active" : "Inactive"), sshKey.sshPublicKey));
                    }
                }
            }
        }
        if (showGroups) {
            stdout.println();
            stdout.println("Member of groups" + (filterGroups == null ? "" : " (Filtering on \"" + filterGroups + "\")") + ":");
            List<GroupInfo> groupInfos = accountGetGroups.get().apply(new AccountResource(userFactory.create(id)));
            Collections.sort(groupInfos, new CustomComparator());
            for (GroupInfo groupInfo : groupInfos) {
                if (null == filterGroups || groupInfo.name.toLowerCase().contains(filterGroups.toLowerCase())) {
                    stdout.println(groupInfo.name);
                }
            }
        }
        stdout.println("");
    }
}
#end_block

#method_before
private List<HashtagsEvent> getHashtagsEvents(Change change, NoteDbUpdateManager manager) throws IOException {
    String refName = ChangeNoteUtil.changeRefName(change.getId());
    ObjectId old = manager.getChangeRepo().getObjectId(refName);
    if (old == null) {
        return Collections.emptyList();
    }
    RevWalk rw = manager.getChangeRepo().rw;
    List<HashtagsEvent> events = new ArrayList<>();
    rw.reset();
    rw.markStart(rw.parseCommit(old));
    for (RevCommit commit : rw) {
        Account.Id authorId;
        try {
            authorId = changeNoteUtil.parseIdent(commit.getAuthorIdent(), change.getId());
        } catch (ConfigInvalidException e) {
            // Corrupt data, no valid hashtags in this commit.
            continue;
        }
        PatchSet.Id psId = parsePatchSetId(change, commit);
        Set<String> hashtags = parseHashtags(commit);
        if (authorId == null || psId == null || hashtags == null) {
            continue;
        }
        Timestamp commitTime = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
        events.add(new HashtagsEvent(psId, authorId, commitTime, hashtags, change.getCreatedOn()));
    }
    return events;
}
#method_after
private List<HashtagsEvent> getHashtagsEvents(Change change, NoteDbUpdateManager manager) throws IOException {
    String refName = changeMetaRef(change.getId());
    ObjectId old = manager.getChangeRepo().getObjectId(refName);
    if (old == null) {
        return Collections.emptyList();
    }
    RevWalk rw = manager.getChangeRepo().rw;
    List<HashtagsEvent> events = new ArrayList<>();
    rw.reset();
    rw.markStart(rw.parseCommit(old));
    for (RevCommit commit : rw) {
        Account.Id authorId;
        try {
            authorId = changeNoteUtil.parseIdent(commit.getAuthorIdent(), change.getId());
        } catch (ConfigInvalidException e) {
            // Corrupt data, no valid hashtags in this commit.
            continue;
        }
        PatchSet.Id psId = parsePatchSetId(change, commit);
        Set<String> hashtags = parseHashtags(commit);
        if (authorId == null || psId == null || hashtags == null) {
            continue;
        }
        Timestamp commitTime = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
        events.add(new HashtagsEvent(psId, authorId, commitTime, hashtags, change.getCreatedOn()));
    }
    return events;
}
#end_block

#method_before
private void deleteRef(Change change, Repository repo, ChainedReceiveCommands cmds) throws IOException {
    String refName = ChangeNoteUtil.changeRefName(change.getId());
    ObjectId old = cmds.getObjectId(repo, refName);
    if (old != null) {
        cmds.add(new ReceiveCommand(old, ObjectId.zeroId(), refName));
    }
}
#method_after
private void deleteRef(Change change, Repository repo, ChainedReceiveCommands cmds) throws IOException {
    String refName = changeMetaRef(change.getId());
    ObjectId old = cmds.getObjectId(repo, refName);
    if (old != null) {
        cmds.add(new ReceiveCommand(old, ObjectId.zeroId(), refName));
    }
}
#end_block

#method_before
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = new HashMap<>();
    List<GroupInfo> result = Lists.newLinkedList();
    Account.Id me = control.getUser().getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup()) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#method_after
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = new HashMap<>();
    List<GroupInfo> result = new LinkedList<>();
    Account.Id me = control.getUser().getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup()) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#end_block

#method_before
private List<AccountInfo> toAccountInfoList(Set<Account.Id> accountIds) throws OrmException {
    List<AccountInfo> result = Lists.newLinkedList();
    AccountLoader loader = infoFactory.create(true);
    for (Account.Id accId : accountIds) {
        result.add(loader.get(accId));
    }
    loader.fill();
    return result;
}
#method_after
private List<AccountInfo> toAccountInfoList(Set<Account.Id> accountIds) throws OrmException {
    List<AccountInfo> result = new LinkedList<>();
    AccountLoader loader = infoFactory.create(true);
    for (Account.Id accId : accountIds) {
        result.add(loader.get(accId));
    }
    loader.fill();
    return result;
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = Lists.newLinkedList();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup()) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = new LinkedList<>();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup()) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
    if (added.isEmpty()) {
        return false;
    }
    patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    ctx.bumpLastUpdatedOn(false);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
    if (added.isEmpty()) {
        return false;
    }
    patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    return true;
}
#end_block

#method_before
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<Account.Id, AccountGroupMember> members = getMembers(internalGroup.getId());
    final List<AccountGroupMember> toRemove = Lists.newLinkedList();
    for (final String nameOrEmail : input.members) {
        Account a = accounts.parse(nameOrEmail).getAccount();
        if (!control.canRemoveMember()) {
            throw new AuthException("Cannot delete member: " + a.getFullName());
        }
        final AccountGroupMember m = members.remove(a.getId());
        if (m != null) {
            toRemove.add(m);
        }
    }
    writeAudits(toRemove);
    db.get().accountGroupMembers().delete(toRemove);
    for (final AccountGroupMember m : toRemove) {
        accountCache.evict(m.getAccountId());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<Account.Id, AccountGroupMember> members = getMembers(internalGroup.getId());
    final List<AccountGroupMember> toRemove = new LinkedList<>();
    for (final String nameOrEmail : input.members) {
        Account a = accounts.parse(nameOrEmail).getAccount();
        if (!control.canRemoveMember()) {
            throw new AuthException("Cannot delete member: " + a.getFullName());
        }
        final AccountGroupMember m = members.remove(a.getId());
        if (m != null) {
            toRemove.add(m);
        }
    }
    writeAudits(toRemove);
    db.get().accountGroupMembers().delete(toRemove);
    for (final AccountGroupMember m : toRemove) {
        accountCache.evict(m.getAccountId());
    }
    return Response.none();
}
#end_block

#method_before
private void appendOneComment(PrintWriter writer, PatchLineComment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    CommentRange range = c.getRange();
    if (range != null) {
        writer.print(range.getStartLine());
        writer.print(':');
        writer.print(range.getStartCharacter());
        writer.print('-');
        writer.print(range.getEndLine());
        writer.print(':');
        writer.print(range.getEndCharacter());
    } else {
        writer.print(c.getLine());
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.getWrittenOn()));
    writer.print("\n");
    PersonIdent ident = newIdent(accountCache.get(c.getAuthor()).getAccount(), c.getWrittenOn(), serverIdent, anonymousCowardName);
    String nameString = ident.getName() + " <" + ident.getEmailAddress() + ">";
    appendHeaderField(writer, AUTHOR, nameString);
    String parent = c.getParentUuid();
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.getKey().get());
    if (c.getTag() != null) {
        appendHeaderField(writer, TAG, c.getTag());
    }
    byte[] messageBytes = c.getMessage().getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.getMessage());
    writer.print("\n\n");
}
#method_after
private void appendOneComment(PrintWriter writer, PatchLineComment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    CommentRange range = c.getRange();
    if (range != null) {
        writer.print(range.getStartLine());
        writer.print(':');
        writer.print(range.getStartCharacter());
        writer.print('-');
        writer.print(range.getEndLine());
        writer.print(':');
        writer.print(range.getEndCharacter());
    } else {
        writer.print(c.getLine());
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.getWrittenOn()));
    writer.print("\n");
    PersonIdent ident = newIdent(accountCache.get(c.getAuthor()).getAccount(), c.getWrittenOn(), serverIdent, anonymousCowardName);
    StringBuilder name = new StringBuilder();
    PersonIdent.appendSanitized(name, ident.getName());
    name.append(" <");
    PersonIdent.appendSanitized(name, ident.getEmailAddress());
    name.append('>');
    appendHeaderField(writer, AUTHOR, name.toString());
    String parent = c.getParentUuid();
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.getKey().get());
    if (c.getTag() != null) {
        appendHeaderField(writer, TAG, c.getTag());
    }
    byte[] messageBytes = c.getMessage().getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.getMessage());
    writer.print("\n\n");
}
#end_block

#method_before
private void startPlugin(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    serverManager = new LifecycleManager();
    serverManager.add(root);
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(getName(), env, scanner, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        serverManager.add(sysInjector);
    } else if (auto != null && auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        serverManager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (env.hasSshModule()) {
        List<Module> modules = Lists.newLinkedList();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getSshModule());
        }
        if (sshModule != null) {
            modules.add(sysInjector.getInstance(sshModule));
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        } else if (auto != null && auto.sshModule != null) {
            modules.add(auto.sshModule);
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        }
    }
    if (env.hasHttpModule()) {
        List<Module> modules = Lists.newLinkedList();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getHttpModule());
        }
        if (httpModule != null) {
            modules.add(sysInjector.getInstance(httpModule));
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        } else if (auto != null && auto.httpModule != null) {
            modules.add(auto.httpModule);
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        }
    }
    serverManager.start();
}
#method_after
private void startPlugin(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    serverManager = new LifecycleManager();
    serverManager.add(root);
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(getName(), env, scanner, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        serverManager.add(sysInjector);
    } else if (auto != null && auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        serverManager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (env.hasSshModule()) {
        List<Module> modules = new LinkedList<>();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getSshModule());
        }
        if (sshModule != null) {
            modules.add(sysInjector.getInstance(sshModule));
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        } else if (auto != null && auto.sshModule != null) {
            modules.add(auto.sshModule);
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        }
    }
    if (env.hasHttpModule()) {
        List<Module> modules = new LinkedList<>();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getHttpModule());
        }
        if (httpModule != null) {
            modules.add(sysInjector.getInstance(httpModule));
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        } else if (auto != null && auto.httpModule != null) {
            modules.add(auto.httpModule);
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        }
    }
    serverManager.start();
}
#end_block

#method_before
public List<PatchLineComment> draftByChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        return sort(byCommentStatus(db.patchComments().byChange(notes.getChangeId()), Status.DRAFT));
    }
    List<PatchLineComment> comments = new ArrayList<>();
    for (String refSuffix : getDraftRefs(notes.getChangeId()).keySet()) {
        Account.Id account = Account.Id.fromRefPart(refSuffix);
        if (account != null) {
            comments.addAll(draftByChangeAuthor(db, notes, account));
        }
    }
    return sort(comments);
}
#method_after
public List<PatchLineComment> draftByChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        return sort(byCommentStatus(db.patchComments().byChange(notes.getChangeId()), Status.DRAFT));
    }
    List<PatchLineComment> comments = new ArrayList<>();
    for (Ref ref : getDraftRefs(notes.getChangeId())) {
        Account.Id account = Account.Id.fromRefSuffix(ref.getName());
        if (account != null) {
            comments.addAll(draftByChangeAuthor(db, notes, account));
        }
    }
    return sort(comments);
}
#end_block

#method_before
public List<PatchLineComment> byPatchSet(ReviewDb db, ChangeNotes notes, PatchSet.Id psId) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().byPatchSet(psId).toList());
    }
    List<PatchLineComment> comments = new ArrayList<>();
    comments.addAll(publishedByPatchSet(db, notes, psId));
    for (String refSuffix : getDraftRefs(notes.getChangeId()).keySet()) {
        Account.Id account = Account.Id.fromRefPart(refSuffix);
        if (account != null) {
            comments.addAll(draftByPatchSetAuthor(db, psId, account, notes));
        }
    }
    return sort(comments);
}
#method_after
public List<PatchLineComment> byPatchSet(ReviewDb db, ChangeNotes notes, PatchSet.Id psId) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().byPatchSet(psId).toList());
    }
    List<PatchLineComment> comments = new ArrayList<>();
    comments.addAll(publishedByPatchSet(db, notes, psId));
    for (Ref ref : getDraftRefs(notes.getChangeId())) {
        Account.Id account = Account.Id.fromRefSuffix(ref.getName());
        if (account != null) {
            comments.addAll(draftByPatchSetAuthor(db, psId, account, notes));
        }
    }
    return sort(comments);
}
#end_block

#method_before
// To be used only by HasDraftByLegacyPredicate.
@Deprecated
public List<PatchLineComment> draftByAuthor(ReviewDb db, Account.Id author) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().draftByAuthor(author).toList());
    }
    Set<String> refNames = getRefNamesAllUsers(RefNames.refsDraftCommentsPrefix(author));
    List<PatchLineComment> comments = new ArrayList<>();
    for (String refName : refNames) {
        Change.Id changeId = Change.Id.parse(refName);
        // Avoid loading notes for all affected changes just to be able to auto-
        // rebuild. This is only used in a corner case in the search codepath, so
        // returning slightly stale values is ok.
        DraftCommentNotes notes = draftFactory.createWithAutoRebuildingDisabled(changeId, author);
        comments.addAll(notes.load().getComments().values());
    }
    return sort(comments);
}
#method_after
// To be used only by HasDraftByLegacyPredicate.
@Deprecated
public List<PatchLineComment> draftByAuthor(ReviewDb db, Account.Id author) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().draftByAuthor(author).toList());
    }
    List<PatchLineComment> comments = new ArrayList<>();
    try (Repository repo = repoManager.openRepository(allUsers)) {
        for (String refName : repo.getRefDatabase().getRefs(RefNames.REFS_DRAFT_COMMENTS).keySet()) {
            Account.Id accountId = Account.Id.fromRefSuffix(refName);
            Change.Id changeId = Change.Id.fromRefPart(refName);
            if (accountId == null || changeId == null) {
                continue;
            }
            // Avoid loading notes for all affected changes just to be able to auto-
            // rebuild. This is only used in a corner case in the search codepath,
            // so returning slightly stale values is ok.
            DraftCommentNotes notes = draftFactory.createWithAutoRebuildingDisabled(changeId, author);
            comments.addAll(notes.load().getComments().values());
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
    return sort(comments);
}
#end_block

#method_before
public void deleteAllDraftsFromAllUsers(Change.Id changeId) throws IOException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
        for (Ref ref : getDraftRefs(repo, changeId).values()) {
            bru.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), ref.getName()));
        }
        bru.setRefLogMessage("Delete drafts from NoteDb", false);
        bru.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand cmd : bru.getCommands()) {
            if (cmd.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Failed to delete draft comment ref %s at %s: %s (%s)", cmd.getRefName(), cmd.getOldId(), cmd.getResult(), cmd.getMessage()));
            }
        }
    }
}
#method_after
public void deleteAllDraftsFromAllUsers(Change.Id changeId) throws IOException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
        for (Ref ref : getDraftRefs(repo, changeId)) {
            bru.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), ref.getName()));
        }
        bru.setRefLogMessage("Delete drafts from NoteDb", false);
        bru.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand cmd : bru.getCommands()) {
            if (cmd.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Failed to delete draft comment ref %s at %s: %s (%s)", cmd.getRefName(), cmd.getOldId(), cmd.getResult(), cmd.getMessage()));
            }
        }
    }
}
#end_block

#method_before
public Map<String, Ref> getDraftRefs(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        return getDraftRefs(repo, changeId);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public Collection<Ref> getDraftRefs(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        return getDraftRefs(repo, changeId);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private Map<String, Ref> getDraftRefs(Repository repo, final Change.Id changeId) throws IOException {
    final String suffix = "/" + changeId.get();
    return Maps.filterKeys(repo.getRefDatabase().getRefs(RefNames.REFS_DRAFT_COMMENTS), new Predicate<String>() {

        @Override
        public boolean apply(String input) {
            return input.endsWith(suffix);
        }
    });
}
#method_after
private Collection<Ref> getDraftRefs(Repository repo, Change.Id changeId) throws IOException {
    return repo.getRefDatabase().getRefs(RefNames.refsDraftCommentsPrefix(changeId)).values();
}
#end_block

#method_before
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    boolean updateTs = commit.getParentCount() == 0;
    createdOn = ts;
    parseTag(commit);
    updateTs |= tag != null;
    if (branch == null) {
        branch = parseBranch(commit);
        updateTs |= branch != null;
    }
    if (status == null) {
        status = parseStatus(commit);
        updateTs |= status != null;
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    if (currentPatchSetId == null || psId.get() > currentPatchSetId.get()) {
        currentPatchSetId = psId;
    }
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null && !patchSetStates.containsKey(psId)) {
        patchSetStates.put(psId, psState);
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    if (changeId == null) {
        changeId = parseChangeId(commit);
        updateTs |= changeId != null;
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
        updateTs = true;
    }
    updateTs |= parseChangeMessage(psId, accountId, commit, ts) != null;
    if (topic == null) {
        topic = parseTopic(commit);
        updateTs |= topic != null;
    }
    Set<String> oldHashtags = hashtags;
    parseHashtags(commit);
    updateTs |= hashtags != oldHashtags;
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
        updateTs |= submissionId != null;
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
        updateTs = true;
    }
    parseGroups(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
        updateTs |= !submitRecords.isEmpty();
    }
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, ts, line);
        updateTs = true;
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (updateTs) {
        if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
            lastUpdatedOn = ts;
        }
    }
}
#method_after
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    if (currentPatchSetId == null || psId.get() > currentPatchSetId.get()) {
        currentPatchSetId = psId;
    }
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null && !patchSetStates.containsKey(psId)) {
        patchSetStates.put(psId, psState);
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
}
#end_block

#method_before
private ChangeMessage parseChangeMessage(PatchSet.Id psId, Account.Id accountId, ChangeNotesCommit commit, Timestamp ts) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return null;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return null;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return null;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return null;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, ts, psId);
    changeMessage.setMessage(changeMsgString);
    changeMessage.setTag(tag);
    changeMessagesByPatchSet.put(psId, changeMessage);
    allChangeMessages.add(changeMessage);
    return changeMessage;
}
#method_after
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, ChangeNotesCommit commit, Timestamp ts) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, ts, psId);
    changeMessage.setMessage(changeMsgString);
    changeMessage.setTag(tag);
    changeMessagesByPatchSet.put(psId, changeMessage);
    allChangeMessages.add(changeMessage);
}
#end_block

#method_before
private boolean includedInOne(final Collection<Ref> refs) throws IOException {
    parseCommits(refs);
    List<RevCommit> before = Lists.newLinkedList();
    List<RevCommit> after = Lists.newLinkedList();
    partition(before, after);
    // Within the "before" set we are trying to handle cases arising from clock skew
    return !includedIn(after, 1).isEmpty() || !includedIn(before, 1).isEmpty();
}
#method_after
private boolean includedInOne(final Collection<Ref> refs) throws IOException {
    parseCommits(refs);
    List<RevCommit> before = new LinkedList<>();
    List<RevCommit> after = new LinkedList<>();
    partition(before, after);
    // Within the "before" set we are trying to handle cases arising from clock skew
    return !includedIn(after, 1).isEmpty() || !includedIn(before, 1).isEmpty();
}
#end_block

#method_before
private static WalkResult recursivePath(RevWalk rw, GitilesView view) throws IOException {
    RevTree root = getRoot(view, rw);
    String path = view.getPathPart();
    TreeWalk tw;
    if (!path.isEmpty()) {
        tw = TreeWalk.forPath(rw.getObjectReader(), path, root);
        if (tw == null) {
            return null;
        }
        ObjectId treeSHA = tw.getObjectId(0);
        tw.close();
        ObjectLoader treeLoader = rw.getObjectReader().open(treeSHA);
        if (treeLoader.getType() != Constants.OBJ_TREE) {
            return null;
        }
        tw = new TreeWalk(rw.getObjectReader());
        tw.addTree(treeSHA);
    } else {
        tw = new TreeWalk(rw.getObjectReader());
        tw.addTree(root);
    }
    tw.setRecursive(true);
    return new WalkResult(tw, path, root, root, FileType.TREE, ImmutableList.<Boolean>of());
}
#method_after
private static WalkResult recursivePath(RevWalk rw, GitilesView view) throws IOException {
    RevTree root = getRoot(view, rw);
    String path = view.getPathPart();
    TreeWalk tw;
    if (!path.isEmpty()) {
        try (TreeWalk toRoot = TreeWalk.forPath(rw.getObjectReader(), path, root)) {
            if (toRoot == null) {
                return null;
            }
            ObjectId treeSHA = toRoot.getObjectId(0);
            ObjectLoader treeLoader = rw.getObjectReader().open(treeSHA);
            if (treeLoader.getType() != Constants.OBJ_TREE) {
                return null;
            }
            tw = new TreeWalk(rw.getObjectReader());
            tw.addTree(treeSHA);
        }
    } else {
        tw = new TreeWalk(rw.getObjectReader());
        tw.addTree(root);
    }
    tw.setRecursive(true);
    return new WalkResult(tw, path, root, root, FileType.TREE, ImmutableList.<Boolean>of());
}
#end_block

#method_before
void setContext(final int context) {
    operation(new Runnable() {

        @Override
        public void run() {
            getSkipManager().removeAll();
            getSkipManager().render(context, diff);
            updateRenderEntireFile();
        }
    });
}
#method_after
void setContext(final int context) {
    operation(new Runnable() {

        @Override
        public void run() {
            skipManager.removeAll();
            skipManager.render(context, diff);
            updateRenderEntireFile();
        }
    });
}
#end_block

#method_before
Runnable maybePrevVimSearch(final CodeMirror cm) {
    return new Runnable() {

        @Override
        public void run() {
            if (cm.vim().hasSearchHighlight()) {
                cm.vim().handleKey("n");
            } else {
                getCommentManager().commentNav(cm, Direction.NEXT).run();
            }
        }
    };
}
#method_after
Runnable maybePrevVimSearch(final CodeMirror cm) {
    return new Runnable() {

        @Override
        public void run() {
            if (cm.vim().hasSearchHighlight()) {
                cm.vim().handleKey("N");
            } else {
                getCommentManager().commentNav(cm, Direction.NEXT).run();
            }
        }
    };
}
#end_block

#method_before
void reloadDiffInfo() {
    final int id = ++reloadVersionId;
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            if (id == reloadVersionId && isAttached()) {
                diff = diffInfo;
                operation(new Runnable() {

                    @Override
                    public void run() {
                        getSkipManager().removeAll();
                        getChunkManager().reset();
                        getDiffTable().scrollbar.removeDiffAnnotations();
                        setShowIntraline(prefs.intralineDifference());
                        render(diff);
                        getSkipManager().render(prefs.context(), diff);
                    }
                });
            }
        }
    });
}
#method_after
void reloadDiffInfo() {
    final int id = ++reloadVersionId;
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            if (id == reloadVersionId && isAttached()) {
                diff = diffInfo;
                operation(new Runnable() {

                    @Override
                    public void run() {
                        skipManager.removeAll();
                        getChunkManager().reset();
                        getDiffTable().scrollbar.removeDiffAnnotations();
                        setShowIntraline(prefs.intralineDifference());
                        render(diff);
                        skipManager.render(prefs.context(), diff);
                    }
                });
            }
        }
    });
}
#end_block

#method_before
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) {
            if (clickEvent.getButton() == NativeEvent.BUTTON_LEFT && !clickEvent.getMetaKey() && !clickEvent.getAltKey() && !clickEvent.getCtrlKey() && !clickEvent.getShiftKey()) {
                cm.setCursor(Pos.create(line));
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        getCommentManager().newDraftOnGutterClick(cm, gutterClass, line + 1);
                    }
                });
            }
        }
    };
}
#method_after
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) {
            if (Element.as(clickEvent.getEventTarget()).hasClassName(getLineNumberClassName()) && clickEvent.getButton() == NativeEvent.BUTTON_LEFT && !clickEvent.getMetaKey() && !clickEvent.getAltKey() && !clickEvent.getCtrlKey() && !clickEvent.getShiftKey()) {
                cm.setCursor(Pos.create(line));
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        getCommentManager().newDraftOnGutterClick(cm, gutterClass, line + 1);
                    }
                });
            }
        }
    };
}
#end_block

#method_before
LineOnOtherInfo lineOnOther(DisplaySide side, int line) {
    return getChunkManager().getLineMapper().lineOnOther(side, line);
}
#method_after
LineOnOtherInfo lineOnOther(DisplaySide side, int line) {
    return getChunkManager().lineMapper.lineOnOther(side, line);
}
#end_block

#method_before
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(httpPassword);
                }
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email));
                    extMailto.setEmailAddress(email);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroup = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroup.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user");
                    db.accountSshKeys().insert(Collections.singleton(sshKey));
                }
            }
        }
    }
}
#method_after
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(httpPassword);
                }
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email));
                    extMailto.setEmailAddress(email);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroup = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroup.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user\n");
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    revision = getRevision();
    super.onLoad();
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    revision = getRevision();
    keys = AuthorizedKeys.parse(accountId, readUTF8(AuthorizedKeys.FILE_NAME));
}
#end_block

#method_before
public void save(String message) throws IOException, ConfigInvalidException {
    save(new PersonIdent("Gerrit Initialization", "init@gerrit"), message);
}
#method_after
public void save(String message) throws IOException {
    save(new PersonIdent("Gerrit Initialization", "init@gerrit"), message);
}
#end_block

#method_before
private void save(PersonIdent ident, String msg) throws IOException, ConfigInvalidException {
    File path = getPath();
    if (path == null) {
        throw new IOException(project + " does not exist.");
    }
    try (Repository repo = new FileRepository(path)) {
        inserter = repo.newObjectInserter();
        reader = repo.newObjectReader();
        try (RevWalk rw = new RevWalk(reader)) {
            RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
            newTree = readTree(srcTree);
            CommitBuilder commit = new CommitBuilder();
            commit.setAuthor(ident);
            commit.setCommitter(ident);
            commit.setMessage(msg);
            super.onSave(commit);
            ObjectId res = newTree.writeTree(inserter);
            if (res.equals(srcTree)) {
                return;
            }
            commit.setTreeId(res);
            if (revision != null) {
                commit.addParentId(revision);
            }
            ObjectId newRevision = inserter.insert(commit);
            updateRef(repo, ident, newRevision, "commit: " + msg);
            revision = newRevision;
        } finally {
            if (inserter != null) {
                inserter.close();
                inserter = null;
            }
            if (reader != null) {
                reader.close();
                reader = null;
            }
        }
    }
}
#method_after
private void save(PersonIdent ident, String msg) throws IOException {
    File path = getPath();
    if (path == null) {
        throw new IOException(project + " does not exist.");
    }
    try (Repository repo = new FileRepository(path);
        ObjectInserter i = repo.newObjectInserter();
        ObjectReader r = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader)) {
        inserter = i;
        reader = r;
        RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
        newTree = readTree(srcTree);
        CommitBuilder commit = new CommitBuilder();
        commit.setAuthor(ident);
        commit.setCommitter(ident);
        commit.setMessage(msg);
        onSave(commit);
        ObjectId res = newTree.writeTree(inserter);
        if (res.equals(srcTree)) {
            return;
        }
        commit.setTreeId(res);
        if (revision != null) {
            commit.addParentId(revision);
        }
        ObjectId newRevision = inserter.insert(commit);
        updateRef(repo, ident, newRevision, "commit: " + msg);
        revision = newRevision;
    } finally {
        inserter = null;
        reader = null;
    }
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource.SshKey rsrc, Input input) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to delete SSH keys");
    }
    if (readFromGit) {
        try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
            Repository git = repoManager.openRepository(allUsersName.get())) {
            VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(rsrc.getUser().getAccountId());
            authorizedKeys.load(md);
            if (authorizedKeys.deleteKey(rsrc.getSshKey().getKey().get())) {
                authorizedKeys.commit(md);
            }
        }
    } else {
        List<AccountSshKey> keys = readFromDb(dbProvider.get(), rsrc.getUser().getAccountId());
        if (keys.remove(rsrc.getSshKey())) {
            try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
                Repository git = repoManager.openRepository(allUsersName.get())) {
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(rsrc.getUser().getAccountId());
                authorizedKeys.load(md);
                authorizedKeys.setKeys(keys);
                authorizedKeys.commit(md);
            }
        }
    }
    dbProvider.get().accountSshKeys().deleteKeys(Collections.singleton(rsrc.getSshKey().getKey()));
    sshKeyCache.evict(rsrc.getUser().getUserName());
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource.SshKey rsrc, Input input) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to delete SSH keys");
    }
    authorizedKeys.deleteKey(rsrc.getUser().getAccountId(), rsrc.getSshKey().getKey().get());
    sshKeyCache.evict(rsrc.getUser().getUserName());
    return Response.none();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    keys = new TreeMap<>();
    int seq = 1;
    for (String line : readUTF8(FILE_NAME).split("\\r?\\n")) {
        line = line.trim();
        if (line.isEmpty()) {
            continue;
        } else if (line.startsWith(INVALID_KEY_COMMENT)) {
            String pub = line.substring(INVALID_KEY_COMMENT.length());
            AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq++), pub);
            key.setInvalid();
            keys.put(key.getKey().get(), Optional.of(key));
        } else if (line.startsWith(DELETED_KEY_COMMENT)) {
            keys.put(seq++, Optional.<AccountSshKey>absent());
        } else if (line.startsWith("#")) {
            continue;
        } else {
            AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq++), line);
            keys.put(key.getKey().get(), Optional.of(key));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException {
    keys = AuthorizedKeys.parse(accountId, readUTF8(AuthorizedKeys.FILE_NAME));
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated SSH keys\n");
    }
    StringBuilder b = new StringBuilder();
    for (Optional<AccountSshKey> key : keys.values()) {
        if (key.isPresent()) {
            if (!key.get().isValid()) {
                b.append(INVALID_KEY_COMMENT);
            }
            b.append(key.get().getSshPublicKey().trim());
        } else {
            b.append(DELETED_KEY_COMMENT);
        }
        b.append("\n");
    }
    saveUTF8(FILE_NAME, b.toString());
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException {
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Updated SSH keys\n");
    }
    saveUTF8(AuthorizedKeys.FILE_NAME, AuthorizedKeys.serialize(keys));
    return true;
}
#end_block

#method_before
public List<AccountSshKey> getKeys() {
    checkState(keys != null, "SSH keys not loaded yet");
    List<AccountSshKey> result = new ArrayList<>();
    for (Optional<AccountSshKey> key : keys.values()) {
        if (key.isPresent()) {
            result.add(key.get());
        }
    }
    return result;
}
#method_after
private List<AccountSshKey> getKeys() {
    checkLoaded();
    return Lists.newArrayList(Optional.presentInstances(keys));
}
#end_block

#method_before
public AccountSshKey getKey(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    Optional<AccountSshKey> key = keys.get(seq);
    return key.isPresent() ? key.get() : null;
}
#method_after
private AccountSshKey getKey(int seq) {
    checkLoaded();
    Optional<AccountSshKey> key = keys.get(seq - 1);
    return key.orNull();
}
#end_block

#method_before
public AccountSshKey addKey(String pub) {
    checkState(keys != null, "SSH keys not loaded yet");
    int seq = keys.isEmpty() ? 1 : keys.lastKey() + 1;
    AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq), pub);
    keys.put(seq, Optional.of(key));
    return key;
}
#method_after
private AccountSshKey addKey(String pub) throws InvalidSshKeyException {
    checkLoaded();
    int seq = keys.size() + 1;
    AccountSshKey.Id keyId = new AccountSshKey.Id(accountId, seq);
    AccountSshKey key = sshKeyCreator.create(keyId, pub);
    keys.add(Optional.of(key));
    return key;
}
#end_block

#method_before
public boolean deleteKey(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    if (keys.containsKey(seq) && keys.get(seq).isPresent()) {
        keys.put(seq, Optional.<AccountSshKey>absent());
        return true;
    }
    return false;
}
#method_after
private boolean deleteKey(int seq) {
    checkLoaded();
    if (seq <= keys.size() && keys.get(seq - 1).isPresent()) {
        keys.set(seq - 1, Optional.<AccountSshKey>absent());
        return true;
    }
    return false;
}
#end_block

#method_before
public void markKeyInvalid(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    AccountSshKey key = getKey(seq);
    if (key != null) {
        key.setInvalid();
    }
}
#method_after
private boolean markKeyInvalid(int seq) {
    checkLoaded();
    AccountSshKey key = getKey(seq);
    if (key != null && key.isValid()) {
        key.setInvalid();
        return true;
    }
    return false;
}
#end_block

#method_before
public void setKeys(List<AccountSshKey> newKeys) {
    keys = new TreeMap<>();
    for (AccountSshKey key : newKeys) {
        keys.put(key.getKey().get(), Optional.of(key));
    }
    for (int seq = 1; seq < keys.lastKey(); seq++) {
        if (!keys.containsKey(seq)) {
            keys.put(seq, Optional.<AccountSshKey>absent());
        }
    }
}
#method_after
public void setKeys(Collection<AccountSshKey> newKeys) {
    Ordering<AccountSshKey> o = Ordering.natural().onResultOf(new Function<AccountSshKey, Integer>() {

        @Override
        public Integer apply(AccountSshKey sshKey) {
            return sshKey.getKey().get();
        }
    });
    keys = Collections.nCopies(o.max(newKeys).getKey().get(), Optional.<AccountSshKey>absent());
    for (AccountSshKey key : newKeys) {
        keys.set(key.getKey().get() - 1, Optional.of(key));
    }
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).loader(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).loader(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
            bind(SshKeyCreator.class).to(SshKeyCreatorImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public Iterable<SshKeyCacheEntry> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        final AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, username);
        final AccountExternalId user = db.accountExternalIds().get(key);
        if (user == null) {
            return NO_SUCH_USER;
        }
        final List<SshKeyCacheEntry> kl = new ArrayList<>(4);
        for (AccountSshKey k : readSshKeys(db, user.getAccountId())) {
            if (k.isValid()) {
                add(db, kl, k);
            }
        }
        if (kl.isEmpty()) {
            return NO_KEYS;
        }
        return Collections.unmodifiableList(kl);
    }
}
#method_after
@Override
public Iterable<SshKeyCacheEntry> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, username);
        AccountExternalId user = db.accountExternalIds().get(key);
        if (user == null) {
            return NO_SUCH_USER;
        }
        List<SshKeyCacheEntry> kl = new ArrayList<>(4);
        for (AccountSshKey k : authorizedKeys.getKeys(user.getAccountId())) {
            if (k.isValid()) {
                add(kl, k);
            }
        }
        if (kl.isEmpty()) {
            return NO_KEYS;
        }
        return Collections.unmodifiableList(kl);
    }
}
#end_block

#method_before
private void add(ReviewDb db, List<SshKeyCacheEntry> kl, AccountSshKey k) {
    try {
        kl.add(new SshKeyCacheEntry(k.getKey(), SshUtil.parse(k)));
    } catch (OutOfMemoryError e) {
        // 
        throw e;
    } catch (Throwable e) {
        markInvalid(db, k);
    }
}
#method_after
private void add(List<SshKeyCacheEntry> kl, AccountSshKey k) {
    try {
        kl.add(new SshKeyCacheEntry(k.getKey(), SshUtil.parse(k)));
    } catch (OutOfMemoryError e) {
        // 
        throw e;
    } catch (Throwable e) {
        markInvalid(k);
    }
}
#end_block

#method_before
private void markInvalid(ReviewDb db, AccountSshKey k) {
    try {
        log.info("Flagging SSH key " + k.getKey() + " invalid");
        k.setInvalid();
        db.accountSshKeys().update(Collections.singleton(k));
        List<AccountSshKey> keys = readFromDb(db, k.getAccount());
        try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get(), userFactory.create(k.getAccount()));
            Repository git = repoManager.openRepository(allUsersName.get())) {
            VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(k.getAccount());
            authorizedKeys.load(md);
            authorizedKeys.setKeys(keys);
            authorizedKeys.commit(md);
        }
    } catch (OrmException | IOException | ConfigInvalidException e) {
        log.error("Failed to mark SSH key" + k.getKey() + " invalid", e);
    }
}
#method_after
private void markInvalid(AccountSshKey k) {
    try {
        log.info("Flagging SSH key " + k.getKey() + " invalid");
        authorizedKeys.markKeyInvalid(k.getAccount(), k.getKey().get());
        k.setInvalid();
    } catch (IOException | ConfigInvalidException e) {
        log.error("Failed to mark SSH key" + k.getKey() + " invalid", e);
    }
}
#end_block

#method_before
public AccountResource.SshKey parse(IdentifiedUser user, IdString id) throws ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    try {
        int seq = Integer.parseInt(id.get(), 10);
        AccountSshKey sshKey;
        if (readFromGit) {
            try (Repository git = repoManager.openRepository(allUsersName.get())) {
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(user.getAccountId());
                authorizedKeys.load(git);
                sshKey = authorizedKeys.getKey(seq);
            }
        } else {
            sshKey = dbProvider.get().accountSshKeys().get(new AccountSshKey.Id(user.getAccountId(), seq));
        }
        if (sshKey == null) {
            throw new ResourceNotFoundException(id);
        }
        return new AccountResource.SshKey(user, sshKey);
    } catch (NumberFormatException e) {
        throw new ResourceNotFoundException(id);
    }
}
#method_after
public AccountResource.SshKey parse(IdentifiedUser user, IdString id) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    try {
        int seq = Integer.parseInt(id.get(), 10);
        AccountSshKey sshKey = authorizedKeys.getKey(user.getAccountId(), seq);
        if (sshKey == null) {
            throw new ResourceNotFoundException(id);
        }
        return new AccountResource.SshKey(user, sshKey);
    } catch (NumberFormatException e) {
        throw new ResourceNotFoundException(id);
    }
}
#end_block

#method_before
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    AccountSshKey sshKey;
    if (readFromGit) {
        try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
            Repository git = repoManager.openRepository(allUsersName.get())) {
            VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(user.getAccountId());
            authorizedKeys.load(md);
            sshKey = authorizedKeys.addKey(sshPublicKey);
            authorizedKeys.commit(md);
        }
    } else {
        List<AccountSshKey> keys = readFromDb(dbProvider.get(), user.getAccountId());
        int max = keys.isEmpty() ? 0 : keys.get(keys.size() - 1).getKey().get();
        try {
            sshKey = sshKeyCache.create(new AccountSshKey.Id(user.getAccountId(), max + 1), sshPublicKey);
            keys.add(sshKey);
            try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
                Repository git = repoManager.openRepository(allUsersName.get())) {
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(user.getAccountId());
                authorizedKeys.load(md);
                authorizedKeys.setKeys(keys);
                authorizedKeys.commit(md);
            }
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    dbProvider.get().accountSshKeys().insert(Collections.singleton(sshKey));
    try {
        addKeyFactory.create(user, sshKey).send();
    } catch (EmailException e) {
        log.error("Cannot send SSH key added message to " + user.getAccount().getPreferredEmail(), e);
    }
    sshKeyCache.evict(user.getUserName());
    return Response.<SshKeyInfo>created(GetSshKeys.newSshKeyInfo(sshKey));
}
#method_after
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    try {
        AccountSshKey sshKey = authorizedKeys.addKey(user.getAccountId(), sshPublicKey);
        try {
            addKeyFactory.create(user, sshKey).send();
        } catch (EmailException e) {
            log.error("Cannot send SSH key added message to " + user.getAccount().getPreferredEmail(), e);
        }
        sshKeyCache.evict(user.getUserName());
        return Response.<SshKeyInfo>created(GetSshKeys.newSshKeyInfo(sshKey));
    } catch (InvalidSshKeyException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, Input input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountSshKey key = createSshKey(id, input.sshKey);
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!EmailValidator.getInstance().isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (key != null) {
        addSshKey(db, key, username);
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, Input input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!EmailValidator.getInstance().isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
public synchronized TestAccount create(String username, String email, String fullName, String... groups) throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    TestAccount account = accounts.get(username);
    if (account != null) {
        return account;
    }
    try (ReviewDb db = reviewDbProvider.open()) {
        Account.Id id = new Account.Id(db.nextAccountId());
        AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
        String httpPass = "http-pass";
        extUser.setPassword(httpPass);
        db.accountExternalIds().insert(Collections.singleton(extUser));
        if (email != null) {
            AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(email));
            extMailto.setEmailAddress(email);
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        }
        Account a = new Account(id, TimeUtil.nowTs());
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        db.accounts().insert(Collections.singleton(a));
        if (groups != null) {
            for (String n : groups) {
                AccountGroup.NameKey k = new AccountGroup.NameKey(n);
                AccountGroup g = groupCache.get(k);
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, g.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
            }
        }
        KeyPair sshKey = genSshKey();
        addSshKey(db, id, username, email, sshKey);
        accountCache.evictByUsername(username);
        byEmailCache.evict(email);
        account = new TestAccount(id, username, email, fullName, sshKey, httpPass);
        accounts.put(username, account);
        return account;
    }
}
#method_after
public synchronized TestAccount create(String username, String email, String fullName, String... groups) throws Exception {
    TestAccount account = accounts.get(username);
    if (account != null) {
        return account;
    }
    try (ReviewDb db = reviewDbProvider.open()) {
        Account.Id id = new Account.Id(db.nextAccountId());
        AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
        String httpPass = "http-pass";
        extUser.setPassword(httpPass);
        db.accountExternalIds().insert(Collections.singleton(extUser));
        if (email != null) {
            AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(email));
            extMailto.setEmailAddress(email);
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        }
        Account a = new Account(id, TimeUtil.nowTs());
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        db.accounts().insert(Collections.singleton(a));
        if (groups != null) {
            for (String n : groups) {
                AccountGroup.NameKey k = new AccountGroup.NameKey(n);
                AccountGroup g = groupCache.get(k);
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, g.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
            }
        }
        KeyPair sshKey = genSshKey();
        authorizedKeys.addKey(id, publicKey(sshKey, email));
        sshKeyCache.evict(username);
        accountCache.evictByUsername(username);
        byEmailCache.evict(email);
        account = new TestAccount(id, username, email, fullName, sshKey, httpPass);
        accounts.put(username, account);
        return account;
    }
}
#end_block

#method_before
public TestAccount create(String username, String group) throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create(username, null, username, group);
}
#method_after
public TestAccount create(String username, String group) throws Exception {
    return create(username, null, username, group);
}
#end_block

#method_before
public TestAccount create(String username) throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create(username, null, username, (String[]) null);
}
#method_after
public TestAccount create(String username) throws Exception {
    return create(username, null, username, (String[]) null);
}
#end_block

#method_before
public TestAccount admin() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("admin", "admin@example.com", "Administrator", "Administrators");
}
#method_after
public TestAccount admin() throws Exception {
    return create("admin", "admin@example.com", "Administrator", "Administrators");
}
#end_block

#method_before
public TestAccount admin2() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("admin2", "admin2@example.com", "Administrator2", "Administrators");
}
#method_after
public TestAccount admin2() throws Exception {
    return create("admin2", "admin2@example.com", "Administrator2", "Administrators");
}
#end_block

#method_before
public TestAccount user() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("user", "user@example.com", "User");
}
#method_after
public TestAccount user() throws Exception {
    return create("user", "user@example.com", "User");
}
#end_block

#method_before
public TestAccount user2() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("user2", "user2@example.com", "User2");
}
#method_after
public TestAccount user2() throws Exception {
    return create("user2", "user2@example.com", "User2");
}
#end_block

#method_before
public List<SshKeyInfo> apply(IdentifiedUser user) throws OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    List<AccountSshKey> keys = readFromGit ? readFromGit(user.getAccountId()) : readFromDb(dbProvider.get(), user.getAccountId());
    return Lists.transform(keys, new Function<AccountSshKey, SshKeyInfo>() {

        @Override
        public SshKeyInfo apply(AccountSshKey key) {
            return newSshKeyInfo(key);
        }
    });
}
#method_after
public List<SshKeyInfo> apply(IdentifiedUser user) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    return Lists.transform(authorizedKeys.getKeys(user.getAccountId()), new Function<AccountSshKey, SshKeyInfo>() {

        @Override
        public SshKeyInfo apply(AccountSshKey key) {
            return newSshKeyInfo(key);
        }
    });
}
#end_block

#method_before
@Override
public String getAvatarUrl(int size) throws RestApiException {
    GetAvatar myGetAvatar = getAvatar.get();
    myGetAvatar.setSize(size);
    return myGetAvatar.apply(account).location();
}
#method_after
@Override
public String getAvatarUrl(int size) throws RestApiException {
    getAvatar.setSize(size);
    return getAvatar.apply(account).location();
}
#end_block

#method_before
@Override
public void starChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        starredChangesCreate.setChange(rsrc);
        starredChangesCreate.apply(account, new StarredChanges.EmptyInput());
    } catch (OrmException e) {
        throw new RestApiException("Cannot star change", e);
    }
}
#method_after
@Override
public void starChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        starredChangesCreate.setChange(rsrc);
        starredChangesCreate.apply(account, new StarredChanges.EmptyInput());
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot star change", e);
    }
}
#end_block

#method_before
@Override
public void unstarChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        AccountResource.StarredChange starredChange = new AccountResource.StarredChange(account.getUser(), rsrc);
        starredChangesDelete.apply(starredChange, new StarredChanges.EmptyInput());
    } catch (OrmException e) {
        throw new RestApiException("Cannot unstar change", e);
    }
}
#method_after
@Override
public void unstarChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        AccountResource.StarredChange starredChange = new AccountResource.StarredChange(account.getUser(), rsrc);
        starredChangesDelete.apply(starredChange, new StarredChanges.EmptyInput());
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot unstar change", e);
    }
}
#end_block

#method_before
@Override
protected void set(int newValue) {
    if (newValue < 0) {
        throw new IllegalArgumentException("invalid sequence number " + newValue);
    }
    seq = newValue;
}
#method_after
@Override
protected void set(int newValue) {
    seq = newValue;
}
#end_block

#method_before
public boolean isValid() {
    return valid;
}
#method_after
public boolean isValid() {
    return valid && id.isValid();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watchedprojects").to(GetWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watched.projects").to(GetWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#end_block

#method_before
@Override
public List<WatchedProjectInfo> getWatchedProjects() throws RestApiException {
    return getWatchedProjects.apply(account);
}
#method_after
@Override
public List<ProjectWatchInfo> getWatchedProjects() throws RestApiException {
    try {
        return getWatchedProjects.apply(account);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get watched projects", e);
    }
}
#end_block

#method_before
@Override
public List<SshKeyInfo> listSshKeys() throws RestApiException {
    try {
        return getSshKeys.apply(account);
    } catch (OrmException e) {
        throw new RestApiException("Cannot list SSH keys", e);
    }
}
#method_after
@Override
public List<SshKeyInfo> listSshKeys() throws RestApiException {
    try {
        return getSshKeys.apply(account);
    } catch (OrmException | IOException | ConfigInvalidException e) {
        throw new RestApiException("Cannot list SSH keys", e);
    }
}
#end_block

#method_before
@Override
public SshKeyInfo addSshKey(String key) throws RestApiException {
    AddSshKey.Input in = new AddSshKey.Input();
    in.raw = RawInputUtil.create(key);
    try {
        return addSshKey.apply(account, in).value();
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot add SSH key", e);
    }
}
#method_after
@Override
public SshKeyInfo addSshKey(String key) throws RestApiException {
    AddSshKey.Input in = new AddSshKey.Input();
    in.raw = RawInputUtil.create(key);
    try {
        return addSshKey.apply(account, in).value();
    } catch (OrmException | IOException | ConfigInvalidException e) {
        throw new RestApiException("Cannot add SSH key", e);
    }
}
#end_block

#method_before
@Override
public List<WatchedProjectInfo> apply(AccountResource rsrc) {
    List<WatchedProjectInfo> watchedProjectInfos = new LinkedList<>();
    for (AccountProjectWatch a : rsrc.getUser().getNotificationFilters()) {
        WatchedProjectInfo wpi = new WatchedProjectInfo();
        wpi.filter = a.getFilter();
        wpi.projectName = a.getProjectNameKey().get();
        wpi.notifyAbandonedChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES));
        wpi.notifyNewChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.NEW_CHANGES));
        wpi.notifyNewPatchSets = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.NEW_PATCHSETS));
        wpi.notifySubmittedChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES));
        wpi.notifyAllComments = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.ALL_COMMENTS));
        watchedProjectInfos.add(wpi);
    }
    return watchedProjectInfos;
}
#method_after
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException {
    if (self.get() != rsrc.getUser()) {
        throw new AuthException("It is not allowed to list project watches " + "of other users");
    }
    List<ProjectWatchInfo> projectWatchInfos = new LinkedList<>();
    Iterable<AccountProjectWatch> projectWatches = dbProvider.get().accountProjectWatches().byAccount(rsrc.getUser().getAccountId());
    for (AccountProjectWatch a : projectWatches) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = a.getFilter();
        pwi.project = a.getProjectNameKey().get();
        pwi.notifyAbandonedChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    return projectWatchInfos;
}
#end_block

#method_before
@Override
public List<WatchedProjectInfo> getWatchedProjects() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<ProjectWatchInfo> getWatchedProjects() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, @Nullable String newFile, @Nullable RawInput content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = currentUser.get().asIdentifiedUser();
    Project.NameKey project = edit.getChange().getProject();
    try (Repository repo = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader()) {
        String refName = edit.getRefName();
        RevCommit prevEdit = edit.getEditCommit();
        ObjectId newTree = writeNewTree(op, rw, inserter, prevEdit, reader, file, newFile, toBlob(inserter, content));
        if (ObjectId.equals(newTree, prevEdit.getTree())) {
            throw new InvalidChangeOperationException("no changes were made");
        }
        Timestamp now = TimeUtil.nowTs();
        ObjectId commit = createCommit(me, inserter, prevEdit, newTree, now);
        inserter.flush();
        return update(repo, me, refName, rw, prevEdit, commit, now);
    }
}
#method_after
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, @Nullable String newFile, @Nullable RawInput content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = currentUser.get().asIdentifiedUser();
    Project.NameKey project = edit.getChange().getProject();
    try (Repository repo = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader()) {
        String refName = edit.getRefName();
        RevCommit prevEdit = edit.getEditCommit();
        ObjectId newTree = writeNewTree(op, rw, inserter, prevEdit, reader, file, newFile, content);
        if (ObjectId.equals(newTree, prevEdit.getTree())) {
            throw new InvalidChangeOperationException("no changes were made");
        }
        Timestamp now = TimeUtil.nowTs();
        ObjectId commit = createCommit(me, inserter, prevEdit, newTree, now);
        inserter.flush();
        return update(repo, me, refName, rw, prevEdit, commit, now);
    }
}
#end_block

#method_before
private static ObjectId writeNewTree(TreeOperation op, RevWalk rw, ObjectInserter ins, RevCommit prevEdit, final ObjectReader reader, String fileName, @Nullable String newFile, @Nullable final ObjectId content) throws IOException {
    DirCache newTree = readTree(reader, prevEdit);
    DirCacheEditor dce = newTree.editor();
    switch(op) {
        case DELETE_ENTRY:
            dce.add(new DeletePath(fileName));
            break;
        case RENAME_ENTRY:
            rw.parseHeaders(prevEdit);
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), fileName, prevEdit.getTree());
            if (tw != null) {
                dce.add(new DeletePath(fileName));
                addFileToCommit(newFile, dce, tw);
            }
            break;
        case CHANGE_ENTRY:
            checkNotNull(content, "new content required");
            dce.add(new PathEdit(fileName) {

                @Override
                public void apply(DirCacheEntry ent) {
                    if (ent.getRawMode() == 0) {
                        ent.setFileMode(FileMode.REGULAR_FILE);
                    }
                    FileMode mode = ent.getFileMode();
                    if (FileMode.GITLINK != mode) {
                        ent.setObjectId(content);
                    } else {
                        ent.setLength(0);
                        ent.setLastModified(0);
                        try {
                            ObjectId id = ObjectId.fromString(reader.open(content).getBytes(), 0);
                            ent.setObjectId(id);
                        } catch (LargeObjectException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        } catch (MissingObjectException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        } catch (IOException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                    }
                }
            });
            break;
        case RESTORE_ENTRY:
            if (prevEdit.getParentCount() == 0) {
                dce.add(new DeletePath(fileName));
                break;
            }
            RevCommit base = prevEdit.getParent(0);
            rw.parseHeaders(base);
            tw = TreeWalk.forPath(rw.getObjectReader(), fileName, base.getTree());
            if (tw == null) {
                dce.add(new DeletePath(fileName));
                break;
            }
            addFileToCommit(fileName, dce, tw);
            break;
    }
    dce.finish();
    return newTree.writeTree(ins);
}
#method_after
private static ObjectId writeNewTree(TreeOperation op, RevWalk rw, final ObjectInserter ins, RevCommit prevEdit, ObjectReader reader, String fileName, @Nullable String newFile, @Nullable final RawInput content) throws InvalidChangeOperationException, IOException {
    DirCache newTree = readTree(reader, prevEdit);
    DirCacheEditor dce = newTree.editor();
    switch(op) {
        case DELETE_ENTRY:
            dce.add(new DeletePath(fileName));
            break;
        case RENAME_ENTRY:
            rw.parseHeaders(prevEdit);
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), fileName, prevEdit.getTree());
            if (tw != null) {
                dce.add(new DeletePath(fileName));
                addFileToCommit(newFile, dce, tw);
            }
            break;
        case CHANGE_ENTRY:
            checkNotNull(content, "new content required");
            final AtomicReference<IOException> ioe = new AtomicReference<>(null);
            final AtomicReference<InvalidChangeOperationException> icoe = new AtomicReference<>(null);
            dce.add(new PathEdit(fileName) {

                @Override
                public void apply(DirCacheEntry ent) {
                    try {
                        if (ent.getFileMode() == FileMode.GITLINK) {
                            ent.setLength(0);
                            ent.setLastModified(0);
                            ent.setObjectId(ObjectId.fromString(ByteStreams.toByteArray(content.getInputStream()), 0));
                        } else {
                            if (ent.getRawMode() == 0) {
                                ent.setFileMode(FileMode.REGULAR_FILE);
                            }
                            ent.setObjectId(toBlob(ins, content));
                        }
                    } catch (IOException e) {
                        ioe.set(e);
                    } catch (InvalidObjectIdException e) {
                        icoe.set(new InvalidChangeOperationException("Invalid object id in submodule link: " + e.getMessage()));
                        icoe.get().initCause(e);
                    }
                }
            });
            if (ioe.get() != null) {
                throw ioe.get();
            }
            if (icoe.get() != null) {
                throw icoe.get();
            }
            break;
        case RESTORE_ENTRY:
            if (prevEdit.getParentCount() == 0) {
                dce.add(new DeletePath(fileName));
                break;
            }
            RevCommit base = prevEdit.getParent(0);
            rw.parseHeaders(base);
            tw = TreeWalk.forPath(rw.getObjectReader(), fileName, base.getTree());
            if (tw == null) {
                dce.add(new DeletePath(fileName));
                break;
            }
            addFileToCommit(fileName, dce, tw);
            break;
    }
    dce.finish();
    return newTree.writeTree(ins);
}
#end_block

#method_before
public Collection<Branch.NameKey> getDestinationBranches(Branch.NameKey src, SubscribeSection s) throws IOException {
    Collection<Branch.NameKey> ret = new ArrayList<>();
    logDebug("Inspecting SubscribeSection " + s);
    for (RefSpec r : s.getRefSpecs()) {
        logDebug("Inspecting ref " + r);
        if (r.matchSource(src.get())) {
            if (r.getDestination() == null) {
                // no need to care for wildcard, as we matched already
                try {
                    mergeOp.openRepo(s.getProject(), false);
                } catch (NoSuchProjectException e) {
                    // to subscribe to it. Allow this for now.
                    continue;
                }
                OpenRepo or = mergeOp.getRepo(s.getProject());
                for (Ref ref : or.repo.getRefDatabase().getRefs(RefNames.REFS_HEADS).values()) {
                    ret.add(new Branch.NameKey(s.getProject(), ref.getName()));
                }
            } else if (r.isWildcard()) {
                // refs/heads/*:refs/heads/*
                ret.add(new Branch.NameKey(s.getProject(), r.expandFromSource(src.get()).getDestination()));
            } else {
                // e.g. refs/heads/master:refs/heads/stable
                ret.add(new Branch.NameKey(s.getProject(), r.getDestination()));
            }
        }
    }
    logDebug("Returning possible branches: " + ret + "for project " + s.getProject());
    return ret;
}
#method_after
public Collection<Branch.NameKey> getDestinationBranches(Branch.NameKey src, SubscribeSection s, MergeOpRepoManager orm) throws IOException {
    Collection<Branch.NameKey> ret = new ArrayList<>();
    logDebug("Inspecting SubscribeSection " + s);
    for (RefSpec r : s.getRefSpecs()) {
        logDebug("Inspecting ref " + r);
        if (r.matchSource(src.get())) {
            if (r.getDestination() == null) {
                // no need to care for wildcard, as we matched already
                try {
                    orm.openRepo(s.getProject(), false);
                } catch (NoSuchProjectException e) {
                    // to subscribe to it. Allow this for now.
                    continue;
                }
                OpenRepo or = orm.getRepo(s.getProject());
                for (Ref ref : or.repo.getRefDatabase().getRefs(RefNames.REFS_HEADS).values()) {
                    ret.add(new Branch.NameKey(s.getProject(), ref.getName()));
                }
            } else if (r.isWildcard()) {
                // refs/heads/*:refs/heads/*
                ret.add(new Branch.NameKey(s.getProject(), r.expandFromSource(src.get()).getDestination()));
            } else {
                // e.g. refs/heads/master:refs/heads/stable
                ret.add(new Branch.NameKey(s.getProject(), r.getDestination()));
            }
        }
    }
    logDebug("Returning possible branches: " + ret + "for project " + s.getProject());
    return ret;
}
#end_block

#method_before
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : cfg.getSubscribeSections(branch)) {
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId);
            m.load();
            ret.addAll(m.subscribedTo(branch));
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch, MergeOpRepoManager orm) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : cfg.getSubscribeSections(branch)) {
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s, orm);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm);
            m.load();
            ret.addAll(m.subscribedTo(branch));
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest));
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch, orm)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest), orm);
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        mergeOp.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = mergeOp.getRepo(subscriber.getParentKey());
    Repository pdb = or.repo;
    try {
        if (pdb.exactRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.exactRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                mergeOp.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = mergeOp.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates, MergeOpRepoManager orm) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId, orm);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#method_after
private static DirCache readTree(final Ref branch, RevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, rw.getObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#end_block

#method_before
@Override
public void close() {
    for (OpenRepo repo : openRepos.values()) {
        repo.close();
    }
}
#method_after
@Override
public void close() {
    orm.close();
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Collection<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    failFast(cs);
    List<SubmitStrategy> strategies = new ArrayList<>(branches.size());
    for (Branch.NameKey branch : branches) {
        OpenRepo or = getRepo(branch.getParentKey());
        OpenBranch ob = or.getBranch(branch);
        BranchBatch submitting = toSubmit.get(branch);
        checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
        Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
        ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
        SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip);
        strategies.add(strategy);
        strategy.addOps(or.getUpdate(), commitsToSubmit);
    }
    try {
        BatchUpdate.execute(batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    SubmoduleOp subOp = subOpProvider.get();
    updateSuperProjects(subOp, br.values());
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Collection<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    failFast(cs);
    List<SubmitStrategy> strategies = new ArrayList<>(branches.size());
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        OpenBranch ob = or.getBranch(branch);
        BranchBatch submitting = toSubmit.get(branch);
        checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
        Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
        ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
        SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip);
        strategies.add(strategy);
        strategy.addOps(or.getUpdate(), commitsToSubmit);
    }
    try {
        BatchUpdate.execute(batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    updateSuperProjects(br.values());
}
#end_block

#method_before
private List<BatchUpdate> batchUpdates(Collection<Project.NameKey> projects) {
    List<BatchUpdate> updates = new ArrayList<>(projects.size());
    for (Project.NameKey project : projects) {
        updates.add(getRepo(project).getUpdate());
    }
    return updates;
}
#method_after
private List<BatchUpdate> batchUpdates(Collection<Project.NameKey> projects) {
    List<BatchUpdate> updates = new ArrayList<>(projects.size());
    for (Project.NameKey project : projects) {
        updates.add(orm.getRepo(project).getUpdate());
    }
    return updates;
}
#end_block

#method_before
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId);
}
#method_after
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify);
}
#end_block

#method_before
private void updateSuperProjects(SubmoduleOp subOp, Collection<Branch.NameKey> branches) {
    logDebug("Updating superprojects");
    try {
        subOp.updateSuperProjects(db, branches, submissionId);
        logDebug("Updating superprojects done");
    } catch (SubmoduleException e) {
        logError("The gitlinks were not updated according to the " + "subscriptions", e);
    }
}
#method_after
private void updateSuperProjects(Collection<Branch.NameKey> branches) {
    logDebug("Updating superprojects");
    SubmoduleOp subOp = subOpProvider.get();
    try {
        subOp.updateSuperProjects(db, branches, submissionId, orm);
        logDebug("Updating superprojects done");
    } catch (SubmoduleException e) {
        logError("The gitlinks were not updated according to the " + "subscriptions", e);
    }
}
#end_block

#method_before
private void openRepos(Collection<Project.NameKey> projects) throws IntegrationException {
    for (Project.NameKey project : projects) {
        try {
            openRepo(project, true);
        } catch (NoSuchProjectException noProject) {
            logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
            abandonAllOpenChangeForDeletedProject(noProject.project());
        } catch (IOException e) {
            throw new IntegrationException("Error opening project " + project, e);
        }
    }
}
#method_after
private void openRepos(Collection<Project.NameKey> projects) throws IntegrationException {
    for (Project.NameKey project : projects) {
        try {
            orm.openRepo(project, true);
        } catch (NoSuchProjectException noProject) {
            logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
            abandonAllOpenChangeForDeletedProject(noProject.project());
        } catch (IOException e) {
            throw new IntegrationException("Error opening project " + project, e);
        }
    }
}
#end_block

#method_before
void load() throws IOException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try {
        mergeOp.openRepo(project, false);
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
    OpenRepo or = mergeOp.getRepo(project);
    ObjectId id = or.repo.resolve(branch.get());
    if (id == null) {
        throw new IOException("Cannot open branch " + branch.get());
    }
    RevCommit commit = or.rw.parseCommit(id);
    TreeWalk tw = TreeWalk.forPath(or.repo, GIT_MODULES, commit.getTree());
    if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
        return;
    }
    try {
        BlobBasedConfig bbc = new BlobBasedConfig(null, or.repo, commit, GIT_MODULES);
        subscriptions = subSecParserFactory.create(bbc, thisServer, branch).parseAllSections();
    } catch (ConfigInvalidException e) {
        throw new IOException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#method_after
void load() throws IOException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try {
        orm.openRepo(project, false);
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
    OpenRepo or = orm.getRepo(project);
    ObjectId id = or.repo.resolve(branch.get());
    if (id == null) {
        throw new IOException("Cannot open branch " + branch.get());
    }
    RevCommit commit = or.rw.parseCommit(id);
    TreeWalk tw = TreeWalk.forPath(or.repo, GIT_MODULES, commit.getTree());
    if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
        return;
    }
    try {
        BlobBasedConfig bbc = new BlobBasedConfig(null, or.repo, commit, GIT_MODULES);
        subscriptions = subSecParserFactory.create(bbc, thisServer, branch).parseAllSections();
    } catch (ConfigInvalidException e) {
        throw new IOException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#end_block

#method_before
@Override
public String healthCheck(final Check check) throws IOException {
    if (check.equals(Check.ACCESS))
        return healthCheckAccess();
    else
        return healthCheckSysinfo();
}
#method_after
@Override
public String healthCheck(final Check check) throws IOException {
    return execute(new Callable<String>() {

        @Override
        public String call() throws Exception {
            if (check.equals(Check.ACCESS))
                return healthCheckAccess();
            else
                return healthCheckSysinfo();
        }
    });
}
#end_block

#method_before
@Override
public void addComment(final String issueKey, final String comment) throws IOException {
    try {
        log.debug("Adding comment {} to issue {}", comment, issueKey);
        client().addComment(issueKey, Comment.valueOf(comment));
        log.debug("Added comment {} to issue {}", comment, issueKey);
    } catch (IOException e) {
        log.error("Failed to add comment {} to issue {}", comment, issueKey);
    }
}
#method_after
@Override
public void addComment(final String issueKey, final String comment) throws IOException {
    execute(new Callable<String>() {

        @Override
        public String call() throws Exception {
            log.debug("Adding comment {} to issue {}", comment, issueKey);
            client().addComment(issueKey, Comment.valueOf(comment));
            log.debug("Added comment {} to issue {}", comment, issueKey);
            return issueKey;
        }
    });
}
#end_block

#method_before
@Override
public void performAction(final String issueKey, final String actionName) throws IOException {
    try {
        log.debug("Performing action {} on issue {}", actionName, issueKey);
        doPerformAction(issueKey, actionName);
    } catch (IOException e) {
        log.error("Failed to perform action {} on issue {}", actionName, issueKey);
        throw new IOException(e);
    }
}
#method_after
@Override
public void performAction(final String issueKey, final String actionName) throws IOException {
    execute(new Callable<String>() {

        @Override
        public String call() throws Exception {
            log.debug("Performing action {} on issue {}", actionName, issueKey);
            doPerformAction(issueKey, actionName);
            return issueKey;
        }
    });
}
#end_block

#method_before
private void doPerformAction(final String issueKey, final String actionName) throws IOException {
    log.debug("Trying to perform action: " + actionName + " on issue " + issueKey);
    try {
        boolean ret = client().doTransition(issueKey, actionName);
        if (ret) {
            log.debug("Action " + actionName + " successful on Issue " + issueKey);
        } else {
            log.debug("Transitioning to current status not possible");
        }
    } catch (IOException e) {
        StringBuilder sb = new StringBuilder();
        for (Transition t : client().getTransitions(issueKey)) {
            if (sb.length() > 0) {
                sb.append(',');
            }
            sb.append('\'');
            sb.append(t.getName());
            sb.append('\'');
        }
        log.error("Available Transitions: " + sb);
        throw e;
    }
}
#method_after
private void doPerformAction(final String issueKey, final String actionName) throws IOException {
    log.debug("Trying to perform action: " + actionName + " on issue " + issueKey);
    boolean ret = client().doTransition(issueKey, actionName);
    if (ret) {
        log.debug("Action " + actionName + " successful on Issue " + issueKey);
    } else {
        log.debug("Action {} on Issue {} not possible", actionName, issueKey);
    }
}
#end_block

#method_before
@Override
public boolean exists(final String issueKey) throws IOException {
    return client().issueExists(issueKey);
}
#method_after
@Override
public boolean exists(final String issueKey) throws IOException {
    return execute(new Callable<Boolean>() {

        @Override
        public Boolean call() throws Exception {
            return client().issueExists(issueKey);
        }
    });
}
#end_block

#method_before
private JiraClient client() throws IOException {
    if (client == null) {
        try {
            log.debug("Connecting to jira at {}", getUrl());
            client = new JiraClient(getUrl(), getUsername(), getPassword());
            log.debug("Authenticating as User {}", getUsername());
        } catch (URISyntaxException e) {
            log.error("Connecting failed at {} as user {}", getUrl(), getUsername());
            throw new IOException(e);
        }
    }
    return client;
}
#method_after
private JiraClient client() throws IOException {
    if (client == null) {
        try {
            log.debug("Connecting to jira at {}", getUrl());
            client = new JiraClient(getUrl(), getUsername(), getPassword());
            log.debug("Authenticating as User {}", getUsername());
        } catch (Exception e) {
            log.info("Unable to connect to " + getUrl() + " as " + getUsername());
            throw new IOException(e);
        }
    }
    return client;
}
#end_block

#method_before
private String healthCheckAccess() throws IOException {
    try {
        new JiraClient(getUrl(), getUsername(), getPassword()).sysInfo();
    } catch (URISyntaxException e) {
        throw new IOException(e);
    }
    final String result = "{\"status\"=\"ok\",\"username\"=\"" + getUsername() + "\"}";
    log.debug("Healtheck on access result: {}", result);
    return result;
}
#method_after
private String healthCheckAccess() throws IOException {
    client().sysInfo();
    final String result = "{\"status\"=\"ok\",\"username\"=\"" + getUsername() + "\"}";
    log.debug("Healtheck on access result: {}", result);
    return result;
}
#end_block

#method_before
public Issue getIssue(String issueKey) throws IOException {
    IssueRestClient issueClient = this.client.getIssueClient();
    Promise<Issue> promise = issueClient.getIssue(issueKey);
    try {
        return promise.claim();
    } catch (Exception e) {
        log.error("Failed to get issue by issuekey " + issueKey);
        throw new IOException(e);
    }
}
#method_after
public Issue getIssue(String issueKey) throws RestClientException {
    IssueRestClient issueClient = this.client.getIssueClient();
    return issueClient.getIssue(issueKey).claim();
}
#end_block

#method_before
public boolean issueExists(String issueKey) {
    try {
        getIssue(issueKey);
        return true;
    } catch (IOException e) {
        log.error("Issue " + issueKey + " not found " + e.getCause().getMessage());
        return false;
    }
}
#method_after
public boolean issueExists(String issueKey) throws RestClientException {
    boolean ret = true;
    try {
        getIssue(issueKey);
    } catch (RestClientException e) {
        if (e.getStatusCode().get() == 404) {
            log.error("Issue " + issueKey + " not found ");
            ret = false;
        } else {
            throw e;
        }
    }
    return ret;
}
#end_block

#method_before
public Iterable<Transition> getTransitions(String issueKey) throws IOException {
    try {
        return client.getIssueClient().getTransitions(getIssue(issueKey)).get();
    } catch (Exception e) {
        log.error("Failed to retrieve transitions of issue " + issueKey);
        throw new IOException("Transitions error", e);
    }
}
#method_after
public Iterable<Transition> getTransitions(String issueKey) throws RestClientException {
    return client.getIssueClient().getTransitions(getIssue(issueKey)).claim();
}
#end_block

#method_before
public void addComment(String issueKey, Comment comment) throws IOException {
    try {
        log.debug("Trying to add comment for issue " + issueKey);
        Issue issue = getIssue(issueKey);
        URI issueUri = new URI(issue.getSelf().toString() + "/comment/");
        IssueRestClient issueClient = client.getIssueClient();
        Promise<Void> promise = issueClient.addComment(issueUri, comment);
        promise.claim();
        log.debug("Comment added to issue " + issueKey);
    } catch (Exception e) {
        log.error("Could not add comment to issue " + issueKey);
        throw new IOException("Adding Comment to issue " + issueKey + " failed", e);
    }
}
#method_after
public void addComment(String issueKey, Comment comment) throws RestClientException, URISyntaxException {
    log.debug("Trying to add comment for issue " + issueKey);
    Issue issue = getIssue(issueKey);
    URI issueUri;
    issueUri = new URI(issue.getSelf().toString() + "/comment/");
    IssueRestClient issueClient = client.getIssueClient();
    Promise<Void> promise = issueClient.addComment(issueUri, comment);
    promise.claim();
    log.debug("Comment added to issue " + issueKey);
}
#end_block

#method_before
public boolean doTransition(String issueKey, String transition) {
    Transition t;
    boolean result = false;
    try {
        t = getTransitionByName(getTransitions(issueKey), transition);
        TransitionInput input;
        input = new TransitionInput(t.getId());
        log.debug("Setting transition input to: " + input.toString());
        client.getIssueClient().transition(getIssue(issueKey), input).claim();
        result = true;
    } catch (IOException e) {
        log.error(e.getMessage());
    }
    return result;
}
#method_after
public boolean doTransition(String issueKey, String transition) throws RestClientException, InvalidTransitionException {
    Transition t = getTransitionByName(getTransitions(issueKey), transition);
    if (t == null) {
        throw new InvalidTransitionException("Action " + transition + " not executable on issue " + issueKey);
    }
    TransitionInput input;
    input = new TransitionInput(t.getId());
    log.debug("Setting transition input to: " + input.toString());
    client.getIssueClient().transition(getIssue(issueKey), input).claim();
    return true;
}
#end_block

#method_before
public ServerInfo sysInfo() throws IOException {
    try {
        return client.getMetadataClient().getServerInfo().get();
    } catch (InterruptedException e) {
        log.error("Serverinfo request interrupted");
        throw new IOException(e);
    } catch (ExecutionException e) {
        log.error(e.getMessage());
        throw new IOException(e);
    }
}
#method_after
public ServerInfo sysInfo() throws RestClientException {
    return client.getMetadataClient().getServerInfo().claim();
}
#end_block

#method_before
private Transition getTransitionByName(Iterable<Transition> transitions, String transition) throws IOException {
    for (Transition t : transitions) {
        if (transition.equals(t.getName())) {
            return t;
        }
    }
    throw new IOException("No matching transition found");
}
#method_after
private Transition getTransitionByName(Iterable<Transition> transitions, String transition) {
    Transition ret = null;
    for (Transition t : transitions) {
        if (transition.equals(t.getName())) {
            ret = t;
            break;
        }
    }
    return ret;
}
#end_block

#method_before
private boolean isJiraConnectSuccessful() {
    ui.message("Checking Jira connectivity ... ");
    try {
        new JiraClient(jiraUrl, jiraUsername, jiraPassword).sysInfo().getVersion();
        ui.message("[OK]\n");
        return true;
    } catch (URISyntaxException | IOException e) {
        ui.message("*FAILED* (%s)\n", e.toString());
        return false;
    }
}
#method_after
private boolean isJiraConnectSuccessful() {
    ui.message("Checking Jira connectivity ... ");
    try {
        new JiraClient(jiraUrl, jiraUsername, jiraPassword).sysInfo().getVersion();
        ui.message("[OK]\n");
        return true;
    } catch (URISyntaxException e) {
        ui.message("*FAILED* (%s)\n", e.toString());
        return false;
    }
}
#end_block

#method_before
@Override
public Response<?> apply(ReviewerResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    ChangeControl control = rsrc.getControl();
    Change.Id changeId = rsrc.getId();
    ReviewDb db = dbProvider.get();
    ChangeUpdate update = updateFactory.create(rsrc.getControl());
    StringBuilder msg = new StringBuilder();
    db.changes().beginTransaction(changeId);
    try {
        List<PatchSetApproval> del = Lists.newArrayList();
        for (PatchSetApproval a : approvals(db, rsrc)) {
            if (control.canRemoveReviewer(a)) {
                del.add(a);
                if (a.getPatchSetId().equals(control.getChange().currentPatchSetId()) && a.getValue() != 0) {
                    if (msg.length() == 0) {
                        msg.append("Removed the following votes:\n\n");
                    }
                    msg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                }
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (del.isEmpty()) {
            throw new ResourceNotFoundException();
        }
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getId(), db);
        db.patchSetApprovals().delete(del);
        update.removeReviewer(rsrc.getUser().getAccountId());
        if (msg.length() > 0) {
            ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(rsrc.getId(), ChangeUtil.messageUUID(db)), control.getUser().getAccountId(), TimeUtil.nowTs(), rsrc.getChange().currentPatchSetId());
            changeMessage.setMessage(msg.toString());
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        emailReviewers(rsrc.getChange(), del);
        if (!del.isEmpty()) {
            PatchSet patchSet = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
            for (PatchSetApproval psa : del) {
                Account account = accountCache.get(psa.getAccountId()).getAccount();
                hooks.doReviewerDeletedHook(rsrc.getChange(), account, patchSet, dbProvider.get());
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    indexer.index(db, rsrc.getChange());
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ReviewerResource rsrc, Input input) throws RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getChangeResource().getProject(), rsrc.getChangeResource().getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc.getReviewerUser().getAccount());
        bu.addOp(rsrc.getChange().getId(), op);
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> approvals) {
    if (approvals.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they removed themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(approvals.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : approvals) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            DeleteReviewerSender cm = deleteReviewerSenderFactory.create(change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Project.NameKey projectName, Change change, List<PatchSetApproval> dels, ChangeMessage changeMessage) {
    // The user knows they removed themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(dels.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : dels) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            DeleteReviewerSender cm = deleteReviewerSenderFactory.create(projectName, change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.setChangeMessage(changeMessage);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot email update for change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(GitModules.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    bind(EventDispatcher.class).to(ChangeHookRunner.class);
    bind(EventSource.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private static Path hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    return path.resolve(value != null ? value : name);
}
#method_after
private static Optional<Path> hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    Path p = path.resolve(value != null ? value : name);
    return Files.exists(p) ? Optional.of(p) : Optional.<Path>absent();
}
#end_block

#method_before
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#method_after
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    if (!refUpdateHook.isPresent()) {
        return null;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#end_block

#method_before
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#method_after
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    dispatcher.get().postEvent(project, event);
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, final Map<String, Short> oldApprovals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval, oldApprovals);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null && approval.getValue() != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            if (oldApprovals != null && !oldApprovals.isEmpty()) {
                Short oldValue = oldApprovals.get(approval.getKey());
                if (oldValue != null) {
                    addArg(args, "--" + lt.getName() + "-oldValue", Short.toString(oldValue));
                }
            }
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    dispatcher.get().postEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#method_after
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(Branch.NameKey refName, ObjectId oldId, ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    dispatcher.get().postEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerDeletedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerDeletedEvent event = new ReviewerDeletedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerDeletedHook, args);
}
#method_after
@Override
public void doReviewerDeletedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, final Map<String, Short> oldApprovals, ReviewDb db) throws OrmException {
    ReviewerDeletedEvent event = new ReviewerDeletedEvent(change);
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (!approvals.isEmpty()) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval, oldApprovals);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerDeletedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    AccountState owner = accountCache.get(change.getOwner());
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    // append votes that were removed
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null && approval.getValue() != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            if (oldApprovals != null && !oldApprovals.isEmpty()) {
                Short oldValue = oldApprovals.get(approval.getKey());
                if (oldValue != null) {
                    addArg(args, "--" + lt.getName() + "-oldValue", Short.toString(oldValue));
                }
            }
        }
    }
    runHook(change.getProject(), reviewerDeletedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    dispatcher.get().postEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    dispatcher.get().postEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, String claName) {
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
    if (!claSignedHook.isPresent()) {
        return;
    }
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    a.value = Short.toString(approval.getValue());
    return a;
}
#method_after
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval, Map<String, Short> oldApprovals) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    if (oldApprovals != null && !oldApprovals.isEmpty()) {
        if (oldApprovals.get(approval.getKey()) != null) {
            a.oldValue = Short.toString(oldApprovals.get(approval.getKey()));
        }
    }
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    if (approval.getValue() != null) {
        a.value = Short.toString(approval.getValue());
    }
    return a;
}
#end_block

#method_before
private synchronized void runHook(Path hook, List<String> args) {
    if (Files.exists(hook)) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (project != null && hook.isPresent()) {
        hookQueue.execute(new AsyncHookTask(project, hook.get(), args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Project.NameKey project, Path hook, List<String> args) {
    if (!Files.exists(hook)) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#method_after
private HookResult runSyncHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (!hook.isPresent()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook.get(), args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.get().toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.get().toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) {
}
#method_after
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, Map<String, Short> oldApprovals, ReviewDb db) {
}
#end_block

#method_before
@Override
public void doReviewerDeletedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) {
}
#method_after
@Override
public void doReviewerDeletedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, Map<String, Short> oldApprovals, ReviewDb db) {
}
#end_block

#method_before
@Override
public void postEvent(Branch.NameKey branchName, Event event) {
}
#method_after
@Override
public void postEvent(Change change, ChangeEvent event, ReviewDb db) {
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    super.init();
    ccExistingReviewers();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    ccExistingReviewers();
    includeWatchers(NotifyType.ALL_COMMENTS);
    add(RecipientType.TO, reviewers);
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    boolean includeSizes = !Strings.isNullOrEmpty(req.getParameter("long"));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        switch(wr.type) {
            case TREE:
                renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes ? repo : null), TreeJsonData.Tree.class);
                break;
            default:
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        switch(wr.type) {
            case TREE:
                renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes), TreeJsonData.Tree.class);
                break;
            default:
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
static Tree toJsonData(ObjectId id, TreeWalk tw, @Nullable Repository repoForSizes) throws IOException {
    ObjectReader reader = repoForSizes != null ? repoForSizes.newObjectReader() : null;
    Tree tree = new Tree();
    tree.id = id.name();
    tree.entries = Lists.newArrayList();
    while (tw.next()) {
        Entry e = new Entry();
        FileMode mode = tw.getFileMode(0);
        e.mode = mode.getBits();
        e.type = Constants.typeString(mode.getObjectType());
        e.id = tw.getObjectId(0).name();
        e.name = tw.getNameString();
        if (reader != null) {
            FileMode fmode = FileMode.fromBits(mode.getBits());
            if (fmode == FileMode.REGULAR_FILE || fmode == FileMode.EXECUTABLE_FILE) {
                SizedEntry se = new SizedEntry();
                se.id = e.id;
                se.mode = e.mode;
                se.name = e.name;
                se.type = e.type;
                se.size = reader.getObjectSize(tw.getObjectId(0), Constants.OBJ_BLOB);
                e = se;
            } else if (fmode == FileMode.SYMLINK) {
                TargetEntry se = new TargetEntry();
                se.id = e.id;
                se.mode = e.mode;
                se.name = e.name;
                se.type = e.type;
                se.target = new String(repoForSizes.open(tw.getObjectId(0), Constants.OBJ_BLOB).getBytes(), UTF_8);
                e = se;
            }
        }
        tree.entries.add(e);
    }
    return tree;
}
#method_after
static Tree toJsonData(ObjectId id, TreeWalk tw, boolean includeSizes) throws IOException {
    Tree tree = new Tree();
    tree.id = id.name();
    tree.entries = Lists.newArrayList();
    while (tw.next()) {
        Entry e = new Entry();
        FileMode mode = tw.getFileMode(0);
        e.mode = mode.getBits();
        e.type = Constants.typeString(mode.getObjectType());
        e.id = tw.getObjectId(0).name();
        e.name = tw.getNameString();
        if (includeSizes) {
            if ((mode.getBits() & FileMode.TYPE_MASK) == FileMode.TYPE_FILE) {
                e.size = tw.getObjectReader().getObjectSize(tw.getObjectId(0), Constants.OBJ_BLOB);
            } else if ((mode.getBits() & FileMode.TYPE_MASK) == FileMode.TYPE_SYMLINK) {
                e.target = new String(tw.getObjectReader().open(tw.getObjectId(0)).getCachedBytes(), UTF_8);
            }
        }
        tree.entries.add(e);
    }
    return tree;
}
#end_block

#method_before
void close() {
    reopenThread.close();
    // not have flushed.
    try {
        searcherManager.maybeRefreshBlocking();
    } catch (IOException e) {
        log.warn("error finishing pending Lucene writes", e);
    }
    try {
        try {
            writer.getIndexWriter().close();
        } catch (AlreadyClosedException e) {
        // Ignore.
        }
    } catch (IOException e) {
        log.warn("error closing Lucene writer", e);
    }
    try {
        dir.close();
    } catch (IOException e) {
        log.warn("error closing Lucene directory", e);
    }
}
#method_after
void close() {
    reopenThread.close();
    // not have flushed.
    try {
        searcherManager.maybeRefreshBlocking();
    } catch (IOException e) {
        log.warn("error finishing pending Lucene writes", e);
    }
    try {
        writer.getIndexWriter().close();
    } catch (AlreadyClosedException e) {
    // Ignore.
    } catch (IOException e) {
        log.warn("error closing Lucene writer", e);
    }
    try {
        dir.close();
    } catch (IOException e) {
        log.warn("error closing Lucene directory", e);
    }
}
#end_block

#method_before
public void postRun() throws Exception {
    for (InitStep step : steps) {
        if (step instanceof InitPlugins && flags.skipPlugins) {
            continue;
        }
        step.postRun();
    }
}
#method_after
public void postRun(Injector injector) throws Exception {
    for (InitStep step : steps) {
        if (step instanceof InitPlugins && flags.skipPlugins) {
            continue;
        }
        injector.injectMembers(step);
        step.postRun();
    }
}
#end_block

#method_before
private void saveSecureStore() throws IOException {
    if (!secureStoreClassName.isEmpty() && !secureStoreJarPath.isEmpty()) {
        File secureStoreJar = new File(secureStoreJarPath);
        File dst = new File(site.lib_dir, secureStoreJar.getName());
        Files.copy(secureStoreJar, dst);
        Section gerritSection = sectionFactory.get("gerrit", null);
        gerritSection.set("secureStoreClass", secureStoreClassName);
    }
}
#method_after
private void saveSecureStore() throws IOException {
    if (secureStoreInitData != null) {
        File dst = new File(site.lib_dir, secureStoreInitData.jarFile.getName());
        Files.copy(secureStoreInitData.jarFile, dst);
        Section gerritSection = sectionFactory.get("gerrit", null);
        gerritSection.set("secureStoreClass", secureStoreInitData.className);
    }
}
#end_block

#method_before
@Test
public void testUpgrade() throws IOException, ConfigInvalidException {
    final File p = newSitePath();
    final SitePaths site = new SitePaths(p);
    assertTrue(site.isNew);
    assertTrue(site.site_path.mkdir());
    assertTrue(site.etc_dir.mkdir());
    for (String n : UpgradeFrom2_0_x.etcFiles) {
        Writer w = new FileWriter(new File(p, n));
        try {
            w.write("# " + n + "\n");
        } finally {
            w.close();
        }
    }
    FileBasedConfig old = new FileBasedConfig(new File(p, "gerrit.config"), FS.DETECTED);
    old.setString("ldap", null, "username", "ldap.user");
    old.setString("ldap", null, "password", "ldap.s3kr3t");
    old.setString("sendemail", null, "smtpUser", "email.user");
    old.setString("sendemail", null, "smtpPass", "email.s3kr3t");
    old.save();
    InMemorySecureStore secureStore = new InMemorySecureStore();
    final InitFlags flags = new InitFlags(site, secureStore, Collections.<String>emptyList());
    final ConsoleUI ui = createStrictMock(ConsoleUI.class);
    Section.Factory sections = new Section.Factory() {

        @Override
        public Section get(String name, String subsection) {
            return new Section(flags, site, ui, name, subsection);
        }
    };
    expect(ui.yesno(eq(true), eq("Upgrade '%s'"), eq(p.getCanonicalPath()))).andReturn(true);
    replay(ui);
    UpgradeFrom2_0_x u = new UpgradeFrom2_0_x(site, flags, ui, sections);
    assertTrue(u.isNeedUpgrade());
    u.run();
    assertFalse(u.isNeedUpgrade());
    verify(ui);
    for (String n : UpgradeFrom2_0_x.etcFiles) {
        if ("gerrit.config".equals(n))
            continue;
        if ("secure.config".equals(n))
            continue;
        assertEquals(// 
        "# " + n + "\n", new String(IO.readFully(new File(site.etc_dir, n)), "UTF-8"));
    }
    FileBasedConfig cfg = new FileBasedConfig(site.gerrit_config, FS.DETECTED);
    cfg.load();
    assertEquals("email.user", cfg.getString("sendemail", null, "smtpUser"));
    assertNull(cfg.getString("sendemail", null, "smtpPass"));
    assertEquals("email.s3kr3t", secureStore.get("sendemail", null, "smtpPass"));
    assertEquals("ldap.user", cfg.getString("ldap", null, "username"));
    assertNull(cfg.getString("ldap", null, "password"));
    assertEquals("ldap.s3kr3t", secureStore.get("ldap", null, "password"));
    u.run();
}
#method_after
@Test
public void testUpgrade() throws IOException, ConfigInvalidException {
    final File p = newSitePath();
    final SitePaths site = new SitePaths(p);
    assertTrue(site.isNew);
    assertTrue(site.site_path.mkdir());
    assertTrue(site.etc_dir.mkdir());
    for (String n : UpgradeFrom2_0_x.etcFiles) {
        Writer w = new FileWriter(new File(p, n));
        try {
            w.write("# " + n + "\n");
        } finally {
            w.close();
        }
    }
    FileBasedConfig old = new FileBasedConfig(new File(p, "gerrit.config"), FS.DETECTED);
    old.setString("ldap", null, "username", "ldap.user");
    old.setString("ldap", null, "password", "ldap.s3kr3t");
    old.setString("sendemail", null, "smtpUser", "email.user");
    old.setString("sendemail", null, "smtpPass", "email.s3kr3t");
    old.save();
    final InMemorySecureStore secureStore = new InMemorySecureStore();
    final InitFlags flags = new InitFlags(site, secureStore, Collections.<String>emptyList());
    final ConsoleUI ui = createStrictMock(ConsoleUI.class);
    Section.Factory sections = new Section.Factory() {

        @Override
        public Section get(String name, String subsection) {
            return new Section(flags, site, secureStore, ui, name, subsection);
        }
    };
    expect(ui.yesno(eq(true), eq("Upgrade '%s'"), eq(p.getCanonicalPath()))).andReturn(true);
    replay(ui);
    UpgradeFrom2_0_x u = new UpgradeFrom2_0_x(site, flags, ui, sections);
    assertTrue(u.isNeedUpgrade());
    u.run();
    assertFalse(u.isNeedUpgrade());
    verify(ui);
    for (String n : UpgradeFrom2_0_x.etcFiles) {
        if ("gerrit.config".equals(n))
            continue;
        if ("secure.config".equals(n))
            continue;
        assertEquals(// 
        "# " + n + "\n", new String(IO.readFully(new File(site.etc_dir, n)), "UTF-8"));
    }
    FileBasedConfig cfg = new FileBasedConfig(site.gerrit_config, FS.DETECTED);
    cfg.load();
    assertEquals("email.user", cfg.getString("sendemail", null, "smtpUser"));
    assertNull(cfg.getString("sendemail", null, "smtpPass"));
    assertEquals("email.s3kr3t", secureStore.get("sendemail", null, "smtpPass"));
    assertEquals("ldap.user", cfg.getString("ldap", null, "username"));
    assertNull(cfg.getString("ldap", null, "password"));
    assertEquals("ldap.s3kr3t", secureStore.get("ldap", null, "password"));
    u.run();
}
#end_block

#method_before
public void run() throws IOException, InterruptedException {
    ui.header("HTTP Daemon");
    boolean proxy = false, ssl = false;
    String address = "*";
    int port = -1;
    String context = "/";
    String listenUrl = httpd.get("listenUrl");
    if (listenUrl != null && !listenUrl.isEmpty()) {
        try {
            final URI uri = toURI(listenUrl);
            proxy = uri.getScheme().startsWith("proxy-");
            ssl = uri.getScheme().endsWith("https");
            address = isAnyAddress(new URI(listenUrl)) ? "*" : uri.getHost();
            port = uri.getPort();
            context = uri.getPath();
        } catch (URISyntaxException e) {
            System.err.println("warning: invalid httpd.listenUrl " + listenUrl);
        }
    }
    proxy = ui.yesno(proxy, "Behind reverse proxy");
    if (proxy) {
        ssl = ui.yesno(ssl, "Proxy uses SSL (https://)");
        context = ui.readString(context, "Subdirectory on proxy server");
    } else {
        ssl = ui.yesno(ssl, "Use SSL (https://)");
        context = "/";
    }
    address = ui.readString(address, "Listen on address");
    if (port < 0) {
        if (proxy) {
            port = 8081;
        } else if (ssl) {
            port = 8443;
        } else {
            port = 8080;
        }
    }
    port = ui.readInt(port, "Listen on port");
    final StringBuilder urlbuf = new StringBuilder();
    urlbuf.append(proxy ? "proxy-" : "");
    urlbuf.append(ssl ? "https" : "http");
    urlbuf.append("://");
    urlbuf.append(address);
    if (0 <= port) {
        urlbuf.append(":");
        urlbuf.append(port);
    }
    urlbuf.append(context);
    httpd.set("listenUrl", urlbuf.toString());
    URI uri;
    try {
        uri = toURI(httpd.get("listenUrl"));
        if (uri.getScheme().startsWith("proxy-")) {
            // If its a proxy URL, assume the reverse proxy is on our system
            // at the protocol standard ports (so omit the ports from the URL).
            // 
            String s = uri.getScheme().substring("proxy-".length());
            uri = new URI(s + "://" + uri.getHost() + uri.getPath());
        }
    } catch (URISyntaxException e) {
        throw die("invalid httpd.listenUrl");
    }
    gerrit.string("Canonical URL", "canonicalWebUrl", uri.toString());
    generateSslCertificate();
}
#method_after
@Override
public void run() throws IOException, InterruptedException {
    ui.header("HTTP Daemon");
    boolean proxy = false, ssl = false;
    String address = "*";
    int port = -1;
    String context = "/";
    String listenUrl = httpd.get("listenUrl");
    if (listenUrl != null && !listenUrl.isEmpty()) {
        try {
            final URI uri = toURI(listenUrl);
            proxy = uri.getScheme().startsWith("proxy-");
            ssl = uri.getScheme().endsWith("https");
            address = isAnyAddress(new URI(listenUrl)) ? "*" : uri.getHost();
            port = uri.getPort();
            context = uri.getPath();
        } catch (URISyntaxException e) {
            System.err.println("warning: invalid httpd.listenUrl " + listenUrl);
        }
    }
    proxy = ui.yesno(proxy, "Behind reverse proxy");
    if (proxy) {
        ssl = ui.yesno(ssl, "Proxy uses SSL (https://)");
        context = ui.readString(context, "Subdirectory on proxy server");
    } else {
        ssl = ui.yesno(ssl, "Use SSL (https://)");
        context = "/";
    }
    address = ui.readString(address, "Listen on address");
    if (port < 0) {
        if (proxy) {
            port = 8081;
        } else if (ssl) {
            port = 8443;
        } else {
            port = 8080;
        }
    }
    port = ui.readInt(port, "Listen on port");
    final StringBuilder urlbuf = new StringBuilder();
    urlbuf.append(proxy ? "proxy-" : "");
    urlbuf.append(ssl ? "https" : "http");
    urlbuf.append("://");
    urlbuf.append(address);
    if (0 <= port) {
        urlbuf.append(":");
        urlbuf.append(port);
    }
    urlbuf.append(context);
    httpd.set("listenUrl", urlbuf.toString());
    URI uri;
    try {
        uri = toURI(httpd.get("listenUrl"));
        if (uri.getScheme().startsWith("proxy-")) {
            // If its a proxy URL, assume the reverse proxy is on our system
            // at the protocol standard ports (so omit the ports from the URL).
            // 
            String s = uri.getScheme().substring("proxy-".length());
            uri = new URI(s + "://" + uri.getHost() + uri.getPath());
        }
    } catch (URISyntaxException e) {
        throw die("invalid httpd.listenUrl");
    }
    gerrit.string("Canonical URL", "canonicalWebUrl", uri.toString());
    generateSslCertificate();
}
#end_block

#method_before
public void run() throws IOException, ConfigInvalidException {
    if (!isNeedUpgrade()) {
        return;
    }
    if (!ui.yesno(true, "Upgrade '%s'", site_path.getCanonicalPath())) {
        throw die("aborted by user");
    }
    for (String name : etcFiles) {
        final File src = new File(site_path, name);
        final File dst = new File(etc_dir, name);
        if (src.exists()) {
            if (dst.exists()) {
                throw die("File " + src + " would overwrite " + dst);
            }
            if (!src.renameTo(dst)) {
                throw die("Cannot rename " + src + " to " + dst);
            }
        }
    }
    // We have to reload the configuration after the rename as
    // the initial load pulled up an non-existent (and thus
    // believed to be empty) file.
    // 
    cfg.load();
    final Properties oldprop = readGerritServerProperties();
    if (oldprop != null) {
        final Section database = sections.get("database", null);
        String url = oldprop.getProperty("url");
        if (url != null && !convertUrl(database, url)) {
            database.set("type", "jdbc");
            database.set("driver", oldprop.getProperty("driver"));
            database.set("url", url);
        }
        String username = oldprop.getProperty("user");
        if (username == null || username.isEmpty()) {
            username = oldprop.getProperty("username");
        }
        if (username != null && !username.isEmpty()) {
            cfg.setString("database", null, "username", username);
        }
        String password = oldprop.getProperty("password");
        if (password != null && !password.isEmpty()) {
            sec.set("database", null, "password", password);
        }
    }
    String[] values;
    values = cfg.getStringList("ldap", null, "password");
    cfg.unset("ldap", null, "password");
    sec.setList("ldap", null, "password", Arrays.asList(values));
    values = cfg.getStringList("sendemail", null, "smtpPass");
    cfg.unset("sendemail", null, "smtpPass");
    sec.setList("sendemail", null, "smtpPass", Arrays.asList(values));
    savePublic(cfg);
}
#method_after
@Override
public void run() throws IOException, ConfigInvalidException {
    if (!isNeedUpgrade()) {
        return;
    }
    if (!ui.yesno(true, "Upgrade '%s'", site_path.getCanonicalPath())) {
        throw die("aborted by user");
    }
    for (String name : etcFiles) {
        final File src = new File(site_path, name);
        final File dst = new File(etc_dir, name);
        if (src.exists()) {
            if (dst.exists()) {
                throw die("File " + src + " would overwrite " + dst);
            }
            if (!src.renameTo(dst)) {
                throw die("Cannot rename " + src + " to " + dst);
            }
        }
    }
    // We have to reload the configuration after the rename as
    // the initial load pulled up an non-existent (and thus
    // believed to be empty) file.
    // 
    cfg.load();
    final Properties oldprop = readGerritServerProperties();
    if (oldprop != null) {
        final Section database = sections.get("database", null);
        String url = oldprop.getProperty("url");
        if (url != null && !convertUrl(database, url)) {
            database.set("type", "jdbc");
            database.set("driver", oldprop.getProperty("driver"));
            database.set("url", url);
        }
        String username = oldprop.getProperty("user");
        if (username == null || username.isEmpty()) {
            username = oldprop.getProperty("username");
        }
        if (username != null && !username.isEmpty()) {
            cfg.setString("database", null, "username", username);
        }
        String password = oldprop.getProperty("password");
        if (password != null && !password.isEmpty()) {
            sec.set("database", null, "password", password);
        }
    }
    String[] values;
    values = cfg.getStringList("ldap", null, "password");
    cfg.unset("ldap", null, "password");
    sec.setList("ldap", null, "password", Arrays.asList(values));
    values = cfg.getStringList("sendemail", null, "smtpPass");
    cfg.unset("sendemail", null, "smtpPass");
    sec.setList("sendemail", null, "smtpPass", Arrays.asList(values));
    savePublic(cfg);
}
#end_block

#method_before
public <T extends Enum<?>> T select(final String title, final String name, final T defValue, final boolean nullIfDefault) {
    final boolean set = get(name) != null;
    T oldValue = ConfigUtil.getEnum(flags.cfg, section, subsection, name, defValue);
    T newValue = ui.readEnum(oldValue, "%s", title);
    if (nullIfDefault && newValue == defValue) {
        newValue = null;
    }
    if (!set || oldValue != newValue) {
        if (newValue != null) {
            set(name, newValue);
        } else {
            unset(name);
        }
    }
    return newValue;
}
#method_after
public <T extends Enum<?>> T select(final String title, final String name, final T defValue, final boolean nullIfDefault) {
    final boolean set = get(name) != null;
    T oldValue = flags.cfg.getEnum(section, subsection, name, defValue);
    T newValue = ui.readEnum(oldValue, "%s", title);
    if (nullIfDefault && newValue == defValue) {
        newValue = null;
    }
    if (!set || oldValue != newValue) {
        if (newValue != null) {
            set(name, newValue);
        } else {
            unset(name);
        }
    }
    return newValue;
}
#end_block

#method_before
public void setSecure(String name, String value) {
    if (value != null) {
        flags.sec.set(section, subsection, name, value);
    } else {
        flags.sec.unset(section, subsection, name);
    }
}
#method_after
public void setSecure(String name, String value) {
    if (value != null) {
        secureStore.set(section, subsection, name, value);
    } else {
        secureStore.unset(section, subsection, name);
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    final SiteInit init = createSiteInit();
    if (beforeInit(init)) {
        return 0;
    }
    init.flags.autoStart = getAutoStart() && init.site.isNew;
    init.flags.skipPlugins = skipPlugins();
    final SiteRun run;
    try {
        init.initializer.run();
        init.flags.deleteOnFailure = false;
        run = createSiteRun(init);
        run.upgradeSchema();
        init.initializer.postRun();
    } catch (Exception failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    } catch (Error failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    }
    System.err.println("Initialized " + getSitePath().getCanonicalPath());
    afterInit(run);
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    final SiteInit init = createSiteInit();
    if (beforeInit(init)) {
        return 0;
    }
    init.flags.autoStart = getAutoStart() && init.site.isNew;
    init.flags.skipPlugins = skipPlugins();
    final SiteRun run;
    try {
        init.initializer.run();
        init.flags.deleteOnFailure = false;
        run = createSiteRun(init);
        run.upgradeSchema();
        init.initializer.postRun(createSysInjector(init));
    } catch (Exception failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    } catch (Error failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    }
    System.err.println("Initialized " + getSitePath().getCanonicalPath());
    afterInit(run);
    return 0;
}
#end_block

#method_before
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<>();
    m.add(new InitModule(standalone, initDb, getSecureStoreClassName()));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = Objects.firstNonNull(getInstallPlugins(), Lists.<String>newArrayList());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(PluginsDistribution.class).toInstance(pluginsDistribution);
            bind(String.class).annotatedWith(SecureStoreJarPath.class).toInstance(Strings.nullToEmpty(getSecireStoreJarPath()));
            bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(Strings.nullToEmpty(getSecureStoreClassName()));
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#method_after
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<>();
    final SecureStoreInitData secureStoreInitData = discoverSecureStoreClass();
    final String currentSecureStoreClassName = getConfiguredSecureStoreClass();
    if (secureStoreInitData != null && currentSecureStoreClassName != null && !currentSecureStoreClassName.equals(secureStoreInitData.className)) {
        String err = String.format("Different secure store was previously configured: %s.", currentSecureStoreClassName);
        die(err, new RuntimeException("secure store mismatch"));
    }
    m.add(new InitModule(standalone, initDb));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = MoreObjects.firstNonNull(getInstallPlugins(), Lists.<String>newArrayList());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(PluginsDistribution.class).toInstance(pluginsDistribution);
            String secureStoreClassName;
            if (secureStoreInitData != null) {
                secureStoreClassName = secureStoreInitData.className;
            } else {
                secureStoreClassName = currentSecureStoreClassName;
            }
            if (secureStoreClassName != null) {
                ui.message("Using secure store: %s\n", secureStoreClassName);
            }
            bind(SecureStoreInitData.class).toProvider(Providers.of(secureStoreInitData));
            bind(String.class).annotatedWith(SecureStoreClassName.class).toProvider(Providers.of(secureStoreClassName));
            bind(SecureStore.class).toProvider(SecureStoreProvider.class).in(SINGLETON);
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#end_block

#method_before
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String msg) {
            System.err.println(msg);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return ui.yesno(def, msg);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            final JdbcSchema db = (JdbcSchema) schema.open();
            try {
                final JdbcExecutor e = new JdbcExecutor(db);
                try {
                    for (String sql : pruneList) {
                        e.execute(sql);
                    }
                } finally {
                    e.close();
                }
            } finally {
                db.close();
            }
        }
    }
}
#method_after
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String msg) {
            System.err.println(msg);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return ui.yesno(def, msg);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) schema.open();
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
}
#end_block

#method_before
private Injector createSysInjector(final SiteInit init) {
    final List<Module> modules = new ArrayList<>();
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(init.ui);
            bind(InitFlags.class).toInstance(init.flags);
        }
    });
    return createDbInjector(SINGLE_USER).createChildInjector(modules);
}
#method_after
private Injector createSysInjector(final SiteInit init) {
    if (sysInjector == null) {
        final List<Module> modules = new ArrayList<>();
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(ConsoleUI.class).toInstance(init.ui);
                bind(InitFlags.class).toInstance(init.flags);
            }
        });
        sysInjector = createDbInjector(SINGLE_USER).createChildInjector(modules);
    }
    return sysInjector;
}
#end_block

#method_before
@Override
protected void afterInit(SiteRun run) throws Exception {
    List<Module> modules = Lists.newArrayList();
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(File.class).annotatedWith(SitePath.class).toInstance(getSitePath());
            bind(Browser.class);
        }
    });
    modules.add(new GerritServerConfigModule());
    Guice.createInjector(modules).injectMembers(this);
    start(run);
}
#method_after
@Override
protected void afterInit(SiteRun run) throws Exception {
    List<Module> modules = Lists.newArrayList();
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(File.class).annotatedWith(SitePath.class).toInstance(getSitePath());
            bind(Browser.class);
            bind(String.class).annotatedWith(SecureStoreClassName.class).toProvider(Providers.of(getConfiguredSecureStoreClass()));
        }
    });
    modules.add(new GerritServerConfigModule());
    Guice.createInjector(modules).injectMembers(this);
    start(run);
}
#end_block

#method_before
public void start(WorkQueue workQueue) {
    pool = workQueue.createQueue(config.getPoolThreads(), poolName);
}
#method_after
public void start(WorkQueue workQueue) {
    String poolName = "ReplicateTo-" + config.getRemoteConfig().getName();
    pool = workQueue.createQueue(config.getPoolThreads(), poolName);
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#method_after
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!shouldReplicate(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#end_block

#method_before
boolean wouldPushProject(final Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    String[] projects = config.getProjects();
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    if (!shouldReplicate(project)) {
        return false;
    }
    // by default push all projects
    List<String> projects = config.getProjects();
    if (projects.isEmpty()) {
        return true;
    }
    return (new ReplicationFilter(projects)).matches(project);
}
#end_block

#method_before
boolean isSingleProjectMatch() {
    String[] projects = config.getProjects();
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#method_after
boolean isSingleProjectMatch() {
    List<String> projects = config.getProjects();
    boolean ret = (projects.size() == 1);
    if (ret) {
        String projectMatch = projects.get(0);
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#end_block

#method_before
boolean wouldPushRef(String ref) {
    if (!config.replicatePermissions() && RefNames.REFS_CONFIG.equals(ref)) {
        return false;
    }
    for (RefSpec s : remote.getPushRefSpecs()) {
        if (s.matchSource(ref)) {
            return true;
        }
    }
    return false;
}
#method_after
boolean wouldPushRef(String ref) {
    if (!config.replicatePermissions() && RefNames.REFS_CONFIG.equals(ref)) {
        return false;
    }
    for (RefSpec s : config.getRemoteConfig().getPushRefSpecs()) {
        if (s.matchSource(ref)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String remoteNameStyle = config.getRemoteNameStyle();
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(config.getRemoteConfig().getURIs().size());
    for (URIish uri : config.getRemoteConfig().getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String remoteNameStyle = config.getRemoteNameStyle();
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
String[] getAdminUrls() {
    return config.getAdminUrls();
}
#method_after
ImmutableList<String> getAdminUrls() {
    return config.getAdminUrls();
}
#end_block

#method_before
String[] getUrls() {
    return config.getUrls();
}
#method_after
ImmutableList<String> getUrls() {
    return config.getUrls();
}
#end_block

#method_before
String[] getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#method_after
ImmutableList<String> getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#end_block

#method_before
String[] getProjects() {
    return config.getProjects();
}
#method_after
ImmutableList<String> getProjects() {
    return config.getProjects();
}
#end_block

#method_before
@Test
public void publishCommentsAllRevisions() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new\ncntent\n", r1.getChangeId()).to("refs/for/master");
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "nit: trailing whitespace"));
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "what happened to this?"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "join lines"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "typo: content"));
    PushOneCommit.Result other = createChange();
    // Drafts on other changes aren't returned.
    addDraft(other.getChangeId(), other.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "unrelated comment"));
    setApiUser(admin);
    // Drafts by other users aren't returned.
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "oops"));
    setApiUser(user);
    ReviewInput reviewInput = new ReviewInput();
    reviewInput.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    reviewInput.message = "comments";
    gApi.changes().id(r2.getChangeId()).current().review(reviewInput);
    assertThat(gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps1Map = gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).comments();
    assertThat(ps1Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps1List = ps1Map.get(FILE_NAME);
    assertThat(ps1List).hasSize(2);
    assertThat(ps1List.get(0).message).isEqualTo("what happened to this?");
    assertThat(ps1List.get(0).side).isEqualTo(Side.PARENT);
    assertThat(ps1List.get(1).message).isEqualTo("nit: trailing whitespace");
    assertThat(ps1List.get(1).side).isNull();
    assertThat(gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps2Map = gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).comments();
    assertThat(ps2Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps2List = ps2Map.get(FILE_NAME);
    assertThat(ps2List).hasSize(2);
    assertThat(ps2List.get(0).message).isEqualTo("join lines");
    assertThat(ps2List.get(1).message).isEqualTo("typo: content");
    ImmutableList<Message> messages = email.getMessages(r2.getChangeId(), "comment");
    assertThat(messages).hasSize(1);
    String url = canonicalWebUrl.get();
    int c = r1.getChange().getId().get();
    assertThat(extractComments(messages.get(0).body())).isEqualTo("Patch Set 2:\n" + "\n" + "(4 comments)\n" + "\n" + "comments\n" + "\n" + url + "#/c/" + c + "/1/a.txt\n" + "File a.txt:\n" + "\n" + "PS1, Line 2: \n" + "what happened to this?\n" + "\n" + "\n" + "PS1, Line 1: ew\n" + "nit: trailing whitespace\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt\n" + "File a.txt:\n" + "\n" + "PS2, Line 1: ew\n" + "join lines\n" + "\n" + "\n" + "PS2, Line 2: nten\n" + "typo: content\n" + "\n");
}
#method_after
@Test
public void publishCommentsAllRevisions() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new\ncntent\n", r1.getChangeId()).to("refs/for/master");
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "nit: trailing whitespace"));
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "what happened to this?"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "join lines"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "typo: content"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 1, "comment 1 on base"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "comment 2 on base"));
    PushOneCommit.Result other = createChange();
    // Drafts on other changes aren't returned.
    addDraft(other.getChangeId(), other.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "unrelated comment"));
    setApiUser(admin);
    // Drafts by other users aren't returned.
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "oops"));
    setApiUser(user);
    ReviewInput reviewInput = new ReviewInput();
    reviewInput.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    reviewInput.message = "comments";
    gApi.changes().id(r2.getChangeId()).current().review(reviewInput);
    assertThat(gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps1Map = gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).comments();
    assertThat(ps1Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps1List = ps1Map.get(FILE_NAME);
    assertThat(ps1List).hasSize(2);
    assertThat(ps1List.get(0).message).isEqualTo("what happened to this?");
    assertThat(ps1List.get(0).side).isEqualTo(Side.PARENT);
    assertThat(ps1List.get(1).message).isEqualTo("nit: trailing whitespace");
    assertThat(ps1List.get(1).side).isNull();
    assertThat(gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps2Map = gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).comments();
    assertThat(ps2Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps2List = ps2Map.get(FILE_NAME);
    assertThat(ps2List).hasSize(4);
    assertThat(ps2List.get(0).message).isEqualTo("comment 1 on base");
    assertThat(ps2List.get(1).message).isEqualTo("comment 2 on base");
    assertThat(ps2List.get(2).message).isEqualTo("join lines");
    assertThat(ps2List.get(3).message).isEqualTo("typo: content");
    ImmutableList<Message> messages = email.getMessages(r2.getChangeId(), "comment");
    assertThat(messages).hasSize(1);
    String url = canonicalWebUrl.get();
    int c = r1.getChange().getId().get();
    assertThat(extractComments(messages.get(0).body())).isEqualTo("Patch Set 2:\n" + "\n" + "(6 comments)\n" + "\n" + "comments\n" + "\n" + url + "#/c/" + c + "/1/a.txt\n" + "File a.txt:\n" + "\n" + "PS1, Line 2: \n" + "what happened to this?\n" + "\n" + "\n" + "PS1, Line 1: ew\n" + "nit: trailing whitespace\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt\n" + "File a.txt:\n" + "\n" + "PS2, Line 1: \n" + "comment 1 on base\n" + "\n" + "\n" + "PS2, Line 2: \n" + "comment 2 on base\n" + "\n" + "\n" + "PS2, Line 1: ew\n" + "join lines\n" + "\n" + "\n" + "PS2, Line 2: nten\n" + "typo: content\n" + "\n");
}
#end_block

#method_before
@Override
public NoteDbChangeState rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject());
    buildUpdates(manager, ChangeBundle.fromReviewDb(db, changeId));
    return execute(db, changeId, manager);
}
#method_after
@Override
public NoteDbChangeState rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject());
    buildUpdates(manager, ChangeBundle.fromReviewDb(db, changeId));
    NoteDbChangeState result = execute(db, changeId, manager);
    manager.execute();
    return result;
}
#end_block

#method_before
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException, ConfigInvalidException {
    Change change = new Change(bundle.getChange());
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = Lists.newArrayList();
    Multimap<Account.Id, PatchLineCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    Repository changeMetaRepo = manager.getChangeRepo().repo;
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteRef(change, changeMetaRepo, manager.getChangeRepo().cmds);
    for (PatchSet ps : bundle.getPatchSets()) {
        events.add(new PatchSetEvent(change, ps, manager.getChangeRepo().rw));
        for (PatchLineComment c : getPatchLineComments(bundle, ps)) {
            PatchLineCommentEvent e = new PatchLineCommentEvent(c, change, ps, patchListCache);
            if (c.getStatus() == Status.PUBLISHED) {
                events.add(e);
            } else {
                draftCommentEvents.put(c.getAuthor(), e);
            }
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        events.add(new ApprovalEvent(psa, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
    }
    sortEvents(change.getId(), events);
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<PatchLineCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (PatchLineCommentEvent e : draftCommentEvents.get(author)) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#method_after
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    Change change = new Change(bundle.getChange());
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = Lists.newArrayList();
    Multimap<Account.Id, PatchLineCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    Repository changeMetaRepo = manager.getChangeRepo().repo;
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteRef(change, changeMetaRepo, manager.getChangeRepo().cmds);
    for (PatchSet ps : bundle.getPatchSets()) {
        events.add(new PatchSetEvent(change, ps, manager.getChangeRepo().rw));
        for (PatchLineComment c : getPatchLineComments(bundle, ps)) {
            PatchLineCommentEvent e = new PatchLineCommentEvent(c, change, ps, patchListCache);
            if (c.getStatus() == Status.PUBLISHED) {
                events.add(e);
            } else {
                draftCommentEvents.put(c.getAuthor(), e);
            }
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        events.add(new ApprovalEvent(psa, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
    }
    sortEvents(change.getId(), events);
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<PatchLineCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (PatchLineCommentEvent e : EVENT_ORDER.sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#end_block

#method_before
private void flushEventsToUpdate(NoteDbUpdateManager manager, EventList<Event> events, Change change) throws OrmException, IOException {
    if (events.isEmpty()) {
        return;
    }
    Comparator<String> labelNameComparator;
    if (projectCache != null) {
        labelNameComparator = projectCache.get(change.getProject()).getLabelTypes().nameComparator();
    } else {
        // No project cache available, bail and use natural ordering; there's no
        // semantic difference anyway difference.
        labelNameComparator = Ordering.natural();
    }
    ChangeUpdate update = updateFactory.create(notesFactory.createWithAutoRebuildingDisabled(change), events.getAccountId(), events.newAuthorIdent(), events.getWhen(), labelNameComparator);
    update.setAllowWriteToNewRef(true);
    update.setPatchSetId(events.getPatchSetId());
    update.setTag(events.getTag());
    for (Event e : events) {
        e.apply(update);
    }
    manager.add(update);
    events.clear();
}
#method_after
private void flushEventsToUpdate(NoteDbUpdateManager manager, EventList<Event> events, Change change) throws OrmException, IOException {
    if (events.isEmpty()) {
        return;
    }
    Comparator<String> labelNameComparator;
    if (projectCache != null) {
        labelNameComparator = projectCache.get(change.getProject()).getLabelTypes().nameComparator();
    } else {
        // No project cache available, bail and use natural ordering; there's no
        // semantic difference anyway difference.
        labelNameComparator = Ordering.natural();
    }
    ChangeUpdate update = updateFactory.create(notesFactory.createWithAutoRebuildingDisabled(change, manager.getChangeRepo().cmds), events.getAccountId(), events.newAuthorIdent(), events.getWhen(), labelNameComparator);
    update.setAllowWriteToNewRef(true);
    update.setPatchSetId(events.getPatchSetId());
    update.setTag(events.getTag());
    for (Event e : events) {
        e.apply(update);
    }
    manager.add(update);
    events.clear();
}
#end_block

#method_before
private void flushEventsToDraftUpdate(NoteDbUpdateManager manager, EventList<PatchLineCommentEvent> events, Change change) throws OrmException {
    if (events.isEmpty()) {
        return;
    }
    ChangeDraftUpdate update = draftUpdateFactory.create(notesFactory.createWithAutoRebuildingDisabled(change), events.getAccountId(), events.newAuthorIdent(), events.getWhen());
    update.setPatchSetId(events.getPatchSetId());
    for (PatchLineCommentEvent e : events) {
        e.applyDraft(update);
    }
    manager.add(update);
    events.clear();
}
#method_after
private void flushEventsToDraftUpdate(NoteDbUpdateManager manager, EventList<PatchLineCommentEvent> events, Change change) throws OrmException, IOException {
    if (events.isEmpty()) {
        return;
    }
    ChangeDraftUpdate update = draftUpdateFactory.create(notesFactory.createWithAutoRebuildingDisabled(change, manager.getChangeRepo().cmds), events.getAccountId(), events.newAuthorIdent(), events.getWhen());
    update.setPatchSetId(events.getPatchSetId());
    for (PatchLineCommentEvent e : events) {
        e.applyDraft(update);
    }
    manager.add(update);
    events.clear();
}
#end_block

#method_before
private List<HashtagsEvent> getHashtagsEvents(Change change, NoteDbUpdateManager manager) throws IOException, ConfigInvalidException {
    String refName = ChangeNoteUtil.changeRefName(change.getId());
    ObjectId old = manager.getChangeRepo().getObjectId(refName);
    if (old == null) {
        return Collections.emptyList();
    }
    RevWalk rw = manager.getChangeRepo().rw;
    List<HashtagsEvent> events = new ArrayList<>();
    rw.reset();
    rw.markStart(rw.parseCommit(old));
    for (RevCommit commit : rw) {
        Account.Id authorId = changeNoteUtil.parseIdent(commit.getAuthorIdent(), change.getId());
        PatchSet.Id psId = parsePatchSetId(change, commit);
        Set<String> hashtags = parseHashtags(commit);
        if (authorId == null || psId == null || hashtags == null) {
            continue;
        }
        Timestamp commitTime = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
        events.add(new HashtagsEvent(psId, authorId, commitTime, hashtags, change.getCreatedOn()));
    }
    return events;
}
#method_after
private List<HashtagsEvent> getHashtagsEvents(Change change, NoteDbUpdateManager manager) throws IOException {
    String refName = ChangeNoteUtil.changeRefName(change.getId());
    ObjectId old = manager.getChangeRepo().getObjectId(refName);
    if (old == null) {
        return Collections.emptyList();
    }
    RevWalk rw = manager.getChangeRepo().rw;
    List<HashtagsEvent> events = new ArrayList<>();
    rw.reset();
    rw.markStart(rw.parseCommit(old));
    for (RevCommit commit : rw) {
        Account.Id authorId;
        try {
            authorId = changeNoteUtil.parseIdent(commit.getAuthorIdent(), change.getId());
        } catch (ConfigInvalidException e) {
            // Corrupt data, no valid hashtags in this commit.
            continue;
        }
        PatchSet.Id psId = parsePatchSetId(change, commit);
        Set<String> hashtags = parseHashtags(commit);
        if (authorId == null || psId == null || hashtags == null) {
            continue;
        }
        Timestamp commitTime = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
        events.add(new HashtagsEvent(psId, authorId, commitTime, hashtags, change.getCreatedOn()));
    }
    return events;
}
#end_block

#method_before
@Override
public ProjectAccessInfo apply(ProjectResource resource) {
    final ProjectAccessInfo info = new ProjectAccessInfo();
    final ProjectConfig config = resource.getControl().getProjectState().getConfig();
    final ProjectControl pc = resource.getControl();
    final RefControl metaConfigControl = pc.controlForRef(RefNames.REFS_CONFIG);
    info.local = Maps.newHashMap();
    info.ownerOf = Sets.newHashSet();
    Map<UUID, Boolean> visibleGroups = new HashMap<>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(section.getName(), createAccessSection(section));
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(name, createAccessSection(section));
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(pc.getProjectState().parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (pc.getProject().getNameKey().equals(allProjectsName)) {
        if (pc.isOwner()) {
            info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    info.isOwner = toBoolean(pc.isOwner());
    info.canUpload = toBoolean(pc.isOwner() || (metaConfigControl.isVisible() && metaConfigControl.canUpload()));
    info.canAdd = toBoolean(pc.canAddRefs());
    info.configVisible = pc.isOwner() || metaConfigControl.isVisible();
    return info;
}
#method_after
public ProjectAccessInfo apply(Project.NameKey nameKey) throws ResourceNotFoundException, ResourceConflictException, IOException {
    try {
        return this.apply(new ProjectResource(projectControlFactory.controlFor(nameKey, self.get())));
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(nameKey.get());
    }
}
#end_block

#method_before
@Override
public ProjectAccessInfo apply(ProjectResource resource) {
    final ProjectAccessInfo info = new ProjectAccessInfo();
    final ProjectConfig config = resource.getControl().getProjectState().getConfig();
    final ProjectControl pc = resource.getControl();
    final RefControl metaConfigControl = pc.controlForRef(RefNames.REFS_CONFIG);
    info.local = Maps.newHashMap();
    info.ownerOf = Sets.newHashSet();
    Map<UUID, Boolean> visibleGroups = new HashMap<>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(section.getName(), createAccessSection(section));
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(name, createAccessSection(section));
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(pc.getProjectState().parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (pc.getProject().getNameKey().equals(allProjectsName)) {
        if (pc.isOwner()) {
            info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    info.isOwner = toBoolean(pc.isOwner());
    info.canUpload = toBoolean(pc.isOwner() || (metaConfigControl.isVisible() && metaConfigControl.canUpload()));
    info.canAdd = toBoolean(pc.canAddRefs());
    info.configVisible = pc.isOwner() || metaConfigControl.isVisible();
    return info;
}
#method_after
@Override
public ProjectAccessInfo apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException {
    // Load the current configuration from the repository, ensuring it's the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    Project.NameKey projectName = rsrc.getNameKey();
    ProjectAccessInfo info = new ProjectAccessInfo();
    ProjectConfig config;
    ProjectControl pc = open(projectName);
    RefControl metaConfigControl = pc.controlForRef(RefNames.REFS_CONFIG);
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = open(projectName);
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open(projectName);
        }
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    info.local = new HashMap<>();
    info.ownerOf = Sets.newHashSet();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(section.getName(), createAccessSection(section));
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                info.local.put(name, createAccessSection(section));
                info.ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                info.local.put(name, createAccessSection(section));
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(pc.getProjectState().parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (pc.getProject().getNameKey().equals(allProjectsName)) {
        if (pc.isOwner()) {
            info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    info.isOwner = toBoolean(pc.isOwner());
    info.canUpload = toBoolean(pc.isOwner() || (metaConfigControl.isVisible() && metaConfigControl.canUpload()));
    info.canAdd = toBoolean(pc.canAddRefs());
    info.configVisible = pc.isOwner() || metaConfigControl.isVisible();
    return info;
}
#end_block

#method_before
private AccessSectionInfo createAccessSection(AccessSection section) {
    AccessSectionInfo accessSectionInfo = new AccessSectionInfo();
    accessSectionInfo.permissions = Maps.newHashMap();
    for (Permission p : section.getPermissions()) {
        PermissionInfo pInfo = new PermissionInfo(p.getLabel(), p.getExclusiveGroup() ? true : null);
        pInfo.rules = Maps.newHashMap();
        for (PermissionRule r : p.getRules()) {
            PermissionRuleInfo info = new PermissionRuleInfo(PermissionRuleActionInfo.values()[r.getAction().ordinal()], r.getForce());
            if (r.hasRange()) {
                info.max = r.getMax();
                info.min = r.getMin();
            }
            pInfo.rules.put(r.getGroup().getUUID().get(), info);
        }
        accessSectionInfo.permissions.put(p.getName(), pInfo);
    }
    return accessSectionInfo;
}
#method_after
private AccessSectionInfo createAccessSection(AccessSection section) {
    AccessSectionInfo accessSectionInfo = new AccessSectionInfo();
    accessSectionInfo.permissions = new HashMap<>();
    for (Permission p : section.getPermissions()) {
        PermissionInfo pInfo = new PermissionInfo(p.getLabel(), p.getExclusiveGroup() ? true : null);
        pInfo.rules = new HashMap<>();
        for (PermissionRule r : p.getRules()) {
            PermissionRuleInfo info = new PermissionRuleInfo(ACTION_TYPE.get(r.getAction()), r.getForce());
            if (r.hasRange()) {
                info.max = r.getMax();
                info.min = r.getMin();
            }
            pInfo.rules.put(r.getGroup().getUUID().get(), info);
        }
        accessSectionInfo.permissions.put(p.getName(), pInfo);
    }
    return accessSectionInfo;
}
#end_block

#method_before
@Override
public ProjectAccessInfo get() throws RestApiException {
    return getAccess.apply(project);
}
#method_after
@Override
public ProjectAccessInfo get() throws RestApiException {
    try {
        return getAccess.apply(project);
    } catch (IOException e) {
        throw new RestApiException("Cannot get access rights", e);
    }
}
#end_block

#method_before
@Override
public ProjectAccessInfo access() throws RestApiException {
    return accessApi.create(checkExists(), projectJson).get();
}
#method_after
@Override
public ProjectAccessInfo access() throws RestApiException {
    return accessApi.create(checkExists()).get();
}
#end_block

#method_before
@Test
public void testGetDefaultInheritance() throws Exception {
    // create proj
    String newProjectName = name("newProjectAccess");
    RestResponse r = adminSession.put("/projects/" + newProjectName);
    String inheritedName = gApi.projects().name(newProjectName).access().inheritsFrom.name;
    assertThat(inheritedName).isEqualTo(allProjectsName.get());
}
#method_after
@Test
public void testGetDefaultInheritance() throws Exception {
    String newProjectName = createProject("newProjectAccess").get();
    String inheritedName = gApi.projects().name(newProjectName).access().inheritsFrom.name;
    assertThat(inheritedName).isEqualTo(AllProjectsNameProvider.DEFAULT);
}
#end_block

#method_before
@Override
public Map<String, ProjectAccessInfo> apply(TopLevelResource resource) throws ResourceNotFoundException, ResourceConflictException, IOException {
    Map<String, ProjectAccessInfo> access = Maps.newTreeMap();
    for (String p : projects) {
        // Load the current configuration from the repository, ensuring it's the most
        // recent version available. If it differs from what was in the project
        // state, force a cache flush now.
        // 
        Project.NameKey projectName = new Project.NameKey(p);
        try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
            ProjectControl pc = open(projectName);
            ProjectConfig config = ProjectConfig.read(md);
            if (config.updateGroupNames(groupBackend)) {
                md.setMessage("Update group names\n");
                config.commit(md);
                projectCache.evict(config.getProject());
                pc = open(projectName);
            } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
                projectCache.evict(config.getProject());
                pc = open(projectName);
            }
            GetAccess ga = new GetAccess(groupControlFactory, allProjectsName, projectJson);
            access.put(p, ga.apply(new ProjectResource(pc)));
        } catch (ConfigInvalidException e) {
            throw new ResourceConflictException(e.getMessage());
        } catch (RepositoryNotFoundException e) {
            throw new ResourceNotFoundException(p);
        }
    }
    return access;
}
#method_after
@Override
public Map<String, ProjectAccessInfo> apply(TopLevelResource resource) throws ResourceNotFoundException, ResourceConflictException, IOException {
    Map<String, ProjectAccessInfo> access = Maps.newTreeMap();
    for (String p : projects) {
        Project.NameKey projectName = new Project.NameKey(p);
        access.put(p, getAccess.apply(projectName));
    }
    return access;
}
#end_block

#method_before
private void initKeyMapType() {
    keyMap.addItem(KeyMapType.DEFAULT.name().toLowerCase(), KeyMapType.DEFAULT.name());
    keyMap.addItem(KeyMapType.EMACS.name().toLowerCase(), KeyMapType.EMACS.name());
    keyMap.addItem(KeyMapType.SUBLIME.name().toLowerCase(), KeyMapType.SUBLIME.name());
    keyMap.addItem(KeyMapType.VIM.name().toLowerCase(), KeyMapType.VIM.name());
}
#method_after
private void initKeyMapType() {
    for (KeyMapType t : KeyMapType.values()) {
        keyMap.addItem(t.name().toLowerCase(), t.name());
    }
}
#end_block

#method_before
private <K, V, I extends Index<K, V>> void initIndex(IndexDefinition<K, V, I> def, FileBasedConfig cfg) {
    TreeMap<Integer, Version<V>> versions = scanVersions(def, cfg);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version<V> search = null;
    List<Version<V>> write = Lists.newArrayListWithCapacity(2);
    for (Version<V> v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(runReindexMsg);
    }
    IndexFactory<K, V, I> factory = def.getIndexFactory();
    I searchIndex = factory.create(search.schema);
    IndexCollection<K, V, I> indexes = def.getIndexCollection();
    indexes.setSearchIndex(searchIndex);
    for (Version<V> v : write) {
        if (v.schema != null) {
            if (v.version != search.version) {
                indexes.addWriteIndex(factory.create(v.schema));
            }
        } else {
            indexes.addWriteIndex(searchIndex);
        }
    }
    // TODO: include index name.
    markNotReady(cfg, versions.values(), write);
    int latest = write.get(0).version;
    if (onlineUpgrade && latest != search.version) {
        OnlineReindexer<K, V, I> reindexer = new OnlineReindexer<>(def, latest);
        synchronized (this) {
            if (!reindexers.containsKey(def.getName())) {
                reindexers.put(def.getName(), reindexer);
                reindexer.start();
            }
        }
    }
}
#method_after
private <K, V, I extends Index<K, V>> void initIndex(IndexDefinition<K, V, I> def, FileBasedConfig cfg) {
    TreeMap<Integer, Version<V>> versions = scanVersions(def, cfg);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version<V> search = null;
    List<Version<V>> write = Lists.newArrayListWithCapacity(2);
    for (Version<V> v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(runReindexMsg);
    }
    IndexFactory<K, V, I> factory = def.getIndexFactory();
    I searchIndex = factory.create(search.schema);
    IndexCollection<K, V, I> indexes = def.getIndexCollection();
    indexes.setSearchIndex(searchIndex);
    for (Version<V> v : write) {
        if (v.schema != null) {
            if (v.version != search.version) {
                indexes.addWriteIndex(factory.create(v.schema));
            } else {
                indexes.addWriteIndex(searchIndex);
            }
        }
    }
    // TODO: include index name.
    markNotReady(cfg, versions.values(), write);
    int latest = write.get(0).version;
    if (onlineUpgrade && latest != search.version) {
        OnlineReindexer<K, V, I> reindexer = new OnlineReindexer<>(def, latest);
        synchronized (this) {
            if (!reindexers.containsKey(def.getName())) {
                reindexers.put(def.getName(), reindexer);
                reindexer.start();
            }
        }
    }
}
#end_block

#method_before
@Override
public Response<?> apply(ConfigResource rsrc, Input input) throws IOException, ConfigInvalidException, UnprocessableEntityException {
    if (input == null) {
        input = new Input();
    }
    FileBasedConfig cfg = new FileBasedConfig(sitePaths.gerrit_config.toFile(), FS.DETECTED);
    cfg.load();
    if (input.showJobsPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsPanel", input.showJobsPanel);
    } else {
        cfg.unset("plugin", pluginName, "stage");
    }
    if (input.showJobsDropDownPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsDropDownPanel", input.showJobsDropDownPanel);
    } else {
        cfg.unset("plugin", pluginName, "stage");
    }
    cfg.save();
    cfgFactory.getFromGerritConfig(pluginName, true);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ConfigResource rsrc, Input input) throws IOException, ConfigInvalidException, UnprocessableEntityException {
    if (input == null) {
        input = new Input();
    }
    FileBasedConfig cfg = new FileBasedConfig(sitePaths.gerrit_config.toFile(), FS.DETECTED);
    cfg.load();
    if (input.showJobsPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsPanel", input.showJobsPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsPanel");
    }
    if (input.showJobsDropDownPanel != null) {
        cfg.setBoolean("plugin", pluginName, "showJobsDropDownPanel", input.showJobsDropDownPanel);
    } else {
        cfg.unset("plugin", pluginName, "showJobsDropDownPanel");
    }
    cfg.save();
    cfgFactory.getFromGerritConfig(pluginName, true);
    return Response.none();
}
#end_block

#method_before
@Override
public Map<String, VerificationInfo> apply(RevisionResource rsrc) throws IOException, OrmException {
    Map<String, VerificationInfo> out = Maps.newHashMap();
    try (CiDb db = schemaFactory.open()) {
        for (PatchSetVerification v : db.patchSetVerifications().byPatchSet(rsrc.getPatchSet().getId())) {
            VerificationInfo info = new VerificationInfo();
            info.value = v.getValue();
            info.url = v.getUrl();
            info.reporter = v.getVerifier();
            info.comment = v.getComment();
            info.granted = v.getGranted();
            info.category = v.getCategory();
            info.voting = v.getVoting();
            info.duration = v.getDuration();
            out.put(v.getJobId().get(), info);
        }
    }
    return out;
}
#method_after
@Override
public Map<String, VerificationInfo> apply(RevisionResource rsrc) throws IOException, OrmException {
    Map<String, VerificationInfo> out = Maps.newHashMap();
    try (CiDb db = schemaFactory.open()) {
        for (PatchSetVerification v : db.patchSetVerifications().byPatchSet(rsrc.getPatchSet().getId())) {
            VerificationInfo info = new VerificationInfo();
            info.value = v.getValue();
            info.abstain = v.getAbstain();
            info.url = v.getUrl();
            info.reporter = v.getReporter();
            info.comment = v.getComment();
            info.granted = v.getGranted();
            info.category = v.getCategory();
            info.duration = v.getDuration();
            out.put(v.getJobId().get(), info);
        }
    }
    return out;
}
#end_block

#method_before
private void parseWithEquals(String text) {
    log.debug("processing verification: " + text);
    checkArgument(!Strings.isNullOrEmpty(text), "Empty verification data");
    Map<String, String> params = null;
    try {
        params = Splitter.on("|").withKeyValueSeparator("=").split(text);
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException(String.valueOf("Invalid verification parameters"));
    }
    String job = params.get("job");
    checkArgument(job != null, "Verification is missing a job");
    String value = params.get("value");
    checkArgument(value != null, "Verification is missing a value");
    VerificationInfo data = new VerificationInfo();
    data.value = Short.parseShort(value);
    String voting = params.get("voting");
    data.voting = Boolean.parseBoolean(voting);
    data.url = params.get("url");
    data.reporter = params.get("reporter");
    data.comment = params.get("comment");
    data.category = params.get("category");
    data.duration = params.get("duration");
    jobResult.put(job, data);
}
#method_after
private void parseWithEquals(String text) {
    log.debug("processing verification: " + text);
    checkArgument(!Strings.isNullOrEmpty(text), "Empty verification data");
    Map<String, String> params = null;
    try {
        params = Splitter.on("|").withKeyValueSeparator("=").split(text);
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException(String.valueOf("Invalid verification parameters"));
    }
    String job = params.get("job");
    checkArgument(job != null, "Verification is missing a job");
    String value = params.get("value");
    checkArgument(value != null, "Verification is missing a value");
    String abstain = params.get("abstain");
    VerificationInfo data = new VerificationInfo();
    data.value = Short.parseShort(value);
    data.abstain = Boolean.valueOf(abstain);
    data.url = params.get("url");
    data.reporter = params.get("reporter");
    data.comment = params.get("comment");
    data.category = params.get("category");
    data.duration = params.get("duration");
    jobResult.put(job, data);
}
#end_block

#method_before
private boolean updateLabels(RevisionResource resource, CiDb db, Map<String, VerificationInfo> jobs) throws OrmException, BadRequestException {
    Preconditions.checkNotNull(jobs);
    List<PatchSetVerification> ups = Lists.newArrayList();
    Map<String, PatchSetVerification> current = scanLabels(resource, db);
    Timestamp ts = TimeUtil.nowTs();
    for (Map.Entry<String, VerificationInfo> ent : jobs.entrySet()) {
        String name = ent.getKey();
        PatchSetVerification c = current.remove(name);
        Short value = ent.getValue().value;
        if (value == null) {
            throw new BadRequestException("Missing value field");
        }
        if (c != null) {
            c.setGranted(ts);
            c.setValue(value);
            boolean voting = ent.getValue().voting;
            c.setVoting(voting);
            String url = ent.getValue().url;
            if (url != null) {
                c.setUrl(url);
            }
            String verifier = ent.getValue().reporter;
            if (verifier != null) {
                c.setVerifier(verifier);
            }
            String comment = ent.getValue().comment;
            if (comment != null) {
                c.setComment(comment);
            }
            String category = ent.getValue().category;
            if (category != null) {
                c.setCategory(category);
            }
            String duration = ent.getValue().duration;
            if (duration != null) {
                c.setDuration(duration);
            }
            log.info("Updating job " + c.getJob() + " for change " + c.getPatchSetId());
            ups.add(c);
        } else {
            c = new PatchSetVerification(new PatchSetVerification.Key(resource.getPatchSet().getId(), new LabelId(name)), value, TimeUtil.nowTs());
            c.setGranted(ts);
            c.setValue(value);
            c.setUrl(ent.getValue().url);
            c.setVerifier(ent.getValue().reporter);
            c.setVoting(ent.getValue().voting);
            c.setComment(ent.getValue().comment);
            c.setCategory(ent.getValue().category);
            c.setDuration(ent.getValue().duration);
            log.info("Adding job " + c.getJob() + " for change " + c.getPatchSetId());
            ups.add(c);
        }
    }
    db.patchSetVerifications().upsert(ups);
    return !ups.isEmpty();
}
#method_after
private boolean updateLabels(RevisionResource resource, CiDb db, Map<String, VerificationInfo> jobs) throws OrmException, BadRequestException {
    Preconditions.checkNotNull(jobs);
    List<PatchSetVerification> ups = Lists.newArrayList();
    Map<String, PatchSetVerification> current = scanLabels(resource, db);
    Timestamp ts = TimeUtil.nowTs();
    for (Map.Entry<String, VerificationInfo> ent : jobs.entrySet()) {
        String name = ent.getKey();
        PatchSetVerification c = current.remove(name);
        Short value = ent.getValue().value;
        if (value == null) {
            throw new BadRequestException("Missing value field");
        }
        if (c != null) {
            c.setGranted(ts);
            c.setValue(value);
            if (Boolean.TRUE.equals(ent.getValue().abstain)) {
                c.setAbstain(true);
            }
            String url = ent.getValue().url;
            if (url != null) {
                c.setUrl(url);
            }
            String reporter = ent.getValue().reporter;
            if (reporter != null) {
                c.setReporter(reporter);
            }
            String comment = ent.getValue().comment;
            if (comment != null) {
                c.setComment(comment);
            }
            String category = ent.getValue().category;
            if (category != null) {
                c.setCategory(category);
            }
            String duration = ent.getValue().duration;
            if (duration != null) {
                c.setDuration(duration);
            }
            log.info("Updating job " + c.getJob() + " for change " + c.getPatchSetId());
            ups.add(c);
        } else {
            c = new PatchSetVerification(new PatchSetVerification.Key(resource.getPatchSet().getId(), new LabelId(name)), value, ts);
            c.setAbstain(ent.getValue().abstain);
            c.setUrl(ent.getValue().url);
            c.setReporter(ent.getValue().reporter);
            c.setComment(ent.getValue().comment);
            c.setCategory(ent.getValue().category);
            c.setDuration(ent.getValue().duration);
            log.info("Adding job " + c.getJob() + " for change " + c.getPatchSetId());
            ups.add(c);
        }
    }
    db.patchSetVerifications().upsert(ups);
    return !ups.isEmpty();
}
#end_block

#method_before
public PatchSet currentPatchSet() throws OrmException {
    if (currentPatchSet == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        for (PatchSet p : patches()) {
            if (p.getId().equals(c.currentPatchSetId())) {
                if (changeControl().isPatchVisible(p, db)) {
                    currentPatchSet = p;
                    return p;
                }
            }
        }
    }
    return currentPatchSet;
}
#method_after
public PatchSet currentPatchSet() throws OrmException {
    if (currentPatchSet == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        for (PatchSet p : patches()) {
            if (p.getId().equals(c.currentPatchSetId())) {
                currentPatchSet = p;
                return p;
            }
        }
    }
    return currentPatchSet;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group2.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(group1.addFinal(new GerritCallback<DiffInfo>() {

        final AsyncCallback<Void> modeInjectorCb = group2.addEmpty();

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            fileSize = bucketFileSize(diffInfo);
            if (prefs.syntaxHighlighting()) {
                if (fileSize.compareTo(FileSize.SMALL) > 0) {
                    modeInjectorCb.onSuccess(null);
                } else {
                    injectMode(diffInfo, modeInjectorCb);
                }
            } else {
                modeInjectorCb.onSuccess(null);
            }
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.edit(changeId.get(), group2.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    final CommentsCollections comments = new CommentsCollections();
    comments.load(base, revision, path, group2);
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS));
    call.get(group2.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            changeStatus = info.status();
            info.revisions().copyKeysIntoChildren("name");
            if (edit != null) {
                edit.setName(edit.commit().commit());
                info.setEdit(edit);
                info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
            }
            String currentRevision = info.currentRevision();
            boolean current = currentRevision != null && revision.get() == info.revision(currentRevision)._number();
            JsArray<RevisionInfo> list = info.revisions().values();
            RevisionInfo.sortRevisionInfoByNumber(list);
            getDiffTable().set(prefs, list, diff, edit != null, current, changeStatus.isOpen(), diff.binary());
            header.setChangeInfo(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ConfigInfoCache.get(changeId, group2.addFinal(getScreenLoadCallback(comments)));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group2.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(group1.addFinal(new GerritCallback<DiffInfo>() {

        final AsyncCallback<Void> modeInjectorCb = group2.addEmpty();

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            fileSize = bucketFileSize(diffInfo);
            if (prefs.syntaxHighlighting()) {
                if (fileSize.compareTo(FileSize.SMALL) > 0) {
                    modeInjectorCb.onSuccess(null);
                } else {
                    injectMode(diffInfo, modeInjectorCb);
                }
            } else {
                modeInjectorCb.onSuccess(null);
            }
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.edit(changeId.get(), group2.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    final CommentsCollections comments = new CommentsCollections(base, revision, path);
    comments.load(group2);
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS));
    call.get(group2.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            changeStatus = info.status();
            info.revisions().copyKeysIntoChildren("name");
            if (edit != null) {
                edit.setName(edit.commit().commit());
                info.setEdit(edit);
                info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
            }
            String currentRevision = info.currentRevision();
            boolean current = currentRevision != null && revision.get() == info.revision(currentRevision)._number();
            JsArray<RevisionInfo> list = info.revisions().values();
            RevisionInfo.sortRevisionInfoByNumber(list);
            getDiffTable().set(prefs, list, diff, edit != null, current, changeStatus.isOpen(), diff.binary());
            header.setChangeInfo(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ConfigInfoCache.get(changeId, group2.addFinal(getScreenLoadCallback(comments)));
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    JumpKeys.enable(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegistrations();
    if (getCommentManager() != null) {
        CallbackGroup group = new CallbackGroup();
        getCommentManager().saveAllDrafts(group);
        group.done();
    }
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    for (CodeMirror cm : getCms()) {
        if (cm != null) {
            cm.getWrapperElement().removeFromParent();
        }
    }
    if (prefsAction != null) {
        prefsAction.hide();
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
    JumpKeys.enable(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegistrations();
    if (getCommentManager() != null) {
        CallbackGroup group = new CallbackGroup();
        getCommentManager().saveAllDrafts(group);
        group.done();
    }
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    for (CodeMirror cm : getCms()) {
        if (cm != null) {
            cm.getWrapperElement().removeFromParent();
        }
    }
    if (prefsAction != null) {
        prefsAction.hide();
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("focus", updateActiveLine(cm));
    KeyMap keyMap = KeyMap.create().on("A", upToChange(true)).on("U", upToChange(false)).on("'['", header.navigate(Direction.PREV)).on("']'", header.navigate(Direction.NEXT)).on("R", header.toggleReviewed()).on("O", getCommentManager().toggleOpenBox(cm)).on("Enter", getCommentManager().toggleOpenBox(cm)).on("N", maybeNextVimSearch(cm)).on("E", openEditScreen(cm)).on("P", getChunkManager().diffChunkNav(cm, Direction.PREV)).on("Shift-M", header.reviewedAndNext()).on("Shift-N", maybePrevVimSearch(cm)).on("Shift-P", getCommentManager().commentNav(cm, Direction.PREV)).on("Shift-O", getCommentManager().openCloseAll(cm)).on("I", new Runnable() {

        @Override
        public void run() {
            switch(getIntraLineStatus()) {
                case OFF:
                case OK:
                    toggleShowIntraline();
                    break;
                case FAILURE:
                case TIMEOUT:
                default:
                    break;
            }
        }
    }).on("','", new Runnable() {

        @Override
        public void run() {
            prefsAction.show();
        }
    }).on("Shift-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-d>");
        }
    }).on("Shift-Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-u>");
        }
    }).on("Ctrl-F", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("/");
        }
    }).on("Ctrl-A", new Runnable() {

        @Override
        public void run() {
            cm.execCommand("selectAll");
        }
    });
    if (revision.get() != 0) {
        cm.on("beforeSelectionChange", onSelectionChange(cm));
        cm.on("gutterClick", onGutterClick(cm));
        keyMap.on("C", getCommentManager().newDraftCallback(cm));
    }
    cm.addKeyMap(keyMap);
}
#method_after
void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("focus", updateActiveLine(cm));
    KeyMap keyMap = KeyMap.create().on("A", upToChange(true)).on("U", upToChange(false)).on("'['", header.navigate(Direction.PREV)).on("']'", header.navigate(Direction.NEXT)).on("R", header.toggleReviewed()).on("O", getCommentManager().toggleOpenBox(cm)).on("Enter", getCommentManager().toggleOpenBox(cm)).on("N", maybeNextVimSearch(cm)).on("Ctrl-Alt-E", openEditScreen(cm)).on("P", getChunkManager().diffChunkNav(cm, Direction.PREV)).on("Shift-M", header.reviewedAndNext()).on("Shift-N", maybePrevVimSearch(cm)).on("Shift-P", getCommentManager().commentNav(cm, Direction.PREV)).on("Shift-O", getCommentManager().openCloseAll(cm)).on("I", new Runnable() {

        @Override
        public void run() {
            switch(getIntraLineStatus()) {
                case OFF:
                case OK:
                    toggleShowIntraline();
                    break;
                case FAILURE:
                case TIMEOUT:
                default:
                    break;
            }
        }
    }).on("','", new Runnable() {

        @Override
        public void run() {
            prefsAction.show();
        }
    }).on("Shift-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-d>");
        }
    }).on("Shift-Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-u>");
        }
    }).on("Ctrl-F", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("/");
        }
    }).on("Ctrl-A", new Runnable() {

        @Override
        public void run() {
            cm.execCommand("selectAll");
        }
    }).on("G O", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:open"));
        }
    }).on("G M", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:merged"));
        }
    }).on("G A", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:abandoned"));
        }
    });
    if (Gerrit.isSignedIn()) {
        keyMap.on("G I", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.MINE);
            }
        }).on("G D", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("owner:self is:draft"));
            }
        }).on("G C", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("has:draft"));
            }
        }).on("G W", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("is:watched status:open"));
            }
        }).on("G S", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("is:starred"));
            }
        });
    }
    if (revision.get() != 0) {
        cm.on("beforeSelectionChange", onSelectionChange(cm));
        cm.on("gutterClick", onGutterClick(cm));
        keyMap.on("C", getCommentManager().newDraftCallback(cm));
    }
    // Needed to for multi-stroke keymaps
    CodeMirror.normalizeKeyMap(keyMap);
    cm.addKeyMap(keyMap);
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()), new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysNavigation.add(new NoOpKeyCommand(0, 'n', PatchUtil.C.chunkNext2()), new NoOpKeyCommand(0, 'p', PatchUtil.C.chunkPrev2()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'n', PatchUtil.C.commentNext()), new NoOpKeyCommand(KeyCommand.M_SHIFT, 'p', PatchUtil.C.commentPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 'f', Gerrit.C.keySearch()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'o', PatchUtil.C.expandAllCommentsOnCurrentLine()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                header.toggleReviewed().run();
            }
        });
    }
    keysAction.add(new KeyCommand(KeyCommand.M_SHIFT, 'm', PatchUtil.C.markAsReviewedAndGoToNext()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            header.reviewedAndNext().run();
        }
    });
    keysAction.add(new KeyCommand(0, 'a', PatchUtil.C.openReply()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange(true).run();
        }
    });
    keysAction.add(new KeyCommand(0, ',', PatchUtil.C.showPreferences()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            prefsAction.show();
        }
    });
    if (getIntraLineStatus() == DiffInfo.IntraLineStatus.OFF || getIntraLineStatus() == DiffInfo.IntraLineStatus.OK) {
        keysAction.add(new KeyCommand(0, 'i', PatchUtil.C.toggleIntraline()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                toggleShowIntraline();
            }
        });
    }
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()), new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysNavigation.add(new NoOpKeyCommand(0, 'n', PatchUtil.C.chunkNext()), new NoOpKeyCommand(0, 'p', PatchUtil.C.chunkPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'n', PatchUtil.C.commentNext()), new NoOpKeyCommand(KeyCommand.M_SHIFT, 'p', PatchUtil.C.commentPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 'f', Gerrit.C.keySearch()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'o', PatchUtil.C.expandAllCommentsOnCurrentLine()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                header.toggleReviewed().run();
            }
        });
        keysAction.add(new NoOpKeyCommand(KeyCommand.M_CTRL | KeyCommand.M_ALT, 'e', Gerrit.C.keyEditor()));
    }
    keysAction.add(new KeyCommand(KeyCommand.M_SHIFT, 'm', PatchUtil.C.markAsReviewedAndGoToNext()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            header.reviewedAndNext().run();
        }
    });
    keysAction.add(new KeyCommand(0, 'a', PatchUtil.C.openReply()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange(true).run();
        }
    });
    keysAction.add(new KeyCommand(0, ',', PatchUtil.C.showPreferences()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            prefsAction.show();
        }
    });
    if (getIntraLineStatus() == DiffInfo.IntraLineStatus.OFF || getIntraLineStatus() == DiffInfo.IntraLineStatus.OK) {
        keysAction.add(new KeyCommand(0, 'i', PatchUtil.C.toggleIntraline()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                toggleShowIntraline();
            }
        });
    }
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
}
#end_block

#method_before
void setContext(final int context) {
    operation(new Runnable() {

        @Override
        public void run() {
            getSkipManager().removeAll();
            getSkipManager().render(context, diff);
            updateRenderEntireFile();
        }
    });
}
#method_after
void setContext(final int context) {
    operation(new Runnable() {

        @Override
        public void run() {
            skipManager.removeAll();
            skipManager.render(context, diff);
            updateRenderEntireFile();
        }
    });
}
#end_block

#method_before
void reloadDiffInfo() {
    final int id = ++reloadVersionId;
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            if (id == reloadVersionId && isAttached()) {
                diff = diffInfo;
                operation(new Runnable() {

                    @Override
                    public void run() {
                        getSkipManager().removeAll();
                        getChunkManager().reset();
                        getDiffTable().scrollbar.removeDiffAnnotations();
                        setShowIntraline(prefs.intralineDifference());
                        render(diff);
                        getSkipManager().render(prefs.context(), diff);
                    }
                });
            }
        }
    });
}
#method_after
void reloadDiffInfo() {
    final int id = ++reloadVersionId;
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            if (id == reloadVersionId && isAttached()) {
                diff = diffInfo;
                operation(new Runnable() {

                    @Override
                    public void run() {
                        skipManager.removeAll();
                        getChunkManager().reset();
                        getDiffTable().scrollbar.removeDiffAnnotations();
                        setShowIntraline(prefs.intralineDifference());
                        render(diff);
                        skipManager.render(prefs.context(), diff);
                    }
                });
            }
        }
    });
}
#end_block

#method_before
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) {
            if (isLineNumberClick(clickEvent) && clickEvent.getButton() == NativeEvent.BUTTON_LEFT && !clickEvent.getMetaKey() && !clickEvent.getAltKey() && !clickEvent.getCtrlKey() && !clickEvent.getShiftKey()) {
                cm.setCursor(Pos.create(line));
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        getCommentManager().newDraftOnGutterClick(cm, gutterClass, line + 1);
                    }
                });
            }
        }
    };
}
#method_after
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) {
            if (clickEvent.getButton() == NativeEvent.BUTTON_LEFT && !clickEvent.getMetaKey() && !clickEvent.getAltKey() && !clickEvent.getCtrlKey() && !clickEvent.getShiftKey()) {
                cm.setCursor(Pos.create(line));
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        getCommentManager().newDraftOnGutterClick(cm, gutterClass, line + 1);
                    }
                });
            }
        }
    };
}
#end_block

#method_before
LineOnOtherInfo lineOnOther(DisplaySide side, int line) {
    return getChunkManager().getLineMapper().lineOnOther(side, line);
}
#method_after
LineOnOtherInfo lineOnOther(DisplaySide side, int line) {
    return getChunkManager().lineMapper.lineOnOther(side, line);
}
#end_block

#method_before
@Override
void render(DiffInfo diff) {
    super.render();
    LineMapper mapper = getLineMapper();
    chunks = new ArrayList<>();
    int cmLine = 0;
    boolean useIntralineBg = diff.metaA() == null || diff.metaB() == null;
    for (Region current : Natives.asList(diff.content())) {
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            int length = current.ab().length();
            mapper.appendCommon(length);
            for (int i = 0; i < length; i++) {
                host.setLineNumber(DisplaySide.A, cmLine + i, origLineA + i + 1);
                host.setLineNumber(DisplaySide.B, cmLine + i, origLineB + i + 1);
            }
            cmLine += length;
        } else if (current.skip() > 0) {
            mapper.appendCommon(current.skip());
            // Maybe current.ab().length();
            cmLine += current.skip();
        } else if (current.common()) {
            mapper.appendCommon(current.b().length());
            cmLine += current.b().length();
        } else {
            cmLine += render(current, cmLine, useIntralineBg);
        }
    }
    host.setLineNumber(DisplaySide.A, cmLine, mapper.getLineA() + 1);
    host.setLineNumber(DisplaySide.B, cmLine, mapper.getLineB() + 1);
}
#method_after
@Override
void render(DiffInfo diff) {
    super.render();
    chunks = new ArrayList<>();
    int cmLine = 0;
    boolean useIntralineBg = diff.metaA() == null || diff.metaB() == null;
    for (Region current : Natives.asList(diff.content())) {
        int origLineA = lineMapper.getLineA();
        int origLineB = lineMapper.getLineB();
        if (current.ab() != null) {
            int length = current.ab().length();
            lineMapper.appendCommon(length);
            for (int i = 0; i < length; i++) {
                host.setLineNumber(DisplaySide.A, cmLine + i, origLineA + i + 1);
                host.setLineNumber(DisplaySide.B, cmLine + i, origLineB + i + 1);
            }
            cmLine += length;
        } else if (current.skip() > 0) {
            lineMapper.appendCommon(current.skip());
            // Maybe current.ab().length();
            cmLine += current.skip();
        } else if (current.common()) {
            lineMapper.appendCommon(current.b().length());
            cmLine += current.b().length();
        } else {
            cmLine += render(current, cmLine, useIntralineBg);
        }
    }
    host.setLineNumber(DisplaySide.A, cmLine, lineMapper.getLineA() + 1);
    host.setLineNumber(DisplaySide.B, cmLine, lineMapper.getLineB() + 1);
}
#end_block

#method_before
private int render(Region region, int cmLine, boolean useIntralineBg) {
    LineMapper mapper = getLineMapper();
    int startA = mapper.getLineA();
    int startB = mapper.getLineB();
    JsArrayString a = region.a();
    JsArrayString b = region.b();
    int aLen = a != null ? a.length() : 0;
    int bLen = b != null ? b.length() : 0;
    boolean insertOrDelete = a == null || b == null;
    colorLines(cm, insertOrDelete && !useIntralineBg ? UnifiedTable.style.diffDelete() : UnifiedTable.style.intralineDelete(), cmLine, aLen);
    colorLines(cm, insertOrDelete && !useIntralineBg ? UnifiedTable.style.diffInsert() : UnifiedTable.style.intralineInsert(), cmLine + aLen, bLen);
    markEdit(DisplaySide.A, cmLine, a, region.editA());
    markEdit(DisplaySide.B, cmLine + aLen, b, region.editB());
    // TODO: verify addGutterTag
    addGutterTag(region, cmLine);
    mapper.appendReplace(aLen, bLen);
    int endA = mapper.getLineA() - 1;
    int endB = mapper.getLineB() - 1;
    if (aLen > 0) {
        addDiffChunk(DisplaySide.A, endA, aLen, cmLine, bLen > 0);
        for (int j = 0; j < aLen; j++) {
            host.setLineNumber(DisplaySide.A, cmLine + j, startA + j + 1);
            host.setLineNumberEmpty(DisplaySide.B, cmLine + j);
        }
    }
    if (bLen > 0) {
        addDiffChunk(DisplaySide.B, endB, bLen, cmLine + aLen, aLen > 0);
        for (int j = 0; j < bLen; j++) {
            host.setLineNumberEmpty(DisplaySide.A, cmLine + aLen + j);
            host.setLineNumber(DisplaySide.B, cmLine + aLen + j, startB + j + 1);
        }
    }
    return aLen + bLen;
}
#method_after
private int render(Region region, int cmLine, boolean useIntralineBg) {
    int startA = lineMapper.getLineA();
    int startB = lineMapper.getLineB();
    JsArrayString a = region.a();
    JsArrayString b = region.b();
    int aLen = a != null ? a.length() : 0;
    int bLen = b != null ? b.length() : 0;
    boolean insertOrDelete = a == null || b == null;
    colorLines(cm, insertOrDelete && !useIntralineBg ? UnifiedTable.style.diffDelete() : UnifiedTable.style.intralineDelete(), cmLine, aLen);
    colorLines(cm, insertOrDelete && !useIntralineBg ? UnifiedTable.style.diffInsert() : UnifiedTable.style.intralineInsert(), cmLine + aLen, bLen);
    markEdit(DisplaySide.A, cmLine, a, region.editA());
    markEdit(DisplaySide.B, cmLine + aLen, b, region.editB());
    // TODO: verify addGutterTag
    addGutterTag(region, cmLine);
    lineMapper.appendReplace(aLen, bLen);
    int endA = lineMapper.getLineA() - 1;
    int endB = lineMapper.getLineB() - 1;
    if (aLen > 0) {
        addDiffChunk(DisplaySide.A, endA, endB, aLen, cmLine, bLen > 0);
        for (int j = 0; j < aLen; j++) {
            host.setLineNumber(DisplaySide.A, cmLine + j, startA + j + 1);
            host.setLineNumberEmpty(DisplaySide.B, cmLine + j);
        }
    }
    if (bLen > 0) {
        addDiffChunk(DisplaySide.B, endB, endA, bLen, cmLine + aLen, aLen > 0);
        for (int j = 0; j < bLen; j++) {
            host.setLineNumberEmpty(DisplaySide.A, cmLine + aLen + j);
            host.setLineNumber(DisplaySide.B, cmLine + aLen + j, startB + j + 1);
        }
    }
    return aLen + bLen;
}
#end_block

#method_before
private void addGutterTag(Region region, int cmLine) {
    Scrollbar scrollbar = getScrollbar();
    if (region.a() == null) {
        scrollbar.insert(cm, cmLine, region.b().length());
    } else if (region.b() == null) {
        scrollbar.delete(cm, cm, cmLine, region.a().length());
    } else {
        scrollbar.edit(cm, cmLine, region.b().length());
    }
}
#method_after
private void addGutterTag(Region region, int cmLine) {
    if (region.a() == null) {
        scrollbar.insert(cm, cmLine, region.b().length());
    } else if (region.b() == null) {
        scrollbar.delete(cm, cm, cmLine, region.a().length());
    } else {
        scrollbar.edit(cm, cmLine, region.b().length());
    }
}
#end_block

#method_before
private void addDiffChunk(DisplaySide side, int chunkEnd, int chunkSize, int cmLine, boolean edit) {
    chunks.add(new UnifiedDiffChunkInfo(side, chunkEnd - chunkSize + 1, chunkEnd, cmLine, edit));
}
#method_after
private void addDiffChunk(DisplaySide side, int chunkEnd, int otherChunkEnd, int chunkSize, int cmLine, boolean edit) {
    chunks.add(new UnifiedDiffChunkInfo(side, chunkEnd - chunkSize + 1, otherChunkEnd - chunkSize + 1, chunkEnd, cmLine, edit));
}
#end_block

#method_before
@Override
Runnable diffChunkNav(final CodeMirror cm, final Direction dir) {
    return new Runnable() {

        @Override
        public void run() {
            int line = cm.extras().hasActiveLine() ? cm.getLineNumber(cm.extras().activeLine()) : 0;
            int res = Collections.binarySearch(chunks, new UnifiedDiffChunkInfo(cm.side(), 0, 0, line, false), getDiffChunkComparatorCmLine());
            diffChunkNavHelper(chunks, host, res, dir);
        }
    };
}
#method_after
@Override
Runnable diffChunkNav(final CodeMirror cm, final Direction dir) {
    return new Runnable() {

        @Override
        public void run() {
            int line = cm.extras().hasActiveLine() ? cm.getLineNumber(cm.extras().activeLine()) : 0;
            int res = Collections.binarySearch(chunks, new UnifiedDiffChunkInfo(cm.side(), 0, 0, 0, line, false), getDiffChunkComparatorCmLine());
            diffChunkNavHelper(chunks, host, res, dir);
        }
    };
}
#end_block

#method_before
private Comparator<UnifiedDiffChunkInfo> getDiffChunkComparatorCmLine() {
    return new Comparator<UnifiedDiffChunkInfo>() {

        @Override
        public int compare(UnifiedDiffChunkInfo o1, UnifiedDiffChunkInfo o2) {
            return o1.getCmLine() - o2.getCmLine();
        }
    };
}
#method_after
private Comparator<UnifiedDiffChunkInfo> getDiffChunkComparatorCmLine() {
    return new Comparator<UnifiedDiffChunkInfo>() {

        @Override
        public int compare(UnifiedDiffChunkInfo o1, UnifiedDiffChunkInfo o2) {
            return o1.cmLine - o2.cmLine;
        }
    };
}
#end_block

#method_before
@Override
int getCmLine(int line, DisplaySide side) {
    int res = Collections.binarySearch(chunks, new UnifiedDiffChunkInfo(side, line, 0, 0, // Dummy DiffChunkInfo
    false), getDiffChunkComparator());
    if (res >= 0) {
        return chunks.get(res).getCmLine();
    } else {
        // The line might be within a DiffChunk
        res = -res - 1;
        if (res > 0) {
            UnifiedDiffChunkInfo info = chunks.get(res - 1);
            if (side == DisplaySide.A && info.isEdit() && info.getSide() == DisplaySide.B) {
                // Need to use the start and cmLine of the deletion chunk
                UnifiedDiffChunkInfo delete = chunks.get(res - 2);
                if (line <= delete.getEnd()) {
                    return delete.getCmLine() + line - delete.getStart();
                } else {
                    // Need to add the length of the insertion chunk
                    return delete.getCmLine() + line - delete.getStart() + info.getEnd() - info.getStart() + 1;
                }
            } else if (side == info.getSide()) {
                return info.getCmLine() + line - info.getStart();
            } else {
                return info.getCmLine() + getLineMapper().lineOnOther(side, line).getLine() - info.getStart();
            }
        } else {
            return line;
        }
    }
}
#method_after
@Override
int getCmLine(int line, DisplaySide side) {
    int res = Collections.binarySearch(chunks, new UnifiedDiffChunkInfo(side, line, 0, 0, 0, // Dummy DiffChunkInfo
    false));
    if (res >= 0) {
        return chunks.get(res).cmLine;
    } else {
        // The line might be within a DiffChunk
        res = -res - 1;
        if (res > 0) {
            UnifiedDiffChunkInfo info = chunks.get(res - 1);
            if (side == DisplaySide.A && info.edit && info.side == DisplaySide.B) {
                // Need to use the start and cmLine of the deletion chunk
                UnifiedDiffChunkInfo delete = chunks.get(res - 2);
                if (line <= delete.end) {
                    return delete.cmLine + line - delete.start;
                } else {
                    // Need to add the length of the insertion chunk
                    return delete.cmLine + line - delete.start + info.end - info.start + 1;
                }
            } else if (side == info.side) {
                return info.cmLine + line - info.start;
            } else {
                return info.cmLine + lineMapper.lineOnOther(side, line).getLine() - info.start;
            }
        } else {
            return line;
        }
    }
}
#end_block

#method_before
@Override
ScreenLoadCallback<ConfigInfoCache.Entry> getScreenLoadCallback(final CommentsCollections comments) {
    return new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentManager = new SideBySideCommentManager(SideBySide.this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen());
            setTheme(result.getTheme());
            display(comments);
        }
    };
}
#method_after
@Override
ScreenLoadCallback<ConfigInfoCache.Entry> getScreenLoadCallback(final CommentsCollections comments) {
    return new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentManager = new SideBySideCommentManager(SideBySide.this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen());
            setTheme(result.getTheme());
            display(comments);
            header.setupPrevNextFiles(comments);
        }
    };
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    operation(new Runnable() {

        @Override
        public void run() {
            resizeCodeMirror();
            chunkManager.adjustPadding();
            cmA.refresh();
            cmB.refresh();
        }
    });
    setLineLength(Patch.COMMIT_MSG.equals(prefs) ? 72 : prefs.lineLength());
    diffTable.refresh();
    if (getStartLine() == 0) {
        DiffChunkInfo d = chunkManager.getFirst();
        if (d != null) {
            if (d.isEdit() && d.getSide() == DisplaySide.A) {
                setStartSide(DisplaySide.B);
                setStartLine(lineOnOther(d.getSide(), d.getStart()).getLine() + 1);
            } else {
                setStartSide(d.getSide());
                setStartLine(d.getStart() + 1);
            }
        }
    }
    if (getStartSide() != null && getStartLine() > 0) {
        CodeMirror cm = getCmFromSide(getStartSide());
        cm.scrollToLine(getStartLine() - 1);
        cm.focus();
    } else {
        cmA.setCursor(Pos.create(0));
        cmA.focus();
    }
    if (Gerrit.isSignedIn() && prefs.autoReview()) {
        header.autoReview();
    }
    prefetchNextFile();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    operation(new Runnable() {

        @Override
        public void run() {
            resizeCodeMirror();
            chunkManager.adjustPadding();
            cmA.refresh();
            cmB.refresh();
        }
    });
    setLineLength(Patch.COMMIT_MSG.equals(path) ? 72 : prefs.lineLength());
    diffTable.refresh();
    if (getStartLine() == 0) {
        DiffChunkInfo d = chunkManager.getFirst();
        if (d != null) {
            if (d.edit && d.side == DisplaySide.A) {
                setStartSide(DisplaySide.B);
                setStartLine(lineOnOther(d.side, d.start).getLine() + 1);
            } else {
                setStartSide(d.side);
                setStartLine(d.start + 1);
            }
        }
    }
    if (getStartSide() != null && getStartLine() > 0) {
        CodeMirror cm = getCmFromSide(getStartSide());
        cm.scrollToLine(getStartLine() - 1);
        cm.focus();
    } else {
        cmA.setCursor(Pos.create(0));
        cmA.focus();
    }
    if (Gerrit.isSignedIn() && prefs.autoReview()) {
        header.autoReview();
    }
    prefetchNextFile();
}
#end_block

#method_before
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
    cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA);
    cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB);
    cmA.extras().side(DisplaySide.A);
    cmB.extras().side(DisplaySide.B);
    setShowTabs(prefs.showTabs());
    chunkManager = new SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar);
    skipManager = new SideBySideSkipManager(this, commentManager);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollSynchronizer = new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper());
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks());
    scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#method_after
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
    cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA);
    cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB);
    cmA.extras().side(DisplaySide.A);
    cmB.extras().side(DisplaySide.B);
    setShowTabs(prefs.showTabs());
    chunkManager = new SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollSynchronizer = new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.lineMapper);
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks());
    scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#end_block

#method_before
@Override
void setShowLineNumbers(boolean b) {
    cmA.setOption("lineNumbers", b);
    cmB.setOption("lineNumbers", b);
    if (b) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    } else {
        diffTable.removeStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
}
#method_after
@Override
void setShowLineNumbers(boolean b) {
    super.setShowLineNumbers(b);
    cmA.setOption("lineNumbers", b);
    cmB.setOption("lineNumbers", b);
}
#end_block

#method_before
@Override
ScreenLoadCallback<ConfigInfoCache.Entry> getScreenLoadCallback(final CommentsCollections comments) {
    return new ScreenLoadCallback<ConfigInfoCache.Entry>(Unified.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentManager = new UnifiedCommentManager(Unified.this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen());
            setTheme(result.getTheme());
            display(comments);
        }
    };
}
#method_after
@Override
ScreenLoadCallback<ConfigInfoCache.Entry> getScreenLoadCallback(final CommentsCollections comments) {
    return new ScreenLoadCallback<ConfigInfoCache.Entry>(Unified.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentManager = new UnifiedCommentManager(Unified.this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen());
            setTheme(result.getTheme());
            display(comments);
            header.setupPrevNextFiles(comments);
        }
    };
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    operation(new Runnable() {

        @Override
        public void run() {
            resizeCodeMirror();
            cm.refresh();
        }
    });
    setLineLength(Patch.COMMIT_MSG.equals(path) ? 72 : prefs.lineLength());
    diffTable.refresh();
    if (getStartLine() == 0) {
        DiffChunkInfo d = chunkManager.getFirst();
        if (d != null) {
            if (d.isEdit() && d.getSide() == DisplaySide.A) {
                setStartSide(DisplaySide.B);
            } else {
                setStartSide(d.getSide());
            }
            setStartLine(chunkManager.getCmLine(d.getStart(), d.getSide()) + 1);
        }
    }
    if (getStartSide() != null && getStartLine() > 0) {
        cm.scrollToLine(chunkManager.getCmLine(getStartLine() - 1, getStartSide()));
        cm.focus();
    } else {
        cm.setCursor(Pos.create(0));
        cm.focus();
    }
    if (Gerrit.isSignedIn() && prefs.autoReview()) {
        header.autoReview();
    }
    prefetchNextFile();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    operation(new Runnable() {

        @Override
        public void run() {
            resizeCodeMirror();
            cm.refresh();
        }
    });
    setLineLength(Patch.COMMIT_MSG.equals(path) ? 72 : prefs.lineLength());
    diffTable.refresh();
    if (getStartLine() == 0) {
        DiffChunkInfo d = chunkManager.getFirst();
        if (d != null) {
            if (d.edit && d.side == DisplaySide.A) {
                setStartSide(DisplaySide.B);
            } else {
                setStartSide(d.side);
            }
            setStartLine(chunkManager.getCmLine(d.start, d.side) + 1);
        }
    }
    if (getStartSide() != null && getStartLine() > 0) {
        cm.scrollToLine(chunkManager.getCmLine(getStartLine() - 1, getStartSide()));
        cm.focus();
    } else {
        cm.setCursor(Pos.create(0));
        cm.focus();
    }
    if (Gerrit.isSignedIn() && prefs.autoReview()) {
        header.autoReview();
    }
    prefetchNextFile();
}
#end_block

#method_before
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
    cm = newCm(diff.metaA() == null ? diff.metaB() : diff.metaA(), diff.textUnified(), diffTable.cm);
    setShowTabs(prefs.showTabs());
    chunkManager = new UnifiedChunkManager(this, cm, diffTable.scrollbar);
    skipManager = new UnifiedSkipManager(this, commentManager);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cm.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cm);
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getSideBySideDiffLink(), diff.unifiedWebLinks());
    setAutoHideDiffHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#method_after
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
    cm = newCm(diff.metaA() == null ? diff.metaB() : diff.metaA(), diff.textUnified(), diffTable.cm);
    setShowTabs(prefs.showTabs());
    chunkManager = new UnifiedChunkManager(this, cm, diffTable.scrollbar);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cm.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cm);
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getSideBySideDiffLink(), diff.unifiedWebLinks());
    setAutoHideDiffHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#end_block

#method_before
@Override
void setShowLineNumbers(boolean b) {
    if (b) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    } else {
        diffTable.removeStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
    cm.refresh();
}
#method_after
@Override
void setShowLineNumbers(boolean b) {
    super.setShowLineNumbers(b);
    cm.refresh();
}
#end_block

#method_before
int getCmLine(int line, DisplaySide side) {
    return chunkManager.getCmLine(line, side);
}
#method_after
@Override
int getCmLine(int line, DisplaySide side) {
    return chunkManager.getCmLine(line, side);
}
#end_block

#method_before
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Input());
    } catch (IOException e) {
        throw new RestApiException("Cannot index change", e);
    }
}
#method_after
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Index.Input());
    } catch (IOException e) {
        throw new RestApiException("Cannot index change", e);
    }
}
#end_block

#method_before
@Test
public void testGcWithoutCapability_Error() throws Exception {
    userSshSession.exec("gerrit gc --all");
    assertThat(userSshSession.hasError()).isTrue();
    assertError("One of the following capabilities is required to access this" + " resource: [runGC, maintainServer]", userSshSession.getError());
}
#method_after
@Test
public void testGcWithoutCapability_Error() throws Exception {
    userSshSession.exec("gerrit gc --all");
    assertThat(userSshSession.hasError()).isTrue();
    String error = userSshSession.getError();
    assertThat(error).isNotNull();
    assertError("One of the following capabilities is required to access this" + " resource: [runGC, maintainServer]", error);
}
#end_block

#method_before
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    // TODO: Handle showLineNumbers preference
    cm = newCm(diff.metaA() == null ? diff.metaB() : diff.metaA(), diff.textUnified(), diffTable.cm);
    setShowTabs(prefs.showTabs());
    chunkManager = new UnifiedChunkManager(this, cm, diffTable.scrollbar);
    setSkipManager(new SkipManager(this, commentManager));
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cm.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            getSkipManager().render(prefs.context(), diff);
        }
    });
    registerCmEvents(cm);
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getSideBySideDiffLink(), diff.unifiedWebLinks());
    setAutoHideDiffHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#method_after
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    // TODO: Handle showLineNumbers preference
    cm = newCm(diff.metaA() == null ? diff.metaB() : diff.metaA(), diff.textUnified(), diffTable.cm);
    setShowTabs(prefs.showTabs());
    chunkManager = new UnifiedChunkManager(this, cm, diffTable.scrollbar);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cm.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cm);
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getSideBySideDiffLink(), diff.unifiedWebLinks());
    setAutoHideDiffHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#end_block

#method_before
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(SideBySideTable.style.showLineNumbers());
    }
    cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA);
    cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB);
    cmA.extras().side(DisplaySide.A);
    cmB.extras().side(DisplaySide.B);
    setShowTabs(prefs.showTabs());
    chunkManager = new SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar);
    setSkipManager(new SkipManager(this, commentManager));
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            getSkipManager().render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollSynchronizer = new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper());
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks());
    scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#method_after
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(SideBySideTable.style.showLineNumbers());
    }
    cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA);
    cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB);
    cmA.extras().side(DisplaySide.A);
    cmB.extras().side(DisplaySide.B);
    setShowTabs(prefs.showTabs());
    chunkManager = new SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollSynchronizer = new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper());
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks());
    scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#end_block

#method_before
void render(int context, DiffInfo diff) {
    if (context == DiffPreferencesInfo.WHOLE_FILE_CONTEXT) {
        return;
    }
    List<SkippedLine> skips = new ArrayList<>();
    int lineA = 0;
    int lineB = 0;
    JsArray<Region> regions = diff.content();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null || current.common() || current.skip() > 0) {
            int len = current.skip() > 0 ? current.skip() : (current.ab() != null ? current.ab() : current.b()).length();
            if (i == 0 && len > context + 1) {
                skips.add(new SkippedLine(0, 0, len - context));
            } else if (i == regions.length() - 1 && len > context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - context));
            } else if (len > 2 * context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - 2 * context));
            }
            lineA += len;
            lineB += len;
        } else {
            lineA += current.a() != null ? current.a().length() : 0;
            lineB += current.b() != null ? current.b().length() : 0;
        }
    }
    skips = commentManager.splitSkips(context, skips);
    if (!skips.isEmpty()) {
        boolean isSideBySide = host.diffScreenType == DiffView.SIDE_BY_SIDE;
        CodeMirror cmA = null;
        if (isSideBySide) {
            cmA = host.getCmFromSide(DisplaySide.A);
        }
        CodeMirror cmB = host.getCmFromSide(DisplaySide.B);
        for (SkippedLine skip : skips) {
            SkipBar barA = null;
            SkipBar barB = newSkipBar(cmB, DisplaySide.B, skip);
            skipBars.add(barB);
            if (isSideBySide) {
                barA = newSkipBar(cmA, DisplaySide.A, skip);
                SkipBar.link(barA, barB);
                skipBars.add(barA);
            }
            if (skip.getStartA() == 0 || skip.getStartB() == 0) {
                if (isSideBySide) {
                    barA.upArrow.setVisible(false);
                }
                barB.upArrow.setVisible(false);
                setLine0(barB);
            } else if (skip.getStartA() + skip.getSize() == lineA || skip.getStartB() + skip.getSize() == lineB) {
                if (isSideBySide) {
                    barA.downArrow.setVisible(false);
                }
                barB.downArrow.setVisible(false);
            }
        }
    }
}
#method_after
void render(int context, DiffInfo diff) {
    if (context == DiffPreferencesInfo.WHOLE_FILE_CONTEXT) {
        return;
    }
    List<SkippedLine> skips = new ArrayList<>();
    int lineA = 0;
    int lineB = 0;
    JsArray<Region> regions = diff.content();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null || current.common() || current.skip() > 0) {
            int len = current.skip() > 0 ? current.skip() : (current.ab() != null ? current.ab() : current.b()).length();
            if (i == 0 && len > context + 1) {
                skips.add(new SkippedLine(0, 0, len - context));
            } else if (i == regions.length() - 1 && len > context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - context));
            } else if (len > 2 * context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - 2 * context));
            }
            lineA += len;
            lineB += len;
        } else {
            lineA += current.a() != null ? current.a().length() : 0;
            lineB += current.b() != null ? current.b().length() : 0;
        }
    }
    skips = host.getCommentManager().splitSkips(context, skips);
    renderSkips(skips, lineA, lineB);
}
#end_block

#method_before
private void decodeHashtags(Document doc, ChangeData cd) {
    IndexableField[] hashtag = doc.getFields(HASHTAG_FIELD);
    Set<String> hashtags = Sets.newHashSetWithExpectedSize(hashtag.length);
    for (IndexableField r : hashtag) {
        hashtags.add(r.stringValue());
    }
    cd.setHashtags(hashtags);
}
#method_after
private void decodeHashtags(Document doc, ChangeData cd) {
    IndexableField[] hashtag = doc.getFields(HASHTAG_FIELD);
    Set<String> hashtags = Sets.newHashSetWithExpectedSize(hashtag.length);
    for (IndexableField r : hashtag) {
        hashtags.add(r.binaryValue().utf8ToString());
    }
    cd.setHashtags(hashtags);
}
#end_block

#method_before
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = BlockedKeywordValidator.performValidation(repo, c, getPatterns().values(), EMPTY_PLUGIN_CONFIG, new ContentTypeUtil(TestUtils.getPatternCache()));
    Set<String> expected = ImmutableSet.of("ERROR: blocked keyword(s) found in file: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)", "ERROR: blocked keyword(s) found in file: bar.txt (Line: 5)" + " (found: $Id: foo bar$)");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    BlockedKeywordValidator validator = new BlockedKeywordValidator(null, new ContentTypeUtil(PATTERN_CACHE), PATTERN_CACHE, null, null);
    List<CommitValidationMessage> m = validator.performValidation(repo, c, getPatterns().values(), EMPTY_PLUGIN_CONFIG);
    Set<String> expected = ImmutableSet.of("ERROR: blocked keyword(s) found in file: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)", "ERROR: blocked keyword(s) found in file: bar.txt (Line: 5)" + " (found: $Id: foo bar$)");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays.asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)));
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, blockedKeywordPatterns.values(), cfg, contentTypeUtil);
            if (!messages.isEmpty()) {
                throw new CommitValidationException("includes files containing blocked keywords", messages);
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on blocked keywords", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays.asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)));
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, blockedKeywordPatterns.values(), cfg);
            if (!messages.isEmpty()) {
                throw new CommitValidationException("includes files containing blocked keywords", messages);
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on blocked keywords", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
static List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, ImmutableCollection<Pattern> blockedKeywordPartterns, PluginConfig cfg, ContentTypeUtil contentTypeUtil) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        if (contentTypeUtil.isBinary(ol, path, cfg)) {
            continue;
        }
        checkFileForBlockedKeywords(blockedKeywordPartterns, messages, path, ol);
    }
    return messages;
}
#method_after
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, ImmutableCollection<Pattern> blockedKeywordPartterns, PluginConfig cfg) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        if (contentTypeUtil.isBinary(ol, path, cfg)) {
            continue;
        }
        checkFileForBlockedKeywords(blockedKeywordPartterns, messages, path, ol);
    }
    return messages;
}
#end_block

#method_before
static String[] getBinaryTypes(PluginConfig cfg) {
    return cfg.getStringList(KEY_BINARY_TYPES);
}
#method_after
@VisibleForTesting
static String[] getBinaryTypes(PluginConfig cfg) {
    return cfg.getStringList(KEY_BINARY_TYPES);
}
#end_block

#method_before
public boolean isBinary(ObjectLoader ol, String pathname, PluginConfig cfg) throws IOException, ExecutionException {
    try (InputStream is = ol.openStream()) {
        return doesTypeMatch(getContentType(is, pathname), getBinaryTypes(cfg));
    }
}
#method_after
public boolean isBinary(ObjectLoader ol, String pathname, PluginConfig cfg) throws IOException, ExecutionException {
    try (InputStream is = ol.openStream()) {
        return matchesAny(getContentType(is, pathname), getBinaryTypes(cfg));
    }
}
#end_block

#method_before
@Test
public void testCarriageReturn() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, EMPTY_PLUGIN_CONFIG, new ContentTypeUtil(TestUtils.getPatternCache()));
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(ImmutableSet.of("ERROR: found carriage return (CR) character in file: foo.txt"));
}
#method_after
@Test
public void testCarriageReturn() throws Exception {
    RevCommit c = makeCommit();
    InvalidLineEndingValidator validator = new InvalidLineEndingValidator(null, new ContentTypeUtil(PATTERN_CACHE), null, null);
    List<CommitValidationMessage> m = validator.performValidation(repo, c, EMPTY_PLUGIN_CONFIG);
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(ImmutableSet.of("ERROR: found carriage return (CR) character in file: foo.txt"));
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, cfg, contentTypeUtil);
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains files with a Windows line ending", messages);
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on Windows line endings", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, cfg);
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains files with a Windows line ending", messages);
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on Windows line endings", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
static List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, PluginConfig cfg, ContentTypeUtil contentTypeUtil) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        if (contentTypeUtil.isBinary(ol, path, cfg)) {
            continue;
        }
        try (InputStreamReader isr = new InputStreamReader(ol.openStream(), StandardCharsets.UTF_8)) {
            if (doesInputStreanContainCR(isr)) {
                messages.add(new CommitValidationMessage("found carriage return (CR) character in file: " + path, true));
            }
        }
    }
    return messages;
}
#method_after
@VisibleForTesting
List<CommitValidationMessage> performValidation(Repository repo, RevCommit c, PluginConfig cfg) throws IOException, ExecutionException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c);
    for (String path : content.keySet()) {
        ObjectLoader ol = repo.open(content.get(path));
        if (contentTypeUtil.isBinary(ol, path, cfg)) {
            continue;
        }
        try (InputStreamReader isr = new InputStreamReader(ol.openStream(), StandardCharsets.UTF_8)) {
            if (doesInputStreanContainCR(isr)) {
                messages.add(new CommitValidationMessage("found carriage return (CR) character in file: " + path, true));
            }
        }
    }
    return messages;
}
#end_block

#method_before
@Override
protected void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    allChangeMessages = ImmutableList.of();
    changeMessagesByPatchSet = ImmutableListMultimap.of();
    comments = ImmutableListMultimap.of();
    hashtags = ImmutableSet.of();
    patchSets = ImmutableSortedMap.of();
}
#method_after
@Override
protected void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    allChangeMessages = ImmutableList.of();
    changeMessagesByPatchSet = ImmutableListMultimap.of();
    comments = ImmutableListMultimap.of();
    hashtags = ImmutableSet.of();
    patchSets = ImmutableSortedMap.of();
    allPastReviewers = ImmutableList.of();
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    Multimap<Account.Id, Change.Id> imports = ArrayListMultimap.create();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("SELECT " + "account_id, " + "change_id " + "FROM starred_changes")) {
        while (rs.next()) {
            Account.Id accountId = new Account.Id(rs.getInt(1));
            Change.Id changeId = new Change.Id(rs.getInt(2));
            imports.put(accountId, changeId);
        }
    }
    if (imports.isEmpty()) {
        return;
    }
    try (Repository git = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(git)) {
        BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
        ObjectId id = StarredChangesUtil.writeLabels(git, StarredChangesUtil.DEFAULT_LABELS);
        for (Map.Entry<Account.Id, Change.Id> e : imports.entries()) {
            bru.addCommand(new ReceiveCommand(ObjectId.zeroId(), id, RefNames.refsStarredChanges(e.getKey(), e.getValue())));
        }
        bru.execute(rw, NullProgressMonitor.INSTANCE);
    } catch (IOException ex) {
        throw new OrmException(ex);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    Multimap<Account.Id, Change.Id> imports = ArrayListMultimap.create();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("SELECT " + "account_id, " + "change_id " + "FROM starred_changes")) {
        while (rs.next()) {
            Account.Id accountId = new Account.Id(rs.getInt(1));
            Change.Id changeId = new Change.Id(rs.getInt(2));
            imports.put(accountId, changeId);
        }
    }
    if (imports.isEmpty()) {
        return;
    }
    try (Repository git = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(git)) {
        BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
        ObjectId id = StarredChangesUtil.writeLabels(git, StarredChangesUtil.DEFAULT_LABELS);
        for (Map.Entry<Account.Id, Change.Id> e : imports.entries()) {
            bru.addCommand(new ReceiveCommand(ObjectId.zeroId(), id, RefNames.refsStarredChanges(e.getValue(), e.getKey())));
        }
        bru.execute(rw, new TextProgressMonitor());
    } catch (IOException ex) {
        throw new OrmException(ex);
    }
}
#end_block

#method_before
public void star(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(accountId, changeId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        labels.add(DEFAULT_LABEL);
        updateLabels(repo, refName, oldObjectId, labels);
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public void star(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        labels.add(DEFAULT_LABEL);
        updateLabels(repo, refName, oldObjectId, labels);
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public void unstar(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(RefNames.refsStarredChanges(accountId, changeId));
        u.setForceUpdate(true);
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Unstar change " + changeId.get(), true);
        RefUpdate.Result result = u.delete();
        switch(result) {
            case FORCED:
                indexer.index(dbProvider.get(), project, changeId);
                return;
            case FAST_FORWARD:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Unstar change %d for account %d failed: %s", changeId.get(), accountId.get(), result.name()));
        }
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public void unstar(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(RefNames.refsStarredChanges(changeId, accountId));
        u.setForceUpdate(true);
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Unstar change " + changeId.get(), true);
        RefUpdate.Result result = u.delete();
        switch(result) {
            case FORCED:
                indexer.index(dbProvider.get(), project, changeId);
                return;
            case FAST_FORWARD:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Unstar change %d for account %d failed: %s", changeId.get(), accountId.get(), result.name()));
        }
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public void unstarAll(Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate batchUpdate = repo.getRefDatabase().newBatchUpdate();
        batchUpdate.setAllowNonFastForwards(true);
        batchUpdate.setRefLogIdent(serverIdent);
        batchUpdate.setRefLogMessage("Unstar change " + changeId.get(), true);
        for (Account.Id accountId : byChangeFromIndex(changeId)) {
            String refName = RefNames.refsStarredChanges(accountId, changeId);
            Ref ref = repo.getRefDatabase().getRef(refName);
            batchUpdate.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), refName));
        }
        batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Unstar change %d failed, ref %s could not be deleted: %s", changeId.get(), command.getRefName(), command.getResult()));
            }
        }
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d failed", changeId.get()), e);
    }
}
#method_after
public void unstarAll(Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate batchUpdate = repo.getRefDatabase().newBatchUpdate();
        batchUpdate.setAllowNonFastForwards(true);
        batchUpdate.setRefLogIdent(serverIdent);
        batchUpdate.setRefLogMessage("Unstar change " + changeId.get(), true);
        for (Account.Id accountId : byChangeFromIndex(changeId)) {
            String refName = RefNames.refsStarredChanges(changeId, accountId);
            Ref ref = repo.getRefDatabase().getRef(refName);
            batchUpdate.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), refName));
        }
        batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Unstar change %d failed, ref %s could not be deleted: %s", changeId.get(), command.getRefName(), command.getResult()));
            }
        }
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d failed", changeId.get()), e);
    }
}
#end_block

#method_before
public Iterable<Account.Id> byChange(final Change.Id changeId) throws OrmException {
    return FluentIterable.from(getRefNames(RefNames.REFS_STARRED_CHANGES)).filter(new Predicate<String>() {

        @Override
        public boolean apply(String refPart) {
            return refPart.endsWith("/" + changeId.get());
        }
    }).transform(new Function<String, Account.Id>() {

        @Override
        public Account.Id apply(String refPart) {
            return Account.Id.fromRefPart(refPart);
        }
    });
}
#method_after
public Set<Account.Id> byChange(Change.Id changeId) throws OrmException {
    return FluentIterable.from(getRefNames(RefNames.refsStarredChangesPrefix(changeId))).transform(new Function<String, Account.Id>() {

        @Override
        public Account.Id apply(String refPart) {
            return Account.Id.parse(refPart);
        }
    }).toSet();
}
#end_block

#method_before
public Iterable<Account.Id> byChangeFromIndex(Change.Id changeId) throws OrmException, NoSuchChangeException {
    Set<String> fields = ImmutableSet.of(ChangeField.ID.getName(), ChangeField.STARREDBY.getName());
    List<ChangeData> changeData = queryProvider.get().setRequestedFields(fields).byLegacyChangeId(changeId);
    if (changeData.size() != 1) {
        throw new NoSuchChangeException(changeId);
    }
    return changeData.get(0).starredBy();
}
#method_after
public Set<Account.Id> byChangeFromIndex(Change.Id changeId) throws OrmException, NoSuchChangeException {
    Set<String> fields = ImmutableSet.of(ChangeField.ID.getName(), ChangeField.STARREDBY.getName());
    List<ChangeData> changeData = queryProvider.get().setRequestedFields(fields).byLegacyChangeId(changeId);
    if (changeData.size() != 1) {
        throw new NoSuchChangeException(changeId);
    }
    return changeData.get(0).starredBy();
}
#end_block

#method_before
private static TreeSet<String> readLabels(Repository repo, ObjectId id) throws IOException {
    if (ObjectId.zeroId().equals(id)) {
        return new TreeSet<>();
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(id, Constants.OBJ_BLOB);
        TreeSet<String> labels = new TreeSet<>();
        Collections.addAll(labels, new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8).split("\n"));
        return labels;
    }
}
#method_after
private static TreeSet<String> readLabels(Repository repo, ObjectId id) throws IOException {
    if (ObjectId.zeroId().equals(id)) {
        return new TreeSet<>();
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(id, Constants.OBJ_BLOB);
        TreeSet<String> labels = new TreeSet<>();
        Iterables.addAll(labels, Splitter.on(CharMatcher.whitespace()).omitEmptyStrings().split(new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8)));
        return labels;
    }
}
#end_block

#method_before
public static ObjectId writeLabels(Repository repo, SortedSet<String> labels) throws IOException {
    try (ObjectInserter oi = repo.newObjectInserter()) {
        ObjectId id = oi.insert(Constants.OBJ_BLOB, Joiner.on("\n").join(labels).getBytes(UTF_8));
        oi.flush();
        return id;
    }
}
#method_after
public static ObjectId writeLabels(Repository repo, SortedSet<String> labels) throws IOException {
    SortedSet<String> invalidLabels = validateLabels(labels);
    if (!invalidLabels.isEmpty()) {
        throw new IllegalArgumentException(String.format("Invalid star labels: %s", Joiner.on(", ").join(labels)));
    }
    try (ObjectInserter oi = repo.newObjectInserter()) {
        ObjectId id = oi.insert(Constants.OBJ_BLOB, Joiner.on("\n").join(labels).getBytes(UTF_8));
        oi.flush();
        return id;
    }
}
#end_block

#method_before
private void updateLabels(Repository repo, String refName, ObjectId oldObjectId, SortedSet<String> labels) throws IOException, OrmException {
    try (RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(refName);
        u.setExpectedOldObjectId(oldObjectId);
        u.setForceUpdate(true);
        u.setNewObjectId(writeLabels(repo, labels));
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Update star labels", true);
        RefUpdate.Result result = u.update(rw);
        switch(result) {
            case NEW:
            case FORCED:
            case NO_CHANGE:
            case FAST_FORWARD:
                return;
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Update star labels on ref %s failed: %s", refName, result.name()));
        }
    }
}
#method_after
private void updateLabels(Repository repo, String refName, ObjectId oldObjectId, SortedSet<String> labels) throws IOException, OrmException {
    try (RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(refName);
        u.setExpectedOldObjectId(oldObjectId);
        u.setForceUpdate(true);
        u.setNewObjectId(writeLabels(repo, labels));
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Update star labels", true);
        RefUpdate.Result result = u.update(rw);
        switch(result) {
            case NEW:
            case FORCED:
            case NO_CHANGE:
            case FAST_FORWARD:
                return;
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
                throw new OrmException(String.format("Update star labels on ref %s failed: %s", refName, result.name()));
        }
    }
}
#end_block

#method_before
private final void deleteChanges(List<ChangeData> changeData) throws OrmException {
    for (ChangeData cd : changeData) {
        Change.Id id = cd.getId();
        ResultSet<PatchSet> patchSets = null;
        patchSets = db.patchSets().byChange(id);
        if (patchSets != null) {
            deleteFromPatchSets(patchSets);
        }
        // In the future, use schemaVersion to decide what to delete.
        db.patchComments().delete(db.patchComments().byChange(id));
        db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id));
        db.changeMessages().delete(db.changeMessages().byChange(id));
        db.changes().delete(Collections.singleton(cd.change()));
    }
}
#method_after
private final void deleteChanges(List<ChangeData> changeData) throws OrmException {
    for (ChangeData cd : changeData) {
        Change.Id id = cd.getId();
        ResultSet<PatchSet> patchSets = null;
        patchSets = db.patchSets().byChange(id);
        if (patchSets != null) {
            deleteFromPatchSets(patchSets);
        }
        // In the future, use schemaVersion to decide what to delete.
        db.patchComments().delete(db.patchComments().byChange(id));
        db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id));
        try {
            starredChangesUtil.unstarAll(cd.project(), id);
        } catch (NoSuchChangeException e) {
        // we can ignore the exception during delete
        }
        db.changeMessages().delete(db.changeMessages().byChange(id));
        db.changes().delete(Collections.singleton(cd.change()));
    }
}
#end_block

#method_before
@Override
public String generate() {
    String message;
    message = "";
    try {
        String template;
        template = ResourceHelper.loadNamedResourceAsString("basic-message-template.json");
        StringBuilder text;
        text = new StringBuilder();
        text.append(escape(event.author.name));
        text.append(" comments: ");
        text.append(escape(event.comment));
        text.append("\\n>>>");
        text.append(escape(event.change.project));
        text.append(" (");
        text.append(escape(event.change.branch));
        text.append("): ");
        text.append(escape(event.change.commitMessage.split("\n")[0]));
        text.append(" (");
        text.append(escape(event.change.url));
        text.append(")");
        message = String.format(template, text, config.getChannel(), config.getUsername());
    } catch (Exception e) {
        LOGGER.error("Error generating message: " + e.getMessage());
    }
    return message;
}
#method_after
@Override
public String generate() {
    String message;
    message = "";
    try {
        String template;
        template = ResourceHelper.loadNamedResourceAsString("basic-message-template.json");
        StringBuilder text;
        text = new StringBuilder();
        text.append(escape(event.author.name));
        text.append(" commented\\n>>>");
        text.append(escape(event.change.project));
        text.append(" (");
        text.append(escape(event.change.branch));
        text.append("): ");
        text.append(escape(Ascii.truncate(event.comment, 200, "...")));
        text.append(" (");
        text.append(escape(event.change.url));
        text.append(")");
        message = String.format(template, text, config.getChannel(), config.getUsername());
    } catch (Exception e) {
        LOGGER.error("Error generating message: " + e.getMessage(), e);
    }
    return message;
}
#end_block

#method_before
@Override
public String generate() {
    String message;
    message = "";
    try {
        String template;
        template = ResourceHelper.loadNamedResourceAsString("basic-message-template.json");
        StringBuilder text;
        text = new StringBuilder();
        text.append(escape(event.submitter.name));
        text.append(" merged\\n>>>");
        text.append(escape(event.change.project));
        text.append(" (");
        text.append(escape(event.change.branch));
        text.append("): ");
        text.append(escape(event.change.commitMessage.split("\n")[0]));
        text.append(" (");
        text.append(escape(event.change.url));
        text.append(")");
        message = String.format(template, text, config.getChannel(), config.getUsername());
    } catch (Exception e) {
        LOGGER.error("Error generating message: " + e.getMessage());
    }
    return message;
}
#method_after
@Override
public String generate() {
    String message;
    message = "";
    try {
        String template;
        template = ResourceHelper.loadNamedResourceAsString("basic-message-template.json");
        StringBuilder text;
        text = new StringBuilder();
        text.append(escape(event.submitter.name));
        text.append(" merged\\n>>>");
        text.append(escape(event.change.project));
        text.append(" (");
        text.append(escape(event.change.branch));
        text.append("): ");
        text.append(escape(event.change.commitMessage.split("\n")[0]));
        text.append(" (");
        text.append(escape(event.change.url));
        text.append(")");
        message = String.format(template, text, config.getChannel(), config.getUsername());
    } catch (Exception e) {
        LOGGER.error("Error generating message: " + e.getMessage(), e);
    }
    return message;
}
#end_block

#method_before
@Override
public String generate() {
    String message;
    message = "";
    try {
        String template;
        template = ResourceHelper.loadNamedResourceAsString("basic-message-template.json");
        StringBuilder text;
        text = new StringBuilder();
        text.append(escape(event.uploader.name));
        text.append(" proposed\\n>>>");
        text.append(escape(event.change.project));
        text.append(" (");
        text.append(escape(event.change.branch));
        text.append("): ");
        text.append(escape(event.change.commitMessage.split("\n")[0]));
        text.append(" (");
        text.append(escape(event.change.url));
        text.append(")");
        message = String.format(template, text, config.getChannel(), config.getUsername());
    } catch (Exception e) {
        LOGGER.error("Error generating message: " + e.getMessage());
    }
    return message;
}
#method_after
@Override
public String generate() {
    String message;
    message = "";
    try {
        String template;
        template = ResourceHelper.loadNamedResourceAsString("basic-message-template.json");
        StringBuilder text;
        text = new StringBuilder();
        text.append(escape(event.uploader.name));
        text.append(" proposed\\n>>>");
        text.append(escape(event.change.project));
        text.append(" (");
        text.append(escape(event.change.branch));
        text.append("): ");
        text.append(escape(event.change.commitMessage.split("\n")[0]));
        text.append(" (");
        text.append(escape(event.change.url));
        text.append(")");
        message = String.format(template, text, config.getChannel(), config.getUsername());
    } catch (Exception e) {
        LOGGER.error("Error generating message: " + e.getMessage(), e);
    }
    return message;
}
#end_block

#method_before
public Iterable<Account.Id> byChange(Change.Id changeId) throws OrmException {
    if (!migration.readAccounts()) {
        return FluentIterable.from(dbProvider.get().starredChanges().byChange(changeId)).transform(new Function<StarredChange, Account.Id>() {

            @Override
            public Account.Id apply(StarredChange in) {
                return in.getAccountId();
            }
        });
    }
    return FluentIterable.from(getRefNames(RefNames.refsStarredChangesPrefix(changeId))).transform(new Function<String, Account.Id>() {

        @Override
        public Account.Id apply(String refPart) {
            return Account.Id.fromRefPart(refPart);
        }
    });
}
#method_after
public Iterable<Account.Id> byChange(Change.Id changeId) throws OrmException {
    if (!migration.readAccounts()) {
        return FluentIterable.from(dbProvider.get().starredChanges().byChange(changeId)).transform(new Function<StarredChange, Account.Id>() {

            @Override
            public Account.Id apply(StarredChange in) {
                return in.getAccountId();
            }
        });
    }
    return FluentIterable.from(getRefNames(RefNames.refsStarredChangesPrefix(changeId))).transform(new Function<String, Account.Id>() {

        @Override
        public Account.Id apply(String refPart) {
            return Account.Id.parse(refPart);
        }
    });
}
#end_block

#method_before
public ResultSet<Change.Id> query(final Account.Id accountId) {
    try {
        if (!migration.readAccounts()) {
            return new ChangeIdResultSet(dbProvider.get().starredChanges().byAccount(accountId));
        }
        return new ListResultSet<>(FluentIterable.from(getRefNames(RefNames.REFS_STARRED_CHANGES)).filter(new Predicate<String>() {

            @Override
            public boolean apply(String refPart) {
                return refPart.endsWith("/" + accountId.get());
            }
        }).transform(new Function<String, Change.Id>() {

            @Override
            public Change.Id apply(String changeId) {
                return Change.Id.parse(changeId);
            }
        }).toList());
    } catch (OrmException | RuntimeException e) {
        log.warn(String.format("Cannot query starred changes for account %d", accountId.get()), e);
        List<Change.Id> empty = Collections.emptyList();
        return new ListResultSet<>(empty);
    }
}
#method_after
@Deprecated
public ResultSet<Change.Id> query(final Account.Id accountId) {
    try {
        if (!migration.readAccounts()) {
            return new ChangeIdResultSet(dbProvider.get().starredChanges().byAccount(accountId));
        }
        return new ListResultSet<>(FluentIterable.from(getRefNames(RefNames.REFS_STARRED_CHANGES)).filter(new Predicate<String>() {

            @Override
            public boolean apply(String refPart) {
                return refPart.endsWith("/" + accountId.get());
            }
        }).transform(new Function<String, Change.Id>() {

            @Override
            public Change.Id apply(String changeId) {
                return Change.Id.parse(changeId);
            }
        }).toList());
    } catch (OrmException | RuntimeException e) {
        log.warn(String.format("Cannot query starred changes for account %d", accountId.get()), e);
        List<Change.Id> empty = Collections.emptyList();
        return new ListResultSet<>(empty);
    }
}
#end_block

#method_before
public void star(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException {
    dbProvider.get().starredChanges().insert(Collections.singleton(new StarredChange(new StarredChange.Key(accountId, changeId))));
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(accountId, changeId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        labels.add(DEFAULT_LABEL);
        updateLabels(repo, refName, oldObjectId, labels);
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public void star(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException {
    dbProvider.get().starredChanges().insert(Collections.singleton(new StarredChange(new StarredChange.Key(accountId, changeId))));
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        labels.add(DEFAULT_LABEL);
        updateLabels(repo, refName, oldObjectId, labels);
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public void unstar(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException {
    dbProvider.get().starredChanges().delete(Collections.singleton(new StarredChange(new StarredChange.Key(accountId, changeId))));
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(RefNames.refsStarredChanges(accountId, changeId));
        u.setForceUpdate(true);
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Unstar change " + changeId.get(), true);
        RefUpdate.Result result = u.delete();
        switch(result) {
            case FORCED:
                indexer.index(dbProvider.get(), project, changeId);
                return;
            case FAST_FORWARD:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Unstar change %d for account %d failed: %s", changeId.get(), accountId.get(), result.name()));
        }
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public void unstar(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException {
    dbProvider.get().starredChanges().delete(Collections.singleton(new StarredChange(new StarredChange.Key(accountId, changeId))));
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(RefNames.refsStarredChanges(changeId, accountId));
        u.setForceUpdate(true);
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Unstar change " + changeId.get(), true);
        RefUpdate.Result result = u.delete();
        switch(result) {
            case FORCED:
                indexer.index(dbProvider.get(), project, changeId);
                return;
            case FAST_FORWARD:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Unstar change %d for account %d failed: %s", changeId.get(), accountId.get(), result.name()));
        }
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public void unstarAll(Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    dbProvider.get().starredChanges().delete(dbProvider.get().starredChanges().byChange(changeId));
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate batchUpdate = repo.getRefDatabase().newBatchUpdate();
        batchUpdate.setAllowNonFastForwards(true);
        batchUpdate.setRefLogIdent(serverIdent);
        batchUpdate.setRefLogMessage("Unstar change " + changeId.get(), true);
        for (Account.Id accountId : byChangeFromIndex(changeId)) {
            String refName = RefNames.refsStarredChanges(accountId, changeId);
            Ref ref = repo.getRefDatabase().getRef(refName);
            batchUpdate.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), refName));
        }
        batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Unstar change %d failed, ref %s could not be deleted: %s", changeId.get(), command.getRefName(), command.getResult()));
            }
        }
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d failed", changeId.get()), e);
    }
}
#method_after
public void unstarAll(Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    dbProvider.get().starredChanges().delete(dbProvider.get().starredChanges().byChange(changeId));
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate batchUpdate = repo.getRefDatabase().newBatchUpdate();
        batchUpdate.setAllowNonFastForwards(true);
        batchUpdate.setRefLogIdent(serverIdent);
        batchUpdate.setRefLogMessage("Unstar change " + changeId.get(), true);
        for (Account.Id accountId : byChangeFromIndex(changeId)) {
            String refName = RefNames.refsStarredChanges(changeId, accountId);
            Ref ref = repo.getRefDatabase().getRef(refName);
            batchUpdate.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), refName));
        }
        batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Unstar change %d failed, ref %s could not be deleted: %s", changeId.get(), command.getRefName(), command.getResult()));
            }
        }
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d failed", changeId.get()), e);
    }
}
#end_block

#method_before
public Iterable<Account.Id> byChange(final Change.Id changeId) throws OrmException {
    if (!readFromGit) {
        return FluentIterable.from(dbProvider.get().starredChanges().byChange(changeId)).transform(new Function<StarredChange, Account.Id>() {

            @Override
            public Account.Id apply(StarredChange in) {
                return in.getAccountId();
            }
        });
    }
    return FluentIterable.from(getRefNames(RefNames.REFS_STARRED_CHANGES)).filter(new Predicate<String>() {

        @Override
        public boolean apply(String refPart) {
            return refPart.endsWith("/" + changeId.get());
        }
    }).transform(new Function<String, Account.Id>() {

        @Override
        public Account.Id apply(String refPart) {
            return Account.Id.fromRefPart(refPart);
        }
    });
}
#method_after
public Set<Account.Id> byChange(Change.Id changeId) throws OrmException {
    if (!readFromGit) {
        return FluentIterable.from(dbProvider.get().starredChanges().byChange(changeId)).transform(new Function<StarredChange, Account.Id>() {

            @Override
            public Account.Id apply(StarredChange in) {
                return in.getAccountId();
            }
        }).toSet();
    }
    return FluentIterable.from(getRefNames(RefNames.refsStarredChangesPrefix(changeId))).transform(new Function<String, Account.Id>() {

        @Override
        public Account.Id apply(String refPart) {
            return Account.Id.parse(refPart);
        }
    }).toSet();
}
#end_block

#method_before
public Iterable<Account.Id> byChangeFromIndex(Change.Id changeId) throws OrmException, NoSuchChangeException {
    Set<String> fields = ImmutableSet.of(ChangeField.ID.getName(), ChangeField.STARREDBY.getName());
    List<ChangeData> changeData = queryProvider.get().setRequestedFields(fields).byLegacyChangeId(changeId);
    if (changeData.size() != 1) {
        throw new NoSuchChangeException(changeId);
    }
    return changeData.get(0).starredBy();
}
#method_after
public Set<Account.Id> byChangeFromIndex(Change.Id changeId) throws OrmException, NoSuchChangeException {
    Set<String> fields = ImmutableSet.of(ChangeField.ID.getName(), ChangeField.STARREDBY.getName());
    List<ChangeData> changeData = queryProvider.get().setRequestedFields(fields).byLegacyChangeId(changeId);
    if (changeData.size() != 1) {
        throw new NoSuchChangeException(changeId);
    }
    return changeData.get(0).starredBy();
}
#end_block

#method_before
private static TreeSet<String> readLabels(Repository repo, ObjectId id) throws IOException {
    if (ObjectId.zeroId().equals(id)) {
        return new TreeSet<>();
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(id, Constants.OBJ_BLOB);
        TreeSet<String> labels = new TreeSet<>();
        Collections.addAll(labels, new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8).split("\n"));
        return labels;
    }
}
#method_after
private static TreeSet<String> readLabels(Repository repo, ObjectId id) throws IOException {
    if (ObjectId.zeroId().equals(id)) {
        return new TreeSet<>();
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(id, Constants.OBJ_BLOB);
        TreeSet<String> labels = new TreeSet<>();
        Iterables.addAll(labels, Splitter.on(CharMatcher.whitespace()).omitEmptyStrings().split(new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8)));
        return labels;
    }
}
#end_block

#method_before
public static ObjectId writeLabels(Repository repo, SortedSet<String> labels) throws IOException {
    try (ObjectInserter oi = repo.newObjectInserter()) {
        ObjectId id = oi.insert(Constants.OBJ_BLOB, Joiner.on("\n").join(labels).getBytes(UTF_8));
        oi.flush();
        return id;
    }
}
#method_after
public static ObjectId writeLabels(Repository repo, SortedSet<String> labels) throws IOException {
    SortedSet<String> invalidLabels = validateLabels(labels);
    if (!invalidLabels.isEmpty()) {
        throw new IllegalArgumentException(String.format("Invalid star labels: %s", Joiner.on(", ").join(labels)));
    }
    try (ObjectInserter oi = repo.newObjectInserter()) {
        ObjectId id = oi.insert(Constants.OBJ_BLOB, Joiner.on("\n").join(labels).getBytes(UTF_8));
        oi.flush();
        return id;
    }
}
#end_block

#method_before
private void updateLabels(Repository repo, String refName, ObjectId oldObjectId, SortedSet<String> labels) throws IOException, OrmException {
    try (RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(refName);
        u.setExpectedOldObjectId(oldObjectId);
        u.setForceUpdate(true);
        u.setNewObjectId(writeLabels(repo, labels));
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Update star labels", true);
        RefUpdate.Result result = u.update(rw);
        switch(result) {
            case NEW:
            case FORCED:
            case NO_CHANGE:
            case FAST_FORWARD:
                return;
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Update star labels on ref %s failed: %s", refName, result.name()));
        }
    }
}
#method_after
private void updateLabels(Repository repo, String refName, ObjectId oldObjectId, SortedSet<String> labels) throws IOException, OrmException {
    try (RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(refName);
        u.setExpectedOldObjectId(oldObjectId);
        u.setForceUpdate(true);
        u.setNewObjectId(writeLabels(repo, labels));
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Update star labels", true);
        RefUpdate.Result result = u.update(rw);
        switch(result) {
            case NEW:
            case FORCED:
            case NO_CHANGE:
            case FAST_FORWARD:
                return;
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
                throw new OrmException(String.format("Update star labels on ref %s failed: %s", refName, result.name()));
        }
    }
}
#end_block

#method_before
public void star(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException, IOException {
    dbProvider.get().starredChanges().insert(Collections.singleton(new StarredChange(new StarredChange.Key(accountId, changeId))));
    if (!migration.writeAccounts()) {
        indexer.index(dbProvider.get(), project, changeId);
        return;
    }
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(accountId, changeId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        labels.add(DEFAULT_LABEL);
        updateLabels(repo, refName, oldObjectId, labels);
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public void star(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException, IOException {
    dbProvider.get().starredChanges().insert(Collections.singleton(new StarredChange(new StarredChange.Key(accountId, changeId))));
    if (!migration.writeAccounts()) {
        indexer.index(dbProvider.get(), project, changeId);
        return;
    }
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        labels.add(DEFAULT_LABEL);
        updateLabels(repo, refName, oldObjectId, labels);
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public void unstar(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException, IOException {
    dbProvider.get().starredChanges().delete(Collections.singleton(new StarredChange(new StarredChange.Key(accountId, changeId))));
    if (!migration.writeAccounts()) {
        indexer.index(dbProvider.get(), project, changeId);
        return;
    }
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(RefNames.refsStarredChanges(accountId, changeId));
        u.setForceUpdate(true);
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Unstar change " + changeId.get(), true);
        RefUpdate.Result result = u.delete();
        switch(result) {
            case FORCED:
                indexer.index(dbProvider.get(), project, changeId);
                return;
            case FAST_FORWARD:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Unstar change %d for account %d failed: %s", changeId.get(), accountId.get(), result.name()));
        }
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public void unstar(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException, IOException {
    dbProvider.get().starredChanges().delete(Collections.singleton(new StarredChange(new StarredChange.Key(accountId, changeId))));
    if (!migration.writeAccounts()) {
        indexer.index(dbProvider.get(), project, changeId);
        return;
    }
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(RefNames.refsStarredChanges(changeId, accountId));
        u.setForceUpdate(true);
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Unstar change " + changeId.get(), true);
        RefUpdate.Result result = u.delete();
        switch(result) {
            case FORCED:
                indexer.index(dbProvider.get(), project, changeId);
                return;
            case FAST_FORWARD:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Unstar change %d for account %d failed: %s", changeId.get(), accountId.get(), result.name()));
        }
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public void unstarAll(Project.NameKey project, Change.Id changeId) throws OrmException, IOException, NoSuchChangeException {
    dbProvider.get().starredChanges().delete(dbProvider.get().starredChanges().byChange(changeId));
    if (!migration.writeAccounts()) {
        indexer.index(dbProvider.get(), project, changeId);
        return;
    }
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate batchUpdate = repo.getRefDatabase().newBatchUpdate();
        batchUpdate.setAllowNonFastForwards(true);
        batchUpdate.setRefLogIdent(serverIdent);
        batchUpdate.setRefLogMessage("Unstar change " + changeId.get(), true);
        for (Account.Id accountId : byChangeFromIndex(changeId)) {
            String refName = RefNames.refsStarredChanges(accountId, changeId);
            Ref ref = repo.getRefDatabase().getRef(refName);
            batchUpdate.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), refName));
        }
        batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Unstar change %d failed, ref %s could not be deleted: %s", changeId.get(), command.getRefName(), command.getResult()));
            }
        }
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d failed", changeId.get()), e);
    }
}
#method_after
public void unstarAll(Project.NameKey project, Change.Id changeId) throws OrmException, IOException, NoSuchChangeException {
    dbProvider.get().starredChanges().delete(dbProvider.get().starredChanges().byChange(changeId));
    if (!migration.writeAccounts()) {
        indexer.index(dbProvider.get(), project, changeId);
        return;
    }
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate batchUpdate = repo.getRefDatabase().newBatchUpdate();
        batchUpdate.setAllowNonFastForwards(true);
        batchUpdate.setRefLogIdent(serverIdent);
        batchUpdate.setRefLogMessage("Unstar change " + changeId.get(), true);
        for (Account.Id accountId : byChangeFromIndex(changeId)) {
            String refName = RefNames.refsStarredChanges(changeId, accountId);
            Ref ref = repo.getRefDatabase().getRef(refName);
            batchUpdate.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), refName));
        }
        batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Unstar change %d failed, ref %s could not be deleted: %s", changeId.get(), command.getRefName(), command.getResult()));
            }
        }
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d failed", changeId.get()), e);
    }
}
#end_block

#method_before
public Iterable<Account.Id> byChange(final Change.Id changeId) throws OrmException {
    if (!migration.readAccounts()) {
        return FluentIterable.from(dbProvider.get().starredChanges().byChange(changeId)).transform(new Function<StarredChange, Account.Id>() {

            @Override
            public Account.Id apply(StarredChange in) {
                return in.getAccountId();
            }
        });
    }
    return FluentIterable.from(getRefNames(RefNames.REFS_STARRED_CHANGES)).filter(new Predicate<String>() {

        @Override
        public boolean apply(String refPart) {
            return refPart.endsWith("/" + changeId.get());
        }
    }).transform(new Function<String, Account.Id>() {

        @Override
        public Account.Id apply(String refPart) {
            return Account.Id.fromRefPart(refPart);
        }
    });
}
#method_after
public Set<Account.Id> byChange(Change.Id changeId) throws OrmException {
    if (!migration.readAccounts()) {
        return FluentIterable.from(dbProvider.get().starredChanges().byChange(changeId)).transform(new Function<StarredChange, Account.Id>() {

            @Override
            public Account.Id apply(StarredChange in) {
                return in.getAccountId();
            }
        }).toSet();
    }
    return FluentIterable.from(getRefNames(RefNames.refsStarredChangesPrefix(changeId))).transform(new Function<String, Account.Id>() {

        @Override
        public Account.Id apply(String refPart) {
            return Account.Id.parse(refPart);
        }
    }).toSet();
}
#end_block

#method_before
public Iterable<Account.Id> byChangeFromIndex(Change.Id changeId) throws OrmException, NoSuchChangeException {
    Set<String> fields = ImmutableSet.of(ChangeField.ID.getName(), ChangeField.STARREDBY.getName());
    List<ChangeData> changeData = queryProvider.get().setRequestedFields(fields).byLegacyChangeId(changeId);
    if (changeData.size() != 1) {
        throw new NoSuchChangeException(changeId);
    }
    return changeData.get(0).starredBy();
}
#method_after
public Set<Account.Id> byChangeFromIndex(Change.Id changeId) throws OrmException, NoSuchChangeException {
    Set<String> fields = ImmutableSet.of(ChangeField.ID.getName(), ChangeField.STARREDBY.getName());
    List<ChangeData> changeData = queryProvider.get().setRequestedFields(fields).byLegacyChangeId(changeId);
    if (changeData.size() != 1) {
        throw new NoSuchChangeException(changeId);
    }
    return changeData.get(0).starredBy();
}
#end_block

#method_before
private static TreeSet<String> readLabels(Repository repo, ObjectId id) throws IOException {
    if (ObjectId.zeroId().equals(id)) {
        return new TreeSet<>();
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(id, Constants.OBJ_BLOB);
        TreeSet<String> labels = new TreeSet<>();
        Collections.addAll(labels, new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8).split("\n"));
        return labels;
    }
}
#method_after
private static TreeSet<String> readLabels(Repository repo, ObjectId id) throws IOException {
    if (ObjectId.zeroId().equals(id)) {
        return new TreeSet<>();
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(id, Constants.OBJ_BLOB);
        TreeSet<String> labels = new TreeSet<>();
        Iterables.addAll(labels, Splitter.on(CharMatcher.whitespace()).omitEmptyStrings().split(new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8)));
        return labels;
    }
}
#end_block

#method_before
public static ObjectId writeLabels(Repository repo, SortedSet<String> labels) throws IOException {
    try (ObjectInserter oi = repo.newObjectInserter()) {
        ObjectId id = oi.insert(Constants.OBJ_BLOB, Joiner.on("\n").join(labels).getBytes(UTF_8));
        oi.flush();
        return id;
    }
}
#method_after
public static ObjectId writeLabels(Repository repo, SortedSet<String> labels) throws IOException {
    SortedSet<String> invalidLabels = validateLabels(labels);
    if (!invalidLabels.isEmpty()) {
        throw new IllegalArgumentException(String.format("Invalid star labels: %s", Joiner.on(", ").join(labels)));
    }
    try (ObjectInserter oi = repo.newObjectInserter()) {
        ObjectId id = oi.insert(Constants.OBJ_BLOB, Joiner.on("\n").join(labels).getBytes(UTF_8));
        oi.flush();
        return id;
    }
}
#end_block

#method_before
private void updateLabels(Repository repo, String refName, ObjectId oldObjectId, SortedSet<String> labels) throws IOException, OrmException {
    try (RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(refName);
        u.setExpectedOldObjectId(oldObjectId);
        u.setForceUpdate(true);
        u.setNewObjectId(writeLabels(repo, labels));
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Update star labels", true);
        RefUpdate.Result result = u.update(rw);
        switch(result) {
            case NEW:
            case FORCED:
            case NO_CHANGE:
            case FAST_FORWARD:
                return;
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new OrmException(String.format("Update star labels on ref %s failed: %s", refName, result.name()));
        }
    }
}
#method_after
private void updateLabels(Repository repo, String refName, ObjectId oldObjectId, SortedSet<String> labels) throws IOException, OrmException {
    try (RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(refName);
        u.setExpectedOldObjectId(oldObjectId);
        u.setForceUpdate(true);
        u.setNewObjectId(writeLabels(repo, labels));
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Update star labels", true);
        RefUpdate.Result result = u.update(rw);
        switch(result) {
            case NEW:
            case FORCED:
            case NO_CHANGE:
            case FAST_FORWARD:
                return;
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
                throw new OrmException(String.format("Update star labels on ref %s failed: %s", refName, result.name()));
        }
    }
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN).length == 0) {
            return Collections.emptyList();
        }
        ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays.asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)));
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, blockedKeywordPatterns.values());
            if (!messages.isEmpty()) {
                throw new CommitValidationException("includes files containing blocked keywords", messages);
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on blocked keywords", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays.asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)));
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, blockedKeywordPatterns.values());
            if (!messages.isEmpty()) {
                throw new CommitValidationException("includes files containing blocked keywords", messages);
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on blocked keywords", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
protected void configure() {
    install(new PatternCache());
    install(BlockedKeywordValidator.module());
    install(FileExtensionValidator.module());
    install(FooterValidator.module());
    install(InvalidFilenameValidator.module());
    install(InvalidLineEndingValidator.module());
    install(MaxPathLengthValidator.module());
    install(SubmoduleValidator.module());
    install(SymlinkValidator.module());
}
#method_after
@Override
protected void configure() {
    install(new PatternCacheModule());
    install(BlockedKeywordValidator.module());
    install(FileExtensionValidator.module());
    install(FooterValidator.module());
    install(InvalidFilenameValidator.module());
    install(InvalidLineEndingValidator.module());
    install(MaxPathLengthValidator.module());
    install(SubmoduleValidator.module());
    install(SymlinkValidator.module());
}
#end_block

#method_before
private RevCommit makeCommit() throws NoFilepatternException, IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: bla bla bla$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit with test files.", files);
}
#method_after
private RevCommit makeCommit() throws NoFilepatternException, IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: foo bar$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit with test files.", files);
}
#end_block

#method_before
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = BlockedKeywordValidator.performValidation(repo, c, getPatterns().values());
    assertEquals(2, m.size());
    List<CommitValidationMessage> expected = new ArrayList<>();
    expected.add(new CommitValidationMessage("blocked keyword(s) found in file: " + "foo.txt (Line: 1) (found: myp4ssw0rd, foobar)", true));
    expected.add(new CommitValidationMessage("blocked keyword(s) found in file: " + "bar.txt (Line: 5) (found: $Id: bla bla bla$)", true));
    assertTrue(TestUtils.compareCommitValidationMessage(m, expected));
}
#method_after
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = BlockedKeywordValidator.performValidation(repo, c, getPatterns().values());
    Set<String> expected = ImmutableSet.of("ERROR: blocked keyword(s) found in file: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)", "ERROR: blocked keyword(s) found in file: bar.txt (Line: 5)" + " (found: $Id: foo bar$)");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(ctx.getWhen());
                setCommentRevId(e, patchListCache, ctx.getChange(), ps);
                ups.add(e);
            }
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    // TODO(dborowitz): Currently doesn't work for PUBLISH_ALL_REVISIONS with
    // notedb.
    plcUtil.deleteComments(ctx.getDb(), u, del);
    plcUtil.putComments(ctx.getDb(), u, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            e.setTag(in.tag);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                ups.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, ups);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    plcUtil.deleteComments(ctx.getDb(), u, del);
    plcUtil.putComments(ctx.getDb(), u, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getNotes(), user.getAccountId())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#method_after
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getNotes(), user.getAccountId())) {
        c.setTag(in.tag);
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#end_block

#method_before
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ups = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen());
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    if (!del.isEmpty() || !ups.isEmpty()) {
        if (ctx.getChange().getStatus().isClosed()) {
            throw new ResourceConflictException("change is closed");
        }
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ups = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    if ((!del.isEmpty() || !ups.isEmpty()) && ctx.getChange().getStatus().isClosed()) {
        throw new ResourceConflictException("change is closed");
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen());
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#method_after
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#end_block

#method_before
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#method_after
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setTag(in.tag);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#end_block

#method_before
private ApprovalAttribute getApprovalAttribute(String label) {
    ApprovalAttribute[] aa = lastCommentAddedEvent.approvals.get();
    ApprovalAttribute res = null;
    for (int i = 0; i < aa.length; i++) {
        if (aa[i].description.equals(label)) {
            res = aa[i];
        }
    }
    return res;
}
#method_after
private ApprovalAttribute getApprovalAttribute(LabelType label) {
    ApprovalAttribute[] aa = lastCommentAddedEvent.approvals.get();
    ApprovalAttribute res = null;
    for (int i = 0; i < aa.length; i++) {
        if (aa[i].description.equals(label.getName())) {
            res = aa[i];
        }
    }
    return res;
}
#end_block

#method_before
@Test
public void newChangeWithVote() throws Exception {
    saveLabelConfig();
    // push a new change with -1 vote
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().label(label.getName(), (short) -1);
    revision(r).review(reviewInput);
    ApprovalAttribute attr = getApprovalAttribute(label.getName());
    String newVote = attr.value;
    String oldVote = attr.oldValue;
    assertThat(oldVote).isEqualTo("0");
    assertThat(newVote).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1", label.getName()));
}
#method_after
@Test
public void newChangeWithVote() throws Exception {
    saveLabelConfig();
    // push a new change with -1 vote
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().label(label.getName(), (short) -1);
    revision(r).review(reviewInput);
    ApprovalAttribute attr = getApprovalAttribute(label);
    assertThat(attr.oldValue).isEqualTo("0");
    assertThat(attr.value).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1", label.getName()));
}
#end_block

#method_before
@Test
public void newPatchSetWithVote() throws Exception {
    saveLabelConfig();
    // push a new change
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    // push a new revision with +1 vote
    ChangeInfo c = get(r.getChangeId());
    r = amendChange(c.changeId);
    reviewInput = new ReviewInput().label(label.getName(), (short) 1);
    revision(r).review(reviewInput);
    ApprovalAttribute attr = getApprovalAttribute(label.getName());
    String newVote = attr.value;
    String oldVote = attr.oldValue;
    assertThat(oldVote).isEqualTo("0");
    assertThat(newVote).isEqualTo("1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 2: %s+1", label.getName()));
}
#method_after
@Test
public void newPatchSetWithVote() throws Exception {
    saveLabelConfig();
    // push a new change
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    // push a new revision with +1 vote
    ChangeInfo c = get(r.getChangeId());
    r = amendChange(c.changeId);
    reviewInput = new ReviewInput().label(label.getName(), (short) 1);
    revision(r).review(reviewInput);
    ApprovalAttribute attr = getApprovalAttribute(label);
    assertThat(attr.oldValue).isEqualTo("0");
    assertThat(attr.value).isEqualTo("1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 2: %s+1", label.getName()));
}
#end_block

#method_before
@Test
public void reviewChange() throws Exception {
    saveLabelConfig();
    // push a change
    PushOneCommit.Result r = createChange();
    // review with message only, do not apply votes
    ReviewInput reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    // reply message only so votes is shown as 0
    ApprovalAttribute attr = getApprovalAttribute(label.getName());
    String newVote = attr.value;
    String oldVote = attr.oldValue;
    assertThat(oldVote).isNull();
    assertThat(newVote).isEqualTo("0");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1:\n\n%s", label.getName()));
    // transition from un-voted to -1 vote
    reviewInput = new ReviewInput().label(label.getName(), -1);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label.getName());
    newVote = attr.value;
    oldVote = attr.oldValue;
    assertThat(oldVote).isEqualTo("0");
    assertThat(newVote).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1", label.getName()));
    // transition vote from -1 to 0
    reviewInput = new ReviewInput().label(label.getName(), 0);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label.getName());
    newVote = attr.value;
    oldVote = attr.oldValue;
    assertThat(oldVote).isEqualTo("-1");
    assertThat(newVote).isEqualTo("0");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: -%s", label.getName()));
    // transition vote from 0 to 1
    reviewInput = new ReviewInput().label(label.getName(), 1);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label.getName());
    newVote = attr.value;
    oldVote = attr.oldValue;
    assertThat(oldVote).isEqualTo("0");
    assertThat(newVote).isEqualTo("1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s+1", label.getName()));
    // transition vote from 1 to -1
    reviewInput = new ReviewInput().label(label.getName(), -1);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label.getName());
    newVote = attr.value;
    oldVote = attr.oldValue;
    assertThat(oldVote).isEqualTo("1");
    assertThat(newVote).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1", label.getName()));
    // review with message only, do not apply votes
    reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label.getName());
    newVote = attr.value;
    oldVote = attr.oldValue;
    // no vote change so not included
    assertThat(oldVote).isEqualTo(null);
    assertThat(newVote).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1:\n\n%s", label.getName()));
}
#method_after
@Test
public void reviewChange() throws Exception {
    saveLabelConfig();
    // push a change
    PushOneCommit.Result r = createChange();
    // review with message only, do not apply votes
    ReviewInput reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    // reply message only so vote is shown as 0
    ApprovalAttribute attr = getApprovalAttribute(label);
    assertThat(attr.oldValue).isNull();
    assertThat(attr.value).isEqualTo("0");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1:\n\n%s", label.getName()));
    // transition from un-voted to -1 vote
    reviewInput = new ReviewInput().label(label.getName(), -1);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label);
    assertThat(attr.oldValue).isEqualTo("0");
    assertThat(attr.value).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1", label.getName()));
    // transition vote from -1 to 0
    reviewInput = new ReviewInput().label(label.getName(), 0);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label);
    assertThat(attr.oldValue).isEqualTo("-1");
    assertThat(attr.value).isEqualTo("0");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: -%s", label.getName()));
    // transition vote from 0 to 1
    reviewInput = new ReviewInput().label(label.getName(), 1);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label);
    assertThat(attr.oldValue).isEqualTo("0");
    assertThat(attr.value).isEqualTo("1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s+1", label.getName()));
    // transition vote from 1 to -1
    reviewInput = new ReviewInput().label(label.getName(), -1);
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label);
    assertThat(attr.oldValue).isEqualTo("1");
    assertThat(attr.value).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1", label.getName()));
    // review with message only, do not apply votes
    reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    attr = getApprovalAttribute(label);
    // no vote change so not included
    assertThat(attr.oldValue).isEqualTo(null);
    assertThat(attr.value).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1:\n\n%s", label.getName()));
}
#end_block

#method_before
@Test
public void reviewChange_MultipleVotes() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().label(label.getName(), -1);
    reviewInput.message = label.getName();
    revision(r).review(reviewInput);
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1\n\n%s", label.getName(), label.getName()));
    reviewInput = new ReviewInput().label(pLabel.getName(), 1);
    reviewInput.message = pLabel.getName();
    revision(r).review(reviewInput);
    c = get(r.getChangeId());
    q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s+1\n\n%s", pLabel.getName(), pLabel.getName()));
    assertThat(lastCommentAddedEvent.approvals.get()).hasLength(3);
    for (ApprovalAttribute approval : lastCommentAddedEvent.approvals.get()) {
        if (approval.type.equals(label.getName())) {
            assertThat(approval.value).isEqualTo("-1");
            assertThat(approval.oldValue).isNull();
        } else if (approval.type.equals(pLabel.getName())) {
            assertThat(approval.value).isEqualTo("1");
            assertThat(approval.oldValue).isEqualTo("0");
        } else if (approval.type.equals("Code-Review")) {
            assertThat(approval.value).isEqualTo("0");
            assertThat(approval.oldValue).isNull();
        } else {
            fail("Unexpected label: " + approval.type);
        }
    }
}
#method_after
@Test
public void reviewChange_MultipleVotes() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().label(label.getName(), -1);
    reviewInput.message = label.getName();
    revision(r).review(reviewInput);
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    ApprovalAttribute labelAttr = getApprovalAttribute(label);
    assertThat(labelAttr.oldValue).isEqualTo("0");
    assertThat(labelAttr.value).isEqualTo("-1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s-1\n\n%s", label.getName(), label.getName()));
    // there should be 3 approval labels (label, pLabel, and CRVV)
    assertThat(lastCommentAddedEvent.approvals.get()).hasLength(3);
    // check the approvals that were not voted on
    ApprovalAttribute pLabelAttr = getApprovalAttribute(pLabel);
    assertThat(pLabelAttr.oldValue).isNull();
    assertThat(pLabelAttr.value).isEqualTo("0");
    LabelType crLabel = LabelType.withDefaultValues("Code-Review");
    ApprovalAttribute crlAttr = getApprovalAttribute(crLabel);
    assertThat(crlAttr.oldValue).isNull();
    assertThat(crlAttr.value).isEqualTo("0");
    // update pLabel approval
    reviewInput = new ReviewInput().label(pLabel.getName(), 1);
    reviewInput.message = pLabel.getName();
    revision(r).review(reviewInput);
    c = get(r.getChangeId());
    q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    pLabelAttr = getApprovalAttribute(pLabel);
    assertThat(pLabelAttr.oldValue).isEqualTo("0");
    assertThat(pLabelAttr.value).isEqualTo("1");
    assertThat(lastCommentAddedEvent.comment).isEqualTo(String.format("Patch Set 1: %s+1\n\n%s", pLabel.getName(), pLabel.getName()));
    // check the approvals that were not voted on
    labelAttr = getApprovalAttribute(label);
    assertThat(labelAttr.oldValue).isNull();
    assertThat(labelAttr.value).isEqualTo("-1");
    crlAttr = getApprovalAttribute(crLabel);
    assertThat(crlAttr.oldValue).isNull();
    assertThat(crlAttr.value).isEqualTo("0");
}
#end_block

#method_before
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "^.*(\\[|\\]|\\*|#).*$", "^.*(%|:|@).*$" };
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern);
    Set<String> expected = new HashSet<>();
    for (String filenames : getInvalidFilenames()) {
        expected.add("ERROR: invalid characters found in filename: " + filenames);
    }
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "\\[|\\]|\\*|#", "[%:@]" };
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern);
    Set<String> expected = new HashSet<>();
    for (String filenames : getInvalidFilenames()) {
        expected.add("ERROR: invalid characters found in filename: " + filenames);
    }
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Override
void render(DiffInfo diff) {
    super.render();
    LineMapper mapper = getLineMapper();
    chunks = new ArrayList<>();
    int cmLine = 0;
    boolean useIntralineBg = diff.metaA() == null || diff.metaB() == null;
    for (Region current : Natives.asList(diff.content())) {
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            int length = current.ab().length();
            mapper.appendCommon(length);
            for (int i = 0; i < length; i++) {
                host.setLineNumber(DisplaySide.A, cmLine + i, origLineA + i + 1);
                host.setLineNumber(DisplaySide.B, cmLine + i, origLineB + i + 1);
            }
            cmLine += length;
        } else if (current.skip() > 0) {
            mapper.appendCommon(current.skip());
            // Maybe current.ab().length();
            cmLine += current.skip();
        } else if (current.common()) {
            mapper.appendCommon(current.b().length());
            cmLine += current.b().length();
        } else {
            cmLine += render(current, cmLine, useIntralineBg);
        }
    }
    host.setLineNumber(DisplaySide.A, cmLine, mapper.getLineA() + 1);
    host.setLineNumber(DisplaySide.B, cmLine, mapper.getLineB() + 1);
}
#method_after
@Override
void render(DiffInfo diff) {
    super.render();
    LineMapper mapper = getLineMapper();
    chunks = new ArrayList<>();
    int cmLine = 0;
    boolean useIntralineBg = diff.metaA() == null || diff.metaB() == null;
    for (Region current : Natives.asList(diff.content())) {
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            int length = current.ab().length();
            mapper.appendCommon(length);
            for (int i = 0; i < length; i++) {
                host.setLineNumber(DisplaySide.A, cmLine + i, origLineA + i + 1);
                host.setLineNumber(DisplaySide.B, cmLine + i, origLineB + i + 1);
            }
            cmLine += length;
        } else if (current.skip() > 0) {
            mapper.appendCommon(current.skip());
            // Maybe current.ab().length();
            cmLine += current.skip();
        } else if (current.common()) {
            mapper.appendCommon(current.b().length());
            cmLine += current.b().length();
        } else {
            cmLine += render(current, cmLine, useIntralineBg);
        }
    }
}
#end_block

#method_before
private int render(Region region, int cmLine, boolean useIntralineBg) {
    LineMapper mapper = getLineMapper();
    int startA = mapper.getLineA();
    int startB = mapper.getLineB();
    JsArrayString a = region.a();
    JsArrayString b = region.b();
    int aLen = a != null ? a.length() : 0;
    int bLen = b != null ? b.length() : 0;
    boolean insertOrDelete = a == null || b == null;
    colorLines(cm, insertOrDelete && !useIntralineBg ? UnifiedTable.style.diffDelete() : UnifiedTable.style.intralineDelete(), cmLine, aLen);
    colorLines(cm, insertOrDelete && !useIntralineBg ? UnifiedTable.style.diffInsert() : UnifiedTable.style.intralineInsert(), cmLine + aLen, bLen);
    markEdit(DisplaySide.A, cmLine, a, region.editA());
    markEdit(DisplaySide.B, cmLine + aLen, b, region.editB());
    // TODO: verify addGutterTag
    addGutterTag(region, cmLine);
    mapper.appendReplace(aLen, bLen);
    int endA = mapper.getLineA() - 1;
    int endB = mapper.getLineB() - 1;
    if (aLen > 0) {
        addDiffChunk(DisplaySide.A, endA, aLen, cmLine, bLen > 0);
        for (int j = 0; j < aLen; j++) {
            host.setLineNumber(DisplaySide.A, cmLine + j, startA + j + 1);
            host.setLineNumberEmpty(DisplaySide.B, cmLine + j);
        }
    }
    if (bLen > 0) {
        addDiffChunk(DisplaySide.B, endB, bLen, cmLine + aLen, aLen > 0);
        for (int j = 0; j < bLen; j++) {
            host.setLineNumberEmpty(DisplaySide.A, cmLine + aLen + j);
            host.setLineNumber(DisplaySide.B, cmLine + aLen + j, startB + j + 1);
        }
    }
    return aLen + bLen;
}
#method_after
private int render(Region region, int cmLine, boolean useIntralineBg) {
    LineMapper mapper = getLineMapper();
    int startA = mapper.getLineA();
    int startB = mapper.getLineB();
    JsArrayString a = region.a();
    JsArrayString b = region.b();
    int aLen = a != null ? a.length() : 0;
    int bLen = b != null ? b.length() : 0;
    boolean insertOrDelete = a == null || b == null;
    colorLines(cm, insertOrDelete && !useIntralineBg ? UnifiedTable.style.diffDelete() : UnifiedTable.style.intralineDelete(), cmLine, aLen);
    colorLines(cm, insertOrDelete && !useIntralineBg ? UnifiedTable.style.diffInsert() : UnifiedTable.style.intralineInsert(), cmLine + aLen, bLen);
    markEdit(DisplaySide.A, cmLine, a, region.editA());
    markEdit(DisplaySide.B, cmLine + aLen, b, region.editB());
    // TODO: verify addGutterTag
    addGutterTag(region, cmLine);
    mapper.appendReplace(aLen, bLen);
    int endA = mapper.getLineA() - 1;
    int endB = mapper.getLineB() - 1;
    if (aLen > 0) {
        addDiffChunk(DisplaySide.A, endA, aLen, cmLine, bLen > 0);
        for (int j = 0; j < aLen; j++) {
            host.setLineNumber(DisplaySide.A, cmLine + j, startA + j + 1);
        }
    }
    if (bLen > 0) {
        addDiffChunk(DisplaySide.B, endB, bLen, cmLine + aLen, aLen > 0);
        for (int j = 0; j < bLen; j++) {
            host.setLineNumber(DisplaySide.B, cmLine + aLen + j, startB + j + 1);
        }
    }
    return aLen + bLen;
}
#end_block

#method_before
private void newDraft(CodeMirror cm) {
    if (cm.somethingSelected()) {
        FromTo fromTo = adjustSelection(cm);
        Pos from = fromTo.from();
        Pos to = fromTo.to();
        UnifiedChunkManager manager = host.getChunkManager();
        LineRegionInfo fromInfo = host.getLineRegionInfoFromCmLine(from.line());
        LineRegionInfo toInfo = host.getLineRegionInfoFromCmLine(to.line());
        DisplaySide side = toInfo.getSide();
        // start line to be on the same side as the end line.
        if ((fromInfo.type == RegionType.INSERT || fromInfo.type == RegionType.COMMON) && toInfo.type == RegionType.DELETE) {
            int startLineOnSideA = manager.getLineMapper().lineOnOther(DisplaySide.B, fromInfo.line).getLine();
            from.line(startLineOnSideA);
            if (fromInfo.type == RegionType.INSERT) {
                from.ch(cm.getLine(startLineOnSideA).length());
            }
            to.line(toInfo.line);
        } else if (fromInfo.type == RegionType.DELETE && toInfo.type == RegionType.INSERT) {
            int startLineOnSideB = manager.getLineMapper().lineOnOther(DisplaySide.A, fromInfo.line).getLine();
            from.line(startLineOnSideB);
            from.ch(cm.getLine(startLineOnSideB).length());
            to.line(toInfo.line);
        } else if (fromInfo.type == RegionType.DELETE && toInfo.type == RegionType.COMMON) {
            int toLineOnSideA = manager.getLineMapper().lineOnOther(DisplaySide.B, toInfo.line).getLine();
            from.line(fromInfo.line);
            to.line(toLineOnSideA);
            side = DisplaySide.A;
        } else {
            // Common case
            from.line(fromInfo.line);
            to.line(toInfo.line);
        }
        addDraftBox(side, CommentInfo.create(getPath(), getStoredSideFromDisplaySide(side), to.line() + 1, CommentRange.create(fromTo))).setEdit(true);
        cm.setCursor(Pos.create(host.getCmLine(to.line(), side), to.ch()));
        cm.setSelection(cm.getCursor());
    } else {
        int cmLine = cm.getLineNumber(cm.extras().activeLine());
        LineRegionInfo info = host.getLineRegionInfoFromCmLine(cmLine);
        insertNewDraft(info.getSide(), cmLine + 1);
    }
}
#method_after
private void newDraft(CodeMirror cm) {
    if (cm.somethingSelected()) {
        FromTo fromTo = adjustSelection(cm);
        Pos from = fromTo.from();
        Pos to = fromTo.to();
        UnifiedChunkManager manager = host.getChunkManager();
        LineRegionInfo fromInfo = host.getLineRegionInfoFromCmLine(from.line());
        LineRegionInfo toInfo = host.getLineRegionInfoFromCmLine(to.line());
        DisplaySide side = toInfo.getSide();
        // start line to be on the same side as the end line.
        if ((fromInfo.type == RegionType.INSERT || fromInfo.type == RegionType.COMMON) && toInfo.type == RegionType.DELETE) {
            LineOnOtherInfo infoOnSideA = manager.getLineMapper().lineOnOther(DisplaySide.B, fromInfo.line);
            int startLineOnSideA = infoOnSideA.getLine();
            if (infoOnSideA.isAligned()) {
                from.line(startLineOnSideA);
            } else {
                from.line(startLineOnSideA + 1);
            }
            from.ch(0);
            to.line(toInfo.line);
        } else if (fromInfo.type == RegionType.DELETE && toInfo.type == RegionType.INSERT) {
            LineOnOtherInfo infoOnSideB = manager.getLineMapper().lineOnOther(DisplaySide.A, fromInfo.line);
            int startLineOnSideB = infoOnSideB.getLine();
            if (infoOnSideB.isAligned()) {
                from.line(startLineOnSideB);
            } else {
                from.line(startLineOnSideB + 1);
            }
            from.ch(0);
            to.line(toInfo.line);
        } else if (fromInfo.type == RegionType.DELETE && toInfo.type == RegionType.COMMON) {
            int toLineOnSideA = manager.getLineMapper().lineOnOther(DisplaySide.B, toInfo.line).getLine();
            from.line(fromInfo.line);
            // Force the end line to be on the same side as the start line.
            to.line(toLineOnSideA);
            side = DisplaySide.A;
        } else {
            // Common case
            from.line(fromInfo.line);
            to.line(toInfo.line);
        }
        addDraftBox(side, CommentInfo.create(getPath(), getStoredSideFromDisplaySide(side), to.line() + 1, CommentRange.create(fromTo))).setEdit(true);
        cm.setCursor(Pos.create(host.getCmLine(to.line(), side), to.ch()));
        cm.setSelection(cm.getCursor());
    } else {
        int cmLine = cm.getLineNumber(cm.extras().activeLine());
        LineRegionInfo info = host.getLineRegionInfoFromCmLine(cmLine);
        insertNewDraft(info.getSide(), cmLine + 1);
    }
}
#end_block

#method_before
@Override
ScreenLoadCallback<ConfigInfoCache.Entry> getScreenLoadCallback(final CommentsCollections comments) {
    return new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentManager = new SideBySideCommentManager(SideBySide.this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen());
            setTheme(result.getTheme());
            display(comments);
        }
    };
}
#method_after
@Override
ScreenLoadCallback<ConfigInfoCache.Entry> getScreenLoadCallback(final CommentsCollections comments) {
    return new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentManager = new SideBySideCommentManager(SideBySide.this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen());
            setTheme(result.getTheme());
            display(comments);
            header.setupPrevNextFiles(comments);
        }
    };
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    operation(new Runnable() {

        @Override
        public void run() {
            resizeCodeMirror();
            chunkManager.adjustPadding();
            cmA.refresh();
            cmB.refresh();
        }
    });
    setLineLength(Patch.COMMIT_MSG.equals(prefs) ? 72 : prefs.lineLength());
    diffTable.refresh();
    if (getStartLine() == 0) {
        DiffChunkInfo d = chunkManager.getFirst();
        if (d != null) {
            if (d.isEdit() && d.getSide() == DisplaySide.A) {
                setStartSide(DisplaySide.B);
                setStartLine(lineOnOther(d.getSide(), d.getStart()).getLine() + 1);
            } else {
                setStartSide(d.getSide());
                setStartLine(d.getStart() + 1);
            }
        }
    }
    if (getStartSide() != null && getStartLine() > 0) {
        CodeMirror cm = getCmFromSide(getStartSide());
        cm.scrollToLine(getStartLine() - 1);
        cm.focus();
    } else {
        cmA.setCursor(Pos.create(0));
        cmA.focus();
    }
    if (Gerrit.isSignedIn() && prefs.autoReview()) {
        header.autoReview();
    }
    prefetchNextFile();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    operation(new Runnable() {

        @Override
        public void run() {
            resizeCodeMirror();
            chunkManager.adjustPadding();
            cmA.refresh();
            cmB.refresh();
        }
    });
    setLineLength(Patch.COMMIT_MSG.equals(path) ? 72 : prefs.lineLength());
    diffTable.refresh();
    if (getStartLine() == 0) {
        DiffChunkInfo d = chunkManager.getFirst();
        if (d != null) {
            if (d.isEdit() && d.getSide() == DisplaySide.A) {
                setStartSide(DisplaySide.B);
                setStartLine(lineOnOther(d.getSide(), d.getStart()).getLine() + 1);
            } else {
                setStartSide(d.getSide());
                setStartLine(d.getStart() + 1);
            }
        }
    }
    if (getStartSide() != null && getStartLine() > 0) {
        CodeMirror cm = getCmFromSide(getStartSide());
        cm.scrollToLine(getStartLine() - 1);
        cm.focus();
    } else {
        cmA.setCursor(Pos.create(0));
        cmA.focus();
    }
    if (Gerrit.isSignedIn() && prefs.autoReview()) {
        header.autoReview();
    }
    prefetchNextFile();
}
#end_block

#method_before
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
    cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA);
    cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB);
    cmA.extras().side(DisplaySide.A);
    cmB.extras().side(DisplaySide.B);
    setShowTabs(prefs.showTabs());
    chunkManager = new SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar);
    skipManager = new SideBySideSkipManager(this, commentManager);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollSynchronizer = new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper());
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks());
    scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#method_after
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(SideBySideTable.style.showLineNumbers());
    }
    cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA);
    cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB);
    cmA.extras().side(DisplaySide.A);
    cmB.extras().side(DisplaySide.B);
    setShowTabs(prefs.showTabs());
    chunkManager = new SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar);
    skipManager = new SideBySideSkipManager(this, commentManager);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollSynchronizer = new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper());
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks());
    scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#end_block

#method_before
@Override
void setShowLineNumbers(boolean b) {
    cmA.setOption("lineNumbers", b);
    cmB.setOption("lineNumbers", b);
    if (b) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    } else {
        diffTable.removeStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
}
#method_after
@Override
void setShowLineNumbers(boolean b) {
    cmA.setOption("lineNumbers", b);
    cmB.setOption("lineNumbers", b);
    if (b) {
        diffTable.addStyleName(SideBySideTable.style.showLineNumbers());
    } else {
        diffTable.removeStyleName(SideBySideTable.style.showLineNumbers());
    }
}
#end_block

#method_before
private SideBySideCommentGroup group(DisplaySide side, int line) {
    SideBySideCommentGroup w = map(side).get(line);
    if (w != null) {
        return w;
    }
    int lineA, lineB;
    if (line == 0) {
        lineA = lineB = 0;
    } else if (side == DisplaySide.A) {
        lineA = line;
        lineB = host.lineOnOther(side, line - 1).getLine() + 1;
    } else {
        lineA = host.lineOnOther(side, line - 1).getLine() + 1;
        lineB = line;
    }
    SideBySideCommentGroup a = newGroup(DisplaySide.A, lineA);
    SideBySideCommentGroup b = newGroup(DisplaySide.B, lineB);
    SideBySideCommentGroup.pair(a, b);
    sideA.put(lineA, a);
    sideB.put(lineB, b);
    if (isAttached()) {
        a.init(host.getDiffTable());
        b.handleRedraw();
    }
    return side == DisplaySide.A ? a : b;
}
#method_after
private SideBySideCommentGroup group(DisplaySide side, int line) {
    SideBySideCommentGroup w = map(side).get(line);
    if (w != null) {
        return w;
    }
    int lineA;
    int lineB;
    if (line == 0) {
        lineA = lineB = 0;
    } else if (side == DisplaySide.A) {
        lineA = line;
        lineB = host.lineOnOther(side, line - 1).getLine() + 1;
    } else {
        lineA = host.lineOnOther(side, line - 1).getLine() + 1;
        lineB = line;
    }
    SideBySideCommentGroup a = newGroup(DisplaySide.A, lineA);
    SideBySideCommentGroup b = newGroup(DisplaySide.B, lineB);
    SideBySideCommentGroup.pair(a, b);
    sideA.put(lineA, a);
    sideB.put(lineB, b);
    if (isAttached()) {
        a.init(host.getDiffTable());
        b.handleRedraw();
    }
    return side == DisplaySide.A ? a : b;
}
#end_block

#method_before
@Override
ScreenLoadCallback<ConfigInfoCache.Entry> getScreenLoadCallback(final CommentsCollections comments) {
    return new ScreenLoadCallback<ConfigInfoCache.Entry>(Unified.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentManager = new UnifiedCommentManager(Unified.this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen());
            setTheme(result.getTheme());
            display(comments);
        }
    };
}
#method_after
@Override
ScreenLoadCallback<ConfigInfoCache.Entry> getScreenLoadCallback(final CommentsCollections comments) {
    return new ScreenLoadCallback<ConfigInfoCache.Entry>(Unified.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentManager = new UnifiedCommentManager(Unified.this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen());
            setTheme(result.getTheme());
            display(comments);
            header.setupPrevNextFiles(comments);
        }
    };
}
#end_block

#method_before
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
    cm = newCm(diff.metaA() == null ? diff.metaB() : diff.metaA(), diff.textUnified(), diffTable.cm);
    setShowTabs(prefs.showTabs());
    chunkManager = new UnifiedChunkManager(this, cm, diffTable.scrollbar);
    skipManager = new UnifiedSkipManager(this, commentManager);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cm.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cm);
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getSideBySideDiffLink(), diff.unifiedWebLinks());
    setAutoHideDiffHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#method_after
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    // TODO: Handle showLineNumbers preference
    cm = newCm(diff.metaA() == null ? diff.metaB() : diff.metaA(), diff.textUnified(), diffTable.cm);
    setShowTabs(prefs.showTabs());
    chunkManager = new UnifiedChunkManager(this, cm, diffTable.scrollbar);
    skipManager = new UnifiedSkipManager(this, commentManager);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cm.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cm);
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getSideBySideDiffLink(), diff.unifiedWebLinks());
    setAutoHideDiffHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#end_block

#method_before
@Override
void setShowLineNumbers(boolean b) {
    if (b) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    } else {
        diffTable.removeStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
    cm.refresh();
}
#method_after
@Override
void setShowLineNumbers(boolean b) {
// TODO: Implement this
}
#end_block

#method_before
void setLineNumber(DisplaySide side, int cmLine, int line) {
    setLineNumber(side, cmLine, String.valueOf(line), UnifiedTable.style.unifiedLineNumber());
}
#method_after
LineHandle setLineNumber(DisplaySide side, final int cmLine, int line) {
    Label gutter = new Label(String.valueOf(line));
    gutter.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            onGutterClick(cmLine);
        }
    });
    diffTable.add(gutter);
    gutter.setStyleName(UnifiedTable.style.unifiedLineNumber());
    return cm.setGutterMarker(cmLine, side == DisplaySide.A ? UnifiedTable.style.lineNumbersLeft() : UnifiedTable.style.lineNumbersRight(), gutter.getElement());
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group2.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(group1.addFinal(new GerritCallback<DiffInfo>() {

        final AsyncCallback<Void> modeInjectorCb = group2.addEmpty();

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            fileSize = bucketFileSize(diffInfo);
            if (prefs.syntaxHighlighting()) {
                if (fileSize.compareTo(FileSize.SMALL) > 0) {
                    modeInjectorCb.onSuccess(null);
                } else {
                    injectMode(diffInfo, modeInjectorCb);
                }
            } else {
                modeInjectorCb.onSuccess(null);
            }
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.edit(changeId.get(), group2.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    final CommentsCollections comments = new CommentsCollections();
    comments.load(base, revision, path, group2);
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS));
    call.get(group2.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            changeStatus = info.status();
            info.revisions().copyKeysIntoChildren("name");
            if (edit != null) {
                edit.setName(edit.commit().commit());
                info.setEdit(edit);
                info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
            }
            String currentRevision = info.currentRevision();
            boolean current = currentRevision != null && revision.get() == info.revision(currentRevision)._number();
            JsArray<RevisionInfo> list = info.revisions().values();
            RevisionInfo.sortRevisionInfoByNumber(list);
            getDiffTable().set(prefs, list, diff, edit != null, current, changeStatus.isOpen(), diff.binary());
            header.setChangeInfo(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ConfigInfoCache.get(changeId, group2.addFinal(getScreenLoadCallback(comments)));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group2.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(group1.addFinal(new GerritCallback<DiffInfo>() {

        final AsyncCallback<Void> modeInjectorCb = group2.addEmpty();

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            fileSize = bucketFileSize(diffInfo);
            if (prefs.syntaxHighlighting()) {
                if (fileSize.compareTo(FileSize.SMALL) > 0) {
                    modeInjectorCb.onSuccess(null);
                } else {
                    injectMode(diffInfo, modeInjectorCb);
                }
            } else {
                modeInjectorCb.onSuccess(null);
            }
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.edit(changeId.get(), group2.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    final CommentsCollections comments = new CommentsCollections(base, revision, path);
    comments.load(group2);
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS));
    call.get(group2.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            changeStatus = info.status();
            info.revisions().copyKeysIntoChildren("name");
            if (edit != null) {
                edit.setName(edit.commit().commit());
                info.setEdit(edit);
                info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
            }
            String currentRevision = info.currentRevision();
            boolean current = currentRevision != null && revision.get() == info.revision(currentRevision)._number();
            JsArray<RevisionInfo> list = info.revisions().values();
            RevisionInfo.sortRevisionInfoByNumber(list);
            getDiffTable().set(prefs, list, diff, edit != null, current, changeStatus.isOpen(), diff.binary());
            header.setChangeInfo(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ConfigInfoCache.get(changeId, group2.addFinal(getScreenLoadCallback(comments)));
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    JumpKeys.enable(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegistrations();
    if (getCommentManager() != null) {
        CallbackGroup group = new CallbackGroup();
        getCommentManager().saveAllDrafts(group);
        group.done();
    }
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    for (CodeMirror cm : getCms()) {
        if (cm != null) {
            cm.getWrapperElement().removeFromParent();
        }
    }
    if (prefsAction != null) {
        prefsAction.hide();
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
    JumpKeys.enable(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegistrations();
    if (getCommentManager() != null) {
        CallbackGroup group = new CallbackGroup();
        getCommentManager().saveAllDrafts(group);
        group.done();
    }
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    for (CodeMirror cm : getCms()) {
        if (cm != null) {
            cm.getWrapperElement().removeFromParent();
        }
    }
    if (prefsAction != null) {
        prefsAction.hide();
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("focus", updateActiveLine(cm));
    KeyMap keyMap = KeyMap.create().on("A", upToChange(true)).on("U", upToChange(false)).on("'['", header.navigate(Direction.PREV)).on("']'", header.navigate(Direction.NEXT)).on("R", header.toggleReviewed()).on("O", getCommentManager().toggleOpenBox(cm)).on("Enter", getCommentManager().toggleOpenBox(cm)).on("N", maybeNextVimSearch(cm)).on("E", openEditScreen(cm)).on("P", getChunkManager().diffChunkNav(cm, Direction.PREV)).on("Shift-M", header.reviewedAndNext()).on("Shift-N", maybePrevVimSearch(cm)).on("Shift-P", getCommentManager().commentNav(cm, Direction.PREV)).on("Shift-O", getCommentManager().openCloseAll(cm)).on("I", new Runnable() {

        @Override
        public void run() {
            switch(getIntraLineStatus()) {
                case OFF:
                case OK:
                    toggleShowIntraline();
                    break;
                case FAILURE:
                case TIMEOUT:
                default:
                    break;
            }
        }
    }).on("','", new Runnable() {

        @Override
        public void run() {
            prefsAction.show();
        }
    }).on("Shift-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-d>");
        }
    }).on("Shift-Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-u>");
        }
    }).on("Ctrl-F", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("/");
        }
    }).on("Ctrl-A", new Runnable() {

        @Override
        public void run() {
            cm.execCommand("selectAll");
        }
    });
    if (revision.get() != 0) {
        cm.on("beforeSelectionChange", onSelectionChange(cm));
        cm.on("gutterClick", onGutterClick(cm));
        keyMap.on("C", getCommentManager().newDraftCallback(cm));
    }
    cm.addKeyMap(keyMap);
}
#method_after
void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("focus", updateActiveLine(cm));
    KeyMap keyMap = KeyMap.create().on("A", upToChange(true)).on("U", upToChange(false)).on("'['", header.navigate(Direction.PREV)).on("']'", header.navigate(Direction.NEXT)).on("R", header.toggleReviewed()).on("O", getCommentManager().toggleOpenBox(cm)).on("Enter", getCommentManager().toggleOpenBox(cm)).on("N", maybeNextVimSearch(cm)).on("Ctrl-Alt-E", openEditScreen(cm)).on("P", getChunkManager().diffChunkNav(cm, Direction.PREV)).on("Shift-M", header.reviewedAndNext()).on("Shift-N", maybePrevVimSearch(cm)).on("Shift-P", getCommentManager().commentNav(cm, Direction.PREV)).on("Shift-O", getCommentManager().openCloseAll(cm)).on("I", new Runnable() {

        @Override
        public void run() {
            switch(getIntraLineStatus()) {
                case OFF:
                case OK:
                    toggleShowIntraline();
                    break;
                case FAILURE:
                case TIMEOUT:
                default:
                    break;
            }
        }
    }).on("','", new Runnable() {

        @Override
        public void run() {
            prefsAction.show();
        }
    }).on("Shift-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-d>");
        }
    }).on("Shift-Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-u>");
        }
    }).on("Ctrl-F", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("/");
        }
    }).on("Ctrl-A", new Runnable() {

        @Override
        public void run() {
            cm.execCommand("selectAll");
        }
    }).on("G O", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:open"));
        }
    }).on("G M", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:merged"));
        }
    }).on("G A", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:abandoned"));
        }
    });
    if (Gerrit.isSignedIn()) {
        keyMap.on("G I", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.MINE);
            }
        }).on("G D", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("owner:self is:draft"));
            }
        }).on("G C", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("has:draft"));
            }
        }).on("G W", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("is:watched status:open"));
            }
        }).on("G S", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("is:starred"));
            }
        });
    }
    if (revision.get() != 0) {
        cm.on("beforeSelectionChange", onSelectionChange(cm));
        cm.on("gutterClick", onGutterClick(cm));
        keyMap.on("C", getCommentManager().newDraftCallback(cm));
    }
    // Needed to for multi-stroke keymaps
    CodeMirror.normalizeKeyMap(keyMap);
    cm.addKeyMap(keyMap);
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()), new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysNavigation.add(new NoOpKeyCommand(0, 'n', PatchUtil.C.chunkNext2()), new NoOpKeyCommand(0, 'p', PatchUtil.C.chunkPrev2()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'n', PatchUtil.C.commentNext()), new NoOpKeyCommand(KeyCommand.M_SHIFT, 'p', PatchUtil.C.commentPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 'f', Gerrit.C.keySearch()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'o', PatchUtil.C.expandAllCommentsOnCurrentLine()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                header.toggleReviewed().run();
            }
        });
    }
    keysAction.add(new KeyCommand(KeyCommand.M_SHIFT, 'm', PatchUtil.C.markAsReviewedAndGoToNext()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            header.reviewedAndNext().run();
        }
    });
    keysAction.add(new KeyCommand(0, 'a', PatchUtil.C.openReply()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange(true).run();
        }
    });
    keysAction.add(new KeyCommand(0, ',', PatchUtil.C.showPreferences()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            prefsAction.show();
        }
    });
    if (getIntraLineStatus() == DiffInfo.IntraLineStatus.OFF || getIntraLineStatus() == DiffInfo.IntraLineStatus.OK) {
        keysAction.add(new KeyCommand(0, 'i', PatchUtil.C.toggleIntraline()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                toggleShowIntraline();
            }
        });
    }
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()), new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysNavigation.add(new NoOpKeyCommand(0, 'n', PatchUtil.C.chunkNext()), new NoOpKeyCommand(0, 'p', PatchUtil.C.chunkPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'n', PatchUtil.C.commentNext()), new NoOpKeyCommand(KeyCommand.M_SHIFT, 'p', PatchUtil.C.commentPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 'f', Gerrit.C.keySearch()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'o', PatchUtil.C.expandAllCommentsOnCurrentLine()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                header.toggleReviewed().run();
            }
        });
        keysAction.add(new NoOpKeyCommand(KeyCommand.M_CTRL | KeyCommand.M_ALT, 'e', Gerrit.C.keyEditor()));
    }
    keysAction.add(new KeyCommand(KeyCommand.M_SHIFT, 'm', PatchUtil.C.markAsReviewedAndGoToNext()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            header.reviewedAndNext().run();
        }
    });
    keysAction.add(new KeyCommand(0, 'a', PatchUtil.C.openReply()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange(true).run();
        }
    });
    keysAction.add(new KeyCommand(0, ',', PatchUtil.C.showPreferences()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            prefsAction.show();
        }
    });
    if (getIntraLineStatus() == DiffInfo.IntraLineStatus.OFF || getIntraLineStatus() == DiffInfo.IntraLineStatus.OK) {
        keysAction.add(new KeyCommand(0, 'i', PatchUtil.C.toggleIntraline()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                toggleShowIntraline();
            }
        });
    }
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
}
#end_block

#method_before
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) {
            if (isLineNumberClick(clickEvent) && clickEvent.getButton() == NativeEvent.BUTTON_LEFT && !clickEvent.getMetaKey() && !clickEvent.getAltKey() && !clickEvent.getCtrlKey() && !clickEvent.getShiftKey()) {
                cm.setCursor(Pos.create(line));
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        getCommentManager().newDraftOnGutterClick(cm, gutterClass, line + 1);
                    }
                });
            }
        }
    };
}
#method_after
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) {
            if (clickEvent.getButton() == NativeEvent.BUTTON_LEFT && !clickEvent.getMetaKey() && !clickEvent.getAltKey() && !clickEvent.getCtrlKey() && !clickEvent.getShiftKey()) {
                cm.setCursor(Pos.create(line));
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        getCommentManager().newDraftOnGutterClick(cm, gutterClass, line + 1);
                    }
                });
            }
        }
    };
}
#end_block

#method_before
@Override
protected void onLoad() {
    DiffApi.list(patchSetId, base, new GerritCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> result) {
            JsArray<FileInfo> files = result.values();
            FileInfo.sortFileInfoByPath(files);
            fileNumber.setInnerText(Integer.toString(Natives.asList(files).indexOf(result.get(path)) + 1));
            fileCount.setInnerText(Integer.toString(files.length()));
            setupPrevNextFiles(files, findCurrentFileIndex(files));
        }
    });
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(patchSetId).view("files").addParameterTrue("reviewed").get(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                boolean b = Natives.asList(result).contains(path);
                reviewed.setValue(b, false);
                if (!b && reviewedState == ReviewedState.AUTO_REVIEW) {
                    postAutoReviewed();
                }
                reviewedState = ReviewedState.LOADED;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    DiffApi.list(patchSetId, base, new GerritCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> result) {
            files = result.values();
            FileInfo.sortFileInfoByPath(files);
            fileNumber.setInnerText(Integer.toString(Natives.asList(files).indexOf(result.get(path)) + 1));
            fileCount.setInnerText(Integer.toString(files.length()));
        }
    });
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(patchSetId).view("files").addParameterTrue("reviewed").get(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                boolean b = Natives.asList(result).contains(path);
                reviewed.setValue(b, false);
                if (!b && reviewedState == ReviewedState.AUTO_REVIEW) {
                    postAutoReviewed();
                }
                reviewedState = ReviewedState.LOADED;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#end_block

#method_before
private boolean shouldSkipFile(FileInfo curr) {
    return prefs.skipDeleted() && ChangeType.DELETED.matches(curr.status()) || prefs.skipUnchanged() && ChangeType.COPIED.matches(curr.status()) || prefs.skipUncommented() && !hasComments;
}
#method_after
private boolean shouldSkipFile(FileInfo curr, CommentsCollections comments) {
    return prefs.skipDeleted() && ChangeType.DELETED.matches(curr.status()) || prefs.skipUnchanged() && ChangeType.RENAMED.matches(curr.status()) || prefs.skipUncommented() && !comments.hasCommentForPath(curr.path());
}
#end_block

#method_before
void setupPrevNextFiles(JsArray<FileInfo> files, int currIndex) {
    FileInfo prevInfo = null;
    FileInfo nextInfo = null;
    for (int i = currIndex - 1; i >= 0; i--) {
        FileInfo curr = files.get(i);
        if (shouldSkipFile(curr)) {
            continue;
        } else {
            prevInfo = curr;
            break;
        }
    }
    for (int i = currIndex + 1; i < files.length(); i++) {
        FileInfo curr = files.get(i);
        if (shouldSkipFile(curr)) {
            continue;
        } else {
            nextInfo = curr;
            break;
        }
    }
    KeyCommand p = setupNav(prev, '[', PatchUtil.C.previousFileHelp(), prevInfo);
    KeyCommand n = setupNav(next, ']', PatchUtil.C.nextFileHelp(), nextInfo);
    if (p != null && n != null) {
        keys.pair(p, n);
    }
    nextPath = nextInfo != null ? nextInfo.path() : null;
}
#method_after
void setupPrevNextFiles(CommentsCollections comments) {
    FileInfo prevInfo = null;
    FileInfo nextInfo = null;
    int currIndex = findCurrentFileIndex(files);
    for (int i = currIndex - 1; i >= 0; i--) {
        FileInfo curr = files.get(i);
        if (shouldSkipFile(curr, comments)) {
            continue;
        } else {
            prevInfo = curr;
            break;
        }
    }
    for (int i = currIndex + 1; i < files.length(); i++) {
        FileInfo curr = files.get(i);
        if (shouldSkipFile(curr, comments)) {
            continue;
        } else {
            nextInfo = curr;
            break;
        }
    }
    KeyCommand p = setupNav(prev, '[', PatchUtil.C.previousFileHelp(), prevInfo);
    KeyCommand n = setupNav(next, ']', PatchUtil.C.nextFileHelp(), nextInfo);
    if (p != null && n != null) {
        keys.pair(p, n);
    }
    nextPath = nextInfo != null ? nextInfo.path() : null;
}
#end_block

#method_before
@Override
protected void onLoad() {
    DiffApi.list(patchSetId, base, new GerritCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> result) {
            JsArray<FileInfo> files = result.values();
            FileInfo.sortFileInfoByPath(files);
            fileNumber.setInnerText(Integer.toString(Natives.asList(files).indexOf(result.get(path)) + 1));
            fileCount.setInnerText(Integer.toString(files.length()));
            setupPrevNextFiles(files, findCurrentFileIndex(files));
        }
    });
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(patchSetId).view("files").addParameterTrue("reviewed").get(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                boolean b = Natives.asList(result).contains(path);
                reviewed.setValue(b, false);
                if (!b && reviewedState == ReviewedState.AUTO_REVIEW) {
                    postAutoReviewed();
                }
                reviewedState = ReviewedState.LOADED;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    DiffApi.list(patchSetId, base, new GerritCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> result) {
            files = result.values();
            FileInfo.sortFileInfoByPath(files);
            fileNumber.setInnerText(Integer.toString(Natives.asList(files).indexOf(result.get(path)) + 1));
            fileCount.setInnerText(Integer.toString(files.length()));
        }
    });
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(patchSetId).view("files").addParameterTrue("reviewed").get(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                boolean b = Natives.asList(result).contains(path);
                reviewed.setValue(b, false);
                if (!b && reviewedState == ReviewedState.AUTO_REVIEW) {
                    postAutoReviewed();
                }
                reviewedState = ReviewedState.LOADED;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#end_block

#method_before
private boolean shouldSkipFile(FileInfo curr) {
    return prefs.skipDeleted() && ChangeType.DELETED.matches(curr.status()) || prefs.skipUncommented() && !hasComments;
}
#method_after
private boolean shouldSkipFile(FileInfo curr, CommentsCollections comments) {
    return prefs.skipDeleted() && ChangeType.DELETED.matches(curr.status()) || prefs.skipUncommented() && !comments.hasCommentForPath(curr.path());
}
#end_block

#method_before
void setupPrevNextFiles(JsArray<FileInfo> files, int currIndex) {
    FileInfo prevInfo = null;
    FileInfo nextInfo = null;
    for (int i = currIndex - 1; i >= 0; i--) {
        FileInfo curr = files.get(i);
        if (shouldSkipFile(curr)) {
            continue;
        } else {
            prevInfo = curr;
            break;
        }
    }
    for (int i = currIndex + 1; i < files.length(); i++) {
        FileInfo curr = files.get(i);
        if (shouldSkipFile(curr)) {
            continue;
        } else {
            nextInfo = curr;
            break;
        }
    }
    KeyCommand p = setupNav(prev, '[', PatchUtil.C.previousFileHelp(), prevInfo);
    KeyCommand n = setupNav(next, ']', PatchUtil.C.nextFileHelp(), nextInfo);
    if (p != null && n != null) {
        keys.pair(p, n);
    }
    nextPath = nextInfo != null ? nextInfo.path() : null;
}
#method_after
void setupPrevNextFiles(CommentsCollections comments) {
    FileInfo prevInfo = null;
    FileInfo nextInfo = null;
    int currIndex = findCurrentFileIndex(files);
    for (int i = currIndex - 1; i >= 0; i--) {
        FileInfo curr = files.get(i);
        if (shouldSkipFile(curr, comments)) {
            continue;
        } else {
            prevInfo = curr;
            break;
        }
    }
    for (int i = currIndex + 1; i < files.length(); i++) {
        FileInfo curr = files.get(i);
        if (shouldSkipFile(curr, comments)) {
            continue;
        } else {
            nextInfo = curr;
            break;
        }
    }
    KeyCommand p = setupNav(prev, '[', PatchUtil.C.previousFileHelp(), prevInfo);
    KeyCommand n = setupNav(next, ']', PatchUtil.C.nextFileHelp(), nextInfo);
    if (p != null && n != null) {
        keys.pair(p, n);
    }
    nextPath = nextInfo != null ? nextInfo.path() : null;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group2.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(group1.addFinal(new GerritCallback<DiffInfo>() {

        final AsyncCallback<Void> modeInjectorCb = group2.addEmpty();

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            fileSize = bucketFileSize(diffInfo);
            if (prefs.syntaxHighlighting()) {
                if (fileSize.compareTo(FileSize.SMALL) > 0) {
                    modeInjectorCb.onSuccess(null);
                } else {
                    injectMode(diffInfo, modeInjectorCb);
                }
            } else {
                modeInjectorCb.onSuccess(null);
            }
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.edit(changeId.get(), group2.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    final CommentsCollections comments = new CommentsCollections();
    comments.load(base, revision, path, group2);
    header.setHasComments(comments);
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS));
    call.get(group2.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            changeStatus = info.status();
            info.revisions().copyKeysIntoChildren("name");
            if (edit != null) {
                edit.setName(edit.commit().commit());
                info.setEdit(edit);
                info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
            }
            String currentRevision = info.currentRevision();
            boolean current = currentRevision != null && revision.get() == info.revision(currentRevision)._number();
            JsArray<RevisionInfo> list = info.revisions().values();
            RevisionInfo.sortRevisionInfoByNumber(list);
            getDiffTable().set(prefs, list, diff, edit != null, current, changeStatus.isOpen(), diff.binary());
            header.setChangeInfo(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ConfigInfoCache.get(changeId, group2.addFinal(getScreenLoadCallback(comments)));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group2.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(group1.addFinal(new GerritCallback<DiffInfo>() {

        final AsyncCallback<Void> modeInjectorCb = group2.addEmpty();

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            fileSize = bucketFileSize(diffInfo);
            if (prefs.syntaxHighlighting()) {
                if (fileSize.compareTo(FileSize.SMALL) > 0) {
                    modeInjectorCb.onSuccess(null);
                } else {
                    injectMode(diffInfo, modeInjectorCb);
                }
            } else {
                modeInjectorCb.onSuccess(null);
            }
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.edit(changeId.get(), group2.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    final CommentsCollections comments = new CommentsCollections(base, revision, path);
    comments.load(group2);
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS));
    call.get(group2.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            changeStatus = info.status();
            info.revisions().copyKeysIntoChildren("name");
            if (edit != null) {
                edit.setName(edit.commit().commit());
                info.setEdit(edit);
                info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
            }
            String currentRevision = info.currentRevision();
            boolean current = currentRevision != null && revision.get() == info.revision(currentRevision)._number();
            JsArray<RevisionInfo> list = info.revisions().values();
            RevisionInfo.sortRevisionInfoByNumber(list);
            getDiffTable().set(prefs, list, diff, edit != null, current, changeStatus.isOpen(), diff.binary());
            header.setChangeInfo(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ConfigInfoCache.get(changeId, group2.addFinal(getScreenLoadCallback(comments)));
}
#end_block

#method_before
@Override
protected void onLoad() {
    DiffApi.list(patchSetId, base, new GerritCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> result) {
            files = result.values();
            FileInfo.sortFileInfoByPath(files);
            fileNumber.setInnerText(Integer.toString(Natives.asList(files).indexOf(result.get(path)) + 1));
            fileCount.setInnerText(Integer.toString(files.length()));
            currIndex = 0;
            for (int i = 0; i < files.length(); i++) {
                if (path.equals(files.get(i).path())) {
                    currIndex = i;
                    break;
                }
            }
            setupPrevNextFiles();
        }
    });
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(patchSetId).view("files").addParameterTrue("reviewed").get(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                boolean b = Natives.asList(result).contains(path);
                reviewed.setValue(b, false);
                if (!b && reviewedState == ReviewedState.AUTO_REVIEW) {
                    postAutoReviewed();
                }
                reviewedState = ReviewedState.LOADED;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    DiffApi.list(patchSetId, base, new GerritCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> result) {
            JsArray<FileInfo> files = result.values();
            FileInfo.sortFileInfoByPath(files);
            fileNumber.setInnerText(Integer.toString(Natives.asList(files).indexOf(result.get(path)) + 1));
            fileCount.setInnerText(Integer.toString(files.length()));
            setupPrevNextFiles(files, findCurrentFileIndex(files));
        }
    });
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(patchSetId).view("files").addParameterTrue("reviewed").get(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                boolean b = Natives.asList(result).contains(path);
                reviewed.setValue(b, false);
                if (!b && reviewedState == ReviewedState.AUTO_REVIEW) {
                    postAutoReviewed();
                }
                reviewedState = ReviewedState.LOADED;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#end_block

#method_before
void setupPrevNextFiles() {
    FileInfo prevInfo = null;
    FileInfo nextInfo = null;
    for (int i = currIndex - 1; i >= 0; i--) {
        FileInfo curr = files.get(i);
        if (prefs.skipDeleted() && curr.status().equals("D")) {
            continue;
        } else {
            prevInfo = curr;
            break;
        }
    }
    for (int i = currIndex + 1; i < files.length(); i++) {
        FileInfo curr = files.get(i);
        if (prefs.skipDeleted() && curr.status().equals("D")) {
            continue;
        } else {
            nextInfo = curr;
            break;
        }
    }
    KeyCommand p = setupNav(prev, '[', PatchUtil.C.previousFileHelp(), prevInfo);
    KeyCommand n = setupNav(next, ']', PatchUtil.C.nextFileHelp(), nextInfo);
    if (p != null && n != null) {
        keys.pair(p, n);
    }
    nextPath = nextInfo != null ? nextInfo.path() : null;
}
#method_after
void setupPrevNextFiles(JsArray<FileInfo> files, int currIndex) {
    FileInfo prevInfo = null;
    FileInfo nextInfo = null;
    for (int i = currIndex - 1; i >= 0; i--) {
        FileInfo curr = files.get(i);
        if (prefs.skipDeleted() && ChangeType.DELETED.matches(curr.status())) {
            continue;
        } else {
            prevInfo = curr;
            break;
        }
    }
    for (int i = currIndex + 1; i < files.length(); i++) {
        FileInfo curr = files.get(i);
        if (prefs.skipDeleted() && ChangeType.DELETED.matches(curr.status())) {
            continue;
        } else {
            nextInfo = curr;
            break;
        }
    }
    KeyCommand p = setupNav(prev, '[', PatchUtil.C.previousFileHelp(), prevInfo);
    KeyCommand n = setupNav(next, ']', PatchUtil.C.nextFileHelp(), nextInfo);
    if (p != null && n != null) {
        keys.pair(p, n);
    }
    nextPath = nextInfo != null ? nextInfo.path() : null;
}
#end_block

#method_before
public SubmitStrategy create(SubmitType submitType, ReviewDb db, Repository repo, CodeReviewRevWalk rw, ObjectInserter inserter, RevFlag canMergeFlag, Set<RevCommit> alreadyAccepted, Branch.NameKey destBranch, IdentifiedUser caller, MergeTip mergeTip, CommitStatus commits, String submissionId, SubmitInput submitInput) throws IntegrationException {
    SubmitStrategy.Arguments args = argsFactory.create(submitType, destBranch, commits, rw, caller, mergeTip, inserter, repo, canMergeFlag, db, alreadyAccepted, submissionId, submitInput);
    switch(submitType) {
        case CHERRY_PICK:
            return new CherryPick(args);
        case FAST_FORWARD_ONLY:
            return new FastForwardOnly(args);
        case MERGE_ALWAYS:
            return new MergeAlways(args);
        case MERGE_IF_NECESSARY:
            return new MergeIfNecessary(args);
        case REBASE_IF_NECESSARY:
            return new RebaseIfNecessary(args);
        default:
            String errorMsg = "No submit strategy for: " + submitType;
            log.error(errorMsg);
            throw new IntegrationException(errorMsg);
    }
}
#method_after
public SubmitStrategy create(SubmitType submitType, ReviewDb db, Repository repo, CodeReviewRevWalk rw, ObjectInserter inserter, RevFlag canMergeFlag, Set<RevCommit> alreadyAccepted, Branch.NameKey destBranch, IdentifiedUser caller, MergeTip mergeTip, CommitStatus commits, String submissionId, NotifyHandling notifyHandling) throws IntegrationException {
    SubmitStrategy.Arguments args = argsFactory.create(submitType, destBranch, commits, rw, caller, mergeTip, inserter, repo, canMergeFlag, db, alreadyAccepted, submissionId, notifyHandling);
    switch(submitType) {
        case CHERRY_PICK:
            return new CherryPick(args);
        case FAST_FORWARD_ONLY:
            return new FastForwardOnly(args);
        case MERGE_ALWAYS:
            return new MergeAlways(args);
        case MERGE_IF_NECESSARY:
            return new MergeIfNecessary(args);
        case REBASE_IF_NECESSARY:
            return new RebaseIfNecessary(args);
        default:
            String errorMsg = "No submit strategy for: " + submitType;
            log.error(errorMsg);
            throw new IntegrationException(errorMsg);
    }
}
#end_block

#method_before
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.submitInput).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null) {
        try {
            args.hooks.doChangeMergedHook(updatedChange, args.accountCache.get(submitter.getAccountId()).getAccount(), mergedPatchSet, ctx.getDb(), mergeResultRev.name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + getId(), ex);
        }
    }
}
#method_after
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null) {
        try {
            args.hooks.doChangeMergedHook(updatedChange, args.accountCache.get(submitter.getAccountId()).getAccount(), mergedPatchSet, ctx.getDb(), mergeResultRev.name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + getId(), ex);
        }
    }
}
#end_block

#method_before
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput);
}
#method_after
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify);
}
#end_block

#method_before
@Override
public void run() {
    RequestContext old = requestContext.setContext(this);
    try {
        MergedSender cm = mergedSenderFactory.create(project, changeId);
        if (submitter != null) {
            cm.setFrom(submitter);
        }
        if (submitInput != null) {
            cm.setNotify(submitInput.notify);
        }
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + changeId, e);
    } finally {
        requestContext.setContext(old);
        if (db != null) {
            db.close();
            db = null;
        }
    }
}
#method_after
@Override
public void run() {
    RequestContext old = requestContext.setContext(this);
    try {
        MergedSender cm = mergedSenderFactory.create(project, changeId);
        if (submitter != null) {
            cm.setFrom(submitter);
        }
        cm.setNotify(notifyHandling);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + changeId, e);
    } finally {
        requestContext.setContext(old);
        if (db != null) {
            db.close();
            db = null;
        }
    }
}
#end_block

#method_before
@Override
protected boolean beforeInit(SiteInit init) throws Exception {
    ErrorLogFile.errorOnlyConsole();
    if (!skipPlugins) {
        final List<PluginData> plugins = InitPlugins.listPluginsAndRemoveTempFiles(init.site, pluginsDistribution);
        ConsoleUI ui = ConsoleUI.getInstance(false);
        if (installAllPlugins && !nullOrEmpty(installPlugins)) {
            ui.message("Conflicting plugin installation options.\n");
            return true;
        }
        verifyInstallPluginList(ui, plugins);
        if (listPlugins) {
            if (!plugins.isEmpty()) {
                ui.message("Available plugins:\n");
                for (PluginData plugin : plugins) {
                    ui.message(" * %s version %s\n", plugin.name, plugin.version);
                }
            } else {
                ui.message("No plugins found.\n");
            }
            return true;
        }
    }
    return false;
}
#method_after
@Override
protected boolean beforeInit(SiteInit init) throws Exception {
    ErrorLogFile.errorOnlyConsole();
    if (!skipPlugins) {
        final List<PluginData> plugins = InitPlugins.listPluginsAndRemoveTempFiles(init.site, pluginsDistribution);
        ConsoleUI ui = ConsoleUI.getInstance(false);
        if (installAllPlugins && !nullOrEmpty(installPlugins)) {
            ui.message("Cannot use --install-plugin together with --install-all-plugins.\n");
            return true;
        }
        verifyInstallPluginList(ui, plugins);
        if (listPlugins) {
            if (!plugins.isEmpty()) {
                ui.message("Available plugins:\n");
                for (PluginData plugin : plugins) {
                    ui.message(" * %s version %s\n", plugin.name, plugin.version);
                }
            } else {
                ui.message("No plugins found.\n");
            }
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "same change-id in multiple changes. Squash the commits with the same change-id or " + "ensure change-ids are unique for each commit");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
public RevTree merge(Repository repo, RevWalk rw, RevCommit merge, ThreeWayMergeStrategy mergeStrategy) throws IOException {
    String hash = merge.name();
    String refName = RefNames.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2);
    Ref ref = repo.getRefDatabase().exactRef(refName);
    if (ref != null && ref.getObjectId() != null) {
        return rw.parseTree(ref.getObjectId());
    }
    ResolveMerger m = (ResolveMerger) mergeStrategy.newMerger(repo, true);
    try (ObjectInserter ins = repo.newObjectInserter()) {
        DirCache dc = DirCache.newInCore();
        m.setDirCache(dc);
        m.setObjectInserter(new ObjectInserter.Filter() {

            @Override
            protected ObjectInserter delegate() {
                return ins;
            }

            @Override
            public void flush() {
            }

            @Override
            public void close() {
            }
        });
        boolean couldMerge;
        try {
            couldMerge = m.merge(merge.getParents());
        } catch (IOException e) {
            // It is not safe to continue further down in this method as throwing
            // an exception most likely means that the merge tree was not created
            // and m.getMergeResults() is empty. This would mean that all paths are
            // unmerged and Gerrit UI would show all paths in the patch list.
            log.warn("Error attempting automerge " + refName, e);
            return null;
        }
        ObjectId treeId;
        if (couldMerge) {
            treeId = m.getResultTreeId();
        } else {
            RevCommit ours = merge.getParent(0);
            RevCommit theirs = merge.getParent(1);
            rw.parseBody(ours);
            rw.parseBody(theirs);
            String oursMsg = ours.getShortMessage();
            String theirsMsg = theirs.getShortMessage();
            String oursName = String.format("HEAD   (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60)));
            String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60)));
            MergeFormatter fmt = new MergeFormatter();
            Map<String, MergeResult<? extends Sequence>> r = m.getMergeResults();
            Map<String, ObjectId> resolved = new HashMap<>();
            for (Map.Entry<String, MergeResult<? extends Sequence>> entry : r.entrySet()) {
                MergeResult<? extends Sequence> p = entry.getValue();
                try (TemporaryBuffer buf = new TemporaryBuffer.LocalFile(null, 10 * 1024 * 1024)) {
                    fmt.formatMerge(buf, p, "BASE", oursName, theirsName, UTF_8.name());
                    buf.close();
                    try (InputStream in = buf.openInputStream()) {
                        resolved.put(entry.getKey(), ins.insert(Constants.OBJ_BLOB, buf.length(), in));
                    }
                }
            }
            DirCacheBuilder builder = dc.builder();
            int cnt = dc.getEntryCount();
            for (int i = 0; i < cnt; ) {
                DirCacheEntry entry = dc.getEntry(i);
                if (entry.getStage() == 0) {
                    builder.add(entry);
                    i++;
                    continue;
                }
                int next = dc.nextEntry(i);
                String path = entry.getPathString();
                DirCacheEntry res = new DirCacheEntry(path);
                if (resolved.containsKey(path)) {
                    // For a file with content merge conflict that we produced a result
                    // above on, collapse the file down to a single stage 0 with just
                    // the blob content, and a randomly selected mode (the lowest stage,
                    // which should be the merge base, or ours).
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(resolved.get(path));
                } else if (next == i + 1) {
                    // If there is exactly one stage present, shouldn't be a conflict...
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else if (next == i + 2) {
                    // Two stages suggests a delete/modify conflict. Pick the higher
                    // stage as the automatic result.
                    entry = dc.getEntry(i + 1);
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else {
                    // 3 stage conflict, no resolve above
                    // Punt on the 3-stage conflict and show the base, for now.
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                }
                builder.add(res);
                i = next;
            }
            builder.finish();
            treeId = dc.writeTree(ins);
        }
        ins.flush();
        RefUpdate update = repo.updateRef(refName);
        update.setNewObjectId(treeId);
        update.disableRefLog();
        update.forceUpdate();
        return rw.lookupTree(treeId);
    }
}
#method_after
public RevTree merge(Repository repo, RevWalk rw, RevCommit merge, ThreeWayMergeStrategy mergeStrategy) throws IOException {
    rw.parseHeaders(merge);
    String hash = merge.name();
    String refName = RefNames.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2);
    Ref ref = repo.getRefDatabase().exactRef(refName);
    if (ref != null && ref.getObjectId() != null) {
        return rw.parseTree(ref.getObjectId());
    }
    ResolveMerger m = (ResolveMerger) mergeStrategy.newMerger(repo, true);
    try (ObjectInserter ins = repo.newObjectInserter()) {
        DirCache dc = DirCache.newInCore();
        m.setDirCache(dc);
        m.setObjectInserter(new ObjectInserter.Filter() {

            @Override
            protected ObjectInserter delegate() {
                return ins;
            }

            @Override
            public void flush() {
            }

            @Override
            public void close() {
            }
        });
        boolean couldMerge;
        try {
            couldMerge = m.merge(merge.getParents());
        } catch (IOException e) {
            // It is not safe to continue further down in this method as throwing
            // an exception most likely means that the merge tree was not created
            // and m.getMergeResults() is empty. This would mean that all paths are
            // unmerged and Gerrit UI would show all paths in the patch list.
            log.warn("Error attempting automerge " + refName, e);
            return null;
        }
        ObjectId treeId;
        if (couldMerge) {
            treeId = m.getResultTreeId();
        } else {
            RevCommit ours = merge.getParent(0);
            RevCommit theirs = merge.getParent(1);
            rw.parseBody(ours);
            rw.parseBody(theirs);
            String oursMsg = ours.getShortMessage();
            String theirsMsg = theirs.getShortMessage();
            String oursName = String.format("HEAD   (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60)));
            String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60)));
            MergeFormatter fmt = new MergeFormatter();
            Map<String, MergeResult<? extends Sequence>> r = m.getMergeResults();
            Map<String, ObjectId> resolved = new HashMap<>();
            for (Map.Entry<String, MergeResult<? extends Sequence>> entry : r.entrySet()) {
                MergeResult<? extends Sequence> p = entry.getValue();
                try (TemporaryBuffer buf = new TemporaryBuffer.LocalFile(null, 10 * 1024 * 1024)) {
                    fmt.formatMerge(buf, p, "BASE", oursName, theirsName, UTF_8.name());
                    buf.close();
                    try (InputStream in = buf.openInputStream()) {
                        resolved.put(entry.getKey(), ins.insert(Constants.OBJ_BLOB, buf.length(), in));
                    }
                }
            }
            DirCacheBuilder builder = dc.builder();
            int cnt = dc.getEntryCount();
            for (int i = 0; i < cnt; ) {
                DirCacheEntry entry = dc.getEntry(i);
                if (entry.getStage() == 0) {
                    builder.add(entry);
                    i++;
                    continue;
                }
                int next = dc.nextEntry(i);
                String path = entry.getPathString();
                DirCacheEntry res = new DirCacheEntry(path);
                if (resolved.containsKey(path)) {
                    // For a file with content merge conflict that we produced a result
                    // above on, collapse the file down to a single stage 0 with just
                    // the blob content, and a randomly selected mode (the lowest stage,
                    // which should be the merge base, or ours).
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(resolved.get(path));
                } else if (next == i + 1) {
                    // If there is exactly one stage present, shouldn't be a conflict...
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else if (next == i + 2) {
                    // Two stages suggests a delete/modify conflict. Pick the higher
                    // stage as the automatic result.
                    entry = dc.getEntry(i + 1);
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else {
                    // 3 stage conflict, no resolve above
                    // Punt on the 3-stage conflict and show the base, for now.
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                }
                builder.add(res);
                i = next;
            }
            builder.finish();
            treeId = dc.writeTree(ins);
        }
        ins.flush();
        RefUpdate update = repo.updateRef(refName);
        update.setNewObjectId(treeId);
        update.disableRefLog();
        update.forceUpdate();
        return rw.lookupTree(treeId);
    }
}
#end_block

#method_before
public RevCommit merge(Repository repo, RevWalk rw, RevCommit merge, ThreeWayMergeStrategy mergeStrategy) throws IOException {
    String hash = merge.name();
    String refName = RefNames.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2);
    Ref ref = repo.getRefDatabase().exactRef(refName);
    if (ref != null && ref.getObjectId() != null) {
        RevObject obj = rw.parseAny(ref.getObjectId());
        if (obj instanceof RevCommit) {
            return (RevCommit) obj;
        }
        return commit(repo, rw, refName, obj, merge.getParents());
    }
    ResolveMerger m = (ResolveMerger) mergeStrategy.newMerger(repo, true);
    try (ObjectInserter ins = repo.newObjectInserter()) {
        DirCache dc = DirCache.newInCore();
        m.setDirCache(dc);
        m.setObjectInserter(new ObjectInserter.Filter() {

            @Override
            protected ObjectInserter delegate() {
                return ins;
            }

            @Override
            public void flush() {
            }

            @Override
            public void close() {
            }
        });
        boolean couldMerge;
        try {
            couldMerge = m.merge(merge.getParents());
        } catch (IOException e) {
            // It is not safe to continue further down in this method as throwing
            // an exception most likely means that the merge tree was not created
            // and m.getMergeResults() is empty. This would mean that all paths are
            // unmerged and Gerrit UI would show all paths in the patch list.
            log.warn("Error attempting automerge " + refName, e);
            return null;
        }
        ObjectId treeId;
        if (couldMerge) {
            treeId = m.getResultTreeId();
        } else {
            RevCommit ours = merge.getParent(0);
            RevCommit theirs = merge.getParent(1);
            rw.parseBody(ours);
            rw.parseBody(theirs);
            String oursMsg = ours.getShortMessage();
            String theirsMsg = theirs.getShortMessage();
            String oursName = String.format("HEAD   (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60)));
            String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60)));
            MergeFormatter fmt = new MergeFormatter();
            Map<String, MergeResult<? extends Sequence>> r = m.getMergeResults();
            Map<String, ObjectId> resolved = new HashMap<>();
            for (Map.Entry<String, MergeResult<? extends Sequence>> entry : r.entrySet()) {
                MergeResult<? extends Sequence> p = entry.getValue();
                try (TemporaryBuffer buf = new TemporaryBuffer.LocalFile(null, 10 * 1024 * 1024)) {
                    fmt.formatMerge(buf, p, "BASE", oursName, theirsName, UTF_8.name());
                    buf.close();
                    try (InputStream in = buf.openInputStream()) {
                        resolved.put(entry.getKey(), ins.insert(Constants.OBJ_BLOB, buf.length(), in));
                    }
                }
            }
            DirCacheBuilder builder = dc.builder();
            int cnt = dc.getEntryCount();
            for (int i = 0; i < cnt; ) {
                DirCacheEntry entry = dc.getEntry(i);
                if (entry.getStage() == 0) {
                    builder.add(entry);
                    i++;
                    continue;
                }
                int next = dc.nextEntry(i);
                String path = entry.getPathString();
                DirCacheEntry res = new DirCacheEntry(path);
                if (resolved.containsKey(path)) {
                    // For a file with content merge conflict that we produced a result
                    // above on, collapse the file down to a single stage 0 with just
                    // the blob content, and a randomly selected mode (the lowest stage,
                    // which should be the merge base, or ours).
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(resolved.get(path));
                } else if (next == i + 1) {
                    // If there is exactly one stage present, shouldn't be a conflict...
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else if (next == i + 2) {
                    // Two stages suggests a delete/modify conflict. Pick the higher
                    // stage as the automatic result.
                    entry = dc.getEntry(i + 1);
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else {
                    // 3 stage conflict, no resolve above
                    // Punt on the 3-stage conflict and show the base, for now.
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                }
                builder.add(res);
                i = next;
            }
            builder.finish();
            treeId = dc.writeTree(ins);
        }
        ins.flush();
        return commit(repo, rw, refName, treeId, merge.getParents());
    }
}
#method_after
public RevCommit merge(Repository repo, RevWalk rw, RevCommit merge, ThreeWayMergeStrategy mergeStrategy) throws IOException {
    rw.parseHeaders(merge);
    String hash = merge.name();
    String refName = RefNames.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2);
    Ref ref = repo.getRefDatabase().exactRef(refName);
    if (ref != null && ref.getObjectId() != null) {
        RevObject obj = rw.parseAny(ref.getObjectId());
        if (obj instanceof RevCommit) {
            return (RevCommit) obj;
        }
        return commit(repo, rw, refName, obj, merge);
    }
    ResolveMerger m = (ResolveMerger) mergeStrategy.newMerger(repo, true);
    try (ObjectInserter ins = repo.newObjectInserter()) {
        DirCache dc = DirCache.newInCore();
        m.setDirCache(dc);
        m.setObjectInserter(new ObjectInserter.Filter() {

            @Override
            protected ObjectInserter delegate() {
                return ins;
            }

            @Override
            public void flush() {
            }

            @Override
            public void close() {
            }
        });
        boolean couldMerge;
        try {
            couldMerge = m.merge(merge.getParents());
        } catch (IOException e) {
            // It is not safe to continue further down in this method as throwing
            // an exception most likely means that the merge tree was not created
            // and m.getMergeResults() is empty. This would mean that all paths are
            // unmerged and Gerrit UI would show all paths in the patch list.
            log.warn("Error attempting automerge " + refName, e);
            return null;
        }
        ObjectId treeId;
        if (couldMerge) {
            treeId = m.getResultTreeId();
        } else {
            RevCommit ours = merge.getParent(0);
            RevCommit theirs = merge.getParent(1);
            rw.parseBody(ours);
            rw.parseBody(theirs);
            String oursMsg = ours.getShortMessage();
            String theirsMsg = theirs.getShortMessage();
            String oursName = String.format("HEAD   (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60)));
            String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60)));
            MergeFormatter fmt = new MergeFormatter();
            Map<String, MergeResult<? extends Sequence>> r = m.getMergeResults();
            Map<String, ObjectId> resolved = new HashMap<>();
            for (Map.Entry<String, MergeResult<? extends Sequence>> entry : r.entrySet()) {
                MergeResult<? extends Sequence> p = entry.getValue();
                try (TemporaryBuffer buf = new TemporaryBuffer.LocalFile(null, 10 * 1024 * 1024)) {
                    fmt.formatMerge(buf, p, "BASE", oursName, theirsName, UTF_8.name());
                    buf.close();
                    try (InputStream in = buf.openInputStream()) {
                        resolved.put(entry.getKey(), ins.insert(Constants.OBJ_BLOB, buf.length(), in));
                    }
                }
            }
            DirCacheBuilder builder = dc.builder();
            int cnt = dc.getEntryCount();
            for (int i = 0; i < cnt; ) {
                DirCacheEntry entry = dc.getEntry(i);
                if (entry.getStage() == 0) {
                    builder.add(entry);
                    i++;
                    continue;
                }
                int next = dc.nextEntry(i);
                String path = entry.getPathString();
                DirCacheEntry res = new DirCacheEntry(path);
                if (resolved.containsKey(path)) {
                    // For a file with content merge conflict that we produced a result
                    // above on, collapse the file down to a single stage 0 with just
                    // the blob content, and a randomly selected mode (the lowest stage,
                    // which should be the merge base, or ours).
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(resolved.get(path));
                } else if (next == i + 1) {
                    // If there is exactly one stage present, shouldn't be a conflict...
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else if (next == i + 2) {
                    // Two stages suggests a delete/modify conflict. Pick the higher
                    // stage as the automatic result.
                    entry = dc.getEntry(i + 1);
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else {
                    // 3 stage conflict, no resolve above
                    // Punt on the 3-stage conflict and show the base, for now.
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                }
                builder.add(res);
                i = next;
            }
            builder.finish();
            treeId = dc.writeTree(ins);
        }
        ins.flush();
        return commit(repo, rw, refName, treeId, merge);
    }
}
#end_block

#method_before
private RevCommit commit(Repository repo, RevWalk rw, String refName, ObjectId tree, RevCommit[] parents) throws IOException {
    CommitBuilder cb = new CommitBuilder();
    cb.setAuthor(gerritIdent);
    cb.setCommitter(gerritIdent);
    cb.setTreeId(tree);
    for (RevCommit p : parents) {
        cb.addParentId(p);
    }
    ObjectId commitId;
    try (ObjectInserter inserter = repo.newObjectInserter()) {
        commitId = inserter.insert(cb);
        inserter.flush();
    }
    RefUpdate update = repo.updateRef(refName);
    update.setNewObjectId(commitId);
    update.disableRefLog();
    update.forceUpdate();
    return rw.lookupCommit(commitId);
}
#method_after
private RevCommit commit(Repository repo, RevWalk rw, String refName, ObjectId tree, RevCommit merge) throws IOException {
    rw.parseHeaders(merge);
    // For maximum stability, choose a single ident using the committer time of
    // the input commit, using the server name and timezone.
    PersonIdent ident = new PersonIdent(gerritIdent, merge.getCommitterIdent().getWhen(), gerritIdent.getTimeZone());
    CommitBuilder cb = new CommitBuilder();
    cb.setAuthor(ident);
    cb.setCommitter(ident);
    cb.setTreeId(tree);
    cb.setMessage("Auto-merge of " + merge.name() + '\n');
    for (RevCommit p : merge.getParents()) {
        cb.addParentId(p);
    }
    ObjectId commitId;
    try (ObjectInserter ins = repo.newObjectInserter()) {
        commitId = ins.insert(cb);
        ins.flush();
    }
    RefUpdate ru = repo.updateRef(refName);
    ru.setNewObjectId(commitId);
    ru.disableRefLog();
    ru.forceUpdate();
    return rw.parseCommit(commitId);
}
#end_block

#method_before
private RevTree aFor(RevCommit b, RevWalk walk) throws IOException {
    switch(b.getParentCount()) {
        case 0:
            return walk.parseTree(emptyTree());
        case 1:
            RevCommit a = b.getParent(0);
            walk.parseBody(a);
            return walk.parseTree(a.getTree());
        case 2:
            return autoMerger.merge(repo, walk, b, mergeStrategy).getTree();
        default:
            return null;
    }
}
#method_after
private RevTree aFor(RevCommit b, RevWalk walk) throws IOException {
    switch(b.getParentCount()) {
        case 0:
            return walk.parseTree(emptyTree());
        case 1:
            RevCommit a = b.getParent(0);
            walk.parseBody(a);
            return walk.parseTree(a.getTree());
        case 2:
            RevCommit am = autoMerger.merge(repo, walk, b, mergeStrategy);
            return am == null ? null : am.getTree();
        default:
            return null;
    }
}
#end_block

#method_before
@Override
public String toString() {
    return new StringBuilder().append('[').append(key).append(": ").append(value).append(']').toString();
}
#method_after
@Override
public String toString() {
    return new StringBuilder().append('[').append(key).append(": ").append(value).append(",tag:").append(tag).append(']').toString();
}
#end_block

#method_before
@Override
public String toString() {
    return "ChangeMessage{" + "key=" + key + ", author=" + author + ", writtenOn=" + writtenOn + ", patchset=" + patchset + ", message=[" + message + ", tag=[" + tag + "]}";
}
#method_after
@Override
public String toString() {
    return "ChangeMessage{" + "key=" + key + ", author=" + author + ", writtenOn=" + writtenOn + ", patchset=" + patchset + ", tag=" + tag + ", message=[" + message + "]}";
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, notes, ps, user, message, comments).sendAsync();
    }
    try {
        hooks.doCommentAddedHook(notes.getChange(), user.getAccount(), ps, message.getMessage(), categories, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, notes, ps, user, message, comments).sendAsync();
    }
    try {
        hooks.doCommentAddedHook(notes.getChange(), user.getAccount(), ps, message.getMessage(), approvals, oldApprovals, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(ctx.getWhen());
                setCommentRevId(e, patchListCache, ctx.getChange(), ps);
                ups.add(e);
            }
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    // TODO(dborowitz): Currently doesn't work for PUBLISH_ALL_REVISIONS with
    // notedb.
    plcUtil.deleteComments(ctx.getDb(), u, del);
    plcUtil.putComments(ctx.getDb(), u, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            e.setTag(in.tag);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                ups.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, ups);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    plcUtil.deleteComments(ctx.getDb(), u, del);
    plcUtil.putComments(ctx.getDb(), u, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getNotes(), user.getAccountId())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#method_after
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getNotes(), user.getAccountId())) {
        c.setTag(in.tag);
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#end_block

#method_before
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> labels = in.labels;
    if (labels == null) {
        labels = Collections.emptyMap();
    }
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ups = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    ChangeUpdate update = ctx.getUpdate(psId);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (Map.Entry<String, Short> ent : labels.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                }
                del.add(c);
                update.putApproval(ent.getKey(), (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            categories.put(normName, c.getValue());
            update.putApproval(ent.getKey(), ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen(), in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            categories.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(ent.getKey(), ent.getValue());
        }
    }
    if (!del.isEmpty() || !ups.isEmpty()) {
        if (ctx.getChange().getStatus().isClosed()) {
            throw new ResourceConflictException("change is closed");
        }
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ups = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    // get all approvals in cases of quick approve vote
    Map<String, Short> allApprovals = approvalsByKey(current.values());
    allApprovals.putAll(inLabels);
    // get previous label votes
    Map<String, Short> currentLabels = new HashMap<>();
    for (Map.Entry<String, PatchSetApproval> ent : current.entrySet()) {
        currentLabels.put(ent.getValue().getLabel(), ent.getValue().getValue());
    }
    Map<String, Short> previous = new HashMap<>();
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        if (!currentLabels.containsKey(ent.getKey())) {
            previous.put(ent.getKey(), (short) 0);
        } else {
            previous.put(ent.getKey(), currentLabels.get(ent.getKey()));
        }
    }
    ChangeUpdate update = ctx.getUpdate(psId);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    if ((!del.isEmpty() || !ups.isEmpty()) && ctx.getChange().getStatus().isClosed()) {
        throw new ResourceConflictException("change is closed");
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen(), in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#method_after
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#end_block

#method_before
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId, in.tag);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#method_after
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setTag(in.tag);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#end_block

#method_before
@Test
public void testWithSubmodule() throws Exception {
    RevCommit c = makeCommitWithSubmodule();
    List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c);
    assertThat(m).hasSize(1);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("submodules are not allowed: modules/library", true));
    assertThat(TestUtils.transformMessages(m)).containsAllIn(expected);
}
#method_after
@Test
public void testWithSubmodule() throws Exception {
    RevCommit c = makeCommitWithSubmodule();
    List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c);
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(ImmutableSet.of("ERROR: submodules are not allowed: modules/library"));
}
#end_block

#method_before
@Test
public void testWithSymlink() throws Exception {
    RevCommit c = makeCommitWithSymlink();
    List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, c);
    assertThat(m).hasSize(2);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("Symbolic links are not allowed: foo.txt", true));
    expected.add(new ComparableCommitValidationMessage("Symbolic links are not allowed: symbolicFolder", true));
    assertThat(TestUtils.transformMessages(m)).containsAllIn(expected);
}
#method_after
@Test
public void testWithSymlink() throws Exception {
    RevCommit c = makeCommitWithSymlink();
    List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, c);
    Set<String> expected = ImmutableSet.of("ERROR: Symbolic links are not allowed: foo.txt", "ERROR: Symbolic links are not allowed: symbolicFolder");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!doCheckBlockedKeywords(cfg)) {
            return Collections.emptyList();
        }
        ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays.asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)));
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, blockedKeywordPatterns.values());
            if (!messages.isEmpty()) {
                throw new CommitValidationException("includes files containing blocked keywords", messages);
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on blocked keywords", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays.asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)));
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, blockedKeywordPatterns.values());
            if (!messages.isEmpty()) {
                throw new CommitValidationException("includes files containing blocked keywords", messages);
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on blocked keywords", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "[@:]", "[#%*]" };
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    for (String filenames : getInvalidFilenames()) {
        expected.add(new ComparableCommitValidationMessage("invalid characters found in filename: " + filenames, true));
    }
    assertThat(m).hasSize(5);
    assertThat(TestUtils.transformMessages(m)).containsAllIn(expected);
}
#method_after
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "[@:]", "[#%*]" };
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern);
    Set<String> expected = new HashSet<>();
    for (String filenames : getInvalidFilenames()) {
        expected.add("ERROR: invalid characters found in filename: " + filenames);
    }
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!doCheckSubmodules(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains submodules", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on submodules", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains submodules", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on submodules", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Test
public void testCarriageReturn() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    assertThat(m).hasSize(1);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("found carriage return (CR) character in file: foo.txt", true));
    assertThat(TestUtils.transformMessages(m)).containsAllIn(expected);
}
#method_after
@Test
public void testCarriageReturn() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(ImmutableSet.of("ERROR: found carriage return (CR) character in file: foo.txt"));
}
#end_block

#method_before
@Test
public void testCarriageReturnWithBinaries() throws Exception {
    RevCommit c = makeCommitWithPseudoBinaries();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    assertThat(m).hasSize(2);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("found carriage return (CR) character in file: foo.jpeg", true));
    expected.add(new ComparableCommitValidationMessage("found carriage return (CR) character in file: foo.iso", true));
    assertThat(TestUtils.transformMessages(m)).containsAllIn(expected);
}
#method_after
@Test
public void testCarriageReturnWithBinaries() throws Exception {
    RevCommit c = makeCommitWithPseudoBinaries();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    Set<String> expected = ImmutableSet.of("ERROR: found carriage return (CR) character in file: foo.jpeg", "ERROR: found carriage return (CR) character in file: foo.iso");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
public static Collection<ComparableCommitValidationMessage> transformMessages(List<CommitValidationMessage> messages) {
    return Collections2.transform(messages, new Function<CommitValidationMessage, ComparableCommitValidationMessage>() {

        @Override
        public ComparableCommitValidationMessage apply(CommitValidationMessage input) {
            return new ComparableCommitValidationMessage(input.getMessage(), input.isError());
        }
    });
}
#method_after
public static List<String> transformMessages(List<CommitValidationMessage> messages) {
    return Lists.transform(messages, new Function<CommitValidationMessage, String>() {

        @Override
        public String apply(CommitValidationMessage input) {
            String pre = (input.isError()) ? "ERROR: " : "MSG: ";
            return pre + input.getMessage();
        }
    });
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!doCheckInvalidLineEndings(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, Sets.newHashSet(cfg.getStringList(KEY_IGNORE_FILES)));
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains files with a Windows line ending", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on Windows line endings", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, Sets.newHashSet(cfg.getStringList(KEY_IGNORE_FILES)));
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains files with a Windows line ending", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on Windows line endings", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
private RevCommit makeCommit() throws NoFilepatternException, IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: bla bla bla$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit with test files.", files);
}
#method_after
private RevCommit makeCommit() throws NoFilepatternException, IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: foo bar$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit with test files.", files);
}
#end_block

#method_before
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = BlockedKeywordValidator.performValidation(repo, c, getPatterns().values());
    assertThat(m).hasSize(2);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("blocked keyword(s) found in file: foo.txt (Line: 1) " + "(found: myp4ssw0rd, foobar)", true));
    expected.add(new ComparableCommitValidationMessage("blocked keyword(s) found in file: bar.txt (Line: 5) " + "(found: $Id: bla bla bla$)", true));
    assertThat(TestUtils.transformMessages(m)).containsAllIn(expected);
}
#method_after
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = BlockedKeywordValidator.performValidation(repo, c, getPatterns().values());
    Set<String> expected = ImmutableSet.of("ERROR: blocked keyword(s) found in file: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)", "ERROR: blocked keyword(s) found in file: bar.txt (Line: 5)" + " (found: $Id: foo bar$)");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!doCheckSymlinks(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains symbolic links", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on symbolic links", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains symbolic links", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on symbolic links", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!doCheckInvalidFilenames(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, cfg.getStringList(KEY_INVALID_FILENAME_PATTERN));
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains files with an invalid filename", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on invalid file names", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        if (!isActive(cfg)) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, cfg.getStringList(KEY_INVALID_FILENAME_PATTERN));
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains files with an invalid filename", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on invalid file names", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Test
public void testWithSubmodule() throws Exception {
    RevCommit c = makeCommitWithSubmodule();
    List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c);
    assertThat(m).hasSize(1);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("submodules are not allowed: modules/library", true));
    assertThat(TestUtils.transformMessages(m)).containsAnyIn(expected);
}
#method_after
@Test
public void testWithSubmodule() throws Exception {
    RevCommit c = makeCommitWithSubmodule();
    List<CommitValidationMessage> m = SubmoduleValidator.performValidation(repo, c);
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(ImmutableSet.of("ERROR: submodules are not allowed: modules/library"));
}
#end_block

#method_before
@Test
public void testCarriageReturn() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    assertThat(m).hasSize(1);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("found carriage return (CR) character in file: foo.txt", true));
    assertThat(TestUtils.transformMessages(m)).containsAnyIn(expected);
}
#method_after
@Test
public void testCarriageReturn() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(ImmutableSet.of("ERROR: found carriage return (CR) character in file: foo.txt"));
}
#end_block

#method_before
@Test
public void testCarriageReturnWithBinaries() throws Exception {
    RevCommit c = makeCommitWithPseudoBinaries();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    assertThat(m).hasSize(2);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("found carriage return (CR) character in file: foo.jpeg", true));
    expected.add(new ComparableCommitValidationMessage("found carriage return (CR) character in file: foo.iso", true));
    assertThat(TestUtils.transformMessages(m)).containsAnyIn(expected);
}
#method_after
@Test
public void testCarriageReturnWithBinaries() throws Exception {
    RevCommit c = makeCommitWithPseudoBinaries();
    List<CommitValidationMessage> m = InvalidLineEndingValidator.performValidation(repo, c, Sets.newHashSet(new String[] { "" }));
    Set<String> expected = ImmutableSet.of("ERROR: found carriage return (CR) character in file: foo.jpeg", "ERROR: found carriage return (CR) character in file: foo.iso");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
public static Collection<ComparableCommitValidationMessage> transformMessages(List<CommitValidationMessage> messages) {
    return Collections2.transform(messages, new Function<CommitValidationMessage, ComparableCommitValidationMessage>() {

        @Override
        public ComparableCommitValidationMessage apply(CommitValidationMessage input) {
            return new ComparableCommitValidationMessage(input.getMessage(), input.isError());
        }
    });
}
#method_after
public static List<String> transformMessages(List<CommitValidationMessage> messages) {
    return Lists.transform(messages, new Function<CommitValidationMessage, String>() {

        @Override
        public String apply(CommitValidationMessage input) {
            String pre = (input.isError()) ? "ERROR: " : "MSG: ";
            return pre + input.getMessage();
        }
    });
}
#end_block

#method_before
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "[@:]", "[#%*]" };
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    for (String filenames : getInvalidFilenames()) {
        expected.add(new ComparableCommitValidationMessage("invalid characters found in filename: " + filenames, true));
    }
    assertThat(m).hasSize(5);
    assertThat(TestUtils.transformMessages(m)).containsAnyIn(expected);
}
#method_after
@Test
public void test() throws Exception {
    String[] invalidFilenamePattern = { "[@:]", "[#%*]" };
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern);
    Set<String> expected = new HashSet<>();
    for (String filenames : getInvalidFilenames()) {
        expected.add("ERROR: invalid characters found in filename: " + filenames);
    }
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
private RevCommit makeCommit() throws NoFilepatternException, IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: bla bla bla$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit with test files.", files);
}
#method_after
private RevCommit makeCommit() throws NoFilepatternException, IOException, GitAPIException {
    Map<File, byte[]> files = new HashMap<>();
    // invalid files
    String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n";
    files.put(new File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(StandardCharsets.UTF_8));
    content = "$Id$\n" + "$Header$\n" + "$Author$\n" + "processXFile($File::Find::name, $Config{$type});\n" + "$Id: foo bar$\n";
    files.put(new File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(StandardCharsets.UTF_8));
    // valid file
    content = "Testline1\n" + "Testline2\n" + "Testline3\n" + "Testline4";
    files.put(new File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(StandardCharsets.UTF_8));
    return TestUtils.makeCommit(repo, "Commit with test files.", files);
}
#end_block

#method_before
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = BlockedKeywordValidator.performValidation(repo, c, getPatterns().values());
    assertThat(m).hasSize(2);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("blocked keyword(s) found in file: foo.txt (Line: 1) " + "(found: myp4ssw0rd, foobar)", true));
    expected.add(new ComparableCommitValidationMessage("blocked keyword(s) found in file: bar.txt (Line: 5) " + "(found: $Id: bla bla bla$)", true));
    assertThat(TestUtils.transformMessages(m)).containsAnyIn(expected);
}
#method_after
@Test
public void testKeywords() throws Exception {
    RevCommit c = makeCommit();
    List<CommitValidationMessage> m = BlockedKeywordValidator.performValidation(repo, c, getPatterns().values());
    Set<String> expected = ImmutableSet.of("ERROR: blocked keyword(s) found in file: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)", "ERROR: blocked keyword(s) found in file: bar.txt (Line: 5)" + " (found: $Id: foo bar$)");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithSymlink() throws Exception {
    RevCommit c = makeCommitWithSymlink();
    List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, c);
    assertThat(m).hasSize(2);
    List<ComparableCommitValidationMessage> expected = new ArrayList<>();
    expected.add(new ComparableCommitValidationMessage("Symbolic links are not allowed: foo.txt", true));
    expected.add(new ComparableCommitValidationMessage("Symbolic links are not allowed: symbolicFolder", true));
    assertThat(TestUtils.transformMessages(m)).containsAnyIn(expected);
}
#method_after
@Test
public void testWithSymlink() throws Exception {
    RevCommit c = makeCommitWithSymlink();
    List<CommitValidationMessage> m = SymlinkValidator.performValidation(repo, c);
    Set<String> expected = ImmutableSet.of("ERROR: Symbolic links are not allowed: foo.txt", "ERROR: Symbolic links are not allowed: symbolicFolder");
    assertThat(TestUtils.transformMessages(m)).containsExactlyElementsIn(expected);
}
#end_block

#method_before
public void putComment(PatchLineComment c) {
    verifyComment(c);
    checkArgument(c.getStatus() == PatchLineComment.Status.DRAFT, "Cannot insert a published comment into a ChangeDraftUpdate");
    put.put(key(c), c);
}
#method_after
public void putComment(PatchLineComment c) {
    verifyComment(c);
    checkArgument(c.getStatus() == PatchLineComment.Status.DRAFT, "Cannot insert a published comment into a ChangeDraftUpdate");
    put.add(c);
}
#end_block

#method_before
private CommitBuilder storeCommentsInNotes(RevWalk rw, ObjectInserter ins, ObjectId curr, CommitBuilder cb) throws ConfigInvalidException, OrmException, IOException {
    RevisionNoteMap rnm = getRevisionNoteMap(rw, curr);
    Set<RevId> updatedRevs = Sets.newHashSetWithExpectedSize(rnm.revisionNotes.size());
    RevisionNoteBuilder.Cache cache = new RevisionNoteBuilder.Cache(rnm);
    for (PatchLineComment c : put.values()) {
        if (!delete.contains(key(c))) {
            cache.get(c.getRevId()).putComment(c);
        }
    }
    for (Key k : delete) {
        cache.get(k.revId()).deleteComment(k.key());
    }
    Map<RevId, RevisionNoteBuilder> builders = cache.getBuilders();
    boolean touchedAnyRevs = false;
    boolean hasComments = false;
    for (Map.Entry<RevId, RevisionNoteBuilder> e : builders.entrySet()) {
        updatedRevs.add(e.getKey());
        ObjectId id = ObjectId.fromString(e.getKey().get());
        byte[] data = e.getValue().build(noteUtil);
        if (!Arrays.equals(data, e.getValue().baseRaw)) {
            touchedAnyRevs = true;
        }
        if (data.length == 0) {
            rnm.noteMap.remove(id);
        } else {
            hasComments = true;
            ObjectId dataBlob = ins.insert(OBJ_BLOB, data);
            rnm.noteMap.set(id, dataBlob);
        }
    }
    // data yet.
    if (!touchedAnyRevs) {
        return NO_OP_UPDATE;
    }
    // If we touched every revision and there are no comments left, tell the
    // caller to delete the entire ref.
    boolean touchedAllRevs = updatedRevs.equals(rnm.revisionNotes.keySet());
    if (touchedAllRevs && !hasComments) {
        return null;
    }
    cb.setTreeId(rnm.noteMap.writeTree(ins));
    return cb;
}
#method_after
private CommitBuilder storeCommentsInNotes(RevWalk rw, ObjectInserter ins, ObjectId curr, CommitBuilder cb) throws ConfigInvalidException, OrmException, IOException {
    RevisionNoteMap rnm = getRevisionNoteMap(rw, curr);
    Set<RevId> updatedRevs = Sets.newHashSetWithExpectedSize(rnm.revisionNotes.size());
    RevisionNoteBuilder.Cache cache = new RevisionNoteBuilder.Cache(rnm);
    for (PatchLineComment c : put) {
        if (!delete.contains(key(c))) {
            cache.get(c.getRevId()).putComment(c);
        }
    }
    for (Key k : delete) {
        cache.get(k.revId()).deleteComment(k.key());
    }
    Map<RevId, RevisionNoteBuilder> builders = cache.getBuilders();
    boolean touchedAnyRevs = false;
    boolean hasComments = false;
    for (Map.Entry<RevId, RevisionNoteBuilder> e : builders.entrySet()) {
        updatedRevs.add(e.getKey());
        ObjectId id = ObjectId.fromString(e.getKey().get());
        byte[] data = e.getValue().build(noteUtil);
        if (!Arrays.equals(data, e.getValue().baseRaw)) {
            touchedAnyRevs = true;
        }
        if (data.length == 0) {
            rnm.noteMap.remove(id);
        } else {
            hasComments = true;
            ObjectId dataBlob = ins.insert(OBJ_BLOB, data);
            rnm.noteMap.set(id, dataBlob);
        }
    }
    // data yet.
    if (!touchedAnyRevs) {
        return NO_OP_UPDATE;
    }
    // If we touched every revision and there are no comments left, tell the
    // caller to delete the entire ref.
    boolean touchedAllRevs = updatedRevs.equals(rnm.revisionNotes.keySet());
    if (touchedAllRevs && !hasComments) {
        return null;
    }
    cb.setTreeId(rnm.noteMap.writeTree(ins));
    return cb;
}
#end_block

#method_before
private RevisionNoteMap getRevisionNoteMap(RevWalk rw, ObjectId curr) throws ConfigInvalidException, OrmException, IOException {
    if (migration.readChanges()) {
        // If reading from changes is enabled, then the old DraftCommentNotes
        // already parsed the revision notes. We can reuse them as long as the ref
        // hasn't advanced.
        DraftCommentNotes draftNotes = getNotes().load().getDraftCommentNotes();
        if (draftNotes != null) {
            ObjectId idFromNotes = firstNonNull(draftNotes.getRevision(), ObjectId.zeroId());
            if (idFromNotes.equals(curr)) {
                return checkNotNull(getNotes().revisionNoteMap);
            }
        }
    }
    NoteMap noteMap;
    if (!curr.equals(ObjectId.zeroId())) {
        noteMap = NoteMap.read(rw.getObjectReader(), rw.parseCommit(curr));
    } else {
        noteMap = NoteMap.newEmptyMap();
    }
    // parse any existing revision notes so we can merge them.
    return RevisionNoteMap.parse(noteUtil, getId(), rw.getObjectReader(), noteMap, true);
}
#method_after
private RevisionNoteMap getRevisionNoteMap(RevWalk rw, ObjectId curr) throws ConfigInvalidException, OrmException, IOException {
    if (migration.readChanges()) {
        // If reading from changes is enabled, then the old DraftCommentNotes
        // already parsed the revision notes. We can reuse them as long as the ref
        // hasn't advanced.
        DraftCommentNotes draftNotes = getNotes().load().getDraftCommentNotes();
        if (draftNotes != null) {
            ObjectId idFromNotes = firstNonNull(draftNotes.getRevision(), ObjectId.zeroId());
            RevisionNoteMap rnm = draftNotes.getRevisionNoteMap();
            if (idFromNotes.equals(curr) && rnm != null) {
                return rnm;
            }
        }
    }
    NoteMap noteMap;
    if (!curr.equals(ObjectId.zeroId())) {
        noteMap = NoteMap.read(rw.getObjectReader(), rw.parseCommit(curr));
    } else {
        noteMap = NoteMap.newEmptyMap();
    }
    // parse any existing revision notes so we can merge them.
    return RevisionNoteMap.parse(noteUtil, getId(), rw.getObjectReader(), noteMap, true);
}
#end_block

#method_before
@Test
public void addingPublishedCommentDoesNotCreateNoOpCommitOnNonEmptyDraftRef() throws Exception {
    Change c = newChange();
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment draft = newComment(ps1, filename, "uuid1", range, range.getEndLine(), otherUser, null, now, "draft comment on ps1", side, rev, Status.DRAFT);
    update.putComment(draft);
    update.commit();
    String draftRef = refsDraftComments(otherUser.getAccountId(), c.getId());
    ObjectId old = exactRefAllUsers(draftRef);
    assertThat(old).isNotNull();
    update = newUpdate(c, otherUser);
    PatchLineComment pub = newComment(ps1, filename, "uuid2", range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    update.putComment(pub);
    update.commit();
    assertThat(exactRefAllUsers(draftRef)).isNotEqualTo(old);
}
#method_after
@Test
public void addingPublishedCommentDoesNotCreateNoOpCommitOnNonEmptyDraftRef() throws Exception {
    Change c = newChange();
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment draft = newComment(ps1, filename, "uuid1", range, range.getEndLine(), otherUser, null, now, "draft comment on ps1", side, rev, Status.DRAFT);
    update.putComment(draft);
    update.commit();
    String draftRef = refsDraftComments(otherUser.getAccountId(), c.getId());
    ObjectId old = exactRefAllUsers(draftRef);
    assertThat(old).isNotNull();
    update = newUpdate(c, otherUser);
    PatchLineComment pub = newComment(ps1, filename, "uuid2", range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.PUBLISHED);
    update.putComment(pub);
    update.commit();
    assertThat(exactRefAllUsers(draftRef)).isEqualTo(old);
}
#end_block

#method_before
byte[] build(ChangeNoteUtil noteUtil) {
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    if (pushCert != null) {
        byte[] certBytes = pushCert.getBytes(UTF_8);
        out.write(certBytes, 0, trimTrailingNewlines(certBytes));
        out.write('\n');
    }
    List<PatchLineComment> all = new ArrayList<>(baseComments.size() + put.size());
    for (PatchLineComment c : Iterables.concat(baseComments, put.values())) {
        if (!delete.contains(c.getKey())) {
            all.add(c);
        }
    }
    Collections.sort(all, PLC_ORDER);
    noteUtil.buildNote(all, out);
    return out.toByteArray();
}
#method_after
byte[] build(ChangeNoteUtil noteUtil) {
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    if (pushCert != null) {
        byte[] certBytes = pushCert.getBytes(UTF_8);
        out.write(certBytes, 0, trimTrailingNewlines(certBytes));
        out.write('\n');
    }
    List<PatchLineComment> all = new ArrayList<>(baseComments.size() + put.size());
    for (PatchLineComment c : baseComments) {
        if (!delete.contains(c.getKey()) && !put.containsKey(c.getKey())) {
            all.add(c);
        }
    }
    for (PatchLineComment c : put.values()) {
        if (!delete.contains(c.getKey())) {
            all.add(c);
        }
    }
    Collections.sort(all, PLC_ORDER);
    noteUtil.buildNote(all, out);
    return out.toByteArray();
}
#end_block

#method_before
@Test
public void testOwnerGroupsForStarFilter() {
    List<String> ownerGroups = Arrays.asList("group1", "group2");
    configureOwnerGroups("*", ownerGroups);
    assertThat(repoCfg.getOwnerGroups(new NameKey("someProject"))).containsExactlyElementsIn(ownerGroups);
}
#method_after
@Test
public void testOwnerGroupsForStarFilter() {
    ImmutableList<String> ownerGroups = ImmutableList.of("group1", "group2");
    configureOwnerGroups("*", ownerGroups);
    assertThat(repoCfg.getOwnerGroups(new NameKey("someProject"))).containsExactlyElementsIn(ownerGroups);
}
#end_block

#method_before
@Test
public void testOwnerGroupsForSpecificFilter() {
    List<String> ownerGroups = Arrays.asList("group1", "group2");
    configureOwnerGroups("someProject", Lists.newArrayList(ownerGroups));
    assertThat(repoCfg.getOwnerGroups(new NameKey("someOtherProject"))).isEmpty();
    assertThat(repoCfg.getOwnerGroups(new NameKey("someProject"))).containsExactlyElementsIn(ownerGroups);
}
#method_after
@Test
public void testOwnerGroupsForSpecificFilter() {
    ImmutableList<String> ownerGroups = ImmutableList.of("group1", "group2");
    configureOwnerGroups("someProject", ownerGroups);
    assertThat(repoCfg.getOwnerGroups(new NameKey("someOtherProject"))).isEmpty();
    assertThat(repoCfg.getOwnerGroups(new NameKey("someProject"))).containsExactlyElementsIn(ownerGroups);
}
#end_block

#method_before
@Test
public void testOwnerGroupsForStartWithFilter() {
    List<String> ownerGroups1 = Arrays.asList("group1");
    List<String> ownerGroups2 = Arrays.asList("group2");
    List<String> ownerGroups3 = Arrays.asList("group3");
    configureOwnerGroups("*", ownerGroups1);
    configureOwnerGroups("somePath/*", ownerGroups2);
    configureOwnerGroups("somePath/somePath/*", ownerGroups3);
    assertThat(repoCfg.getOwnerGroups(new NameKey("someProject"))).containsExactlyElementsIn(ownerGroups1);
    assertThat(repoCfg.getOwnerGroups(new NameKey("somePath/someProject"))).containsExactlyElementsIn(ownerGroups2);
    assertThat(repoCfg.getOwnerGroups(new NameKey("somePath/somePath/someProject"))).containsExactlyElementsIn(ownerGroups3);
}
#method_after
@Test
public void testOwnerGroupsForStartWithFilter() {
    ImmutableList<String> ownerGroups1 = ImmutableList.of("group1");
    ImmutableList<String> ownerGroups2 = ImmutableList.of("group2");
    ImmutableList<String> ownerGroups3 = ImmutableList.of("group3");
    configureOwnerGroups("*", ownerGroups1);
    configureOwnerGroups("somePath/*", ownerGroups2);
    configureOwnerGroups("somePath/somePath/*", ownerGroups3);
    assertThat(repoCfg.getOwnerGroups(new NameKey("someProject"))).containsExactlyElementsIn(ownerGroups1);
    assertThat(repoCfg.getOwnerGroups(new NameKey("somePath/someProject"))).containsExactlyElementsIn(ownerGroups2);
    assertThat(repoCfg.getOwnerGroups(new NameKey("somePath/somePath/someProject"))).containsExactlyElementsIn(ownerGroups3);
}
#end_block

#method_before
@Test
public void testAllBasePath() {
    List<Path> allBasePaths = Arrays.asList(Paths.get("/someBasePath1"), Paths.get("/someBasePath2"), Paths.get("/someBasePath2"));
    configureBasePath("*", allBasePaths.get(0).toString());
    configureBasePath("project/*", allBasePaths.get(1).toString());
    configureBasePath("project/project/*", allBasePaths.get(2).toString());
    assertThat(repoCfg.getAllBasePaths()).isEqualTo(allBasePaths);
}
#method_after
@Test
public void testAllBasePath() {
    ImmutableList<Path> allBasePaths = ImmutableList.of(Paths.get("/someBasePath1"), Paths.get("/someBasePath2"), Paths.get("/someBasePath2"));
    configureBasePath("*", allBasePaths.get(0).toString());
    configureBasePath("project/*", allBasePaths.get(1).toString());
    configureBasePath("project/project/*", allBasePaths.get(2).toString());
    assertThat(repoCfg.getAllBasePaths()).isEqualTo(allBasePaths);
}
#end_block

#method_before
public List<String> getOwnerGroups(Project.NameKey project) {
    String[] groups = cfg.getStringList(SECTION_NAME, findSubSection(project.get()), OWNER_GROUP_NAME);
    return Arrays.asList(groups);
}
#method_after
public List<String> getOwnerGroups(Project.NameKey project) {
    return ImmutableList.copyOf(cfg.getStringList(SECTION_NAME, findSubSection(project.get()), OWNER_GROUP_NAME));
}
#end_block

#method_before
@Override
public ScheduledThreadPoolExecutor get() {
    return executor;
}
#method_after
@Override
public Executor get() {
    return executor;
}
#end_block

#method_before
@Test
public void testIndexChangeOK() throws Exception {
    event = setUpMocks(INDEX_OP, true, "", false);
    assertThat(restClient.index(event)).isTrue();
}
#method_after
@Test
public void testIndexChangeOK() throws Exception {
    setUpMocks(INDEX_OP, SUCCESSFUL, EMPTY_MSG, DO_NOT_THROW_EXCEPTION);
    assertThat(restClient.index(CHANGE_NUMBER)).isTrue();
}
#end_block

#method_before
@Test
public void testIndexChangeFailed() throws Exception {
    event = setUpMocks(INDEX_OP, false, "Error", false);
    assertThat(restClient.index(event)).isFalse();
}
#method_after
@Test
public void testIndexChangeFailed() throws Exception {
    setUpMocks(INDEX_OP, FAILED, ERROR_MSG, DO_NOT_THROW_EXCEPTION);
    assertThat(restClient.index(CHANGE_NUMBER)).isFalse();
}
#end_block

#method_before
@Test
public void testIndexChangeThrowsException() throws Exception {
    event = setUpMocks(INDEX_OP, false, "Exception", true);
    assertThat(restClient.index(event)).isFalse();
}
#method_after
@Test
public void testIndexChangeThrowsException() throws Exception {
    setUpMocks(INDEX_OP, FAILED, EXCEPTION_MSG, THROW_EXCEPTION);
    assertThat(restClient.index(CHANGE_NUMBER)).isFalse();
}
#end_block

#method_before
@Test
public void testChangeDeletedFromIndexOK() throws Exception {
    event = setUpMocks(DELETE_OP, true, "", false);
    assertThat(restClient.deleteFromIndex(event)).isTrue();
}
#method_after
@Test
public void testChangeDeletedFromIndexOK() throws Exception {
    setUpMocks(DELETE_OP, SUCCESSFUL, EMPTY_MSG, DO_NOT_THROW_EXCEPTION);
    assertThat(restClient.deleteFromIndex(CHANGE_NUMBER)).isTrue();
}
#end_block

#method_before
@Test
public void testChangeDeletedFromIndexFailed() throws Exception {
    event = setUpMocks(DELETE_OP, false, "Error", false);
    assertThat(restClient.deleteFromIndex(event)).isFalse();
}
#method_after
@Test
public void testChangeDeletedFromIndexFailed() throws Exception {
    setUpMocks(DELETE_OP, FAILED, ERROR_MSG, DO_NOT_THROW_EXCEPTION);
    assertThat(restClient.deleteFromIndex(CHANGE_NUMBER)).isFalse();
}
#end_block

#method_before
@Test
public void testChangeDeletedFromThrowsException() throws Exception {
    event = setUpMocks(DELETE_OP, false, "Exception", true);
    assertThat(restClient.deleteFromIndex(event)).isFalse();
}
#method_after
@Test
public void testChangeDeletedFromThrowsException() throws Exception {
    setUpMocks(DELETE_OP, FAILED, EXCEPTION_MSG, THROW_EXCEPTION);
    assertThat(restClient.deleteFromIndex(CHANGE_NUMBER)).isFalse();
}
#end_block

#method_before
private Event setUpMocks(String operation, boolean ok, String msg, boolean exception) throws Exception {
    String request = Joiner.on("/").join("/plugins", PLUGIN_NAME, operation, CHANGE_NUMBER);
    HttpSession httpSession = createNiceMock(HttpSession.class);
    if (exception) {
        expect(httpSession.post(request)).andThrow(new IOException());
    } else {
        IndexResult result = new IndexResult(ok, msg);
        expect(httpSession.post(request)).andReturn(result);
    }
    restClient = new RestSession(httpSession, PLUGIN_NAME);
    Event event = createNiceMock(Event.class);
    expect(event.getChangeId()).andReturn(CHANGE_NUMBER);
    replayAll();
    return event;
}
#method_after
private void setUpMocks(String operation, boolean isOperationSuccessful, String msg, boolean exception) throws Exception {
    String request = Joiner.on("/").join("/plugins", PLUGIN_NAME, INDEX_OP, CHANGE_NUMBER);
    HttpSession httpSession = createNiceMock(HttpSession.class);
    if (exception) {
        if (operation.equals(INDEX_OP)) {
            expect(httpSession.post(request)).andThrow(new IOException());
        } else {
            expect(httpSession.delete(request)).andThrow(new IOException());
        }
    } else {
        IndexResult result = new IndexResult(isOperationSuccessful, msg);
        if (operation.equals(INDEX_OP)) {
            expect(httpSession.post(request)).andReturn(result);
        } else {
            expect(httpSession.delete(request)).andReturn(result);
        }
    }
    restClient = new RestSession(httpSession, PLUGIN_NAME);
    replayAll();
}
#end_block

#method_before
private void setUpMocks(boolean mockRestClient) {
    eventMock = createNiceMock(Event.class);
    pool = new PoolMock(1);
    if (mockRestClient) {
        restClient = createMock(RestSession.class);
    } else {
        restClient = null;
    }
    replayAll();
    indexEventHandler = new IndexEventHandler(pool, PLUGIN_NAME, restClient);
}
#method_after
@Before
public void setUpMocks() {
    cd = createNiceMock(ChangeData.class);
    id = Change.Id.parse(Integer.toString(CHANGE_ID));
    expect(cd.getId()).andReturn(id).anyTimes();
    poolMock = createMock(Executor.class);
    poolMock.execute(anyObject(SyncIndexTask.class));
    expectLastCall().andDelegateTo(MoreExecutors.directExecutor());
    restClientMock = createMock(RestSession.class);
    indexEventHandler = new IndexEventHandler(poolMock, PLUGIN_NAME, restClientMock);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(CloseableHttpClient.class).toProvider(HttpClientProvider.class);
    bind(Configuration.class).in(Scopes.SINGLETON);
    bind(HttpSession.class);
    bind(RestSession.class);
    bind(ScheduledThreadPoolExecutor.class).annotatedWith(SyncIndexExecutor.class).toProvider(SyncIndexExecutorProvider.class).in(Scopes.SINGLETON);
    listener().to(SyncIndexExecutorProvider.class);
    DynamicSet.bind(binder(), ChangeIndexedListener.class).to(IndexEventHandler.class);
}
#method_after
@Override
protected void configure() {
    bind(CloseableHttpClient.class).toProvider(HttpClientProvider.class).in(Scopes.SINGLETON);
    bind(Configuration.class).in(Scopes.SINGLETON);
    bind(HttpSession.class);
    bind(RestSession.class);
    bind(Executor.class).annotatedWith(SyncIndexExecutor.class).toProvider(SyncIndexExecutorProvider.class);
    listener().to(SyncIndexExecutorProvider.class);
    DynamicSet.bind(binder(), ChangeIndexedListener.class).to(IndexEventHandler.class);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    cfg = createMock(Configuration.class);
    expect(cfg.getUrl()).andReturn(URL).anyTimes();
    expect(cfg.getUser()).andReturn("user");
    expect(cfg.getPassword()).andReturn("pass");
    expect(cfg.getMaxTries()).andReturn(MAX_TRIES).anyTimes();
    expect(cfg.getConnectionTimeout()).andReturn(TIMEOUT).anyTimes();
    expect(cfg.getSocketTimeout()).andReturn(TIMEOUT).anyTimes();
    expect(cfg.getRetryInterval()).andReturn(RETRY_INTERVAL).anyTimes();
    replayAll();
    httpClient = new HttpClientProvider(cfg).get();
    httpSession = new HttpSession(httpClient, URL);
}
#method_after
@Before
public void setUp() throws Exception {
    String url = "http://localhost:" + wireMockRule.port();
    cfg = createMock(Configuration.class);
    expect(cfg.getUrl()).andReturn(url).anyTimes();
    expect(cfg.getUser()).andReturn("user");
    expect(cfg.getPassword()).andReturn("pass");
    expect(cfg.getMaxTries()).andReturn(MAX_TRIES).anyTimes();
    expect(cfg.getConnectionTimeout()).andReturn(TIMEOUT).anyTimes();
    expect(cfg.getSocketTimeout()).andReturn(TIMEOUT).anyTimes();
    expect(cfg.getRetryInterval()).andReturn(RETRY_INTERVAL).anyTimes();
    replayAll();
    httpClient = new HttpClientProvider(cfg).get();
    httpSession = new HttpSession(httpClient, url);
    wireMockRule.resetRequests();
}
#end_block

#method_before
@Test
public void testResponseOK() throws Exception {
    stubFor(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(OK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isTrue();
}
#method_after
@Test
public void testResponseOK() throws Exception {
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(OK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isTrue();
}
#end_block

#method_before
@Test
public void testNotAuthorized() throws Exception {
    String expected = "unauthorized";
    stubFor(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(UNAUTHORIZED).withBody(expected)));
    IndexResult result = httpSession.post(ENDPOINT);
    assertThat(result.isSuccessful()).isFalse();
    assertThat(result.getMessage()).isEqualTo(expected);
}
#method_after
@Test
public void testNotAuthorized() throws Exception {
    String expected = "unauthorized";
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(UNAUTHORIZED).withBody(expected)));
    IndexResult result = httpSession.post(ENDPOINT);
    assertThat(result.isSuccessful()).isFalse();
    assertThat(result.getMessage()).isEqualTo(expected);
}
#end_block

#method_before
@Test
public void testNotFound() throws Exception {
    String expected = "not found";
    stubFor(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(NOT_FOUND).withBody(expected)));
    IndexResult result = httpSession.post(ENDPOINT);
    assertThat(result.isSuccessful()).isFalse();
    assertThat(result.getMessage()).isEqualTo(expected);
}
#method_after
@Test
public void testNotFound() throws Exception {
    String expected = "not found";
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(NOT_FOUND).withBody(expected)));
    IndexResult result = httpSession.post(ENDPOINT);
    assertThat(result.isSuccessful()).isFalse();
    assertThat(result.getMessage()).isEqualTo(expected);
}
#end_block

#method_before
@Test
public void testBadResponseRetryThenOK() throws Exception {
    stubFor(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_ERROR).whenScenarioStateIs(Scenario.STARTED).willSetStateTo(REQUEST_MADE).willReturn(aResponse().withStatus(ERROR)));
    stubFor(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_ERROR).whenScenarioStateIs(REQUEST_MADE).willReturn(aResponse().withStatus(OK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isTrue();
}
#method_after
@Test
public void testBadResponseRetryThenOK() throws Exception {
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_ERROR).whenScenarioStateIs(Scenario.STARTED).willSetStateTo(REQUEST_MADE).willReturn(aResponse().withStatus(ERROR)));
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_ERROR).whenScenarioStateIs(REQUEST_MADE).willReturn(aResponse().withStatus(OK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isTrue();
}
#end_block

#method_before
@Test
public void testBadResponseRetryThenGiveUp() throws Exception {
    stubFor(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(ERROR).withBody(ERROR_MESSAGE)));
    IndexResult result = httpSession.post(ENDPOINT);
    assertThat(result.isSuccessful()).isFalse();
    assertThat(result.getMessage()).isEqualTo(ERROR_MESSAGE);
}
#method_after
@Test
public void testBadResponseRetryThenGiveUp() throws Exception {
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withStatus(ERROR).withBody(ERROR_MESSAGE)));
    IndexResult result = httpSession.post(ENDPOINT);
    assertThat(result.isSuccessful()).isFalse();
    assertThat(result.getMessage()).isEqualTo(ERROR_MESSAGE);
}
#end_block

#method_before
@Test
public void testRetryAfterDelay() throws Exception {
    stubFor(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_DELAY).whenScenarioStateIs(Scenario.STARTED).willSetStateTo(REQUEST_MADE).willReturn(aResponse().withStatus(ERROR).withFixedDelay(TIMEOUT / 2)));
    stubFor(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_DELAY).whenScenarioStateIs(REQUEST_MADE).willReturn(aResponse().withStatus(OK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isTrue();
}
#method_after
@Test
public void testRetryAfterDelay() throws Exception {
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_DELAY).whenScenarioStateIs(Scenario.STARTED).willSetStateTo(REQUEST_MADE).willReturn(aResponse().withStatus(ERROR).withFixedDelay(TIMEOUT / 2)));
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_DELAY).whenScenarioStateIs(REQUEST_MADE).willReturn(aResponse().withStatus(OK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isTrue();
}
#end_block

#method_before
@Test
public void testGiveUpAtTimeout() throws Exception {
    stubFor(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_DELAY).whenScenarioStateIs(Scenario.STARTED).willSetStateTo(REQUEST_MADE).willReturn(aResponse().withStatus(ERROR).withFixedDelay(TIMEOUT)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isFalse();
}
#method_after
@Test
public void testGiveUpAtTimeout() throws Exception {
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).inScenario(RETRY_AT_DELAY).whenScenarioStateIs(Scenario.STARTED).willSetStateTo(REQUEST_MADE).willReturn(aResponse().withStatus(ERROR).withFixedDelay(TIMEOUT)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isFalse();
}
#end_block

#method_before
@Test
public void testResponseWithMalformedResponse() throws Exception {
    stubFor(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withFault(Fault.MALFORMED_RESPONSE_CHUNK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isFalse();
}
#method_after
@Test
public void testResponseWithMalformedResponse() throws Exception {
    wireMockRule.givenThat(post(urlEqualTo(ENDPOINT)).willReturn(aResponse().withFault(Fault.MALFORMED_RESPONSE_CHUNK)));
    assertThat(httpSession.post(ENDPOINT).isSuccessful()).isFalse();
}
#end_block

#method_before
@Override
public void onChangeIndexed(Event event) {
    executeIndexTask(event, false);
}
#method_after
@Override
public void onChangeIndexed(ChangeData cd) {
    executeIndexTask(cd.getId(), false);
}
#end_block

#method_before
@Override
public void onChangeDeleted(Event event) {
    executeIndexTask(event, true);
}
#method_after
@Override
public void onChangeDeleted(Change.Id id) {
    executeIndexTask(id, true);
}
#end_block

#method_before
private void executeIndexTask(Event event, boolean removed) {
    if (!Context.isForwardedEvent()) {
        executor.execute(new SyncIndexTask(event, removed));
    }
}
#method_after
private void executeIndexTask(Change.Id id, boolean deleted) {
    if (!Context.isForwardedEvent()) {
        SyncIndexTask syncIndexTask = new SyncIndexTask(id.get(), deleted);
        if (queuedTasks.add(syncIndexTask)) {
            executor.execute(syncIndexTask);
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    if (removed) {
        restClient.deleteFromIndex(event);
    } else {
        restClient.index(event);
    }
}
#method_after
@Override
public void run() {
    queuedTasks.remove(this);
    if (deleted) {
        restClient.deleteFromIndex(changeId);
    } else {
        restClient.index(changeId);
    }
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("[%s] Index change %s in target instance", pluginName, event.getChangeId());
}
#method_after
@Override
public String toString() {
    return String.format("[%s] Index change %s in target instance", pluginName, changeId);
}
#end_block

#method_before
private boolean index(Event event, boolean removed) {
    int changeId = event.getChangeId();
    try {
        IndexResult result = httpSession.post(buildEndpoint(changeId, removed));
        if (result.isSuccessful()) {
            return true;
        }
        String operation = removed ? "delete from index change " : "index change ";
        log.error("Unable to " + operation + changeId + " Cause: " + result.getMessage());
    } catch (IOException e) {
        log.error("Error trying to update index for change " + changeId, e);
    }
    return false;
}
#method_after
boolean index(int changeId) {
    try {
        IndexResult result = httpSession.post(buildEndpoint(changeId));
        if (result.isSuccessful()) {
            return true;
        }
        log.error("Unable to index change {}. Cause: {}", changeId, result.getMessage());
    } catch (IOException e) {
        log.error("Error trying to index change " + changeId, e);
    }
    return false;
}
#end_block

#method_before
boolean deleteFromIndex(Event event) {
    return index(event, true);
}
#method_after
boolean deleteFromIndex(int changeId) {
    try {
        IndexResult result = httpSession.delete(buildEndpoint(changeId));
        if (result.isSuccessful()) {
            return true;
        }
        log.error("Unable to delete from index change {}. Cause: {}", changeId, result.getMessage());
    } catch (IOException e) {
        log.error("Error trying to delete from index change " + changeId, e);
    }
    return false;
}
#end_block

#method_before
private String buildEndpoint(int changeNumber, boolean removed) {
    String operation = removed ? "delete" : "index";
    return Joiner.on("/").join("/plugins", pluginName, operation, changeNumber);
}
#method_after
private String buildEndpoint(int changeId) {
    return Joiner.on("/").join("/plugins", pluginName, "index", changeId);
}
#end_block

#method_before
@Override
public CloseableHttpClient get() {
    if (httpClient == null) {
        httpClient = HttpClients.custom().setSSLSocketFactory(sslSocketFactory).setConnectionManager(customConnectionManager()).setDefaultCredentialsProvider(buildCredentials()).setDefaultRequestConfig(customRequestConfig()).setRetryHandler(customRetryHandler()).setServiceUnavailableRetryStrategy(customServiceUnavailRetryStrategy()).build();
    }
    return httpClient;
}
#method_after
@Override
public CloseableHttpClient get() {
    return HttpClients.custom().setSSLSocketFactory(sslSocketFactory).setConnectionManager(customConnectionManager()).setDefaultCredentialsProvider(buildCredentials()).setDefaultRequestConfig(customRequestConfig()).setRetryHandler(customRetryHandler()).setServiceUnavailableRetryStrategy(customServiceUnavailRetryStrategy()).build();
}
#end_block

#method_before
private void logRetry(String cause) {
    log.warn("Retrying request to '" + cfg.getUrl() + "' Cause: " + cause);
}
#method_after
private void logRetry(String cause) {
    log.debug("Retrying request to '" + cfg.getUrl() + "' Cause: " + cause);
}
#end_block

#method_before
private HttpClientConnectionManager customConnectionManager() {
    Registry<ConnectionSocketFactory> socketFactoryRegistry = RegistryBuilder.<ConnectionSocketFactory>create().register("https", sslSocketFactory).register("http", PlainConnectionSocketFactory.INSTANCE).build();
    PoolingHttpClientConnectionManager connManager = new PoolingHttpClientConnectionManager(socketFactoryRegistry);
    connManager.setDefaultMaxPerRoute(CONNECTIONS_PER_ROUTE);
    connManager.setMaxTotal(MAX_CONNECTIONS);
    connManager.setValidateAfterInactivity(10000);
    return connManager;
}
#method_after
private HttpClientConnectionManager customConnectionManager() {
    Registry<ConnectionSocketFactory> socketFactoryRegistry = RegistryBuilder.<ConnectionSocketFactory>create().register("https", sslSocketFactory).register("http", PlainConnectionSocketFactory.INSTANCE).build();
    PoolingHttpClientConnectionManager connManager = new PoolingHttpClientConnectionManager(socketFactoryRegistry);
    connManager.setDefaultMaxPerRoute(CONNECTIONS_PER_ROUTE);
    connManager.setMaxTotal(MAX_CONNECTIONS);
    connManager.setValidateAfterInactivity(MAX_CONNECTION_INACTIVITY);
    return connManager;
}
#end_block

#method_before
private SSLConnectionSocketFactory buildSslSocketFactory() {
    return new SSLConnectionSocketFactory(buildSslContext(), new DummyHostnameVerifier());
}
#method_after
private SSLConnectionSocketFactory buildSslSocketFactory() {
    return new SSLConnectionSocketFactory(buildSslContext(), NoopHostnameVerifier.INSTANCE);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    config = createNiceMock(Configuration.class);
    expect(config.getUrl()).andReturn(EMPTY);
    expect(config.getUser()).andReturn(EMPTY);
    expect(config.getPassword()).andReturn(EMPTY);
    expect(config.getMaxTries()).andReturn(1);
    expect(config.getConnectionTimeout()).andReturn(TIME_INTERVAL);
    expect(config.getSocketTimeout()).andReturn(TIME_INTERVAL);
    expect(config.getRetryInterval()).andReturn(TIME_INTERVAL);
    replayAll();
    httpClientProvider = new HttpClientProvider(config);
}
#method_after
@Before
public void setUp() throws Exception {
    config = createNiceMock(Configuration.class);
    expect(config.getUrl()).andReturn(EMPTY).anyTimes();
    expect(config.getUser()).andReturn(EMPTY).anyTimes();
    expect(config.getPassword()).andReturn(EMPTY).anyTimes();
    expect(config.getMaxTries()).andReturn(1).anyTimes();
    expect(config.getConnectionTimeout()).andReturn(TIME_INTERVAL).anyTimes();
    expect(config.getSocketTimeout()).andReturn(TIME_INTERVAL).anyTimes();
    expect(config.getRetryInterval()).andReturn(TIME_INTERVAL).anyTimes();
    replayAll();
}
#end_block

#method_before
@Test
public void testGet() throws Exception {
    CloseableHttpClient httpClient1 = httpClientProvider.get();
    assertThat(httpClient1).isNotNull();
    CloseableHttpClient httpClient2 = httpClientProvider.get();
    assertThat(httpClient1).isEqualTo(httpClient2);
}
#method_after
@Test
public void testGet() throws Exception {
    Injector injector = Guice.createInjector(new TestModule());
    CloseableHttpClient httpClient1 = injector.getInstance(CloseableHttpClient.class);
    assertThat(httpClient1).isNotNull();
    CloseableHttpClient httpClient2 = injector.getInstance(CloseableHttpClient.class);
    assertThat(httpClient1).isEqualTo(httpClient2);
}
#end_block

#method_before
IndexResult post(String endpoint) throws IOException {
    HttpPost post = new HttpPost(url + endpoint);
    return httpClient.execute(post, new IndexResponseHandler());
}
#method_after
IndexResult post(String endpoint) throws IOException {
    return httpClient.execute(new HttpPost(url + endpoint), new IndexResponseHandler());
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setContentType("text/plain");
    rsp.setCharacterEncoding("UTF-8");
    try {
        List<String> params = Splitter.on('/').splitToList(req.getPathInfo());
        String operation = params.get(OPERATION_INDEX);
        String changeId = params.get(ID_INDEX);
        Change.Id id = Change.Id.parse(changeId);
        Context.setForwardedEvent(true);
        if ("index".equals(operation)) {
            verifyChange(changeId);
            index(id);
        } else if ("delete".equals(operation)) {
            indexer.delete(id);
        }
        rsp.setStatus(SC_NO_CONTENT);
    } catch (IOException e) {
        rsp.sendError(SC_BAD_REQUEST, e.getMessage());
        logger.error("Unable to update index", e);
    } catch (ResourceNotFoundException | OrmException e) {
        rsp.sendError(SC_NOT_FOUND, "Change not found\n");
        logger.debug("Error trying to find a change ", e);
    } finally {
        Context.unsetForwardedEvent();
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setContentType("text/plain");
    rsp.setCharacterEncoding("UTF-8");
    Change.Id id = getIdFromRequest(req.getPathInfo());
    try (ReviewDb db = schemaFactory.open()) {
        Context.setForwardedEvent(true);
        Change change = db.changes().get(id);
        if (change == null) {
            throw new NoSuchChangeException(id);
        }
        indexer.index(db, change);
        rsp.setStatus(SC_NO_CONTENT);
    } catch (IOException e) {
        rsp.sendError(SC_CONFLICT, e.getMessage());
        logger.error("Unable to update index", e);
    } catch (OrmException | NoSuchChangeException e) {
        rsp.sendError(SC_NOT_FOUND, "Change not found\n");
        logger.debug("Error trying to find a change ", e);
    } finally {
        Context.unsetForwardedEvent();
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serveRegex("/(index|delete)/\\d+$").with(SyncIndexRestApiServlet.class);
}
#method_after
@Override
protected void configureServlets() {
    serveRegex("/index/\\d+$").with(SyncIndexRestApiServlet.class);
}
#end_block

#method_before
@Test
public void testValuesPresentInGerritConfig() throws Exception {
    buildMocks(true);
    assertThat(configuration.getUrl()).isEqualTo(URL);
    assertThat(configuration.getUser()).isEqualTo(USER);
    assertThat(configuration.getPassword()).isEqualTo(PASS);
    assertThat(configuration.getConnectionTimeout()).isEqualTo(TIMEOUT);
    assertThat(configuration.getSocketTimeout()).isEqualTo(TIMEOUT);
    assertThat(configuration.getMaxTries()).isEqualTo(MAX_TRIES);
    assertThat(configuration.getRetryInterval()).isEqualTo(RETRY_INTERVAL);
}
#method_after
@Test
public void testValuesPresentInGerritConfig() throws Exception {
    buildMocks(true);
    assertThat(configuration.getUrl()).isEqualTo(URL);
    assertThat(configuration.getUser()).isEqualTo(USER);
    assertThat(configuration.getPassword()).isEqualTo(PASS);
    assertThat(configuration.getConnectionTimeout()).isEqualTo(TIMEOUT);
    assertThat(configuration.getSocketTimeout()).isEqualTo(TIMEOUT);
    assertThat(configuration.getMaxTries()).isEqualTo(MAX_TRIES);
    assertThat(configuration.getRetryInterval()).isEqualTo(RETRY_INTERVAL);
    assertThat(configuration.getThreadPoolSize()).isEqualTo(THREAD_POOL_SIZE);
}
#end_block

#method_before
@Test
public void testValuesNotPresentInGerritConfig() throws Exception {
    buildMocks(false);
    assertThat(configuration.getUrl()).isEqualTo(EMPTY);
    assertThat(configuration.getUser()).isEqualTo(EMPTY);
    assertThat(configuration.getPassword()).isEqualTo(EMPTY);
    assertThat(configuration.getConnectionTimeout()).isEqualTo(0);
    assertThat(configuration.getSocketTimeout()).isEqualTo(0);
    assertThat(configuration.getMaxTries()).isEqualTo(0);
    assertThat(configuration.getRetryInterval()).isEqualTo(0);
}
#method_after
@Test
public void testValuesNotPresentInGerritConfig() throws Exception {
    buildMocks(false);
    assertThat(configuration.getUrl()).isEqualTo(EMPTY);
    assertThat(configuration.getUser()).isEqualTo(EMPTY);
    assertThat(configuration.getPassword()).isEqualTo(EMPTY);
    assertThat(configuration.getConnectionTimeout()).isEqualTo(0);
    assertThat(configuration.getSocketTimeout()).isEqualTo(0);
    assertThat(configuration.getMaxTries()).isEqualTo(0);
    assertThat(configuration.getRetryInterval()).isEqualTo(0);
    assertThat(configuration.getThreadPoolSize()).isEqualTo(0);
}
#end_block

#method_before
private void buildMocks(boolean values) {
    expect(configMock.getString("url")).andReturn(values ? URL : null);
    expect(configMock.getString("user")).andReturn(values ? USER : null);
    expect(configMock.getString("password")).andReturn(values ? PASS : null);
    expect(configMock.getInt("connectionTimeout", TIMEOUT)).andReturn(values ? TIMEOUT : 0);
    expect(configMock.getInt("socketTimeout", TIMEOUT)).andReturn(values ? TIMEOUT : 0);
    expect(configMock.getInt("maxTries", MAX_TRIES)).andReturn(values ? MAX_TRIES : 0);
    expect(configMock.getInt("retryInterval", RETRY_INTERVAL)).andReturn(values ? RETRY_INTERVAL : 0);
    replayAll();
    configuration = new Configuration(cfgFactoryMock, pluginName);
}
#method_after
private void buildMocks(boolean values) {
    expect(configMock.getString("url")).andReturn(values ? URL : null);
    expect(configMock.getString("user")).andReturn(values ? USER : null);
    expect(configMock.getString("password")).andReturn(values ? PASS : null);
    expect(configMock.getInt("connectionTimeout", TIMEOUT)).andReturn(values ? TIMEOUT : 0);
    expect(configMock.getInt("socketTimeout", TIMEOUT)).andReturn(values ? TIMEOUT : 0);
    expect(configMock.getInt("maxTries", MAX_TRIES)).andReturn(values ? MAX_TRIES : 0);
    expect(configMock.getInt("retryInterval", RETRY_INTERVAL)).andReturn(values ? RETRY_INTERVAL : 0);
    expect(configMock.getInt("threadPoolSize", THREAD_POOL_SIZE)).andReturn(values ? THREAD_POOL_SIZE : 0);
    replayAll();
    configuration = new Configuration(cfgFactoryMock, pluginName);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    executorMock = createStrictMock(WorkQueue.Executor.class);
    WorkQueue workQueueMock = createNiceMock(WorkQueue.class);
    expect(workQueueMock.createQueue(1, "Sync remote index")).andReturn(executorMock);
    replayAll();
    syncIndexExecutorProvider = new SyncIndexExecutorProvider(workQueueMock);
}
#method_after
@Before
public void setUp() throws Exception {
    executorMock = createStrictMock(WorkQueue.Executor.class);
    WorkQueue workQueueMock = createNiceMock(WorkQueue.class);
    expect(workQueueMock.createQueue(4, "Sync remote index")).andReturn(executorMock);
    Configuration configMock = createStrictMock(Configuration.class);
    expect(configMock.getThreadPoolSize()).andReturn(4);
    replayAll();
    syncIndexExecutorProvider = new SyncIndexExecutorProvider(workQueueMock, configMock);
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    JumpKeys.enable(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegistrations();
    if (getCommentManager() != null) {
        CallbackGroup group = new CallbackGroup();
        getCommentManager().saveAllDrafts(group);
        group.done();
    }
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    for (CodeMirror cm : getCms()) {
        if (cm != null) {
            cm.getWrapperElement().removeFromParent();
        }
    }
    if (prefsAction != null) {
        prefsAction.hide();
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
    JumpKeys.enable(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegistrations();
    if (getCommentManager() != null) {
        CallbackGroup group = new CallbackGroup();
        getCommentManager().saveAllDrafts(group);
        group.done();
    }
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    for (CodeMirror cm : getCms()) {
        if (cm != null) {
            cm.getWrapperElement().removeFromParent();
        }
    }
    if (prefsAction != null) {
        prefsAction.hide();
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("focus", updateActiveLine(cm));
    KeyMap keyMap = KeyMap.create().on("A", upToChange(true)).on("U", upToChange(false)).on("'['", header.navigate(Direction.PREV)).on("']'", header.navigate(Direction.NEXT)).on("R", header.toggleReviewed()).on("O", getCommentManager().toggleOpenBox(cm)).on("Enter", getCommentManager().toggleOpenBox(cm)).on("N", maybeNextVimSearch(cm)).on("E", openEditScreen(cm)).on("P", getChunkManager().diffChunkNav(cm, Direction.PREV)).on("Shift-M", header.reviewedAndNext()).on("Shift-N", maybePrevVimSearch(cm)).on("Shift-P", getCommentManager().commentNav(cm, Direction.PREV)).on("Shift-O", getCommentManager().openCloseAll(cm)).on("I", new Runnable() {

        @Override
        public void run() {
            switch(getIntraLineStatus()) {
                case OFF:
                case OK:
                    toggleShowIntraline();
                    break;
                case FAILURE:
                case TIMEOUT:
                default:
                    break;
            }
        }
    }).on("','", new Runnable() {

        @Override
        public void run() {
            prefsAction.show();
        }
    }).on("Shift-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-d>");
        }
    }).on("Shift-Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-u>");
        }
    }).on("Ctrl-F", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("/");
        }
    }).on("Ctrl-A", new Runnable() {

        @Override
        public void run() {
            cm.execCommand("selectAll");
        }
    });
    if (revision.get() != 0) {
        cm.on("beforeSelectionChange", onSelectionChange(cm));
        cm.on("gutterClick", onGutterClick(cm));
        keyMap.on("C", getCommentManager().newDraftCallback(cm));
    }
    cm.addKeyMap(keyMap);
}
#method_after
void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("focus", updateActiveLine(cm));
    KeyMap keyMap = KeyMap.create().on("A", upToChange(true)).on("U", upToChange(false)).on("'['", header.navigate(Direction.PREV)).on("']'", header.navigate(Direction.NEXT)).on("R", header.toggleReviewed()).on("O", getCommentManager().toggleOpenBox(cm)).on("Enter", getCommentManager().toggleOpenBox(cm)).on("N", maybeNextVimSearch(cm)).on("Ctrl-Alt-E", openEditScreen(cm)).on("P", getChunkManager().diffChunkNav(cm, Direction.PREV)).on("Shift-M", header.reviewedAndNext()).on("Shift-N", maybePrevVimSearch(cm)).on("Shift-P", getCommentManager().commentNav(cm, Direction.PREV)).on("Shift-O", getCommentManager().openCloseAll(cm)).on("I", new Runnable() {

        @Override
        public void run() {
            switch(getIntraLineStatus()) {
                case OFF:
                case OK:
                    toggleShowIntraline();
                    break;
                case FAILURE:
                case TIMEOUT:
                default:
                    break;
            }
        }
    }).on("','", new Runnable() {

        @Override
        public void run() {
            prefsAction.show();
        }
    }).on("Shift-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-d>");
        }
    }).on("Shift-Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-u>");
        }
    }).on("Ctrl-F", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("/");
        }
    }).on("Ctrl-A", new Runnable() {

        @Override
        public void run() {
            cm.execCommand("selectAll");
        }
    }).on("G O", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:open"));
        }
    }).on("G M", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:merged"));
        }
    }).on("G A", new Runnable() {

        @Override
        public void run() {
            Gerrit.display(PageLinks.toChangeQuery("status:abandoned"));
        }
    });
    if (Gerrit.isSignedIn()) {
        keyMap.on("G I", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.MINE);
            }
        }).on("G D", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("owner:self is:draft"));
            }
        }).on("G C", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("has:draft"));
            }
        }).on("G W", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("is:watched status:open"));
            }
        }).on("G S", new Runnable() {

            @Override
            public void run() {
                Gerrit.display(PageLinks.toChangeQuery("is:starred"));
            }
        });
    }
    if (revision.get() != 0) {
        cm.on("beforeSelectionChange", onSelectionChange(cm));
        cm.on("gutterClick", onGutterClick(cm));
        keyMap.on("C", getCommentManager().newDraftCallback(cm));
    }
    // Needed to for multi-stroke keymaps
    CodeMirror.normalizeKeyMap(keyMap);
    cm.addKeyMap(keyMap);
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()), new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysNavigation.add(new NoOpKeyCommand(0, 'n', PatchUtil.C.chunkNext()), new NoOpKeyCommand(0, 'p', PatchUtil.C.chunkPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'n', PatchUtil.C.commentNext()), new NoOpKeyCommand(KeyCommand.M_SHIFT, 'p', PatchUtil.C.commentPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 'f', Gerrit.C.keySearch()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'o', PatchUtil.C.expandAllCommentsOnCurrentLine()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                header.toggleReviewed().run();
            }
        });
    }
    keysAction.add(new KeyCommand(KeyCommand.M_SHIFT, 'm', PatchUtil.C.markAsReviewedAndGoToNext()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            header.reviewedAndNext().run();
        }
    });
    keysAction.add(new KeyCommand(0, 'a', PatchUtil.C.openReply()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange(true).run();
        }
    });
    keysAction.add(new KeyCommand(0, ',', PatchUtil.C.showPreferences()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            prefsAction.show();
        }
    });
    if (getIntraLineStatus() == DiffInfo.IntraLineStatus.OFF || getIntraLineStatus() == DiffInfo.IntraLineStatus.OK) {
        keysAction.add(new KeyCommand(0, 'i', PatchUtil.C.toggleIntraline()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                toggleShowIntraline();
            }
        });
    }
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()), new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysNavigation.add(new NoOpKeyCommand(0, 'n', PatchUtil.C.chunkNext()), new NoOpKeyCommand(0, 'p', PatchUtil.C.chunkPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'n', PatchUtil.C.commentNext()), new NoOpKeyCommand(KeyCommand.M_SHIFT, 'p', PatchUtil.C.commentPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 'f', Gerrit.C.keySearch()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'o', PatchUtil.C.expandAllCommentsOnCurrentLine()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                header.toggleReviewed().run();
            }
        });
        keysAction.add(new NoOpKeyCommand(KeyCommand.M_CTRL | KeyCommand.M_ALT, 'e', Gerrit.C.keyEditor()));
    }
    keysAction.add(new KeyCommand(KeyCommand.M_SHIFT, 'm', PatchUtil.C.markAsReviewedAndGoToNext()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            header.reviewedAndNext().run();
        }
    });
    keysAction.add(new KeyCommand(0, 'a', PatchUtil.C.openReply()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange(true).run();
        }
    });
    keysAction.add(new KeyCommand(0, ',', PatchUtil.C.showPreferences()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            prefsAction.show();
        }
    });
    if (getIntraLineStatus() == DiffInfo.IntraLineStatus.OFF || getIntraLineStatus() == DiffInfo.IntraLineStatus.OK) {
        keysAction.add(new KeyCommand(0, 'i', PatchUtil.C.toggleIntraline()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                toggleShowIntraline();
            }
        });
    }
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
}
#end_block

#method_before
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException, ConfigInvalidException {
    Change change = new Change(bundle.getChange());
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = Lists.newArrayList();
    Multimap<Account.Id, PatchLineCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    Repository changeMetaRepo = manager.getChangeRepo().repo;
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteRef(change, changeMetaRepo, manager.getChangeRepo().cmds);
    for (PatchSet ps : bundle.getPatchSets()) {
        events.add(new PatchSetEvent(change, ps, manager.getCodeRepo().rw));
        List<PatchLineComment> comments = PatchLineCommentsUtil.PLC_ORDER.sortedCopy(bundle.getPatchLineComments());
        for (PatchLineComment c : comments) {
            PatchLineCommentEvent e = new PatchLineCommentEvent(c, change, ps, patchListCache);
            if (c.getStatus() == Status.PUBLISHED) {
                events.add(e);
            } else {
                draftCommentEvents.put(c.getAuthor(), e);
            }
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        events.add(new ApprovalEvent(psa, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
    }
    Collections.sort(events, EVENT_ORDER);
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<PatchLineCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (PatchLineCommentEvent e : draftCommentEvents.get(author)) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#method_after
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException, ConfigInvalidException {
    Change change = new Change(bundle.getChange());
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = Lists.newArrayList();
    Multimap<Account.Id, PatchLineCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    Repository changeMetaRepo = manager.getChangeRepo().repo;
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteRef(change, changeMetaRepo, manager.getChangeRepo().cmds);
    for (PatchSet ps : bundle.getPatchSets()) {
        events.add(new PatchSetEvent(change, ps, manager.getCodeRepo().rw));
        for (PatchLineComment c : getPatchLineComments(bundle, ps)) {
            PatchLineCommentEvent e = new PatchLineCommentEvent(c, change, ps, patchListCache);
            if (c.getStatus() == Status.PUBLISHED) {
                events.add(e);
            } else {
                draftCommentEvents.put(c.getAuthor(), e);
            }
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        events.add(new ApprovalEvent(psa, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
    }
    Collections.sort(events, EVENT_ORDER);
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<PatchLineCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (PatchLineCommentEvent e : draftCommentEvents.get(author)) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#end_block

#method_before
PersonIdent newAuthorIdent() {
    Account.Id id = getAccountId();
    if (id == null) {
        return serverIdent;
    }
    return changeNoteUtil.newIdent(accountCache.get(id).getAccount(), getWhen(), serverIdent, anonymousCowardName);
}
#method_after
PersonIdent newAuthorIdent() {
    Account.Id id = getAccountId();
    if (id == null) {
        return new PersonIdent(serverIdent, getWhen());
    }
    return changeNoteUtil.newIdent(accountCache.get(id).getAccount(), getWhen(), serverIdent, anonymousCowardName);
}
#end_block

#method_before
private void setTopic(ChangeUpdate update) {
    String msg = message.getMessage();
    Matcher m = TOPIC_SET_REGEXP.matcher(msg);
    if (m.matches()) {
        String topic = m.group(1);
        update.setTopic(topic);
        noteDbChange.setTopic(topic);
        return;
    }
    m = TOPIC_CHANGED_REGEXP.matcher(msg);
    if (m.matches()) {
        String topic = m.group(2);
        update.setTopic(topic);
        noteDbChange.setTopic(topic);
        return;
    }
    if (TOPIC_REMOVED_REGEXP.matcher(msg).matches()) {
        update.setTopic(null);
        noteDbChange.setTopic(null);
    }
}
#method_after
private void setTopic(ChangeUpdate update) {
    String msg = message.getMessage();
    if (msg == null) {
        return;
    }
    Matcher m = TOPIC_SET_REGEXP.matcher(msg);
    if (m.matches()) {
        String topic = m.group(1);
        update.setTopic(topic);
        noteDbChange.setTopic(topic);
        return;
    }
    m = TOPIC_CHANGED_REGEXP.matcher(msg);
    if (m.matches()) {
        String topic = m.group(2);
        update.setTopic(topic);
        noteDbChange.setTopic(topic);
        return;
    }
    if (TOPIC_REMOVED_REGEXP.matcher(msg).matches()) {
        update.setTopic(null);
        noteDbChange.setTopic(null);
    }
}
#end_block

#method_before
private void setStatus(ChangeUpdate update) {
    String msg = message.getMessage();
    if (STATUS_ABANDONED_REGEXP.matcher(msg).matches()) {
        update.setStatus(Change.Status.ABANDONED);
        noteDbChange.setStatus(Change.Status.ABANDONED);
        return;
    }
    if (STATUS_RESTORED_REGEXP.matcher(msg).matches()) {
        update.setStatus(Change.Status.NEW);
        noteDbChange.setStatus(Change.Status.NEW);
    }
}
#method_after
private void setStatus(ChangeUpdate update) {
    String msg = message.getMessage();
    if (msg == null) {
        return;
    }
    if (STATUS_ABANDONED_REGEXP.matcher(msg).matches()) {
        update.setStatus(Change.Status.ABANDONED);
        noteDbChange.setStatus(Change.Status.ABANDONED);
        return;
    }
    if (STATUS_RESTORED_REGEXP.matcher(msg).matches()) {
        update.setStatus(Change.Status.NEW);
        noteDbChange.setStatus(Change.Status.NEW);
    }
}
#end_block

#method_before
private List<Destination> allDestinations() throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("Config file " + config.getFile() + " does not exist; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Config file " + config.getFile() + " is empty; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    defaultForceUpdate = config.getBoolean("gerrit", "defaultForceUpdate", false);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(defaultForceUpdate));
        }
        Destination destination = new Destination(injector, c, new DefaultDestinationConfiguration(c, config), replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend, stateLog, groupIncludeCache);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations() throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("Config file " + config.getFile() + " does not exist; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Config file " + config.getFile() + " is empty; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    defaultForceUpdate = config.getBoolean("gerrit", "defaultForceUpdate", false);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(defaultForceUpdate));
        }
        Destination destination = new Destination(injector, new DestinationConfiguration(c, config), replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend, stateLog, groupIncludeCache);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#end_block

#method_before
public void start(WorkQueue workQueue) {
    pool = workQueue.createQueue(config.getPoolThreads(), poolName);
}
#method_after
public void start(WorkQueue workQueue) {
    String poolName = "ReplicateTo-" + config.getRemoteConfig().getName();
    pool = workQueue.createQueue(config.getPoolThreads(), poolName);
}
#end_block

#method_before
private boolean isVisible(final Project.NameKey project, ReplicationState... states) {
    try {
        return threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, states);
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    return false;
}
#method_after
private boolean isVisible(final Project.NameKey project, ReplicationState... states) {
    try {
        return threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, states);
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new RuntimeException(e);
    }
    return false;
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#method_after
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#end_block

#method_before
boolean wouldPushProject(final Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    String[] projects = config.getProjects();
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    String[] projects = config.getProjects();
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#end_block

#method_before
boolean wouldPushRef(String ref) {
    if (!config.replicatePermissions() && RefNames.REFS_CONFIG.equals(ref)) {
        return false;
    }
    for (RefSpec s : remote.getPushRefSpecs()) {
        if (s.matchSource(ref)) {
            return true;
        }
    }
    return false;
}
#method_after
boolean wouldPushRef(String ref) {
    if (!config.replicatePermissions() && RefNames.REFS_CONFIG.equals(ref)) {
        return false;
    }
    for (RefSpec s : config.getRemoteConfig().getPushRefSpecs()) {
        if (s.matchSource(ref)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String remoteNameStyle = config.getRemoteNameStyle();
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(config.getRemoteConfig().getURIs().size());
    for (URIish uri : config.getRemoteConfig().getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String remoteNameStyle = config.getRemoteNameStyle();
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
@Test
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    // Adding an existing key should have no effect
    gApi.accounts().self().addSshKey(inital);
    assertThat(info).hasSize(2);
}
#method_after
@Test
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    // Add an existing key again
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
}
#end_block

#method_before
@Override
public SshKeyInfo addSshKey(String key) throws RestApiException {
    AddSshKey.Input in = new AddSshKey.Input();
    in.raw = RestSession.newRawInput(key);
    try {
        return addSshKey.apply(account, in).value();
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot add SSH key", e);
    }
}
#method_after
@Override
public SshKeyInfo addSshKey(String key) throws RestApiException {
    AddSshKey.Input in = new AddSshKey.Input();
    in.raw = RawInputUtil.create(key);
    try {
        return addSshKey.apply(account, in).value();
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot add SSH key", e);
    }
}
#end_block

#method_before
private void verifyComment(PatchLineComment c) {
    checkArgument(c.getRevId() != null);
    checkArgument(c.getAuthor().equals(getUser().getAccountId()), "The author for the following comment does not match the author of" + " this ChangeDraftUpdate (%s): %s", getUser().getAccountId(), c);
}
#method_after
private void verifyComment(PatchLineComment c) {
    checkArgument(c.getRevId() != null, "RevId required for comment: %s", c);
    checkArgument(c.getAuthor().equals(getUser().getAccountId()), "The author for the following comment does not match the author of" + " this ChangeDraftUpdate (%s): %s", getUser().getAccountId(), c);
}
#end_block

#method_before
@Test
public void applyDeltaToNullWithNoNewMetaId() {
    Change c = newChange();
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, new Delta(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, new Delta(c.getId(), noMetaId(), drafts(new Account.Id(1001), zeroId())));
    assertThat(c.getNoteDbState()).isNull();
}
#method_after
@Test
public void applyDeltaToNullWithNoNewMetaId() {
    Change c = newChange();
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, Delta.create(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(1001), zeroId())));
    assertThat(c.getNoteDbState()).isNull();
}
#end_block

#method_before
@Test
public void applyDeltaToMetaId() {
    Change c = newChange();
    applyDelta(c, new Delta(c.getId(), metaId(SHA1), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name());
    applyDelta(c, new Delta(c.getId(), metaId(SHA2), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // No-op delta.
    applyDelta(c, new Delta(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // Set to zero clears the field.
    applyDelta(c, new Delta(c.getId(), metaId(zeroId()), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
}
#method_after
@Test
public void applyDeltaToMetaId() {
    Change c = newChange();
    applyDelta(c, Delta.create(c.getId(), metaId(SHA1), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name());
    applyDelta(c, Delta.create(c.getId(), metaId(SHA2), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // No-op delta.
    applyDelta(c, Delta.create(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // Set to zero clears the field.
    applyDelta(c, Delta.create(c.getId(), metaId(zeroId()), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
}
#end_block

#method_before
@Test
public void applyDeltaToDrafts() {
    Change c = newChange();
    applyDelta(c, new Delta(c.getId(), metaId(SHA1), drafts(new Account.Id(1001), SHA2)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, new Delta(c.getId(), noMetaId(), drafts(new Account.Id(2003), SHA3)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name() + ",2003=" + SHA3.name());
    applyDelta(c, new Delta(c.getId(), noMetaId(), drafts(new Account.Id(2003), zeroId())));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, new Delta(c.getId(), metaId(SHA3), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA3.name() + ",1001=" + SHA2.name());
}
#method_after
@Test
public void applyDeltaToDrafts() {
    Change c = newChange();
    applyDelta(c, Delta.create(c.getId(), metaId(SHA1), drafts(new Account.Id(1001), SHA2)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(2003), SHA3)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name() + ",2003=" + SHA3.name());
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(2003), zeroId())));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, Delta.create(c.getId(), metaId(SHA3), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA3.name() + ",1001=" + SHA2.name());
}
#end_block

#method_before
public ChangeUpdate getUpdate(PatchSet.Id psId) {
    ChangeUpdate u = updates.get(psId);
    if (u == null) {
        u = changeUpdateFactory.create(ctl, when);
        u.setPatchSetId(psId);
        updates.put(psId, u);
    }
    return u;
}
#method_after
public ChangeUpdate getUpdate(PatchSet.Id psId) {
    ChangeUpdate u = updates.get(psId);
    if (u == null) {
        u = changeUpdateFactory.create(ctl, when);
        if (newChanges.containsKey(ctl.getId())) {
            u.setAllowWriteToNewRef(true);
        }
        u.setPatchSetId(psId);
        updates.put(psId, u);
    }
    return u;
}
#end_block

#method_before
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            NoteDbUpdateManager updateManager = null;
            boolean dirty = false;
            try {
                ctx = newChangeContext(id);
                // Call updateChange on each op.
                for (Op op : e.getValue()) {
                    dirty |= op.updateChange(ctx);
                }
                if (!dirty) {
                    return;
                }
                // Stage the NoteDb update and store its state in the Change.
                if (ctx.deleted) {
                    if (notesMigration.writeChanges()) {
                        new ChangeDelete(plcUtil, getRepository(), ctx.getNotes()).delete();
                    }
                } else {
                    if (notesMigration.writeChanges()) {
                        updateManager = updateManagerFactory.create(ctx.getProject());
                        for (ChangeUpdate u : ctx.updates.values()) {
                            updateManager.add(u);
                        }
                        NoteDbChangeState.applyDelta(ctx.getChange(), updateManager.stage().get(id));
                    }
                }
                // Bump lastUpdatedOn or rowVersion and commit.
                if (newChanges.containsKey(id)) {
                    db.changes().insert(bumpLastUpdatedOn(ctx));
                } else if (ctx.saved) {
                    db.changes().update(bumpLastUpdatedOn(ctx));
                } else if (ctx.deleted) {
                    db.changes().delete(bumpLastUpdatedOn(ctx));
                } else {
                    db.changes().update(bumpRowVersionNotLastUpdatedOn(ctx));
                }
                db.commit();
            } finally {
                db.rollback();
            }
            // Execute NoteDb updates after committing ReviewDb updates.
            if (updateManager != null) {
                updateManager.execute();
            }
            // Reindex changes.
            if (ctx.deleted) {
                indexFutures.add(indexer.deleteAsync(id));
            } else {
                indexFutures.add(indexer.indexAsync(ctx.getProject(), id));
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            NoteDbUpdateManager updateManager = null;
            boolean dirty = false;
            try {
                ctx = newChangeContext(id);
                // Call updateChange on each op.
                for (Op op : e.getValue()) {
                    dirty |= op.updateChange(ctx);
                }
                if (!dirty) {
                    return;
                }
                // Stage the NoteDb update and store its state in the Change.
                if (!ctx.deleted && notesMigration.writeChanges()) {
                    updateManager = updateManagerFactory.create(ctx.getProject());
                    for (ChangeUpdate u : ctx.updates.values()) {
                        updateManager.add(u);
                    }
                    NoteDbChangeState.applyDelta(ctx.getChange(), updateManager.stage().get(id));
                }
                // Bump lastUpdatedOn or rowVersion and commit.
                if (newChanges.containsKey(id)) {
                    db.changes().insert(bumpLastUpdatedOn(ctx));
                } else if (ctx.saved) {
                    db.changes().update(bumpLastUpdatedOn(ctx));
                } else if (ctx.deleted) {
                    db.changes().delete(bumpLastUpdatedOn(ctx));
                } else {
                    db.changes().update(bumpRowVersionNotLastUpdatedOn(ctx));
                }
                db.commit();
            } finally {
                db.rollback();
            }
            // Execute NoteDb updates after committing ReviewDb updates.
            if (notesMigration.writeChanges()) {
                if (updateManager != null) {
                    updateManager.execute();
                }
                if (ctx.deleted) {
                    new ChangeDelete(plcUtil, getRepository(), ctx.getNotes()).delete();
                }
            }
            // Reindex changes.
            if (ctx.deleted) {
                indexFutures.add(indexer.deleteAsync(id));
            } else {
                indexFutures.add(indexer.indexAsync(ctx.getProject(), id));
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
@Test
public void changeFields() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    gApi.changes().id(id.get()).topic(name("a-topic"));
    checker.checkChanges(id);
}
#method_after
@Test
public void changeFields() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    gApi.changes().id(id.get()).topic(name("a-topic"));
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void patchSets() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    r = amendChange(r.getChangeId());
    checker.checkChanges(id);
}
#method_after
@Test
public void patchSets() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    r = amendChange(r.getChangeId());
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void noteDbChangeState() throws Exception {
    notesMigration.setAllEnabled(true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    ObjectId changeMetaId = getMetaRef(project, ChangeNoteUtil.changeRefName(id));
    assertThat(db.changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name());
    DraftInput in = new DraftInput();
    in.line = 1;
    in.message = "comment by user";
    in.path = PushOneCommit.FILE_NAME;
    setApiUser(user);
    gApi.changes().id(id.get()).current().createDraft(in);
    ObjectId userDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(user.getId(), id));
    assertThat(db.changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + user.getId() + "=" + userDraftsId.name());
    in = new DraftInput();
    in.line = 2;
    in.message = "comment by admin";
    in.path = PushOneCommit.FILE_NAME;
    setApiUser(admin);
    gApi.changes().id(id.get()).current().createDraft(in);
    ObjectId adminDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(admin.getId(), id));
    assertThat(admin.getId().get()).isLessThan(user.getId().get());
    assertThat(db.changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
    in.message = "revised comment by admin";
    gApi.changes().id(id.get()).current().createDraft(in);
    adminDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(admin.getId(), id));
    assertThat(db.changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
}
#method_after
@Test
public void noteDbChangeState() throws Exception {
    notesMigration.setAllEnabled(true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    ObjectId changeMetaId = getMetaRef(project, ChangeNoteUtil.changeRefName(id));
    assertThat(unwrapDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name());
    DraftInput in = new DraftInput();
    in.line = 1;
    in.message = "comment by user";
    in.path = PushOneCommit.FILE_NAME;
    setApiUser(user);
    gApi.changes().id(id.get()).current().createDraft(in);
    ObjectId userDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(user.getId(), id));
    assertThat(unwrapDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + user.getId() + "=" + userDraftsId.name());
    in = new DraftInput();
    in.line = 2;
    in.message = "comment by admin";
    in.path = PushOneCommit.FILE_NAME;
    setApiUser(admin);
    gApi.changes().id(id.get()).current().createDraft(in);
    ObjectId adminDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(admin.getId(), id));
    assertThat(admin.getId().get()).isLessThan(user.getId().get());
    assertThat(unwrapDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
    in.message = "revised comment by admin";
    gApi.changes().id(id.get()).current().createDraft(in);
    adminDraftsId = getMetaRef(allUsers, RefNames.refsDraftComments(admin.getId(), id));
    assertThat(unwrapDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
}
#end_block

#method_before
@VisibleForTesting
static NoteDbChangeState parse(Change.Id id, String str) {
    if (str == null) {
        return null;
    }
    List<String> parts = Splitter.on(',').splitToList(str);
    checkArgument(!parts.isEmpty(), "invalid state string: %s", str);
    ObjectId changeMetaId = ObjectId.fromString(parts.get(0));
    Map<Account.Id, ObjectId> draftIds = Maps.newHashMapWithExpectedSize(parts.size());
    Splitter s = Splitter.on('=');
    for (int i = 1; i < parts.size(); i++) {
        String p = parts.get(i);
        List<String> draftParts = s.splitToList(p);
        checkArgument(draftParts.size() == 2, "invalid draft state part: %s", p);
        draftIds.put(Account.Id.parse(draftParts.get(0)), ObjectId.fromString(draftParts.get(1)));
    }
    return new NoteDbChangeState(id, changeMetaId, draftIds);
}
#method_after
@VisibleForTesting
static NoteDbChangeState parse(Change.Id id, String str) {
    if (str == null) {
        return null;
    }
    List<String> parts = Splitter.on(',').splitToList(str);
    checkArgument(!parts.isEmpty(), "invalid state string for change %s: %s", id, str);
    ObjectId changeMetaId = ObjectId.fromString(parts.get(0));
    Map<Account.Id, ObjectId> draftIds = Maps.newHashMapWithExpectedSize(parts.size() - 1);
    Splitter s = Splitter.on('=');
    for (int i = 1; i < parts.size(); i++) {
        String p = parts.get(i);
        List<String> draftParts = s.splitToList(p);
        checkArgument(draftParts.size() == 2, "invalid draft state part for change %s: %s", id, p);
        draftIds.put(Account.Id.parse(draftParts.get(0)), ObjectId.fromString(draftParts.get(1)));
    }
    return new NoteDbChangeState(id, changeMetaId, draftIds);
}
#end_block

#method_before
public static void applyDelta(Change change, Delta delta) {
    String oldStr = change.getNoteDbState();
    if (oldStr == null && (delta == null || !delta.newChangeMetaId.isPresent())) {
        // Can't construct a complete state, bail.
        return;
    }
    NoteDbChangeState oldState = parse(change.getId(), oldStr);
    if (delta == null) {
        return;
    }
    ObjectId changeMetaId;
    if (delta.newChangeMetaId.isPresent()) {
        changeMetaId = delta.newChangeMetaId.get();
        if (changeMetaId.equals(ObjectId.zeroId())) {
            change.setNoteDbState(null);
            return;
        }
    } else {
        changeMetaId = oldState.changeMetaId;
    }
    Map<Account.Id, ObjectId> draftIds = new HashMap<>();
    if (oldState != null) {
        draftIds.putAll(oldState.draftIds);
    }
    for (Map.Entry<Account.Id, ObjectId> e : delta.newDraftIds.entrySet()) {
        if (e.getValue().equals(ObjectId.zeroId())) {
            draftIds.remove(e.getKey());
        } else {
            draftIds.put(e.getKey(), e.getValue());
        }
    }
    change.setNoteDbState(new NoteDbChangeState(change.getId(), changeMetaId, draftIds).toString());
}
#method_after
public static void applyDelta(Change change, Delta delta) {
    if (delta == null) {
        return;
    }
    String oldStr = change.getNoteDbState();
    if (oldStr == null && !delta.newChangeMetaId().isPresent()) {
        // point in proceeding.
        return;
    }
    NoteDbChangeState oldState = parse(change.getId(), oldStr);
    ObjectId changeMetaId;
    if (delta.newChangeMetaId().isPresent()) {
        changeMetaId = delta.newChangeMetaId().get();
        if (changeMetaId.equals(ObjectId.zeroId())) {
            change.setNoteDbState(null);
            return;
        }
    } else {
        changeMetaId = oldState.changeMetaId;
    }
    Map<Account.Id, ObjectId> draftIds = new HashMap<>();
    if (oldState != null) {
        draftIds.putAll(oldState.draftIds);
    }
    for (Map.Entry<Account.Id, ObjectId> e : delta.newDraftIds().entrySet()) {
        if (e.getValue().equals(ObjectId.zeroId())) {
            draftIds.remove(e.getKey());
        } else {
            draftIds.put(e.getKey(), e.getValue());
        }
    }
    change.setNoteDbState(toString(changeMetaId, draftIds));
}
#end_block

#method_before
@Override
public String toString() {
    List<Account.Id> accountIds = Lists.newArrayList(draftIds.keySet());
    Collections.sort(accountIds, ReviewDbUtil.intKeyOrdering());
    StringBuilder sb = new StringBuilder(changeMetaId.name());
    for (Account.Id id : accountIds) {
        sb.append(',').append(id.get()).append('=').append(draftIds.get(id).name());
    }
    return sb.toString();
}
#method_after
private static String toString(ObjectId changeMetaId, Map<Account.Id, ObjectId> draftIds) {
    List<Account.Id> accountIds = Lists.newArrayList(draftIds.keySet());
    Collections.sort(accountIds, ReviewDbUtil.intKeyOrdering());
    StringBuilder sb = new StringBuilder(changeMetaId.name());
    for (Account.Id id : accountIds) {
        sb.append(',').append(id.get()).append('=').append(draftIds.get(id).name());
    }
    return sb.toString();
}
#end_block

#method_before
@Override
public String toString() {
    List<Account.Id> accountIds = Lists.newArrayList(draftIds.keySet());
    Collections.sort(accountIds, ReviewDbUtil.intKeyOrdering());
    StringBuilder sb = new StringBuilder(changeMetaId.name());
    for (Account.Id id : accountIds) {
        sb.append(',').append(id.get()).append('=').append(draftIds.get(id).name());
    }
    return sb.toString();
}
#method_after
@Override
public String toString() {
    return toString(changeMetaId, draftIds);
}
#end_block

#method_before
private static void diffChanges(List<String> diffs, ChangeBundle bundleA, ChangeBundle bundleB) {
    Change a = bundleA.change;
    Change b = bundleB.change;
    String desc = a.getId().equals(b.getId()) ? describe(a.getId()) : "Changes";
    diffColumns(diffs, Change.class, desc, bundleA, a, bundleB, b);
}
#method_after
private static void diffChanges(List<String> diffs, ChangeBundle bundleA, ChangeBundle bundleB) {
    Change a = bundleA.change;
    Change b = bundleB.change;
    String desc = a.getId().equals(b.getId()) ? describe(a.getId()) : "Changes";
    diffColumnsExcluding(diffs, Change.class, desc, bundleA, a, bundleB, b, "rowVersion", "noteDbState");
}
#end_block

#method_before
public Map<Change.Id, NoteDbChangeState.Delta> stage() throws OrmException, IOException {
    if (staged != null) {
        return staged;
    }
    staged = new HashMap<>();
    if (isEmpty()) {
        return staged;
    }
    initChangeRepo();
    if (!draftUpdates.isEmpty()) {
        initAllUsersRepo();
    }
    addCommands();
    Table<Change.Id, Account.Id, ObjectId> allDraftIds = getDraftIds();
    Set<Change.Id> changeIds = new HashSet<>();
    for (ReceiveCommand cmd : changeRepo.cmds.getCommands().values()) {
        Change.Id changeId = Change.Id.fromRef(cmd.getRefName());
        changeIds.add(changeId);
        Optional<ObjectId> metaId = Optional.of(cmd.getNewId());
        staged.put(changeId, new NoteDbChangeState.Delta(changeId, metaId, allDraftIds.rowMap().remove(changeId)));
    }
    for (Map.Entry<Change.Id, Map<Account.Id, ObjectId>> e : allDraftIds.rowMap().entrySet()) {
        // If a change remains in the table at this point, it means we are
        // updating its drafts but not the change itself.
        staged.put(e.getKey(), new NoteDbChangeState.Delta(e.getKey(), Optional.<ObjectId>absent(), e.getValue()));
    }
    return staged;
}
#method_after
public Map<Change.Id, NoteDbChangeState.Delta> stage() throws OrmException, IOException {
    if (staged != null) {
        return staged;
    }
    try (Timer1.Context timer = metrics.stageUpdateLatency.start(CHANGES)) {
        staged = new HashMap<>();
        if (isEmpty()) {
            return staged;
        }
        initChangeRepo();
        if (!draftUpdates.isEmpty()) {
            initAllUsersRepo();
        }
        addCommands();
        Table<Change.Id, Account.Id, ObjectId> allDraftIds = getDraftIds();
        Set<Change.Id> changeIds = new HashSet<>();
        for (ReceiveCommand cmd : changeRepo.cmds.getCommands().values()) {
            Change.Id changeId = Change.Id.fromRef(cmd.getRefName());
            changeIds.add(changeId);
            Optional<ObjectId> metaId = Optional.of(cmd.getNewId());
            staged.put(changeId, NoteDbChangeState.Delta.create(changeId, metaId, allDraftIds.rowMap().remove(changeId)));
        }
        for (Map.Entry<Change.Id, Map<Account.Id, ObjectId>> e : allDraftIds.rowMap().entrySet()) {
            // If a change remains in the table at this point, it means we are
            // updating its drafts but not the change itself.
            staged.put(e.getKey(), NoteDbChangeState.Delta.create(e.getKey(), Optional.<ObjectId>absent(), e.getValue()));
        }
        return staged;
    }
}
#end_block

#method_before
private Table<Change.Id, Account.Id, ObjectId> getDraftIds() {
    Table<Change.Id, Account.Id, ObjectId> draftIds = HashBasedTable.create();
    if (allUsersRepo == null) {
        return draftIds;
    }
    for (ReceiveCommand cmd : allUsersRepo.cmds.getCommands().values()) {
        String r = cmd.getRefName();
        if (r.startsWith(REFS_DRAFT_COMMENTS)) {
            String msg = "invalid draft ref: %s";
            Account.Id accountId = Account.Id.fromRefPart(r.substring(REFS_DRAFT_COMMENTS.length()));
            checkState(accountId != null, msg, r);
            int s = r.lastIndexOf('/');
            checkState(s >= 0 && s < r.length() - 1, msg, r);
            Change.Id changeId = Change.Id.parse(r.substring(s + 1));
            draftIds.put(changeId, accountId, cmd.getNewId());
        }
    }
    return draftIds;
}
#method_after
private Table<Change.Id, Account.Id, ObjectId> getDraftIds() {
    Table<Change.Id, Account.Id, ObjectId> draftIds = HashBasedTable.create();
    if (allUsersRepo == null) {
        return draftIds;
    }
    for (ReceiveCommand cmd : allUsersRepo.cmds.getCommands().values()) {
        String r = cmd.getRefName();
        if (r.startsWith(REFS_DRAFT_COMMENTS)) {
            Account.Id accountId = Account.Id.fromRefPart(r.substring(REFS_DRAFT_COMMENTS.length()));
            checkDraftRef(accountId != null, r);
            int s = r.lastIndexOf('/');
            checkDraftRef(s >= 0 && s < r.length() - 1, r);
            Change.Id changeId = Change.Id.parse(r.substring(s + 1));
            draftIds.put(changeId, accountId, cmd.getNewId());
        }
    }
    return draftIds;
}
#end_block

#method_before
public void execute() throws OrmException, IOException {
    if (isEmpty()) {
        return;
    }
    // TODO(dborowitz): Separate metric for staging latency?
    stage();
    try (Timer1.Context timer = metrics.updateLatency.start(CHANGES)) {
        // ChangeUpdates must execute before ChangeDraftUpdates.
        // 
        // ChangeUpdate will automatically delete draft comments for any published
        // comments, but the updates to the two repos don't happen atomically.
        // Thus if the change meta update succeeds and the All-Users update fails,
        // we may have stale draft comments. Doing it in this order allows stale
        // comments to be filtered out by ChangeNotes, reflecting the fact that
        // comments can only go from DRAFT to PUBLISHED, not vice versa.
        execute(changeRepo);
        execute(allUsersRepo);
    } finally {
        if (allUsersRepo != null) {
            allUsersRepo.close();
        }
        if (changeRepo != null) {
            changeRepo.close();
        }
    }
}
#method_after
public void execute() throws OrmException, IOException {
    if (isEmpty()) {
        return;
    }
    try (Timer1.Context timer = metrics.updateLatency.start(CHANGES)) {
        stage();
        // ChangeUpdates must execute before ChangeDraftUpdates.
        // 
        // ChangeUpdate will automatically delete draft comments for any published
        // comments, but the updates to the two repos don't happen atomically.
        // Thus if the change meta update succeeds and the All-Users update fails,
        // we may have stale draft comments. Doing it in this order allows stale
        // comments to be filtered out by ChangeNotes, reflecting the fact that
        // comments can only go from DRAFT to PUBLISHED, not vice versa.
        execute(changeRepo);
        execute(allUsersRepo);
    } finally {
        if (allUsersRepo != null) {
            allUsersRepo.close();
        }
        if (changeRepo != null) {
            changeRepo.close();
        }
    }
}
#end_block

#method_before
private static void addUpdates(ListMultimap<String, ? extends AbstractChangeUpdate> updates, OpenRepo or) throws OrmException, IOException {
    for (String refName : updates.keySet()) {
        ObjectId old = firstNonNull(or.cmds.getObjectId(or.repo, refName), ObjectId.zeroId());
        ObjectId curr = old;
        for (AbstractChangeUpdate u : updates.get(refName)) {
            ObjectId next = u.apply(or.rw, or.ins, curr);
            if (next == null) {
                continue;
            }
            curr = next;
        }
        if (!old.equals(curr)) {
            or.cmds.add(new ReceiveCommand(old, curr, refName));
        }
    }
}
#method_after
private static <U extends AbstractChangeUpdate> void addUpdates(ListMultimap<String, U> all, OpenRepo or) throws OrmException, IOException {
    for (Map.Entry<String, Collection<U>> e : all.asMap().entrySet()) {
        String refName = e.getKey();
        Collection<U> updates = e.getValue();
        ObjectId old = firstNonNull(or.cmds.getObjectId(or.repo, refName), ObjectId.zeroId());
        // writing partial change meta if the change hasn't been backfilled yet.
        if (!allowWrite(updates, old)) {
            continue;
        }
        ObjectId curr = old;
        for (U u : updates) {
            ObjectId next = u.apply(or.rw, or.ins, curr);
            if (next == null) {
                continue;
            }
            curr = next;
        }
        if (!old.equals(curr)) {
            or.cmds.add(new ReceiveCommand(old, curr, refName));
        }
    }
}
#end_block

