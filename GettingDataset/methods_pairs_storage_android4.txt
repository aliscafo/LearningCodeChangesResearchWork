322
#method_before
public void setDnsConfigurationForNetwork(int netId, LinkProperties lp, boolean isDefaultNetwork) {
    // We only use the PrivateDnsConfig data pushed to this class instance
    // from ConnectivityService because it works in coordination with
    // NetworkMonitor to decide which networks need validation and runs the
    // blocking calls to resolve Private DNS strict mode hostnames.
    // 
    // At this time we do attempt to enable Private DNS on non-Internet
    // networks like IMS.
    final PrivateDnsConfig privateDnsCfg = mPrivateDnsMap.get(netId);
    final boolean useTls = (privateDnsCfg != null) && privateDnsCfg.useTls;
    final boolean strictMode = (privateDnsCfg != null) && privateDnsCfg.inStrictMode();
    final String tlsHostname = strictMode ? privateDnsCfg.hostname : "";
    final String[] tlsServers = strictMode ? NetworkUtils.makeStrings(Arrays.stream(privateDnsCfg.ips).filter((ip) -> lp.isReachable(ip)).collect(Collectors.toList())) : new String[0];
    final String[] assignedServers = NetworkUtils.makeStrings(lp.getDnsServers());
    final String[] domainStrs = getDomainStrings(lp.getDomains());
    updateParametersSettings();
    final int[] params = { mSampleValidity, mSuccessThreshold, mMinSamples, mMaxSamples };
    Slog.d(TAG, String.format("setDnsConfigurationForNetwork(%d, %s, %s, %s, %s, %s, %s)", netId, Arrays.toString(assignedServers), Arrays.toString(domainStrs), Arrays.toString(params), useTls, tlsHostname, Arrays.toString(tlsServers)));
    try {
        mNMS.setDnsConfigurationForNetwork(netId, assignedServers, domainStrs, params, useTls, tlsHostname, tlsServers);
    } catch (Exception e) {
        Slog.e(TAG, "Error setting DNS configuration: " + e);
        return;
    }
    // the privacy protections of things like DNS-over-TLS.
    if (isDefaultNetwork)
        setDefaultDnsSystemProperties(lp.getDnsServers());
    flushVmDnsCache();
}
#method_after
public void setDnsConfigurationForNetwork(int netId, LinkProperties lp, boolean isDefaultNetwork) {
    final String[] assignedServers = NetworkUtils.makeStrings(lp.getDnsServers());
    final String[] domainStrs = getDomainStrings(lp.getDomains());
    updateParametersSettings();
    final int[] params = { mSampleValidity, mSuccessThreshold, mMinSamples, mMaxSamples };
    // We only use the PrivateDnsConfig data pushed to this class instance
    // from ConnectivityService because it works in coordination with
    // NetworkMonitor to decide which networks need validation and runs the
    // blocking calls to resolve Private DNS strict mode hostnames.
    // 
    // At this time we do attempt to enable Private DNS on non-Internet
    // networks like IMS.
    final PrivateDnsConfig privateDnsCfg = mPrivateDnsMap.get(netId);
    final boolean useTls = (privateDnsCfg != null) && privateDnsCfg.useTls;
    final boolean strictMode = (privateDnsCfg != null) && privateDnsCfg.inStrictMode();
    final String tlsHostname = strictMode ? privateDnsCfg.hostname : "";
    final String[] tlsServers = strictMode ? NetworkUtils.makeStrings(Arrays.stream(privateDnsCfg.ips).filter((ip) -> lp.isReachable(ip)).collect(Collectors.toList())) : // Opportunistic
    useTls ? // Opportunistic
    assignedServers : // Off
    new String[0];
    Slog.d(TAG, String.format("setDnsConfigurationForNetwork(%d, %s, %s, %s, %s, %s)", netId, Arrays.toString(assignedServers), Arrays.toString(domainStrs), Arrays.toString(params), tlsHostname, Arrays.toString(tlsServers)));
    try {
        mNMS.setDnsConfigurationForNetwork(netId, assignedServers, domainStrs, params, tlsHostname, tlsServers);
    } catch (Exception e) {
        Slog.e(TAG, "Error setting DNS configuration: " + e);
        return;
    }
    // the privacy protections of things like DNS-over-TLS.
    if (isDefaultNetwork)
        setDefaultDnsSystemProperties(lp.getDnsServers());
    flushVmDnsCache();
}
#end_block

#method_before
@Override
public void setDnsConfigurationForNetwork(int netId, String[] servers, String[] domains, int[] params, boolean useTls, String tlsHostname, String[] tlsServers) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final String[] tlsFingerprints = new String[0];
    try {
        mNetdService.setResolverConfiguration(netId, servers, domains, params, useTls, tlsHostname, tlsServers, tlsFingerprints);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
@Override
public void setDnsConfigurationForNetwork(int netId, String[] servers, String[] domains, int[] params, String tlsHostname, String[] tlsServers) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final String[] tlsFingerprints = new String[0];
    try {
        mNetdService.setResolverConfiguration(netId, servers, domains, params, tlsHostname, tlsServers, tlsFingerprints);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
@Test
public void testBasicDnsConfigurationPushed() throws Exception {
    final String[] EMPTY_TLS_SERVERS = new String[0];
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    waitForIdle();
    verify(mNetworkManagementService, never()).setDnsConfigurationForNetwork(anyInt(), any(), any(), any(), anyBoolean(), anyString(), eq(EMPTY_TLS_SERVERS));
    final LinkProperties cellLp = new LinkProperties();
    cellLp.setInterfaceName("test_rmnet_data0");
    mCellNetworkAgent.sendLinkProperties(cellLp);
    mCellNetworkAgent.connect(false);
    waitForIdle();
    verify(mNetworkManagementService, times(1)).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), anyBoolean(), anyString(), eq(EMPTY_TLS_SERVERS));
    // CS tells netd about the empty DNS config for this network.
    assertEmpty(mStringArrayCaptor.getValue());
    reset(mNetworkManagementService);
    cellLp.addDnsServer(InetAddress.getByName("2001:db8::1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mNetworkManagementService, times(1)).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), anyBoolean(), anyString(), eq(EMPTY_TLS_SERVERS));
    assertEquals(1, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.contains(mStringArrayCaptor.getValue(), "2001:db8::1"));
    reset(mNetworkManagementService);
    cellLp.addDnsServer(InetAddress.getByName("192.0.2.1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mNetworkManagementService, times(1)).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), anyBoolean(), anyString(), eq(EMPTY_TLS_SERVERS));
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mNetworkManagementService);
}
#method_after
@Test
public void testBasicDnsConfigurationPushed() throws Exception {
    final String IFNAME = "test_rmnet_data0";
    final String[] EMPTY_TLS_SERVERS = new String[0];
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    waitForIdle();
    verify(mNetworkManagementService, never()).setDnsConfigurationForNetwork(anyInt(), any(), any(), any(), anyString(), eq(EMPTY_TLS_SERVERS));
    final LinkProperties cellLp = new LinkProperties();
    cellLp.setInterfaceName(IFNAME);
    // Add IPv4 and IPv6 default routes, because DNS-over-TLS code does
    // "is-reachable" testing in order to not program netd with unreachable
    // nameservers that it might try repeated to validate.
    cellLp.addLinkAddress(new LinkAddress("192.0.2.4/24"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("192.0.2.4"), IFNAME));
    cellLp.addLinkAddress(new LinkAddress("2001:db8:1::1/64"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("2001:db8:1::1"), IFNAME));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    mCellNetworkAgent.connect(false);
    waitForIdle();
    verify(mNetworkManagementService, times(1)).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), anyString(), eq(EMPTY_TLS_SERVERS));
    // CS tells netd about the empty DNS config for this network.
    assertEmpty(mStringArrayCaptor.getValue());
    reset(mNetworkManagementService);
    cellLp.addDnsServer(InetAddress.getByName("2001:db8::1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mNetworkManagementService, times(1)).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), anyString(), eq(EMPTY_TLS_SERVERS));
    assertEquals(1, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.contains(mStringArrayCaptor.getValue(), "2001:db8::1"));
    reset(mNetworkManagementService);
    cellLp.addDnsServer(InetAddress.getByName("192.0.2.1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mNetworkManagementService, times(1)).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), anyString(), eq(EMPTY_TLS_SERVERS));
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mNetworkManagementService);
    final String TLS_SPECIFIER = "tls.example.com";
    final String TLS_SERVER6 = "2001:db8:53::53";
    final InetAddress[] TLS_IPS = new InetAddress[] { InetAddress.getByName(TLS_SERVER6) };
    final String[] TLS_SERVERS = new String[] { TLS_SERVER6 };
    final Handler h = mCellNetworkAgent.getWrappedNetworkMonitor().connectivityHandler;
    h.sendMessage(h.obtainMessage(NetworkMonitor.EVENT_PRIVATE_DNS_CONFIG_RESOLVED, 0, mCellNetworkAgent.getNetwork().netId, new DnsManager.PrivateDnsConfig(TLS_SPECIFIER, TLS_IPS)));
    waitForIdle();
    verify(mNetworkManagementService, times(1)).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(TLS_SPECIFIER), eq(TLS_SERVERS));
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mNetworkManagementService);
}
#end_block

#method_before
// Android-removed: isAncestor's only usage was removed above.
/**
 * Returns true if the second classloader can be found in the first
 * classloader's delegation chain.
 * Equivalent to the inaccessible: first.isAncestor(second).
 */
/*
        private static boolean isAncestor(ClassLoader first, ClassLoader second) {
            ClassLoader acl = first;
            do {
                acl = acl.getParent();
                if (second == acl) {
                    return true;
                }
            } while (acl != null);
            return false;
        }
        */
private final void accessCheck(T obj) {
    if (!cclass.isInstance(obj))
        throwAccessCheckException(obj);
}
#method_after
// Android-removed: isAncestor's only usage was removed above.
/*
        /**
         * Returns true if the second classloader can be found in the first
         * classloader's delegation chain.
         * Equivalent to the inaccessible: first.isAncestor(second).
         *
        private static boolean isAncestor(ClassLoader first, ClassLoader second) {
            ClassLoader acl = first;
            do {
                acl = acl.getParent();
                if (second == acl) {
                    return true;
                }
            } while (acl != null);
            return false;
        }
        */
private final void accessCheck(T obj) {
    if (!cclass.isInstance(obj))
        throwAccessCheckException(obj);
}
#end_block

#method_before
private void addActiveLog(int reason, String packageName, boolean enable) {
    synchronized (mActiveLogs) {
        if (mActiveLogs.size() > ACTIVE_LOG_MAX_SIZE) {
            mActiveLogs.remove();
        }
        mActiveLogs.add(new ActiveLog(reason, packageName, enable, System.currentTimeMillis()));
        if (enable) {
            StatsLog.write_non_chained(StatsLog.BLUETOOTH_ENABLED_STATE_CHANGED, Binder.getCallingUid(), null, StatsLog.BLUETOOTH_ENABLED_STATE_CHANGED__STATE__ENABLED, reason, packageName);
        } else {
            StatsLog.write_non_chained(StatsLog.BLUETOOTH_ENABLED_STATE_CHANGED, Binder.getCallingUid(), null, StatsLog.BLUETOOTH_ENABLED_STATE_CHANGED__STATE__DISABLED, reason, packageName);
        }
    }
}
#method_after
private void addActiveLog(int reason, String packageName, boolean enable) {
    synchronized (mActiveLogs) {
        if (mActiveLogs.size() > ACTIVE_LOG_MAX_SIZE) {
            mActiveLogs.remove();
        }
        mActiveLogs.add(new ActiveLog(reason, packageName, enable, System.currentTimeMillis()));
    }
    int state = enable ? StatsLog.BLUETOOTH_ENABLED_STATE_CHANGED__STATE__ENABLED : StatsLog.BLUETOOTH_ENABLED_STATE_CHANGED__STATE__DISABLED;
    StatsLog.write_non_chained(StatsLog.BLUETOOTH_ENABLED_STATE_CHANGED, Binder.getCallingUid(), null, state, reason, packageName);
}
#end_block

#method_before
private void createOrUpdateTransform(IpSecConfig c, int resourceId, SpiRecord spiRecord, EncapSocketRecord socketRecord) throws RemoteException {
    int encapType = c.getEncapType(), encapLocalPort = 0, encapRemotePort = 0;
    if (encapType != IpSecTransform.ENCAP_NONE) {
        encapLocalPort = socketRecord.getPort();
        encapRemotePort = c.getEncapRemotePort();
    }
    IpSecAlgorithm auth = c.getAuthentication();
    IpSecAlgorithm crypt = c.getEncryption();
    IpSecAlgorithm authCrypt = c.getAuthenticatedEncryption();
    String cryptName;
    if (crypt == null) {
        cryptname = (authCrypt == null) ? IpSecAlgorithm.CRYPT_NULL : "";
    } else {
        cryptName = crypt.getName();
    }
    mSrvConfig.getNetdInstance().ipSecAddSecurityAssociation(resourceId, c.getMode(), c.getSourceAddress(), c.getDestinationAddress(), (c.getNetwork() != null) ? c.getNetwork().netId : 0, spiRecord.getSpi(), c.getMarkValue(), c.getMarkMask(), (auth != null) ? auth.getName() : "", (auth != null) ? auth.getKey() : new byte[] {}, (auth != null) ? auth.getTruncationLengthBits() : 0, cryptName, (crypt != null) ? crypt.getKey() : new byte[] {}, (crypt != null) ? crypt.getTruncationLengthBits() : 0, (authCrypt != null) ? authCrypt.getName() : "", (authCrypt != null) ? authCrypt.getKey() : new byte[] {}, (authCrypt != null) ? authCrypt.getTruncationLengthBits() : 0, encapType, encapLocalPort, encapRemotePort);
}
#method_after
private void createOrUpdateTransform(IpSecConfig c, int resourceId, SpiRecord spiRecord, EncapSocketRecord socketRecord) throws RemoteException {
    int encapType = c.getEncapType(), encapLocalPort = 0, encapRemotePort = 0;
    if (encapType != IpSecTransform.ENCAP_NONE) {
        encapLocalPort = socketRecord.getPort();
        encapRemotePort = c.getEncapRemotePort();
    }
    IpSecAlgorithm auth = c.getAuthentication();
    IpSecAlgorithm crypt = c.getEncryption();
    IpSecAlgorithm authCrypt = c.getAuthenticatedEncryption();
    String cryptName;
    if (crypt == null) {
        cryptName = (authCrypt == null) ? IpSecAlgorithm.CRYPT_NULL : "";
    } else {
        cryptName = crypt.getName();
    }
    mSrvConfig.getNetdInstance().ipSecAddSecurityAssociation(resourceId, c.getMode(), c.getSourceAddress(), c.getDestinationAddress(), (c.getNetwork() != null) ? c.getNetwork().netId : 0, spiRecord.getSpi(), c.getMarkValue(), c.getMarkMask(), (auth != null) ? auth.getName() : "", (auth != null) ? auth.getKey() : new byte[] {}, (auth != null) ? auth.getTruncationLengthBits() : 0, cryptName, (crypt != null) ? crypt.getKey() : new byte[] {}, (crypt != null) ? crypt.getTruncationLengthBits() : 0, (authCrypt != null) ? authCrypt.getName() : "", (authCrypt != null) ? authCrypt.getKey() : new byte[] {}, (authCrypt != null) ? authCrypt.getTruncationLengthBits() : 0, encapType, encapLocalPort, encapRemotePort);
}
#end_block

#method_before
// Called from native code.
@SuppressWarnings("unused")
private static void callChangeCallbacks() {
    synchronized (sChangeCallbacks) {
        // Log.i("foo", "Calling " + sChangeCallbacks.size() + " change callbacks!");
        if (sChangeCallbacks.size() == 0) {
            return;
        }
        ArrayList<Runnable> callbacks = new ArrayList<Runnable>(sChangeCallbacks);
        for (int i = 0; i < callbacks.size(); i++) {
            try {
                callbacks.get(i).run();
            } catch (Exception e) {
            // Ignore.
            } catch (Throwable t) {
                // We could continue after Throwable, but it isn't clear that we
                // should, these are usually really bad. But at least try to log
                // something.
                Log.e(TAG, "Error during callChangeCallbacks", t);
                return;
            }
        }
    }
}
#method_after
// Called from native code.
@SuppressWarnings("unused")
private static void callChangeCallbacks() {
    synchronized (sChangeCallbacks) {
        // Log.i("foo", "Calling " + sChangeCallbacks.size() + " change callbacks!");
        if (sChangeCallbacks.size() == 0) {
            return;
        }
        ArrayList<Runnable> callbacks = new ArrayList<Runnable>(sChangeCallbacks);
        for (int i = 0; i < callbacks.size(); i++) {
            try {
                callbacks.get(i).run();
            } catch (Throwable t) {
                Log.wtf(TAG, "Exception in SystemProperties change callback", t);
            // Ignore and try to go on.
            }
        }
    }
}
#end_block

#method_before
private Result verify(DataSource apk) throws IOException, ApkFormatException, NoSuchAlgorithmException {
    if (mMinSdkVersion != null) {
        if (mMinSdkVersion < 0) {
            throw new IllegalArgumentException("minSdkVersion must not be negative: " + mMinSdkVersion);
        }
        if ((mMinSdkVersion != null) && (mMinSdkVersion > mMaxSdkVersion)) {
            throw new IllegalArgumentException("minSdkVersion (" + mMinSdkVersion + ") > maxSdkVersion (" + mMaxSdkVersion + ")");
        }
    }
    int maxSdkVersion = mMaxSdkVersion;
    ApkUtils.ZipSections zipSections;
    try {
        zipSections = ApkUtils.findZipSections(apk);
    } catch (ZipFormatException e) {
        throw new ApkFormatException("Malformed APK: not a ZIP archive", e);
    }
    ByteBuffer androidManifest = null;
    int minSdkVersion;
    if (mMinSdkVersion != null) {
        // No need to obtain minSdkVersion from the APK's AndroidManifest.xml
        minSdkVersion = mMinSdkVersion;
    } else {
        // Need to obtain minSdkVersion from the APK's AndroidManifest.xml
        if (androidManifest == null) {
            androidManifest = getAndroidManifestFromApk(apk, zipSections);
        }
        minSdkVersion = ApkUtils.getMinSdkVersionFromBinaryAndroidManifest(androidManifest.slice());
        if (minSdkVersion > mMaxSdkVersion) {
            throw new IllegalArgumentException("minSdkVersion from APK (" + minSdkVersion + ") > maxSdkVersion (" + mMaxSdkVersion + ")");
        }
    }
    Result result = new Result();
    // Android N and newer attempts to verify APKs using the APK Signing Block, which can
    // include v2 and/or v3 signatures.  If none is found, it falls back to JAR signature
    // verification. If the signature is found but does not verify, the APK is rejected.
    Set<Integer> foundApkSigSchemeIds = new HashSet<>(2);
    if (maxSdkVersion >= AndroidSdkVersion.N) {
        // Android P and newer attempts to verify APKs using APK Signature Scheme v3
        if (maxSdkVersion >= AndroidSdkVersion.P) {
            try {
                ApkSigningBlockUtils.Result v3Result = V3SchemeVerifier.verify(apk, zipSections, Math.max(minSdkVersion, AndroidSdkVersion.P), maxSdkVersion);
                foundApkSigSchemeIds.add(ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3);
                result.mergeFrom(v3Result);
            } catch (ApkSigningBlockUtils.SignatureNotFoundException ignored) {
            // v3 signature not required
            }
            if (result.containsErrors()) {
                return result;
            }
        }
        // no APK Signature Scheme v3 (or newer scheme) signatures were found.
        if (minSdkVersion < AndroidSdkVersion.P || foundApkSigSchemeIds.isEmpty()) {
            try {
                ApkSigningBlockUtils.Result v2Result = V2SchemeVerifier.verify(apk, zipSections, SUPPORTED_APK_SIG_SCHEME_NAMES, foundApkSigSchemeIds, Math.max(minSdkVersion, AndroidSdkVersion.N), maxSdkVersion);
                foundApkSigSchemeIds.add(ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2);
                result.mergeFrom(v2Result);
            } catch (ApkSigningBlockUtils.SignatureNotFoundException ignored) {
            // v2 signature not required
            }
            if (result.containsErrors()) {
                return result;
            }
        }
    }
    // are signed using APK Signature Scheme v2 or newer.
    if (maxSdkVersion >= AndroidSdkVersion.O) {
        if (androidManifest == null) {
            androidManifest = getAndroidManifestFromApk(apk, zipSections);
        }
        int targetSandboxVersion = getTargetSandboxVersionFromBinaryAndroidManifest(androidManifest.slice());
        if (targetSandboxVersion > 1) {
            if (foundApkSigSchemeIds.isEmpty()) {
                result.addError(Issue.NO_SIG_FOR_TARGET_SANDBOX_VERSION, targetSandboxVersion);
            }
        }
    }
    // scheme) signatures were found.
    if ((minSdkVersion < AndroidSdkVersion.N) || (foundApkSigSchemeIds.isEmpty())) {
        V1SchemeVerifier.Result v1Result = V1SchemeVerifier.verify(apk, zipSections, SUPPORTED_APK_SIG_SCHEME_NAMES, foundApkSigSchemeIds, minSdkVersion, maxSdkVersion);
        result.mergeFrom(v1Result);
    }
    if (result.containsErrors()) {
        return result;
    }
    // signatures verified.
    if ((result.isVerifiedUsingV1Scheme()) && (result.isVerifiedUsingV2Scheme())) {
        ArrayList<Result.V1SchemeSignerInfo> v1Signers = new ArrayList<>(result.getV1SchemeSigners());
        ArrayList<Result.V2SchemeSignerInfo> v2Signers = new ArrayList<>(result.getV2SchemeSigners());
        ArrayList<ByteArray> v1SignerCerts = new ArrayList<>();
        ArrayList<ByteArray> v2SignerCerts = new ArrayList<>();
        for (Result.V1SchemeSignerInfo signer : v1Signers) {
            try {
                v1SignerCerts.add(new ByteArray(signer.getCertificate().getEncoded()));
            } catch (CertificateEncodingException e) {
                throw new RuntimeException("Failed to encode JAR signer " + signer.getName() + " certs", e);
            }
        }
        for (Result.V2SchemeSignerInfo signer : v2Signers) {
            try {
                v2SignerCerts.add(new ByteArray(signer.getCertificate().getEncoded()));
            } catch (CertificateEncodingException e) {
                throw new RuntimeException("Failed to encode APK Signature Scheme v2 signer (index: " + signer.getIndex() + ") certs", e);
            }
        }
        for (int i = 0; i < v1SignerCerts.size(); i++) {
            ByteArray v1Cert = v1SignerCerts.get(i);
            if (!v2SignerCerts.contains(v1Cert)) {
                Result.V1SchemeSignerInfo v1Signer = v1Signers.get(i);
                v1Signer.addError(Issue.V2_SIG_MISSING);
                break;
            }
        }
        for (int i = 0; i < v2SignerCerts.size(); i++) {
            ByteArray v2Cert = v2SignerCerts.get(i);
            if (!v1SignerCerts.contains(v2Cert)) {
                Result.V2SchemeSignerInfo v2Signer = v2Signers.get(i);
                v2Signer.addError(Issue.JAR_SIG_MISSING);
                break;
            }
        }
    }
    // matches the oldest signing certificate in the provided SigningCertificateLineage
    if (result.isVerifiedUsingV3Scheme() && (result.isVerifiedUsingV1Scheme() || result.isVerifiedUsingV2Scheme())) {
        SigningCertificateLineage lineage = result.getSigningCertificateLineage();
        X509Certificate oldSignerCert;
        if (result.isVerifiedUsingV1Scheme()) {
            List<Result.V1SchemeSignerInfo> v1Signers = result.getV1SchemeSigners();
            if (v1Signers.size() != 1) {
                // APK Signature Scheme v3 only supports single-signers, error to sign with
                // multiple and then only one
                result.addError(Issue.V3_SIG_MULTIPLE_PAST_SIGNERS);
            }
            oldSignerCert = v1Signers.get(0).mCertChain.get(0);
        } else {
            List<Result.V2SchemeSignerInfo> v2Signers = result.getV2SchemeSigners();
            if (v2Signers.size() != 1) {
                // APK Signature Scheme v3 only supports single-signers, error to sign with
                // multiple and then only one
                result.addError(Issue.V3_SIG_MULTIPLE_PAST_SIGNERS);
            }
            oldSignerCert = v2Signers.get(0).mCerts.get(0);
        }
        if (lineage == null) {
            // no signing certificate history with which to contend, just make sure that v3
            // matches previous versions
            List<Result.V3SchemeSignerInfo> v3Signers = result.getV3SchemeSigners();
            if (v3Signers.size() != 1) {
                // multiple v3 signers should never exist without rotation history, since
                // multiple signers implies a different signer for different platform versions
                result.addError(Issue.V3_SIG_MULTIPLE_SIGNERS);
            }
            try {
                if (!Arrays.equals(oldSignerCert.getEncoded(), v3Signers.get(0).mCerts.get(0).getEncoded())) {
                    result.addError(Issue.V3_SIG_PAST_SIGNERS_MISMATCH);
                }
            } catch (CertificateEncodingException e) {
                // we just go the encoding for the v1/v2 certs above, so must be v3
                throw new RuntimeException("Failed to encode APK Signature Scheme v3 signer cert", e);
            }
        } else {
            // as our v1/v2 signer
            try {
                lineage = lineage.getSubLineage(oldSignerCert);
                if (lineage.size() != 1) {
                    // the v1/v2 signer was found, but not at the root of the lineage
                    result.addError(Issue.V3_SIG_PAST_SIGNERS_MISMATCH);
                }
            } catch (IllegalArgumentException e) {
                // the v1/v2 signer was not found in the lineage
                result.addError(Issue.V3_SIG_PAST_SIGNERS_MISMATCH);
            }
        }
    }
    if (result.containsErrors()) {
        return result;
    }
    // Verified
    result.setVerified();
    if (result.isVerifiedUsingV3Scheme()) {
        List<Result.V3SchemeSignerInfo> v3Signers = result.getV3SchemeSigners();
        result.addSignerCertificate(v3Signers.get(v3Signers.size() - 1).getCertificate());
    } else if (result.isVerifiedUsingV2Scheme()) {
        for (Result.V2SchemeSignerInfo signerInfo : result.getV2SchemeSigners()) {
            result.addSignerCertificate(signerInfo.getCertificate());
        }
    } else if (result.isVerifiedUsingV1Scheme()) {
        for (Result.V1SchemeSignerInfo signerInfo : result.getV1SchemeSigners()) {
            result.addSignerCertificate(signerInfo.getCertificate());
        }
    } else {
        throw new RuntimeException("APK considered verified, but has not verified using either v1 or v2 schemes");
    }
    return result;
}
#method_after
private Result verify(DataSource apk) throws IOException, ApkFormatException, NoSuchAlgorithmException {
    if (mMinSdkVersion != null) {
        if (mMinSdkVersion < 0) {
            throw new IllegalArgumentException("minSdkVersion must not be negative: " + mMinSdkVersion);
        }
        if ((mMinSdkVersion != null) && (mMinSdkVersion > mMaxSdkVersion)) {
            throw new IllegalArgumentException("minSdkVersion (" + mMinSdkVersion + ") > maxSdkVersion (" + mMaxSdkVersion + ")");
        }
    }
    int maxSdkVersion = mMaxSdkVersion;
    ApkUtils.ZipSections zipSections;
    try {
        zipSections = ApkUtils.findZipSections(apk);
    } catch (ZipFormatException e) {
        throw new ApkFormatException("Malformed APK: not a ZIP archive", e);
    }
    ByteBuffer androidManifest = null;
    int minSdkVersion;
    if (mMinSdkVersion != null) {
        // No need to obtain minSdkVersion from the APK's AndroidManifest.xml
        minSdkVersion = mMinSdkVersion;
    } else {
        // Need to obtain minSdkVersion from the APK's AndroidManifest.xml
        if (androidManifest == null) {
            androidManifest = getAndroidManifestFromApk(apk, zipSections);
        }
        minSdkVersion = ApkUtils.getMinSdkVersionFromBinaryAndroidManifest(androidManifest.slice());
        if (minSdkVersion > mMaxSdkVersion) {
            throw new IllegalArgumentException("minSdkVersion from APK (" + minSdkVersion + ") > maxSdkVersion (" + mMaxSdkVersion + ")");
        }
    }
    Result result = new Result();
    // Android N and newer attempts to verify APKs using the APK Signing Block, which can
    // include v2 and/or v3 signatures.  If none is found, it falls back to JAR signature
    // verification. If the signature is found but does not verify, the APK is rejected.
    Set<Integer> foundApkSigSchemeIds = new HashSet<>(2);
    if (maxSdkVersion >= AndroidSdkVersion.N) {
        // Android P and newer attempts to verify APKs using APK Signature Scheme v3
        if (maxSdkVersion >= AndroidSdkVersion.P) {
            try {
                ApkSigningBlockUtils.Result v3Result = V3SchemeVerifier.verify(apk, zipSections, Math.max(minSdkVersion, AndroidSdkVersion.P), maxSdkVersion);
                foundApkSigSchemeIds.add(ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3);
                result.mergeFrom(v3Result);
            } catch (ApkSigningBlockUtils.SignatureNotFoundException ignored) {
            // v3 signature not required
            }
            if (result.containsErrors()) {
                return result;
            }
        }
        // no APK Signature Scheme v3 (or newer scheme) signatures were found.
        if (minSdkVersion < AndroidSdkVersion.P || foundApkSigSchemeIds.isEmpty()) {
            try {
                ApkSigningBlockUtils.Result v2Result = V2SchemeVerifier.verify(apk, zipSections, SUPPORTED_APK_SIG_SCHEME_NAMES, foundApkSigSchemeIds, Math.max(minSdkVersion, AndroidSdkVersion.N), maxSdkVersion);
                foundApkSigSchemeIds.add(ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2);
                result.mergeFrom(v2Result);
            } catch (ApkSigningBlockUtils.SignatureNotFoundException ignored) {
            // v2 signature not required
            }
            if (result.containsErrors()) {
                return result;
            }
        }
    }
    // are signed using APK Signature Scheme v2 or newer.
    if (maxSdkVersion >= AndroidSdkVersion.O) {
        if (androidManifest == null) {
            androidManifest = getAndroidManifestFromApk(apk, zipSections);
        }
        int targetSandboxVersion = getTargetSandboxVersionFromBinaryAndroidManifest(androidManifest.slice());
        if (targetSandboxVersion > 1) {
            if (foundApkSigSchemeIds.isEmpty()) {
                result.addError(Issue.NO_SIG_FOR_TARGET_SANDBOX_VERSION, targetSandboxVersion);
            }
        }
    }
    // scheme) signatures were found.
    if ((minSdkVersion < AndroidSdkVersion.N) || (foundApkSigSchemeIds.isEmpty())) {
        V1SchemeVerifier.Result v1Result = V1SchemeVerifier.verify(apk, zipSections, SUPPORTED_APK_SIG_SCHEME_NAMES, foundApkSigSchemeIds, minSdkVersion, maxSdkVersion);
        result.mergeFrom(v1Result);
    }
    if (result.containsErrors()) {
        return result;
    }
    // signatures verified.
    if ((result.isVerifiedUsingV1Scheme()) && (result.isVerifiedUsingV2Scheme())) {
        ArrayList<Result.V1SchemeSignerInfo> v1Signers = new ArrayList<>(result.getV1SchemeSigners());
        ArrayList<Result.V2SchemeSignerInfo> v2Signers = new ArrayList<>(result.getV2SchemeSigners());
        ArrayList<ByteArray> v1SignerCerts = new ArrayList<>();
        ArrayList<ByteArray> v2SignerCerts = new ArrayList<>();
        for (Result.V1SchemeSignerInfo signer : v1Signers) {
            try {
                v1SignerCerts.add(new ByteArray(signer.getCertificate().getEncoded()));
            } catch (CertificateEncodingException e) {
                throw new RuntimeException("Failed to encode JAR signer " + signer.getName() + " certs", e);
            }
        }
        for (Result.V2SchemeSignerInfo signer : v2Signers) {
            try {
                v2SignerCerts.add(new ByteArray(signer.getCertificate().getEncoded()));
            } catch (CertificateEncodingException e) {
                throw new RuntimeException("Failed to encode APK Signature Scheme v2 signer (index: " + signer.getIndex() + ") certs", e);
            }
        }
        for (int i = 0; i < v1SignerCerts.size(); i++) {
            ByteArray v1Cert = v1SignerCerts.get(i);
            if (!v2SignerCerts.contains(v1Cert)) {
                Result.V1SchemeSignerInfo v1Signer = v1Signers.get(i);
                v1Signer.addError(Issue.V2_SIG_MISSING);
                break;
            }
        }
        for (int i = 0; i < v2SignerCerts.size(); i++) {
            ByteArray v2Cert = v2SignerCerts.get(i);
            if (!v1SignerCerts.contains(v2Cert)) {
                Result.V2SchemeSignerInfo v2Signer = v2Signers.get(i);
                v2Signer.addError(Issue.JAR_SIG_MISSING);
                break;
            }
        }
    }
    // matches the oldest signing certificate in the provided SigningCertificateLineage
    if (result.isVerifiedUsingV3Scheme() && (result.isVerifiedUsingV1Scheme() || result.isVerifiedUsingV2Scheme())) {
        SigningCertificateLineage lineage = result.getSigningCertificateLineage();
        X509Certificate oldSignerCert;
        if (result.isVerifiedUsingV1Scheme()) {
            List<Result.V1SchemeSignerInfo> v1Signers = result.getV1SchemeSigners();
            if (v1Signers.size() != 1) {
                // APK Signature Scheme v3 only supports single-signers, error to sign with
                // multiple and then only one
                result.addError(Issue.V3_SIG_MULTIPLE_PAST_SIGNERS);
            }
            oldSignerCert = v1Signers.get(0).mCertChain.get(0);
        } else {
            List<Result.V2SchemeSignerInfo> v2Signers = result.getV2SchemeSigners();
            if (v2Signers.size() != 1) {
                // APK Signature Scheme v3 only supports single-signers, error to sign with
                // multiple and then only one
                result.addError(Issue.V3_SIG_MULTIPLE_PAST_SIGNERS);
            }
            oldSignerCert = v2Signers.get(0).mCerts.get(0);
        }
        if (lineage == null) {
            // no signing certificate history with which to contend, just make sure that v3
            // matches previous versions
            List<Result.V3SchemeSignerInfo> v3Signers = result.getV3SchemeSigners();
            if (v3Signers.size() != 1) {
                // multiple v3 signers should never exist without rotation history, since
                // multiple signers implies a different signer for different platform versions
                result.addError(Issue.V3_SIG_MULTIPLE_SIGNERS);
            }
            try {
                if (!Arrays.equals(oldSignerCert.getEncoded(), v3Signers.get(0).mCerts.get(0).getEncoded())) {
                    result.addError(Issue.V3_SIG_PAST_SIGNERS_MISMATCH);
                }
            } catch (CertificateEncodingException e) {
                // we just go the encoding for the v1/v2 certs above, so must be v3
                throw new RuntimeException("Failed to encode APK Signature Scheme v3 signer cert", e);
            }
        } else {
            // as our v1/v2 signer
            try {
                lineage = lineage.getSubLineage(oldSignerCert);
                if (lineage.size() != 1) {
                    // the v1/v2 signer was found, but not at the root of the lineage
                    result.addError(Issue.V3_SIG_PAST_SIGNERS_MISMATCH);
                }
            } catch (IllegalArgumentException e) {
                // the v1/v2 signer was not found in the lineage
                result.addError(Issue.V3_SIG_PAST_SIGNERS_MISMATCH);
            }
        }
    }
    if (result.containsErrors()) {
        return result;
    }
    // Verified
    result.setVerified();
    if (result.isVerifiedUsingV3Scheme()) {
        List<Result.V3SchemeSignerInfo> v3Signers = result.getV3SchemeSigners();
        result.addSignerCertificate(v3Signers.get(v3Signers.size() - 1).getCertificate());
    } else if (result.isVerifiedUsingV2Scheme()) {
        for (Result.V2SchemeSignerInfo signerInfo : result.getV2SchemeSigners()) {
            result.addSignerCertificate(signerInfo.getCertificate());
        }
    } else if (result.isVerifiedUsingV1Scheme()) {
        for (Result.V1SchemeSignerInfo signerInfo : result.getV1SchemeSigners()) {
            result.addSignerCertificate(signerInfo.getCertificate());
        }
    } else {
        throw new RuntimeException("APK verified, but has not verified using any of v1, v2 or v3schemes");
    }
    return result;
}
#end_block

#method_before
public DefaultApkSignerEngine build() throws InvalidKeyException {
    if (mV3SigningExplicitlyDisabled && mV3SigningExplicitlyEnabled) {
        throw new IllegalStateException("Builder configured to both enable and disable APK " + "Signature Scheme v3 signing");
    }
    if (mV3SigningExplicitlyDisabled) {
        mV3SigningEnabled = false;
    } else if (mV3SigningExplicitlyEnabled) {
        mV3SigningEnabled = true;
    }
    // make sure our signers are appropriately setup
    if (mSigningCertificateLineage != null) {
        try {
            mSignerConfigs = mSigningCertificateLineage.sortSignerConfigs(mSignerConfigs);
            if (!mV3SigningEnabled && mSignerConfigs.size() > 1) {
                // which signer the user intended to sign
                throw new IllegalStateException("Provided multiple signers which are part " + "of the SigningCertificateLineage, but not signing with APK " + "Signature Scheme v3");
            }
        } catch (IllegalArgumentException e) {
            throw new IllegalStateException("Provided signer configs do not match the " + "provided SigningCertificateLineage", e);
        }
    } else if (mV3SigningEnabled && mSignerConfigs.size() > 1) {
        throw new IllegalStateException("Multiple signing certificates provided for use " + "with APK Signature Scheme v3 without an accompanying SigningCertificateLineage");
    }
    return new DefaultApkSignerEngine(mSignerConfigs, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mV3SigningEnabled, mDebuggableApkPermitted, mOtherSignersSignaturesPreserved, mCreatedBy, mSigningCertificateLineage);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mName, mPrivateKey, mCertificates);
}
#end_block

#method_before
private static void parseSigner(ByteBuffer signerBlock, CertificateFactory certFactory, ApkSigningBlockUtils.Result.SignerInfo result, Set<ContentDigestAlgorithm> contentDigestsToVerify, Map<Integer, String> supportedApkSigSchemeNames, Set<Integer> foundApkSigSchemeIds, int minSdkVersion, int maxSdkVersion) throws ApkFormatException, NoSuchAlgorithmException {
    ByteBuffer signedData = ApkSigningBlockUtils.getLengthPrefixedSlice(signerBlock);
    byte[] signedDataBytes = new byte[signedData.remaining()];
    signedData.get(signedDataBytes);
    signedData.flip();
    result.signedData = signedDataBytes;
    ByteBuffer signatures = ApkSigningBlockUtils.getLengthPrefixedSlice(signerBlock);
    byte[] publicKeyBytes = ApkSigningBlockUtils.readLengthPrefixedByteArray(signerBlock);
    // Parse the signatures block and identify supported signatures
    int signatureCount = 0;
    List<ApkSigningBlockUtils.SupportedSignature> supportedSignatures = new ArrayList<>(1);
    while (signatures.hasRemaining()) {
        signatureCount++;
        try {
            ByteBuffer signature = ApkSigningBlockUtils.getLengthPrefixedSlice(signatures);
            int sigAlgorithmId = signature.getInt();
            byte[] sigBytes = ApkSigningBlockUtils.readLengthPrefixedByteArray(signature);
            result.signatures.add(new ApkSigningBlockUtils.Result.SignerInfo.Signature(sigAlgorithmId, sigBytes));
            SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.findById(sigAlgorithmId);
            if (signatureAlgorithm == null) {
                result.addWarning(Issue.V2_SIG_UNKNOWN_SIG_ALGORITHM, sigAlgorithmId);
                continue;
            }
            supportedSignatures.add(new ApkSigningBlockUtils.SupportedSignature(signatureAlgorithm, sigBytes));
        } catch (ApkFormatException | BufferUnderflowException e) {
            result.addError(Issue.V2_SIG_MALFORMED_SIGNATURE, signatureCount);
            return;
        }
    }
    if (result.signatures.isEmpty()) {
        result.addError(Issue.V2_SIG_NO_SIGNATURES);
        return;
    }
    // Verify signatures over signed-data block using the public key
    List<ApkSigningBlockUtils.SupportedSignature> signaturesToVerify = null;
    try {
        signaturesToVerify = ApkSigningBlockUtils.getSignaturesToVerify(supportedSignatures, minSdkVersion, maxSdkVersion);
    } catch (ApkSigningBlockUtils.NoSupportedSignaturesException e) {
        result.addError(Issue.V2_SIG_NO_SUPPORTED_SIGNATURES);
        return;
    }
    for (ApkSigningBlockUtils.SupportedSignature signature : signaturesToVerify) {
        SignatureAlgorithm signatureAlgorithm = signature.algorithm;
        String jcaSignatureAlgorithm = signatureAlgorithm.getJcaSignatureAlgorithmAndParams().getFirst();
        AlgorithmParameterSpec jcaSignatureAlgorithmParams = signatureAlgorithm.getJcaSignatureAlgorithmAndParams().getSecond();
        String keyAlgorithm = signatureAlgorithm.getJcaKeyAlgorithm();
        PublicKey publicKey;
        try {
            publicKey = KeyFactory.getInstance(keyAlgorithm).generatePublic(new X509EncodedKeySpec(publicKeyBytes));
        } catch (Exception e) {
            result.addError(Issue.V2_SIG_MALFORMED_PUBLIC_KEY, e);
            return;
        }
        try {
            Signature sig = Signature.getInstance(jcaSignatureAlgorithm);
            sig.initVerify(publicKey);
            if (jcaSignatureAlgorithmParams != null) {
                sig.setParameter(jcaSignatureAlgorithmParams);
            }
            signedData.position(0);
            sig.update(signedData);
            byte[] sigBytes = signature.signature;
            if (!sig.verify(sigBytes)) {
                result.addError(Issue.V2_SIG_DID_NOT_VERIFY, signatureAlgorithm);
                return;
            }
            result.verifiedSignatures.put(signatureAlgorithm, sigBytes);
            contentDigestsToVerify.add(signatureAlgorithm.getContentDigestAlgorithm());
        } catch (InvalidKeyException | InvalidAlgorithmParameterException | SignatureException e) {
            result.addError(Issue.V2_SIG_VERIFY_EXCEPTION, signatureAlgorithm, e);
            return;
        }
    }
    // At least one signature over signedData has verified. We can now parse signed-data.
    signedData.position(0);
    ByteBuffer digests = ApkSigningBlockUtils.getLengthPrefixedSlice(signedData);
    ByteBuffer certificates = ApkSigningBlockUtils.getLengthPrefixedSlice(signedData);
    ByteBuffer additionalAttributes = ApkSigningBlockUtils.getLengthPrefixedSlice(signedData);
    // Parse the certificates block
    int certificateIndex = -1;
    while (certificates.hasRemaining()) {
        certificateIndex++;
        byte[] encodedCert = ApkSigningBlockUtils.readLengthPrefixedByteArray(certificates);
        X509Certificate certificate;
        try {
            certificate = (X509Certificate) certFactory.generateCertificate(new ByteArrayInputStream(encodedCert));
        } catch (CertificateException e) {
            result.addError(Issue.V2_SIG_MALFORMED_CERTIFICATE, certificateIndex, certificateIndex + 1, e);
            return;
        }
        // Wrap the cert so that the result's getEncoded returns exactly the original encoded
        // form. Without this, getEncoded may return a different form from what was stored in
        // the signature. This is because some X509Certificate(Factory) implementations
        // re-encode certificates.
        certificate = new GuaranteedEncodedFormX509Certificate(certificate, encodedCert);
        result.certs.add(certificate);
    }
    if (result.certs.isEmpty()) {
        result.addError(Issue.V2_SIG_NO_CERTIFICATES);
        return;
    }
    X509Certificate mainCertificate = result.certs.get(0);
    byte[] certificatePublicKeyBytes = mainCertificate.getPublicKey().getEncoded();
    if (!Arrays.equals(publicKeyBytes, certificatePublicKeyBytes)) {
        result.addError(Issue.V2_SIG_PUBLIC_KEY_MISMATCH_BETWEEN_CERTIFICATE_AND_SIGNATURES_RECORD, ApkSigningBlockUtils.toHex(certificatePublicKeyBytes), ApkSigningBlockUtils.toHex(publicKeyBytes));
        return;
    }
    // Parse the digests block
    int digestCount = 0;
    while (digests.hasRemaining()) {
        digestCount++;
        try {
            ByteBuffer digest = ApkSigningBlockUtils.getLengthPrefixedSlice(digests);
            int sigAlgorithmId = digest.getInt();
            byte[] digestBytes = ApkSigningBlockUtils.readLengthPrefixedByteArray(digest);
            result.contentDigests.add(new ApkSigningBlockUtils.Result.SignerInfo.ContentDigest(sigAlgorithmId, digestBytes));
        } catch (ApkFormatException | BufferUnderflowException e) {
            result.addError(Issue.V2_SIG_MALFORMED_DIGEST, digestCount);
            return;
        }
    }
    List<Integer> sigAlgsFromSignaturesRecord = new ArrayList<>(result.signatures.size());
    for (ApkSigningBlockUtils.Result.SignerInfo.Signature signature : result.signatures) {
        sigAlgsFromSignaturesRecord.add(signature.getAlgorithmId());
    }
    List<Integer> sigAlgsFromDigestsRecord = new ArrayList<>(result.contentDigests.size());
    for (ApkSigningBlockUtils.Result.SignerInfo.ContentDigest digest : result.contentDigests) {
        sigAlgsFromDigestsRecord.add(digest.getSignatureAlgorithmId());
    }
    if (!sigAlgsFromSignaturesRecord.equals(sigAlgsFromDigestsRecord)) {
        result.addError(Issue.V2_SIG_SIG_ALG_MISMATCH_BETWEEN_SIGNATURES_AND_DIGESTS_RECORDS, sigAlgsFromSignaturesRecord, sigAlgsFromDigestsRecord);
        return;
    }
    // Parse the additional attributes block.
    // TODO fix this up so that it takes into account stripping protection
    int additionalAttributeCount = 0;
    Set<Integer> supportedApkSigSchemeIds = supportedApkSigSchemeNames.keySet();
    Set<Integer> supportedExpectedApkSigSchemeIds = new HashSet<>(1);
    while (additionalAttributes.hasRemaining()) {
        additionalAttributeCount++;
        try {
            ByteBuffer attribute = ApkSigningBlockUtils.getLengthPrefixedSlice(additionalAttributes);
            int id = attribute.getInt();
            byte[] value = ByteBufferUtils.toByteArray(attribute);
            result.additionalAttributes.add(new ApkSigningBlockUtils.Result.SignerInfo.AdditionalAttribute(id, value));
            switch(id) {
                case V2SchemeSigner.STRIPPING_PROTECTION_ATTR_ID:
                    // stripping protection added when signing with a newer scheme
                    int foundId = attribute.getInt();
                    if (supportedApkSigSchemeIds.contains(foundId)) {
                        supportedExpectedApkSigSchemeIds.add(id);
                    } else {
                        result.addWarning(Issue.V2_SIG_UNKNOWN_APK_SIG_SCHEME_ID, result.index, foundId);
                    }
                    break;
                default:
                    result.addWarning(Issue.V2_SIG_UNKNOWN_ADDITIONAL_ATTRIBUTE, id);
            }
        } catch (ApkFormatException | BufferUnderflowException e) {
            result.addError(Issue.V2_SIG_MALFORMED_ADDITIONAL_ATTRIBUTE, additionalAttributeCount);
            return;
        }
    }
    // make sure that all known IDs indicated in stripping protection have already verified
    for (int id : supportedExpectedApkSigSchemeIds) {
        if (!foundApkSigSchemeIds.contains(id)) {
            String apkSigSchemeName = supportedApkSigSchemeNames.get(id);
            result.addError(Issue.V2_SIG_MISSING_APK_SIG_REFERENCED, result.index, apkSigSchemeName);
        }
    }
}
#method_after
private static void parseSigner(ByteBuffer signerBlock, CertificateFactory certFactory, ApkSigningBlockUtils.Result.SignerInfo result, Set<ContentDigestAlgorithm> contentDigestsToVerify, Map<Integer, String> supportedApkSigSchemeNames, Set<Integer> foundApkSigSchemeIds, int minSdkVersion, int maxSdkVersion) throws ApkFormatException, NoSuchAlgorithmException {
    ByteBuffer signedData = ApkSigningBlockUtils.getLengthPrefixedSlice(signerBlock);
    byte[] signedDataBytes = new byte[signedData.remaining()];
    signedData.get(signedDataBytes);
    signedData.flip();
    result.signedData = signedDataBytes;
    ByteBuffer signatures = ApkSigningBlockUtils.getLengthPrefixedSlice(signerBlock);
    byte[] publicKeyBytes = ApkSigningBlockUtils.readLengthPrefixedByteArray(signerBlock);
    // Parse the signatures block and identify supported signatures
    int signatureCount = 0;
    List<ApkSigningBlockUtils.SupportedSignature> supportedSignatures = new ArrayList<>(1);
    while (signatures.hasRemaining()) {
        signatureCount++;
        try {
            ByteBuffer signature = ApkSigningBlockUtils.getLengthPrefixedSlice(signatures);
            int sigAlgorithmId = signature.getInt();
            byte[] sigBytes = ApkSigningBlockUtils.readLengthPrefixedByteArray(signature);
            result.signatures.add(new ApkSigningBlockUtils.Result.SignerInfo.Signature(sigAlgorithmId, sigBytes));
            SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.findById(sigAlgorithmId);
            if (signatureAlgorithm == null) {
                result.addWarning(Issue.V2_SIG_UNKNOWN_SIG_ALGORITHM, sigAlgorithmId);
                continue;
            }
            supportedSignatures.add(new ApkSigningBlockUtils.SupportedSignature(signatureAlgorithm, sigBytes));
        } catch (ApkFormatException | BufferUnderflowException e) {
            result.addError(Issue.V2_SIG_MALFORMED_SIGNATURE, signatureCount);
            return;
        }
    }
    if (result.signatures.isEmpty()) {
        result.addError(Issue.V2_SIG_NO_SIGNATURES);
        return;
    }
    // Verify signatures over signed-data block using the public key
    List<ApkSigningBlockUtils.SupportedSignature> signaturesToVerify = null;
    try {
        signaturesToVerify = ApkSigningBlockUtils.getSignaturesToVerify(supportedSignatures, minSdkVersion, maxSdkVersion);
    } catch (ApkSigningBlockUtils.NoSupportedSignaturesException e) {
        result.addError(Issue.V2_SIG_NO_SUPPORTED_SIGNATURES);
        return;
    }
    for (ApkSigningBlockUtils.SupportedSignature signature : signaturesToVerify) {
        SignatureAlgorithm signatureAlgorithm = signature.algorithm;
        String jcaSignatureAlgorithm = signatureAlgorithm.getJcaSignatureAlgorithmAndParams().getFirst();
        AlgorithmParameterSpec jcaSignatureAlgorithmParams = signatureAlgorithm.getJcaSignatureAlgorithmAndParams().getSecond();
        String keyAlgorithm = signatureAlgorithm.getJcaKeyAlgorithm();
        PublicKey publicKey;
        try {
            publicKey = KeyFactory.getInstance(keyAlgorithm).generatePublic(new X509EncodedKeySpec(publicKeyBytes));
        } catch (Exception e) {
            result.addError(Issue.V2_SIG_MALFORMED_PUBLIC_KEY, e);
            return;
        }
        try {
            Signature sig = Signature.getInstance(jcaSignatureAlgorithm);
            sig.initVerify(publicKey);
            if (jcaSignatureAlgorithmParams != null) {
                sig.setParameter(jcaSignatureAlgorithmParams);
            }
            signedData.position(0);
            sig.update(signedData);
            byte[] sigBytes = signature.signature;
            if (!sig.verify(sigBytes)) {
                result.addError(Issue.V2_SIG_DID_NOT_VERIFY, signatureAlgorithm);
                return;
            }
            result.verifiedSignatures.put(signatureAlgorithm, sigBytes);
            contentDigestsToVerify.add(signatureAlgorithm.getContentDigestAlgorithm());
        } catch (InvalidKeyException | InvalidAlgorithmParameterException | SignatureException e) {
            result.addError(Issue.V2_SIG_VERIFY_EXCEPTION, signatureAlgorithm, e);
            return;
        }
    }
    // At least one signature over signedData has verified. We can now parse signed-data.
    signedData.position(0);
    ByteBuffer digests = ApkSigningBlockUtils.getLengthPrefixedSlice(signedData);
    ByteBuffer certificates = ApkSigningBlockUtils.getLengthPrefixedSlice(signedData);
    ByteBuffer additionalAttributes = ApkSigningBlockUtils.getLengthPrefixedSlice(signedData);
    // Parse the certificates block
    int certificateIndex = -1;
    while (certificates.hasRemaining()) {
        certificateIndex++;
        byte[] encodedCert = ApkSigningBlockUtils.readLengthPrefixedByteArray(certificates);
        X509Certificate certificate;
        try {
            certificate = (X509Certificate) certFactory.generateCertificate(new ByteArrayInputStream(encodedCert));
        } catch (CertificateException e) {
            result.addError(Issue.V2_SIG_MALFORMED_CERTIFICATE, certificateIndex, certificateIndex + 1, e);
            return;
        }
        // Wrap the cert so that the result's getEncoded returns exactly the original encoded
        // form. Without this, getEncoded may return a different form from what was stored in
        // the signature. This is because some X509Certificate(Factory) implementations
        // re-encode certificates.
        certificate = new GuaranteedEncodedFormX509Certificate(certificate, encodedCert);
        result.certs.add(certificate);
    }
    if (result.certs.isEmpty()) {
        result.addError(Issue.V2_SIG_NO_CERTIFICATES);
        return;
    }
    X509Certificate mainCertificate = result.certs.get(0);
    byte[] certificatePublicKeyBytes = mainCertificate.getPublicKey().getEncoded();
    if (!Arrays.equals(publicKeyBytes, certificatePublicKeyBytes)) {
        result.addError(Issue.V2_SIG_PUBLIC_KEY_MISMATCH_BETWEEN_CERTIFICATE_AND_SIGNATURES_RECORD, ApkSigningBlockUtils.toHex(certificatePublicKeyBytes), ApkSigningBlockUtils.toHex(publicKeyBytes));
        return;
    }
    // Parse the digests block
    int digestCount = 0;
    while (digests.hasRemaining()) {
        digestCount++;
        try {
            ByteBuffer digest = ApkSigningBlockUtils.getLengthPrefixedSlice(digests);
            int sigAlgorithmId = digest.getInt();
            byte[] digestBytes = ApkSigningBlockUtils.readLengthPrefixedByteArray(digest);
            result.contentDigests.add(new ApkSigningBlockUtils.Result.SignerInfo.ContentDigest(sigAlgorithmId, digestBytes));
        } catch (ApkFormatException | BufferUnderflowException e) {
            result.addError(Issue.V2_SIG_MALFORMED_DIGEST, digestCount);
            return;
        }
    }
    List<Integer> sigAlgsFromSignaturesRecord = new ArrayList<>(result.signatures.size());
    for (ApkSigningBlockUtils.Result.SignerInfo.Signature signature : result.signatures) {
        sigAlgsFromSignaturesRecord.add(signature.getAlgorithmId());
    }
    List<Integer> sigAlgsFromDigestsRecord = new ArrayList<>(result.contentDigests.size());
    for (ApkSigningBlockUtils.Result.SignerInfo.ContentDigest digest : result.contentDigests) {
        sigAlgsFromDigestsRecord.add(digest.getSignatureAlgorithmId());
    }
    if (!sigAlgsFromSignaturesRecord.equals(sigAlgsFromDigestsRecord)) {
        result.addError(Issue.V2_SIG_SIG_ALG_MISMATCH_BETWEEN_SIGNATURES_AND_DIGESTS_RECORDS, sigAlgsFromSignaturesRecord, sigAlgsFromDigestsRecord);
        return;
    }
    // Parse the additional attributes block.
    int additionalAttributeCount = 0;
    Set<Integer> supportedApkSigSchemeIds = supportedApkSigSchemeNames.keySet();
    Set<Integer> supportedExpectedApkSigSchemeIds = new HashSet<>(1);
    while (additionalAttributes.hasRemaining()) {
        additionalAttributeCount++;
        try {
            ByteBuffer attribute = ApkSigningBlockUtils.getLengthPrefixedSlice(additionalAttributes);
            int id = attribute.getInt();
            byte[] value = ByteBufferUtils.toByteArray(attribute);
            result.additionalAttributes.add(new ApkSigningBlockUtils.Result.SignerInfo.AdditionalAttribute(id, value));
            switch(id) {
                case V2SchemeSigner.STRIPPING_PROTECTION_ATTR_ID:
                    // stripping protection added when signing with a newer scheme
                    int foundId = attribute.getInt();
                    if (supportedApkSigSchemeIds.contains(foundId)) {
                        supportedExpectedApkSigSchemeIds.add(id);
                    } else {
                        result.addWarning(Issue.V2_SIG_UNKNOWN_APK_SIG_SCHEME_ID, result.index, foundId);
                    }
                    break;
                default:
                    result.addWarning(Issue.V2_SIG_UNKNOWN_ADDITIONAL_ATTRIBUTE, id);
            }
        } catch (ApkFormatException | BufferUnderflowException e) {
            result.addError(Issue.V2_SIG_MALFORMED_ADDITIONAL_ATTRIBUTE, additionalAttributeCount);
            return;
        }
    }
    // make sure that all known IDs indicated in stripping protection have already verified
    for (int id : supportedExpectedApkSigSchemeIds) {
        if (!foundApkSigSchemeIds.contains(id)) {
            String apkSigSchemeName = supportedApkSigSchemeNames.get(id);
            result.addError(Issue.V2_SIG_MISSING_APK_SIG_REFERENCED, result.index, apkSigSchemeName);
        }
    }
}
#end_block

#method_before
public SigningCertificateLineage build() throws CertificateEncodingException, InvalidKeyException, NoSuchAlgorithmException, SignatureException {
    if (mMinSdkVersion < AndroidSdkVersion.P) {
        mMinSdkVersion = AndroidSdkVersion.P;
    }
    if (mOriginalCapabilities == null) {
        mOriginalCapabilities = new SignerCapabilities.Builder().build();
    }
    if (mNewCapabilities == null) {
        mNewCapabilities = new SignerCapabilities.Builder().build();
    }
    return createSigningLineage(mMinSdkVersion, mOriginalSignerConfig, mOriginalCapabilities, mNewSignerConfig, mNewCapabilities);
}
#method_after
public SignerCapabilities build() {
    return new SignerCapabilities(mFlags);
}
#end_block

#method_before
public SigningCertificateLineage build() throws CertificateEncodingException, InvalidKeyException, NoSuchAlgorithmException, SignatureException {
    if (mMinSdkVersion < AndroidSdkVersion.P) {
        mMinSdkVersion = AndroidSdkVersion.P;
    }
    if (mOriginalCapabilities == null) {
        mOriginalCapabilities = new SignerCapabilities.Builder().build();
    }
    if (mNewCapabilities == null) {
        mNewCapabilities = new SignerCapabilities.Builder().build();
    }
    return createSigningLineage(mMinSdkVersion, mOriginalSignerConfig, mOriginalCapabilities, mNewSignerConfig, mNewCapabilities);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mPrivateKey, mCertificate);
}
#end_block

#method_before
@Override
protected boolean start() {
    if (DBG) {
        Log.d(TAG, "start()");
    }
    if (sHearingAidService != null) {
        throw new IllegalStateException("start() called twice");
    }
    // Step 1: Get BluetoothAdapter, AdapterService, A2dpNativeInterface, AudioManager.
    // None of them can be null.
    mAdapter = Objects.requireNonNull(BluetoothAdapter.getDefaultAdapter(), "BluetoothAdapter cannot be null when HearingAidService starts");
    mAdapterService = Objects.requireNonNull(AdapterService.getAdapterService(), "AdapterService cannot be null when HearingAidService starts");
    // TODO: Add native interface
    // Step 2: Start handler thread for state machines
    mStateMachines.clear();
    mStateMachinesThread = new HandlerThread("HearingAidService.StateMachines");
    mStateMachinesThread.start();
    // Step 3: Initialize native interface
    // TODO: Implement me
    // Step 4: Setup broadcast receivers
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
    mBondStateChangedReceiver = new BondStateChangedReceiver();
    registerReceiver(mBondStateChangedReceiver, filter);
    filter = new IntentFilter();
    filter.addAction(BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);
    mConnectionStateChangedReceiver = new ConnectionStateChangedReceiver();
    registerReceiver(mConnectionStateChangedReceiver, filter);
    // Step 5: Mark service as started
    setHearingAidService(this);
    // Step 6: Clear active device
    setActiveDevice(null);
    return true;
}
#method_after
@Override
protected boolean start() {
    if (DBG) {
        Log.d(TAG, "start()");
    }
    if (sHearingAidService != null) {
        throw new IllegalStateException("start() called twice");
    }
    // Get BluetoothAdapter, AdapterService, A2dpNativeInterface, AudioManager.
    // None of them can be null.
    mAdapter = Objects.requireNonNull(BluetoothAdapter.getDefaultAdapter(), "BluetoothAdapter cannot be null when HearingAidService starts");
    mAdapterService = Objects.requireNonNull(AdapterService.getAdapterService(), "AdapterService cannot be null when HearingAidService starts");
    // TODO: Add native interface
    // Start handler thread for state machines
    mStateMachines.clear();
    mStateMachinesThread = new HandlerThread("HearingAidService.StateMachines");
    mStateMachinesThread.start();
    // Initialize native interface
    // TODO: Init native interface
    // Setup broadcast receivers
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
    mBondStateChangedReceiver = new BondStateChangedReceiver();
    registerReceiver(mBondStateChangedReceiver, filter);
    filter = new IntentFilter();
    filter.addAction(BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);
    mConnectionStateChangedReceiver = new ConnectionStateChangedReceiver();
    registerReceiver(mConnectionStateChangedReceiver, filter);
    // Mark service as started
    setHearingAidService(this);
    // Clear active device
    setActiveDevice(null);
    return true;
}
#end_block

#method_before
@Override
protected boolean stop() {
    if (DBG) {
        Log.d(TAG, "stop()");
    }
    if (sHearingAidService == null) {
        Log.w(TAG, "stop() called before start()");
        return true;
    }
    // Step 6: Clear active device
    setActiveDevice(null);
    // Step 5: Mark service as stopped
    setHearingAidService(null);
    // Step 4: Unregister broadcast receivers
    unregisterReceiver(mBondStateChangedReceiver);
    mBondStateChangedReceiver = null;
    unregisterReceiver(mConnectionStateChangedReceiver);
    mConnectionStateChangedReceiver = null;
    // Step 3: Destroy state machines and stop handler thread
    synchronized (mStateMachines) {
        for (HearingAidStateMachine sm : mStateMachines.values()) {
            sm.doQuit();
            sm.cleanup();
        }
        mStateMachines.clear();
    }
    if (mStateMachinesThread != null) {
        mStateMachinesThread.quitSafely();
        mStateMachinesThread = null;
    }
    // Step 1: Clear BluetoothAdapter, AdapterService, HearingAidNativeInterface
    // TODO: Add native interface
    mAdapterService = null;
    mAdapter = null;
    return true;
}
#method_after
@Override
protected boolean stop() {
    if (DBG) {
        Log.d(TAG, "stop()");
    }
    if (sHearingAidService == null) {
        Log.w(TAG, "stop() called before start()");
        return true;
    }
    // Clear active device
    setActiveDevice(null);
    // Mark service as stopped
    setHearingAidService(null);
    // Unregister broadcast receivers
    unregisterReceiver(mBondStateChangedReceiver);
    mBondStateChangedReceiver = null;
    unregisterReceiver(mConnectionStateChangedReceiver);
    mConnectionStateChangedReceiver = null;
    // Destroy state machines and stop handler thread
    synchronized (mStateMachines) {
        for (HearingAidStateMachine sm : mStateMachines.values()) {
            sm.doQuit();
            sm.cleanup();
        }
        mStateMachines.clear();
    }
    if (mStateMachinesThread != null) {
        mStateMachinesThread.quitSafely();
        mStateMachinesThread = null;
    }
    // Clear BluetoothAdapter, AdapterService, HearingAidNativeInterface
    // TODO: Set native interface to null
    mAdapterService = null;
    mAdapter = null;
    return true;
}
#end_block

#method_before
List<BluetoothDevice> getConnectedDevices() {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>();
        for (HearingAidStateMachine sm : mStateMachines.values()) {
            if (sm.isConnected()) {
                devices.add(sm.getDevice());
            }
        }
        return devices;
    }
}
#method_after
List<BluetoothDevice> getConnectedDevices() {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        List<BluetoothDevice> devices = new ArrayList<>();
        for (HearingAidStateMachine sm : mStateMachines.values()) {
            if (sm.isConnected()) {
                devices.add(sm.getDevice());
            }
        }
        return devices;
    }
}
#end_block

#method_before
List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>();
        Set<BluetoothDevice> bondedDevices = mAdapter.getBondedDevices();
        for (BluetoothDevice device : bondedDevices) {
            ParcelUuid[] featureUuids = device.getUuids();
            if (!BluetoothUuid.isUuidPresent(featureUuids, BluetoothUuid.HearingAid)) {
                continue;
            }
            int connectionState = BluetoothProfile.STATE_DISCONNECTED;
            HearingAidStateMachine sm = mStateMachines.get(device);
            if (sm != null) {
                connectionState = sm.getConnectionState();
            }
            for (int i = 0; i < states.length; i++) {
                if (connectionState == states[i]) {
                    devices.add(device);
                }
            }
        }
        return devices;
    }
}
#method_after
List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        List<BluetoothDevice> devices = new ArrayList<>();
        Set<BluetoothDevice> bondedDevices = mAdapter.getBondedDevices();
        for (BluetoothDevice device : bondedDevices) {
            ParcelUuid[] featureUuids = device.getUuids();
            if (!BluetoothUuid.isUuidPresent(featureUuids, BluetoothUuid.HearingAid)) {
                continue;
            }
            int connectionState = BluetoothProfile.STATE_DISCONNECTED;
            HearingAidStateMachine sm = mStateMachines.get(device);
            if (sm != null) {
                connectionState = sm.getConnectionState();
            }
            for (int state : states) {
                if (connectionState == state) {
                    devices.add(device);
                }
            }
        }
        return devices;
    }
}
#end_block

#method_before
private HearingAidStateMachine getOrCreateStateMachine(BluetoothDevice device) {
    if (device == null) {
        Log.e(TAG, "getOrCreateStateMachine failed: device cannot be null");
        return null;
    }
    synchronized (mStateMachines) {
        HearingAidStateMachine sm = mStateMachines.get(device);
        if (sm != null) {
            return sm;
        }
        // Limit the maximum number of state machines to avoid DoS attack
        if (mStateMachines.size() > MAX_HEARING_AID_STATE_MACHINES) {
            Log.e(TAG, "Maximum number of HearingAid state machines reached: " + MAX_HEARING_AID_STATE_MACHINES);
            return null;
        }
        if (DBG) {
            Log.d(TAG, "Creating a new state machine for " + device);
        }
        sm = HearingAidStateMachine.make(device, this, mStateMachinesThread.getLooper());
        mStateMachines.put(device, sm);
        return sm;
    }
}
#method_after
private HearingAidStateMachine getOrCreateStateMachine(BluetoothDevice device) {
    if (device == null) {
        Log.e(TAG, "getOrCreateStateMachine failed: device cannot be null");
        return null;
    }
    synchronized (mStateMachines) {
        HearingAidStateMachine sm = mStateMachines.get(device);
        if (sm != null) {
            return sm;
        }
        // Limit the maximum number of state machines to avoid DoS attack
        if (mStateMachines.size() >= MAX_HEARING_AID_STATE_MACHINES) {
            Log.e(TAG, "Maximum number of HearingAid state machines reached: " + MAX_HEARING_AID_STATE_MACHINES);
            return null;
        }
        if (DBG) {
            Log.d(TAG, "Creating a new state machine for " + device);
        }
        sm = HearingAidStateMachine.make(device, this, mStateMachinesThread.getLooper());
        mStateMachines.put(device, sm);
        return sm;
    }
}
#end_block

#method_before
@Override
public List<BluetoothDevice> getConnectedDevices() {
    HearingAidService service = getService();
    if (service == null) {
        return new ArrayList<BluetoothDevice>(0);
    }
    return service.getConnectedDevices();
}
#method_after
@Override
public List<BluetoothDevice> getConnectedDevices() {
    HearingAidService service = getService();
    if (service == null) {
        return new ArrayList<>(0);
    }
    return service.getConnectedDevices();
}
#end_block

#method_before
@Override
public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
    HearingAidService service = getService();
    if (service == null) {
        return new ArrayList<BluetoothDevice>(0);
    }
    return service.getDevicesMatchingConnectionStates(states);
}
#method_after
@Override
public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
    HearingAidService service = getService();
    if (service == null) {
        return new ArrayList<>(0);
    }
    return service.getDevicesMatchingConnectionStates(states);
}
#end_block

#method_before
@Override
public void setVolume(int volume) {
    // Android sends value in scale 0 to 25, hearing aid accept -128 to 0
    volume = ((volume * 512) / 100) - 128;
}
#method_after
@Override
public void setVolume(int volume) {
}
#end_block

#method_before
@Override
protected boolean start() {
    if (DBG) {
        Log.d(TAG, "start()");
    }
    if (sHearingAidService != null) {
        throw new IllegalStateException("start() called twice");
    }
    // Step 1: Get BluetoothAdapter, AdapterService, A2dpNativeInterface, AudioManager.
    // None of them can be null.
    mAdapter = Objects.requireNonNull(BluetoothAdapter.getDefaultAdapter(), "BluetoothAdapter cannot be null when HearingAidService starts");
    mAdapterService = Objects.requireNonNull(AdapterService.getAdapterService(), "AdapterService cannot be null when HearingAidService starts");
    // TODO: Add native interface
    // Step 2: Start handler thread for state machines
    // TODO: Clear state machines
    mStateMachinesThread = new HandlerThread("HearingAidService.StateMachines");
    mStateMachinesThread.start();
    // Step 3: Initialize native interface
    // TODO: Init native interface
    // Step 4: Setup broadcast receivers
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
    mBondStateChangedReceiver = new BondStateChangedReceiver();
    registerReceiver(mBondStateChangedReceiver, filter);
    filter = new IntentFilter();
    filter.addAction(BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);
    mConnectionStateChangedReceiver = new ConnectionStateChangedReceiver();
    registerReceiver(mConnectionStateChangedReceiver, filter);
    // Step 5: Mark service as started
    setHearingAidService(this);
    // Step 6: Clear active device
    setActiveDevice(null);
    return true;
}
#method_after
@Override
protected boolean start() {
    if (DBG) {
        Log.d(TAG, "start()");
    }
    if (sHearingAidService != null) {
        throw new IllegalStateException("start() called twice");
    }
    // Get BluetoothAdapter, AdapterService, A2dpNativeInterface, AudioManager.
    // None of them can be null.
    mAdapter = Objects.requireNonNull(BluetoothAdapter.getDefaultAdapter(), "BluetoothAdapter cannot be null when HearingAidService starts");
    mAdapterService = Objects.requireNonNull(AdapterService.getAdapterService(), "AdapterService cannot be null when HearingAidService starts");
    // TODO: Add native interface
    // Start handler thread for state machines
    // TODO: Clear state machines
    mStateMachinesThread = new HandlerThread("HearingAidService.StateMachines");
    mStateMachinesThread.start();
    // Initialize native interface
    // TODO: Init native interface
    // Setup broadcast receivers
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
    mBondStateChangedReceiver = new BondStateChangedReceiver();
    registerReceiver(mBondStateChangedReceiver, filter);
    filter = new IntentFilter();
    filter.addAction(BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);
    mConnectionStateChangedReceiver = new ConnectionStateChangedReceiver();
    registerReceiver(mConnectionStateChangedReceiver, filter);
    // Mark service as started
    setHearingAidService(this);
    // Clear active device
    setActiveDevice(null);
    return true;
}
#end_block

#method_before
@Override
protected boolean stop() {
    if (DBG) {
        Log.d(TAG, "stop()");
    }
    if (sHearingAidService == null) {
        Log.w(TAG, "stop() called before start()");
        return true;
    }
    // Step 6: Clear active device
    setActiveDevice(null);
    // Step 5: Mark service as stopped
    setHearingAidService(null);
    // Step 4: Unregister broadcast receivers
    unregisterReceiver(mBondStateChangedReceiver);
    mBondStateChangedReceiver = null;
    unregisterReceiver(mConnectionStateChangedReceiver);
    mConnectionStateChangedReceiver = null;
    if (mStateMachinesThread != null) {
        mStateMachinesThread.quitSafely();
        mStateMachinesThread = null;
    }
    // Step 1: Clear BluetoothAdapter, AdapterService, HearingAidNativeInterface
    // TODO: Set native interface to null
    mAdapterService = null;
    mAdapter = null;
    return true;
}
#method_after
@Override
protected boolean stop() {
    if (DBG) {
        Log.d(TAG, "stop()");
    }
    if (sHearingAidService == null) {
        Log.w(TAG, "stop() called before start()");
        return true;
    }
    // Clear active device
    setActiveDevice(null);
    // Mark service as stopped
    setHearingAidService(null);
    // Unregister broadcast receivers
    unregisterReceiver(mBondStateChangedReceiver);
    mBondStateChangedReceiver = null;
    unregisterReceiver(mConnectionStateChangedReceiver);
    mConnectionStateChangedReceiver = null;
    // TODO: Implement me: destroy state machine
    if (mStateMachinesThread != null) {
        mStateMachinesThread.quitSafely();
        mStateMachinesThread = null;
    }
    // Clear BluetoothAdapter, AdapterService, HearingAidNativeInterface
    // TODO: Set native interface to null
    mAdapterService = null;
    mAdapter = null;
    return true;
}
#end_block

#method_before
@Override
public List<BluetoothDevice> getConnectedDevices() {
    HearingAidService service = getService();
    if (service == null) {
        return new ArrayList<BluetoothDevice>(0);
    }
    return service.getConnectedDevices();
}
#method_after
@Override
public List<BluetoothDevice> getConnectedDevices() {
    HearingAidService service = getService();
    if (service == null) {
        return new ArrayList<>(0);
    }
    return service.getConnectedDevices();
}
#end_block

#method_before
@Override
public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
    HearingAidService service = getService();
    if (service == null) {
        return new ArrayList<BluetoothDevice>(0);
    }
    return service.getDevicesMatchingConnectionStates(states);
}
#method_after
@Override
public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
    HearingAidService service = getService();
    if (service == null) {
        return new ArrayList<>(0);
    }
    return service.getDevicesMatchingConnectionStates(states);
}
#end_block

#method_before
@Override
public void setVolume(int volume) {
// TODO: Implement me
}
#method_after
@Override
public void setVolume(int volume) {
}
#end_block

#method_before
@Override
public void adjustVolume(int direction) {
// TODO: Implement me
}
#method_after
@Override
public void adjustVolume(int direction) {
}
#end_block

#method_before
/**
 * If the current thread is operating in a ForkJoinPool,
 * unschedules and returns, without executing, a task externally
 * submitted to the pool, if one is available. Availability may be
 * transient, so a {@code null} result does not necessarily imply
 * quiescence of the pool.  This method is designed primarily to
 * support extensions, and is unlikely to be useful otherwise.
 *
 * @return a task, or {@code null} if none are available
 * @since 9
 * @hide
 */
protected static ForkJoinTask<?> pollSubmission() {
    Thread t;
    return ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ? ((ForkJoinWorkerThread) t).pool.pollSubmission() : null;
}
#method_after
protected static ForkJoinTask<?> pollSubmission() {
    Thread t;
    return ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ? ((ForkJoinWorkerThread) t).pool.pollSubmission() : null;
}
#end_block

#method_before
/**
 * Performs non-fair tryLock.  tryAcquire is implemented in
 * subclasses, but both need nonfair try for trylock method.
 */
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (// overflow
        nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
#method_after
/**
 * Performs non-fair tryLock.  tryAcquire is implemented in
 * subclasses, but both need nonfair try for trylock method.
 */
// Android-removed: @ReservedStackAccess from OpenJDK 9, not available on Android.
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (// overflow
        nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
#end_block

#method_before
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
#method_after
// Android-removed: @ReservedStackAccess from OpenJDK 9, not available on Android.
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
#end_block

#method_before
/**
 * Performs lock.  Try immediate barge, backing up to normal
 * acquire on failure.
 */
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
#method_after
/**
 * Performs lock.  Try immediate barge, backing up to normal
 * acquire on failure.
 */
// Android-removed: @ReservedStackAccess from OpenJDK 9, not available on Android.
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
#end_block

#method_before
/**
 * Fair version of tryAcquire.  Don't grant access unless
 * recursive call or no waiters or is first.
 */
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
#method_after
/**
 * Fair version of tryAcquire.  Don't grant access unless
 * recursive call or no waiters or is first.
 */
// Android-removed: @ReservedStackAccess from OpenJDK 9, not available on Android.
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
#end_block

#method_before
/**
 * Sets the core number of threads.  This overrides any value set
 * in the constructor.  If the new value is smaller than the
 * current value, excess existing threads will be terminated when
 * they next become idle.  If larger, new threads will, if needed,
 * be started to execute any queued tasks.
 *
 * @param corePoolSize the new core size
 * @throws IllegalArgumentException if {@code corePoolSize < 0}
 * @see #getCorePoolSize
 */
// Android-changed: Reverted code that threw an IAE when
// {@code corePoolSize} is greater than the {@linkplain #getMaximumPoolSize()
// maximum pool size}. This is due to defective code in a commonly used third
// party library that does something like :
// 
// exec.setCorePoolSize(N);
public void setCorePoolSize(int corePoolSize) {
    // if (corePoolSize < 0 || maximumPoolSize < corePoolSize)
    if (corePoolSize < 0)
        throw new IllegalArgumentException();
    int delta = corePoolSize - this.corePoolSize;
    this.corePoolSize = corePoolSize;
    if (workerCountOf(ctl.get()) > corePoolSize)
        interruptIdleWorkers();
    else if (delta > 0) {
        // We don't really know how many new threads are "needed".
        // As a heuristic, prestart enough new workers (up to new
        // core size) to handle the current number of tasks in
        // queue, but stop if queue becomes empty while doing so.
        int k = Math.min(delta, workQueue.size());
        while (k-- > 0 && addWorker(null, true)) {
            if (workQueue.isEmpty())
                break;
        }
    }
}
#method_after
// Android-changed: Tolerate maximumPoolSize >= corePoolSize during setCorePoolSize().
public void setCorePoolSize(int corePoolSize) {
    // if (corePoolSize < 0 || maximumPoolSize < corePoolSize)
    if (corePoolSize < 0)
        // END Android-changed: Tolerate maximumPoolSize >= corePoolSize during setCorePoolSize().
        throw new IllegalArgumentException();
    int delta = corePoolSize - this.corePoolSize;
    this.corePoolSize = corePoolSize;
    if (workerCountOf(ctl.get()) > corePoolSize)
        interruptIdleWorkers();
    else if (delta > 0) {
        // We don't really know how many new threads are "needed".
        // As a heuristic, prestart enough new workers (up to new
        // core size) to handle the current number of tasks in
        // queue, but stop if queue becomes empty while doing so.
        int k = Math.min(delta, workQueue.size());
        while (k-- > 0 && addWorker(null, true)) {
            if (workQueue.isEmpty())
                break;
        }
    }
}
#end_block

#method_before
/*
     * Various flavors of acquire, varying in exclusive/shared and
     * control modes.  Each is mostly the same, but annoyingly
     * different.  Only a little bit of factoring is possible due to
     * interactions of exception mechanics (including ensuring that we
     * cancel if tryAcquire throws exception) and other control, at
     * least not without hurting performance too much.
     */
/**
 * Acquires in exclusive uninterruptible mode for thread already in
 * queue. Used by condition wait methods as well as acquire.
 *
 * @param node the node
 * @param arg the acquire argument
 * @return {@code true} if interrupted while waiting
 */
final boolean acquireQueued(final Node node, int arg) {
    try {
        boolean interrupted = false;
        for (; ; ) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                // help GC
                p.next = null;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())
                interrupted = true;
        }
    } catch (Throwable t) {
        cancelAcquire(node);
        throw t;
    }
}
#method_after
/*
     * Various flavors of acquire, varying in exclusive/shared and
     * control modes.  Each is mostly the same, but annoyingly
     * different.  Only a little bit of factoring is possible due to
     * interactions of exception mechanics (including ensuring that we
     * cancel if tryAcquire throws exception) and other control, at
     * least not without hurting performance too much.
     */
/**
 * Acquires in exclusive uninterruptible mode for thread already in
 * queue. Used by condition wait methods as well as acquire.
 *
 * @param node the node
 * @param arg the acquire argument
 * @return {@code true} if interrupted while waiting
 */
// Android-removed: @ReservedStackAccess from OpenJDK 9, not available on Android.
final boolean acquireQueued(final Node node, int arg) {
    try {
        boolean interrupted = false;
        for (; ; ) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                // help GC
                p.next = null;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())
                interrupted = true;
        }
    } catch (Throwable t) {
        cancelAcquire(node);
        throw t;
    }
}
#end_block

#method_before
/**
 * Acquires in exclusive mode, ignoring interrupts.  Implemented
 * by invoking at least once {@link #tryAcquire},
 * returning on success.  Otherwise the thread is queued, possibly
 * repeatedly blocking and unblocking, invoking {@link
 * #tryAcquire} until success.  This method can be used
 * to implement method {@link Lock#lock}.
 *
 * @param arg the acquire argument.  This value is conveyed to
 *        {@link #tryAcquire} but is otherwise uninterpreted and
 *        can represent anything you like.
 */
public final void acquire(int arg) {
    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
#method_after
/**
 * Acquires in exclusive mode, ignoring interrupts.  Implemented
 * by invoking at least once {@link #tryAcquire},
 * returning on success.  Otherwise the thread is queued, possibly
 * repeatedly blocking and unblocking, invoking {@link
 * #tryAcquire} until success.  This method can be used
 * to implement method {@link Lock#lock}.
 *
 * @param arg the acquire argument.  This value is conveyed to
 *        {@link #tryAcquire} but is otherwise uninterpreted and
 *        can represent anything you like.
 */
// Android-removed: @ReservedStackAccess from OpenJDK 9, not available on Android.
public final void acquire(int arg) {
    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
#end_block

#method_before
/**
 * Releases in exclusive mode.  Implemented by unblocking one or
 * more threads if {@link #tryRelease} returns true.
 * This method can be used to implement method {@link Lock#unlock}.
 *
 * @param arg the release argument.  This value is conveyed to
 *        {@link #tryRelease} but is otherwise uninterpreted and
 *        can represent anything you like.
 * @return the value returned from {@link #tryRelease}
 */
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
#method_after
/**
 * Releases in exclusive mode.  Implemented by unblocking one or
 * more threads if {@link #tryRelease} returns true.
 * This method can be used to implement method {@link Lock#unlock}.
 *
 * @param arg the release argument.  This value is conveyed to
 *        {@link #tryRelease} but is otherwise uninterpreted and
 *        can represent anything you like.
 * @return the value returned from {@link #tryRelease}
 */
// Android-removed: @ReservedStackAccess from OpenJDK 9, not available on Android.
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
#end_block

#method_before
/**
 * Releases in shared mode.  Implemented by unblocking one or more
 * threads if {@link #tryReleaseShared} returns true.
 *
 * @param arg the release argument.  This value is conveyed to
 *        {@link #tryReleaseShared} but is otherwise uninterpreted
 *        and can represent anything you like.
 * @return the value returned from {@link #tryReleaseShared}
 */
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
#method_after
/**
 * Releases in shared mode.  Implemented by unblocking one or more
 * threads if {@link #tryReleaseShared} returns true.
 *
 * @param arg the release argument.  This value is conveyed to
 *        {@link #tryReleaseShared} but is otherwise uninterpreted
 *        and can represent anything you like.
 * @return the value returned from {@link #tryReleaseShared}
 */
// Android-removed: @ReservedStackAccess from OpenJDK 9, not available on Android.
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
#end_block

#method_before
// jdk9 additions
/**
 * Returns a new incomplete CompletableFuture of the type to be
 * returned by a CompletionStage method. Subclasses should
 * normally override this method to return an instance of the same
 * class as this CompletableFuture. The default implementation
 * returns an instance of class CompletableFuture.
 *
 * @param <U> the type of the value
 * @return a new CompletableFuture
 * @since 9
 * @hide
 */
public <U> CompletableFuture<U> newIncompleteFuture() {
    return new CompletableFuture<U>();
}
#method_after
// jdk9 additions
public <U> CompletableFuture<U> newIncompleteFuture() {
    return new CompletableFuture<U>();
}
#end_block

#method_before
/**
 * Returns the default Executor used for async methods that do not
 * specify an Executor. This class uses the {@link
 * ForkJoinPool#commonPool()} if it supports more than one
 * parallel thread, or else an Executor using one thread per async
 * task.  This method may be overridden in subclasses to return
 * an Executor that provides at least one independent thread.
 *
 * @return the executor
 * @since 9
 * @hide
 */
public Executor defaultExecutor() {
    return ASYNC_POOL;
}
#method_after
public Executor defaultExecutor() {
    return ASYNC_POOL;
}
#end_block

#method_before
/**
 * Returns a new CompletableFuture that is completed normally with
 * the same value as this CompletableFuture when it completes
 * normally. If this CompletableFuture completes exceptionally,
 * then the returned CompletableFuture completes exceptionally
 * with a CompletionException with this exception as cause. The
 * behavior is equivalent to {@code thenApply(x -> x)}. This
 * method may be useful as a form of "defensive copying", to
 * prevent clients from completing, while still being able to
 * arrange dependent actions.
 *
 * @return the new CompletableFuture
 * @since 9
 * @hide
 */
public CompletableFuture<T> copy() {
    return uniCopyStage();
}
#method_after
public CompletableFuture<T> copy() {
    return uniCopyStage();
}
#end_block

#method_before
/**
 * Returns a new CompletionStage that is completed normally with
 * the same value as this CompletableFuture when it completes
 * normally, and cannot be independently completed or otherwise
 * used in ways not defined by the methods of interface {@link
 * CompletionStage}.  If this CompletableFuture completes
 * exceptionally, then the returned CompletionStage completes
 * exceptionally with a CompletionException with this exception as
 * cause.
 *
 * @return the new CompletionStage
 * @since 9
 * @hide
 */
public CompletionStage<T> minimalCompletionStage() {
    return uniAsMinimalStage();
}
#method_after
public CompletionStage<T> minimalCompletionStage() {
    return uniAsMinimalStage();
}
#end_block

#method_before
/**
 * Completes this CompletableFuture with the result of
 * the given Supplier function invoked from an asynchronous
 * task using the given executor.
 *
 * @param supplier a function returning the value to be used
 * to complete this CompletableFuture
 * @param executor the executor to use for asynchronous execution
 * @return this CompletableFuture
 * @since 9
 * @hide
 */
public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier, Executor executor) {
    if (supplier == null || executor == null)
        throw new NullPointerException();
    executor.execute(new AsyncSupply<T>(this, supplier));
    return this;
}
#method_after
public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier, Executor executor) {
    if (supplier == null || executor == null)
        throw new NullPointerException();
    executor.execute(new AsyncSupply<T>(this, supplier));
    return this;
}
#end_block

#method_before
/**
 * Completes this CompletableFuture with the result of the given
 * Supplier function invoked from an asynchronous task using the
 * default executor.
 *
 * @param supplier a function returning the value to be used
 * to complete this CompletableFuture
 * @return this CompletableFuture
 * @since 9
 * @hide
 */
public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier) {
    return completeAsync(supplier, defaultExecutor());
}
#method_after
public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier) {
    return completeAsync(supplier, defaultExecutor());
}
#end_block

#method_before
/**
 * Exceptionally completes this CompletableFuture with
 * a {@link TimeoutException} if not otherwise completed
 * before the given timeout.
 *
 * @param timeout how long to wait before completing exceptionally
 *        with a TimeoutException, in units of {@code unit}
 * @param unit a {@code TimeUnit} determining how to interpret the
 *        {@code timeout} parameter
 * @return this CompletableFuture
 * @since 9
 * @hide
 */
public CompletableFuture<T> orTimeout(long timeout, TimeUnit unit) {
    if (unit == null)
        throw new NullPointerException();
    if (result == null)
        whenComplete(new Canceller(Delayer.delay(new Timeout(this), timeout, unit)));
    return this;
}
#method_after
public CompletableFuture<T> orTimeout(long timeout, TimeUnit unit) {
    if (unit == null)
        throw new NullPointerException();
    if (result == null)
        whenComplete(new Canceller(Delayer.delay(new Timeout(this), timeout, unit)));
    return this;
}
#end_block

#method_before
/**
 * Completes this CompletableFuture with the given value if not
 * otherwise completed before the given timeout.
 *
 * @param value the value to use upon timeout
 * @param timeout how long to wait before completing normally
 *        with the given value, in units of {@code unit}
 * @param unit a {@code TimeUnit} determining how to interpret the
 *        {@code timeout} parameter
 * @return this CompletableFuture
 * @since 9
 * @hide
 */
public CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit unit) {
    if (unit == null)
        throw new NullPointerException();
    if (result == null)
        whenComplete(new Canceller(Delayer.delay(new DelayedCompleter<T>(this, value), timeout, unit)));
    return this;
}
#method_after
public CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit unit) {
    if (unit == null)
        throw new NullPointerException();
    if (result == null)
        whenComplete(new Canceller(Delayer.delay(new DelayedCompleter<T>(this, value), timeout, unit)));
    return this;
}
#end_block

#method_before
/**
 * Returns a new Executor that submits a task to the given base
 * executor after the given delay (or no delay if non-positive).
 * Each delay commences upon invocation of the returned executor's
 * {@code execute} method.
 *
 * @param delay how long to delay, in units of {@code unit}
 * @param unit a {@code TimeUnit} determining how to interpret the
 *        {@code delay} parameter
 * @param executor the base executor
 * @return the new delayed executor
 * @since 9
 * @hide
 */
public static Executor delayedExecutor(long delay, TimeUnit unit, Executor executor) {
    if (unit == null || executor == null)
        throw new NullPointerException();
    return new DelayedExecutor(delay, unit, executor);
}
#method_after
public static Executor delayedExecutor(long delay, TimeUnit unit, Executor executor) {
    if (unit == null || executor == null)
        throw new NullPointerException();
    return new DelayedExecutor(delay, unit, executor);
}
#end_block

#method_before
/**
 * Returns a new Executor that submits a task to the default
 * executor after the given delay (or no delay if non-positive).
 * Each delay commences upon invocation of the returned executor's
 * {@code execute} method.
 *
 * @param delay how long to delay, in units of {@code unit}
 * @param unit a {@code TimeUnit} determining how to interpret the
 *        {@code delay} parameter
 * @return the new delayed executor
 * @since 9
 * @hide
 */
public static Executor delayedExecutor(long delay, TimeUnit unit) {
    if (unit == null)
        throw new NullPointerException();
    return new DelayedExecutor(delay, unit, ASYNC_POOL);
}
#method_after
public static Executor delayedExecutor(long delay, TimeUnit unit) {
    if (unit == null)
        throw new NullPointerException();
    return new DelayedExecutor(delay, unit, ASYNC_POOL);
}
#end_block

#method_before
/**
 * Returns a new CompletionStage that is already completed with
 * the given value and supports only those methods in
 * interface {@link CompletionStage}.
 *
 * @param value the value
 * @param <U> the type of the value
 * @return the completed CompletionStage
 * @since 9
 * @hide
 */
public static <U> CompletionStage<U> completedStage(U value) {
    return new MinimalStage<U>((value == null) ? NIL : value);
}
#method_after
public static <U> CompletionStage<U> completedStage(U value) {
    return new MinimalStage<U>((value == null) ? NIL : value);
}
#end_block

#method_before
/**
 * Returns a new CompletableFuture that is already completed
 * exceptionally with the given exception.
 *
 * @param ex the exception
 * @param <U> the type of the value
 * @return the exceptionally completed CompletableFuture
 * @since 9
 * @hide
 */
public static <U> CompletableFuture<U> failedFuture(Throwable ex) {
    if (ex == null)
        throw new NullPointerException();
    return new CompletableFuture<U>(new AltResult(ex));
}
#method_after
public static <U> CompletableFuture<U> failedFuture(Throwable ex) {
    if (ex == null)
        throw new NullPointerException();
    return new CompletableFuture<U>(new AltResult(ex));
}
#end_block

#method_before
/**
 * Returns a new CompletionStage that is already completed
 * exceptionally with the given exception and supports only those
 * methods in interface {@link CompletionStage}.
 *
 * @param ex the exception
 * @param <U> the type of the value
 * @return the exceptionally completed CompletionStage
 * @since 9
 * @hide
 */
public static <U> CompletionStage<U> failedStage(Throwable ex) {
    if (ex == null)
        throw new NullPointerException();
    return new MinimalStage<U>(new AltResult(ex));
}
#method_after
public static <U> CompletionStage<U> failedStage(Throwable ex) {
    if (ex == null)
        throw new NullPointerException();
    return new MinimalStage<U>(new AltResult(ex));
}
#end_block

#method_before
public void verify(PublicKey key, Provider sigProvider) throws CertificateException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    // Android-changed: Eliminate infinite loop in default implementation.
    // The method X509CertImpl calls this method, thus entering an
    // infinite loop. This strange behaviour was checked to be not
    // specific to libcore by running a test with vogar --mode=jvm
    // 
    // X509CertImpl.verify(this, key, sigProvider);
    super.verify(key, sigProvider);
}
#method_after
public void verify(PublicKey key, Provider sigProvider) throws CertificateException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    // Android-changed: Eliminate infinite recursion in default implementation.
    // The method X509CertImpl calls this method, thus entering an
    // infinite recursive loop. This strange behaviour was checked to be not
    // specific to libcore by running a test with vogar --mode=jvm.
    // This is fixed upstream in OpenJDK 10.
    // 
    // X509CertImpl.verify(this, key, sigProvider);
    super.verify(key, sigProvider);
}
#end_block

#method_before
@Override
boolean start() {
    if (mEnabled) {
        mState = STATE_WAITING_TIMEOUT;
        addTimer(mState, HdmiConfig.TIMEOUT_MS);
        if (paramsBackup != null) {
            HdmiLogger.debug("Set old audio format");
            setAudioFormat();
        } else {
            HdmiLogger.debug("No old audio format. Send a command to reqeust.");
            sendRequestShortAudioDescriptor();
        }
    } else {
        resetShortAudioDescriptor();
        finish();
    }
    return true;
}
#method_after
@Override
boolean start() {
    if (mEnabled) {
        mState = STATE_WAITING_TIMEOUT;
        addTimer(mState, HdmiConfig.TIMEOUT_MS);
        if (mParamsBackup != null) {
            HdmiLogger.debug("Set old audio format");
            setAudioFormat();
        } else {
            HdmiLogger.debug("No old audio format. Send a command to reqeust.");
            sendRequestShortAudioDescriptor();
        }
    } else {
        resetShortAudioDescriptor();
        finish();
    }
    return true;
}
#end_block

#method_before
private void sendRequestShortAudioDescriptor() {
    byte[] params = new byte[4];
    params[0] = (byte) MSAPI_CODEC_DD;
    params[1] = (byte) MSAPI_CODEC_AAC;
    params[2] = (byte) MSAPI_CODEC_DTS;
    params[3] = (byte) MSAPI_CODEC_DDP;
    HdmiCecMessage command = HdmiCecMessageBuilder.buildRequestShortAudioDescriptor(getSourceAddress(), mAvrAddress, params);
    sendCommand(command, new HdmiControlService.SendMessageCallback() {

        @Override
        public void onSendCompleted(int error) {
            switch(error) {
                case Constants.SEND_RESULT_SUCCESS:
                case Constants.SEND_RESULT_BUSY:
                case Constants.SEND_RESULT_FAILURE:
                    // Ignores it silently.
                    break;
                case Constants.SEND_RESULT_NAK:
                    HdmiLogger.debug("Failed to send <Request Short Audio Descriptor>.");
                    finish();
                    break;
            }
        }
    });
}
#method_after
private void sendRequestShortAudioDescriptor() {
    byte[] params = new byte[4];
    params[0] = (byte) Constants.MSAPI_CODEC_DD;
    params[1] = (byte) Constants.MSAPI_CODEC_AAC;
    params[2] = (byte) Constants.MSAPI_CODEC_DTS;
    params[3] = (byte) Constants.MSAPI_CODEC_DDP;
    HdmiCecMessage command = HdmiCecMessageBuilder.buildRequestShortAudioDescriptor(getSourceAddress(), mAvrAddress, params);
    sendCommand(command, new HdmiControlService.SendMessageCallback() {

        @Override
        public void onSendCompleted(int error) {
            switch(error) {
                case Constants.SEND_RESULT_SUCCESS:
                case Constants.SEND_RESULT_BUSY:
                case Constants.SEND_RESULT_FAILURE:
                    // Ignores it silently.
                    break;
                case Constants.SEND_RESULT_NAK:
                    HdmiLogger.debug("Failed to send <Request Short Audio Descriptor>.");
                    finish();
                    break;
            }
        }
    });
}
#end_block

#method_before
private void resetShortAudioDescriptor() {
    String audioParameter = "set_ARC_format=";
    String keyValuePairs;
    byte[] buffer = new byte[2];
    buffer[0] = (byte) 0x00;
    buffer[1] = (byte) mAvrPort;
    keyValuePairs = audioParameter + Arrays.toString(buffer);
    if (paramsBackup != null) {
        byte[] paramsClear = new byte[paramsBackup.length];
        for (int index = 0; index < paramsBackup.length; index += SAD_LEN) {
            // enAudioFormatCode
            paramsClear[index] = (byte) ((paramsBackup[index] & 0x78) >> 3);
            paramsClear[index + 1] = (byte) 0x00;
            paramsClear[index + 2] = (byte) 0x00;
        }
        keyValuePairs += Arrays.toString(paramsClear);
    }
    tv().setAudioParameters(keyValuePairs);
}
#method_after
private void resetShortAudioDescriptor() {
    String audioParameter = "set_ARC_format=";
    String keyValuePairs;
    byte[] buffer = new byte[2];
    buffer[0] = (byte) 0x00;
    buffer[1] = (byte) mAvrPort;
    keyValuePairs = audioParameter + Arrays.toString(buffer);
    mCallback.updateSAD(keyValuePairs, false);
}
#end_block

#method_before
public static void removeAudioFormat() {
    HdmiLogger.debug("Remove audio format.");
    paramsBackup = null;
}
#method_after
public static void removeAudioFormat() {
    HdmiLogger.debug("Remove audio format.");
    mParamsBackup = null;
}
#end_block

#method_before
private void setAudioFormat() {
    byte[] buffer = new byte[2];
    String audioParameter = "set_ARC_format=";
    String keyValuePairs;
    buffer[0] = (byte) (paramsBackup.length);
    buffer[1] = (byte) (mAvrPort);
    keyValuePairs = audioParameter + Arrays.toString(buffer);
    keyValuePairs += Arrays.toString(paramsBackup);
    HdmiLogger.debug("keyValuePairs:" + keyValuePairs);
    tv().setAudioParameters(keyValuePairs);
    finish();
}
#method_after
private void setAudioFormat() {
    byte[] buffer = new byte[2];
    String audioParameter = "set_ARC_format=";
    String keyValuePairs;
    buffer[0] = (byte) (mParamsBackup.length);
    buffer[1] = (byte) (mAvrPort);
    keyValuePairs = audioParameter + Arrays.toString(buffer);
    keyValuePairs += Arrays.toString(mParamsBackup);
    HdmiLogger.debug("keyValuePairs:" + keyValuePairs);
    mCallback.updateSAD(keyValuePairs, isMultiChannelsSupported());
    finish();
}
#end_block

#method_before
@Override
boolean processCommand(HdmiCecMessage cmd) {
    if (mState != STATE_WAITING_TIMEOUT) {
        return false;
    }
    int opcode = cmd.getOpcode();
    byte[] params = cmd.getParams();
    if (opcode == Constants.MESSAGE_FEATURE_ABORT) {
        int originalOpcode = cmd.getParams()[0] & 0xFF;
        if (originalOpcode == Constants.MESSAGE_REQUEST_SHORT_AUDIO_DESCRIPTOR) {
            HdmiLogger.debug("Feature aborted for <Request Short Audio Descriptor>");
            finish();
            return true;
        }
    } else if (opcode == Constants.MESSAGE_REPORT_SHORT_AUDIO_DESCRIPTOR) {
        HdmiLogger.debug("ProcessCommand: <Report Short Audio Descriptor>");
        HdmiLogger.debug("length:" + params.length);
        if ((params.length == 0) || (params.length > SAD_LEN_MAX)) {
            finish();
            return false;
        }
        if ((params[0] & 0xFF) == MSAPI_CODEC_NONE) {
            resetShortAudioDescriptor();
            finish();
            return true;
        }
        paramsBackup = new byte[params.length];
        paramsBackup = Arrays.copyOf(params, params.length);
        setAudioFormat();
        return true;
    }
    return false;
}
#method_after
@Override
boolean processCommand(HdmiCecMessage cmd) {
    if (mState != STATE_WAITING_TIMEOUT) {
        return false;
    }
    int opcode = cmd.getOpcode();
    byte[] params = cmd.getParams();
    if (opcode == Constants.MESSAGE_FEATURE_ABORT) {
        int originalOpcode = cmd.getParams()[0] & 0xFF;
        if (originalOpcode == Constants.MESSAGE_REQUEST_SHORT_AUDIO_DESCRIPTOR) {
            HdmiLogger.debug("Feature aborted for <Request Short Audio Descriptor>");
            finish();
            return true;
        }
    } else if (opcode == Constants.MESSAGE_REPORT_SHORT_AUDIO_DESCRIPTOR) {
        HdmiLogger.debug("ProcessCommand: <Report Short Audio Descriptor>");
        HdmiLogger.debug("length:" + params.length);
        if ((params.length == 0) || (params.length > SAD_LEN_MAX)) {
            finish();
            return false;
        }
        if ((params[0] & 0xFF) == Constants.MSAPI_CODEC_NONE) {
            resetShortAudioDescriptor();
            finish();
            return true;
        }
        mParamsBackup = new byte[params.length];
        mParamsBackup = Arrays.copyOf(params, params.length);
        setAudioFormat();
        return true;
    }
    return false;
}
#end_block

#method_before
void setSystemAudioMode(boolean on, boolean updateSetting) {
    HdmiLogger.debug("System Audio Mode change[old:%b new:%b]", mSystemAudioActivated, on);
    if (updateSetting) {
        mService.writeBooleanSetting(Global.HDMI_SYSTEM_AUDIO_ENABLED, on);
    }
    updateAudioManagerForSystemAudio(on);
    synchronized (mLock) {
        if (mSystemAudioActivated != on) {
            mSystemAudioActivated = on;
            if (getAvrDeviceInfo() != null) {
                RequestShortAudioDescriptorAction action = new RequestShortAudioDescriptorAction(this, getAvrDeviceInfo().getLogicalAddress(), getAvrDeviceInfo().getPortId(), on);
                addAndStartAction(action);
            }
            mService.announceSystemAudioModeChange(on);
        }
    }
}
#method_after
void setSystemAudioMode(boolean on, boolean updateSetting) {
    HdmiLogger.debug("System Audio Mode change[old:%b new:%b]", mSystemAudioActivated, on);
    if (updateSetting) {
        mService.writeBooleanSetting(Global.HDMI_SYSTEM_AUDIO_ENABLED, on);
    }
    updateAudioManagerForSystemAudio(on);
    synchronized (mLock) {
        if (mSystemAudioActivated != on) {
            mSystemAudioActivated = on;
            if (getAvrDeviceInfo() != null) {
                RequestShortAudioDescriptorAction action = new RequestShortAudioDescriptorAction(this, getAvrDeviceInfo().getLogicalAddress(), getAvrDeviceInfo().getPortId(), on, new RequestSADCallback() {

                    @Override
                    public void updateSAD(String keyValuePairs, boolean supportMultiChannels) {
                        mService.getAudioManager().setParameters(keyValuePairs);
                        mService.setCecOption(Constants.OPTION_CEC_SUPPORT_MULTICHANNELS, supportMultiChannels ? Constants.ENABLED : Constants.DISABLED);
                    }
                });
                addAndStartAction(action);
            }
            mService.announceSystemAudioModeChange(on);
        }
    }
}
#end_block

#method_before
public static Metadata toMetadata(MediaSession.QueueItem item) {
    if (item == null) {
        return empty_data();
    }
    Bundle bundle = descriptionToBundle(item.getDescription());
    if (DEBUG) {
        for (String key : bundle.keySet()) {
            Log.e(TAG, "toMetadata: QueueItem: ContainsKey: " + key);
        }
    }
    Metadata ret = bundleToMetadata(bundle);
    // For Queue Items, the Media Id will always be just its Queue ID
    // We don't need to use its actual ID since we don't promise UIDS being valid
    // between a file system and it's now playing list.
    // TODO (apanicke): Remove this prefix later, for now it makes debugging
    // easier.
    ret.mediaId = "NowPlayingId" + item.getQueueId();
    return ret;
}
#method_after
public static Metadata toMetadata(MediaSession.QueueItem item) {
    if (item == null) {
        return empty_data();
    }
    Bundle bundle = descriptionToBundle(item.getDescription());
    if (DEBUG) {
        for (String key : bundle.keySet()) {
            Log.d(TAG, "toMetadata: QueueItem: ContainsKey: " + key);
        }
    }
    Metadata ret = bundleToMetadata(bundle);
    // For Queue Items, the Media Id will always be just its Queue ID
    // We don't need to use its actual ID since we don't promise UIDS being valid
    // between a file system and it's now playing list.
    // TODO (apanicke): Remove this prefix later, for now it makes debugging
    // easier.
    ret.mediaId = "NowPlayingId" + item.getQueueId();
    return ret;
}
#end_block

#method_before
public static Metadata toMetadata(MediaMetadata data) {
    if (data == null) {
        return empty_data();
    }
    MediaDescription desc = data.getDescription();
    Bundle dataBundle = mediaMetadataToBundle(data);
    Bundle bundle = descriptionToBundle(data.getDescription());
    // Prioritize the media metadata over the media description
    bundle.putAll(dataBundle);
    if (DEBUG) {
        for (String key : bundle.keySet()) {
            Log.e(TAG, "toMetadata: MediaMetadata: ContainsKey: " + key);
        }
    }
    Metadata ret = bundleToMetadata(bundle);
    // This will always be currsong. The AVRCP service will overwrite the mediaId if it needs to
    // TODO (apanicke): Remove when the service is ready, right now it makes debugging much more
    // convenient
    ret.mediaId = "currsong";
    return ret;
}
#method_after
public static Metadata toMetadata(MediaMetadata data) {
    if (data == null) {
        return empty_data();
    }
    MediaDescription desc = data.getDescription();
    Bundle dataBundle = mediaMetadataToBundle(data);
    Bundle bundle = descriptionToBundle(data.getDescription());
    // Prioritize the media metadata over the media description
    bundle.putAll(dataBundle);
    if (DEBUG) {
        for (String key : bundle.keySet()) {
            Log.d(TAG, "toMetadata: MediaMetadata: ContainsKey: " + key);
        }
    }
    Metadata ret = bundleToMetadata(bundle);
    // This will always be currsong. The AVRCP service will overwrite the mediaId if it needs to
    // TODO (apanicke): Remove when the service is ready, right now it makes debugging much more
    // convenient
    ret.mediaId = "currsong";
    return ret;
}
#end_block

#method_before
public static Metadata toMetadata(MediaItem item) {
    if (item == null) {
        return empty_data();
    }
    Bundle bundle = descriptionToBundle(item.getDescription());
    if (DEBUG) {
        for (String key : bundle.keySet()) {
            Log.e(TAG, "toMetadata: MediaItem: ContainsKey: " + key);
        }
    }
    Metadata ret = bundleToMetadata(bundle);
    ret.mediaId = item.getMediaId();
    return ret;
}
#method_after
public static Metadata toMetadata(MediaItem item) {
    if (item == null) {
        return empty_data();
    }
    Bundle bundle = descriptionToBundle(item.getDescription());
    if (DEBUG) {
        for (String key : bundle.keySet()) {
            Log.d(TAG, "toMetadata: MediaItem: ContainsKey: " + key);
        }
    }
    Metadata ret = bundleToMetadata(bundle);
    ret.mediaId = item.getMediaId();
    return ret;
}
#end_block

#method_before
void connect() {
    mDelegate.connect();
}
#method_after
public void connect() {
    mDelegate.connect();
}
#end_block

#method_before
void disconnect() {
    mDelegate.disconnect();
}
#method_after
public void disconnect() {
    mDelegate.disconnect();
}
#end_block

#method_before
Bundle getExtras() {
    return mDelegate.getExtras();
}
#method_after
public Bundle getExtras() {
    return mDelegate.getExtras();
}
#end_block

#method_before
void getItem(String mediaId, ItemCallback callback) {
    mDelegate.getItem(mediaId, callback);
}
#method_after
public void getItem(String mediaId, ItemCallback callback) {
    mDelegate.getItem(mediaId, callback);
}
#end_block

#method_before
String getRoot() {
    return mDelegate.getRoot();
}
#method_after
public String getRoot() {
    return mDelegate.getRoot();
}
#end_block

#method_before
ComponentName getServiceComponent() {
    return mDelegate.getServiceComponent();
}
#method_after
public ComponentName getServiceComponent() {
    return mDelegate.getServiceComponent();
}
#end_block

#method_before
MediaSession.Token getSessionToken() {
    return mDelegate.getSessionToken();
}
#method_after
public MediaSession.Token getSessionToken() {
    return mDelegate.getSessionToken();
}
#end_block

#method_before
boolean isConnected() {
    return mDelegate.isConnected();
}
#method_after
public boolean isConnected() {
    return mDelegate.isConnected();
}
#end_block

#method_before
void subscribe(String parentId, Bundle options, SubscriptionCallback callback) {
    mDelegate.subscribe(parentId, options, callback);
}
#method_after
public void subscribe(String parentId, Bundle options, SubscriptionCallback callback) {
    mDelegate.subscribe(parentId, options, callback);
}
#end_block

#method_before
void subscribe(String parentId, SubscriptionCallback callback) {
    mDelegate.subscribe(parentId, callback);
}
#method_after
public void subscribe(String parentId, SubscriptionCallback callback) {
    mDelegate.subscribe(parentId, callback);
}
#end_block

#method_before
void unsubscribe(String parentId) {
    mDelegate.unsubscribe(parentId);
}
#method_after
public void unsubscribe(String parentId) {
    mDelegate.unsubscribe(parentId);
}
#end_block

#method_before
void unsubscribe(String parentId, SubscriptionCallback callback) {
    mDelegate.unsubscribe(parentId, callback);
}
#method_after
public void unsubscribe(String parentId, SubscriptionCallback callback) {
    mDelegate.unsubscribe(parentId, callback);
}
#end_block

#method_before
@VisibleForTesting
void testInit(Context context, ComponentName serviceComponent, ConnectionCallback callback, Bundle rootHints) {
    // This is only used by Mockito to capture the constructor arguments on creation
    Log.wtfStack("AvrcpMockMediaBrowser", "This function should never be called");
}
#method_after
@VisibleForTesting
public void testInit(Context context, ComponentName serviceComponent, ConnectionCallback callback, Bundle rootHints) {
    // This is only used by Mockito to capture the constructor arguments on creation
    Log.wtfStack("AvrcpMockMediaBrowser", "This function should never be called");
}
#end_block

#method_before
private Pair<Uri, Boolean> insertSingleRow(Uri url, ContentValues initialValues) {
    Uri result = null;
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    checkPermission();
    syncBearerBitmaskAndNetworkTypeBitmask(initialValues);
    boolean notify = false;
    SQLiteDatabase db = getWritableDatabase();
    int match = s_urlMatcher.match(url);
    switch(match) {
        case URL_TELEPHONY_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_TELEPHONY:
            {
                ContentValues values;
                if (initialValues != null) {
                    values = new ContentValues(initialValues);
                } else {
                    values = new ContentValues();
                }
                values.put(SUBSCRIPTION_ID, subId);
                values = DatabaseHelper.setDefaultValue(values);
                if (!values.containsKey(EDITED)) {
                    values.put(EDITED, CARRIER_EDITED);
                }
                // Owned_by should be others if inserted via general uri.
                values.put(OWNED_BY, OWNED_BY_OTHERS);
                Pair<Uri, Boolean> ret = insertRowWithValue(values);
                result = ret.first;
                notify = ret.second;
                break;
            }
        case URL_CURRENT_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in the query
            }
        case URL_CURRENT:
            {
                // zero out the previous operator
                db.update(CARRIERS_TABLE, s_currentNullMap, CURRENT + "!=0", null);
                String numeric = initialValues.getAsString(NUMERIC);
                int updated = db.update(CARRIERS_TABLE, s_currentSetMap, NUMERIC + " = '" + numeric + "'", null);
                if (updated > 0) {
                    if (VDBG)
                        log("Setting numeric '" + numeric + "' to be the current operator");
                } else {
                    loge("Failed setting numeric '" + numeric + "' to the current operator");
                }
                break;
            }
        case URL_PREFERAPN_USING_SUBID:
        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_PREFERAPN:
        case URL_PREFERAPN_NO_UPDATE:
            {
                if (initialValues != null) {
                    if (initialValues.containsKey(COLUMN_APN_ID)) {
                        setPreferredApnId(initialValues.getAsLong(COLUMN_APN_ID), subId, true);
                    }
                }
                break;
            }
        case URL_DPC:
            {
                ensureCallingFromSystemOrPhoneUid("URL_DPC called from non SYSTEM_UID.");
                ContentValues values;
                if (initialValues != null) {
                    values = new ContentValues(initialValues);
                } else {
                    values = new ContentValues();
                }
                // Owned_by should be DPC if inserted via URL_DPC.
                values.put(OWNED_BY, OWNED_BY_DPC);
                // DPC records should not be user editable.
                values.put(USER_EDITABLE, false);
                final long rowID = db.insertWithOnConflict(CARRIERS_TABLE, null, values, SQLiteDatabase.CONFLICT_IGNORE);
                if (rowID >= 0) {
                    result = ContentUris.withAppendedId(CONTENT_URI, rowID);
                    notify = true;
                }
                if (VDBG)
                    log("insert: inserted " + values.toString() + " rowID = " + rowID);
                break;
            }
        case URL_SIMINFO:
            {
                long id = db.insert(SIMINFO_TABLE, null, initialValues);
                result = ContentUris.withAppendedId(SubscriptionManager.CONTENT_URI, id);
                break;
            }
    }
    return Pair.create(result, notify);
}
#method_after
private Pair<Uri, Boolean> insertSingleRow(Uri url, ContentValues initialValues) {
    Uri result = null;
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    checkPermission();
    syncBearerBitmaskAndNetworkTypeBitmask(initialValues);
    boolean notify = false;
    SQLiteDatabase db = getWritableDatabase();
    int match = s_urlMatcher.match(url);
    switch(match) {
        case URL_TELEPHONY_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_TELEPHONY:
            {
                ContentValues values;
                if (initialValues != null) {
                    values = new ContentValues(initialValues);
                } else {
                    values = new ContentValues();
                }
                values = DatabaseHelper.setDefaultValue(values);
                if (!values.containsKey(EDITED)) {
                    values.put(EDITED, CARRIER_EDITED);
                }
                // Owned_by should be others if inserted via general uri.
                values.put(OWNED_BY, OWNED_BY_OTHERS);
                Pair<Uri, Boolean> ret = insertRowWithValue(values);
                result = ret.first;
                notify = ret.second;
                break;
            }
        case URL_CURRENT_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in the query
            }
        case URL_CURRENT:
            {
                // zero out the previous operator
                db.update(CARRIERS_TABLE, s_currentNullMap, CURRENT + "!=0", null);
                String numeric = initialValues.getAsString(NUMERIC);
                int updated = db.update(CARRIERS_TABLE, s_currentSetMap, NUMERIC + " = '" + numeric + "'", null);
                if (updated > 0) {
                    if (VDBG)
                        log("Setting numeric '" + numeric + "' to be the current operator");
                } else {
                    loge("Failed setting numeric '" + numeric + "' to the current operator");
                }
                break;
            }
        case URL_PREFERAPN_USING_SUBID:
        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_PREFERAPN:
        case URL_PREFERAPN_NO_UPDATE:
            {
                if (initialValues != null) {
                    if (initialValues.containsKey(COLUMN_APN_ID)) {
                        setPreferredApnId(initialValues.getAsLong(COLUMN_APN_ID), subId, true);
                    }
                }
                break;
            }
        case URL_DPC:
            {
                ensureCallingFromSystemOrPhoneUid("URL_DPC called from non SYSTEM_UID.");
                ContentValues values;
                if (initialValues != null) {
                    values = new ContentValues(initialValues);
                } else {
                    values = new ContentValues();
                }
                // Owned_by should be DPC if inserted via URL_DPC.
                values.put(OWNED_BY, OWNED_BY_DPC);
                // DPC records should not be user editable.
                values.put(USER_EDITABLE, false);
                final long rowID = db.insertWithOnConflict(CARRIERS_TABLE, null, values, SQLiteDatabase.CONFLICT_IGNORE);
                if (rowID >= 0) {
                    result = ContentUris.withAppendedId(CONTENT_URI, rowID);
                    notify = true;
                }
                if (VDBG)
                    log("insert: inserted " + values.toString() + " rowID = " + rowID);
                break;
            }
        case URL_SIMINFO:
            {
                long id = db.insert(SIMINFO_TABLE, null, initialValues);
                result = ContentUris.withAppendedId(SubscriptionManager.CONTENT_URI, id);
                break;
            }
    }
    return Pair.create(result, notify);
}
#end_block

#method_before
@Override
public synchronized void onPrivateDnsValidationEvent(int netId) {
    for (INetdEventCallback callback : mNetdEventCallbackList) {
        if (callback != null) {
            callback.onPrivateDnsValidationEvent(netId);
        }
    }
}
#method_after
@Override
public synchronized // This method must not block or perform long-running operations.
void onPrivateDnsValidationEvent(int netId, String ipAddress, String hostname, boolean validated) throws RemoteException {
    for (INetdEventCallback callback : mNetdEventCallbackList) {
        if (callback != null) {
            callback.onPrivateDnsValidationEvent(netId, ipAddress, hostname, validated);
        }
    }
}
#end_block

#method_before
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    if (keyFileInputStream == null) {
        request.setAttribute("error_title", "GCS Key file Error");
        request.setAttribute("error_message", "The GCS Key file is not existed!");
        RequestDispatcher dispatcher = request.getRequestDispatcher(ERROR_MESSAGE_JSP);
        try {
            dispatcher.forward(request, response);
        } catch (ServletException e) {
            logger.log(Level.SEVERE, "Servlet Excpetion caught : ", e);
        }
    } else {
        String action = request.getParameter("action") == null ? "read" : request.getParameter("action");
        String path = request.getParameter("path") == null ? "/" : request.getParameter("path");
        String entry = request.getParameter("entry") == null ? "" : request.getParameter("entry");
        Path pathInfo = Paths.get(path);
        Bucket vtsReportBucket = storage.get(GCS_BUCKET_NAME);
        List<String> dirList = new ArrayList<>();
        List<String> fileList = new ArrayList<>();
        List<String> entryList = new ArrayList<>();
        Map<String, Object> resultMap = new HashMap<>();
        String entryContent = "";
        if (pathInfo.toString().endsWith(".zip")) {
            Blob blobFile = (Blob) this.syncCache.get(path.toString());
            if (blobFile == null) {
                blobFile = vtsReportBucket.get(path);
                this.syncCache.put(path.toString(), blobFile);
            } else {
            }
            if (action.equalsIgnoreCase("read")) {
                InputStream blobInputStream = new ByteArrayInputStream(blobFile.getContent());
                ZipInputStream zipInputStream = new ZipInputStream(blobInputStream);
                ZipEntry zipEntry;
                while ((zipEntry = zipInputStream.getNextEntry()) != null) {
                    if (zipEntry.isDirectory()) {
                    } else {
                        if (entry.length() > 0) {
                            System.out.println("param entry => " + entry);
                            if (zipEntry.getName().equals(entry)) {
                                System.out.println("matched !!!! " + zipEntry.getName());
                                entryContent = IOUtils.toString(zipInputStream, StandardCharsets.UTF_8.name());
                            }
                        } else {
                            entryList.add(zipEntry.getName());
                        }
                    }
                }
                resultMap.put("entryList", entryList);
                resultMap.put("entryContent", entryContent);
                String json = new Gson().toJson(resultMap);
                response.setContentType("application/json");
                response.setCharacterEncoding("UTF-8");
                response.getWriter().write(json);
            } else {
                response.setContentType("application/octet-stream");
                response.setContentLength(blobFile.getSize().intValue());
                response.setHeader("Content-Disposition", "attachment; filename=\"" + pathInfo.getFileName() + "\"");
                response.getOutputStream().write(blobFile.getContent());
            }
        } else {
            logger.log(Level.INFO, "path info => " + pathInfo);
            logger.log(Level.INFO, "path name count => " + pathInfo.getNameCount());
            BlobListOption[] listOptions;
            if (pathInfo.getNameCount() == 0) {
                listOptions = new BlobListOption[] { BlobListOption.currentDirectory() };
            } else {
                if (pathInfo.getNameCount() <= 1) {
                    dirList.add("/");
                } else {
                    dirList.add(pathInfo.getParent().toString());
                }
                listOptions = new BlobListOption[] { BlobListOption.currentDirectory(), BlobListOption.prefix(pathInfo.toString() + "/") };
            }
            Iterator<Blob> blobIterator = vtsReportBucket.list(listOptions).iterateAll();
            while (blobIterator.hasNext()) {
                Blob blob = blobIterator.next();
                logger.log(Level.INFO, "blob name => " + blob);
                if (blob.isDirectory()) {
                    logger.log(Level.INFO, "directory name => " + blob.getName());
                    dirList.add(blob.getName());
                } else {
                    logger.log(Level.INFO, "file name => " + blob.getName());
                    fileList.add(blob.getName());
                }
            }
            response.setStatus(HttpServletResponse.SC_OK);
            request.setAttribute("entryList", entryList);
            request.setAttribute("dirList", dirList);
            request.setAttribute("fileList", fileList);
            request.setAttribute("path", path);
            RequestDispatcher dispatcher = request.getRequestDispatcher(GCS_LOG_JSP);
            try {
                dispatcher.forward(request, response);
            } catch (ServletException e) {
                logger.log(Level.SEVERE, "Servlet Excpetion caught : ", e);
            }
        }
    }
}
#method_after
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    if (keyFileInputStream == null) {
        request.setAttribute("error_title", "GCS Key file Error");
        request.setAttribute("error_message", "The GCS Key file is not existed!");
        RequestDispatcher dispatcher = request.getRequestDispatcher(ERROR_MESSAGE_JSP);
        try {
            dispatcher.forward(request, response);
        } catch (ServletException e) {
            logger.log(Level.SEVERE, "Servlet Excpetion caught : ", e);
        }
    } else {
        String action = request.getParameter("action") == null ? "read" : request.getParameter("action");
        String path = request.getParameter("path") == null ? "/" : request.getParameter("path");
        String entry = request.getParameter("entry") == null ? "" : request.getParameter("entry");
        Path pathInfo = Paths.get(path);
        Bucket vtsReportBucket = storage.get(GCS_BUCKET_NAME);
        List<String> dirList = new ArrayList<>();
        List<String> fileList = new ArrayList<>();
        List<String> entryList = new ArrayList<>();
        Map<String, Object> resultMap = new HashMap<>();
        String entryContent = "";
        if (pathInfo.toString().endsWith(".zip")) {
            Blob blobFile = (Blob) this.syncCache.get(path.toString());
            if (blobFile == null) {
                blobFile = vtsReportBucket.get(path);
                this.syncCache.put(path.toString(), blobFile);
            }
            if (action.equalsIgnoreCase("read")) {
                InputStream blobInputStream = new ByteArrayInputStream(blobFile.getContent());
                ZipInputStream zipInputStream = new ZipInputStream(blobInputStream);
                ZipEntry zipEntry;
                while ((zipEntry = zipInputStream.getNextEntry()) != null) {
                    if (zipEntry.isDirectory()) {
                    } else {
                        if (entry.length() > 0) {
                            System.out.println("param entry => " + entry);
                            if (zipEntry.getName().equals(entry)) {
                                System.out.println("matched !!!! " + zipEntry.getName());
                                entryContent = IOUtils.toString(zipInputStream, StandardCharsets.UTF_8.name());
                            }
                        } else {
                            entryList.add(zipEntry.getName());
                        }
                    }
                }
                resultMap.put("entryList", entryList);
                resultMap.put("entryContent", entryContent);
                String json = new Gson().toJson(resultMap);
                response.setContentType("application/json");
                response.setCharacterEncoding("UTF-8");
                response.getWriter().write(json);
            } else {
                response.setContentType("application/octet-stream");
                response.setContentLength(blobFile.getSize().intValue());
                response.setHeader("Content-Disposition", "attachment; filename=\"" + pathInfo.getFileName() + "\"");
                response.getOutputStream().write(blobFile.getContent());
            }
        } else {
            logger.log(Level.INFO, "path info => " + pathInfo);
            logger.log(Level.INFO, "path name count => " + pathInfo.getNameCount());
            BlobListOption[] listOptions;
            if (pathInfo.getNameCount() == 0) {
                listOptions = new BlobListOption[] { BlobListOption.currentDirectory() };
            } else {
                if (pathInfo.getNameCount() <= 1) {
                    dirList.add("/");
                } else {
                    dirList.add(pathInfo.getParent().toString());
                }
                listOptions = new BlobListOption[] { BlobListOption.currentDirectory(), BlobListOption.prefix(pathInfo.toString() + "/") };
            }
            Iterator<Blob> blobIterator = vtsReportBucket.list(listOptions).iterateAll();
            while (blobIterator.hasNext()) {
                Blob blob = blobIterator.next();
                logger.log(Level.INFO, "blob name => " + blob);
                if (blob.isDirectory()) {
                    logger.log(Level.INFO, "directory name => " + blob.getName());
                    dirList.add(blob.getName());
                } else {
                    logger.log(Level.INFO, "file name => " + blob.getName());
                    fileList.add(blob.getName());
                }
            }
            response.setStatus(HttpServletResponse.SC_OK);
            request.setAttribute("entryList", entryList);
            request.setAttribute("dirList", dirList);
            request.setAttribute("fileList", fileList);
            request.setAttribute("path", path);
            RequestDispatcher dispatcher = request.getRequestDispatcher(GCS_LOG_JSP);
            try {
                dispatcher.forward(request, response);
            } catch (ServletException e) {
                logger.log(Level.SEVERE, "Servlet Excpetion caught : ", e);
            }
        }
    }
}
#end_block

#method_before
public int getLteLevel() {
    /*
         * TS 36.214 Physical Layer Section 5.1.3
         * TS 36.331 RRC
         *
         * RSSI = received signal + noise
         * RSRP = reference signal dBm
         * RSRQ = quality of signal dB = Number of Resource blocks*RSRP/RSSI
         * SNR = gain = signal/noise ratio = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    if (mLteRsrp > MAX_LTE_RSRP || mLteRsrp < MIN_LTE_RSRP) {
        if (mLteRsrp != INVALID) {
            Log.wtf(LOG_TAG, "getLteLevel - invalid lte rsrp: mLteRsrp=" + mLteRsrp);
        }
    } else if (mLteRsrp >= (mLteRsrpThresholds[3] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
    } else if (mLteRsrp >= (mLteRsrpThresholds[2] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
    } else if (mLteRsrp >= (mLteRsrpThresholds[1] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
    } else if (mLteRsrp >= (mLteRsrpThresholds[0] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_POOR;
    } else {
        rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    }
    if (useOnlyRsrpForLteLevel()) {
        log("getLTELevel - rsrp = " + rsrpIconLevel);
        if (rsrpIconLevel != -1) {
            return rsrpIconLevel;
        }
    }
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel + " lteRsrpBoost:" + mLteRsrpBoost);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-31, 99) as defined in TS 27.001 8.5 */
    if (mLteSignalStrength > 31)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLteLevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
#method_after
public int getLteLevel() {
    /*
         * TS 36.214 Physical Layer Section 5.1.3
         * TS 36.331 RRC
         *
         * RSSI = received signal + noise
         * RSRP = reference signal dBm
         * RSRQ = quality of signal dB = Number of Resource blocks*RSRP/RSSI
         * SNR = gain = signal/noise ratio = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    if (mLteRsrp > MAX_LTE_RSRP || mLteRsrp < MIN_LTE_RSRP) {
        if (mLteRsrp != INVALID) {
            Log.wtf(LOG_TAG, "getLteLevel - invalid lte rsrp: mLteRsrp=" + mLteRsrp);
        }
    } else if (mLteRsrp >= (mLteRsrpThresholds[3] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
    } else if (mLteRsrp >= (mLteRsrpThresholds[2] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
    } else if (mLteRsrp >= (mLteRsrpThresholds[1] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
    } else if (mLteRsrp >= (mLteRsrpThresholds[0] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_POOR;
    } else {
        rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    }
    if (useOnlyRsrpForLteLevel()) {
        log("getLTELevel - rsrp = " + rsrpIconLevel);
        if (rsrpIconLevel != -1) {
            return rsrpIconLevel;
        }
    }
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel + " lteRsrpBoost:" + mLteRsrpBoost);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-31, 99) as defined in TS 27.007 8.5 */
    if (mLteSignalStrength > 31)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLteLevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
#end_block

#method_before
private static File preparePackageParserCache(boolean isUpgrade) {
    if (!DEFAULT_PACKAGE_PARSER_CACHE_ENABLED) {
        return null;
    }
    // Disable package parsing on eng builds to allow for faster incremental development.
    if (Build.IS_ENG) {
        return null;
    }
    if (SystemProperties.getBoolean("pm.boot.disable_package_cache", false)) {
        Slog.i(TAG, "Disabling package parser cache due to system property.");
        return null;
    }
    // The base directory for the package parser cache lives under /data/system/.
    final File cacheBaseDir = FileUtils.createDir(Environment.getDataSystemDirectory(), "package_cache");
    if (cacheBaseDir == null) {
        return null;
    }
    // can only happen during upgrades).
    if (isUpgrade) {
        FileUtils.deleteContents(cacheBaseDir);
    }
    // Return the versioned package cache directory. This is something like
    // "/data/system/package_cache/1"
    File cacheDir = FileUtils.createDir(cacheBaseDir, PACKAGE_PARSER_CACHE_VERSION);
    // destined for release.
    if (Build.IS_USERDEBUG && Build.VERSION.INCREMENTAL.startsWith("eng.") && cacheDir != null) {
        Slog.w(TAG, "Wiping cache directory because the system partition changed.");
        // Heuristic: If the /system directory has been modified recently due to an "adb sync"
        // or a regular make, then blow away the cache. Note that mtimes are *NOT* reliable
        // in general and should not be used for production changes. In this specific case,
        // we know that they will work.
        File frameworkDir = new File(Environment.getRootDirectory(), "framework");
        if (cacheDir.lastModified() < frameworkDir.lastModified()) {
            FileUtils.deleteContents(cacheBaseDir);
            cacheDir = FileUtils.createDir(cacheBaseDir, PACKAGE_PARSER_CACHE_VERSION);
        }
    }
    return cacheDir;
}
#method_after
private static File preparePackageParserCache(boolean isUpgrade) {
    if (!DEFAULT_PACKAGE_PARSER_CACHE_ENABLED) {
        return null;
    }
    // Disable package parsing on eng builds to allow for faster incremental development.
    if (Build.IS_ENG) {
        return null;
    }
    if (SystemProperties.getBoolean("pm.boot.disable_package_cache", false)) {
        Slog.i(TAG, "Disabling package parser cache due to system property.");
        return null;
    }
    // The base directory for the package parser cache lives under /data/system/.
    final File cacheBaseDir = FileUtils.createDir(Environment.getDataSystemDirectory(), "package_cache");
    if (cacheBaseDir == null) {
        return null;
    }
    // can only happen during upgrades).
    if (isUpgrade) {
        FileUtils.deleteContents(cacheBaseDir);
    }
    // Return the versioned package cache directory. This is something like
    // "/data/system/package_cache/1"
    File cacheDir = FileUtils.createDir(cacheBaseDir, PACKAGE_PARSER_CACHE_VERSION);
    if (cacheDir == null) {
        // Something went wrong. Attempt to delete everything and return.
        Slog.wtf(TAG, "Cache directory cannot be created - wiping base dir " + cacheBaseDir);
        FileUtils.deleteContentsAndDir(cacheBaseDir);
        return null;
    }
    // destined for release.
    if (Build.IS_USERDEBUG && Build.VERSION.INCREMENTAL.startsWith("eng.")) {
        Slog.w(TAG, "Wiping cache directory because the system partition changed.");
        // Heuristic: If the /system directory has been modified recently due to an "adb sync"
        // or a regular make, then blow away the cache. Note that mtimes are *NOT* reliable
        // in general and should not be used for production changes. In this specific case,
        // we know that they will work.
        File frameworkDir = new File(Environment.getRootDirectory(), "framework");
        if (cacheDir.lastModified() < frameworkDir.lastModified()) {
            FileUtils.deleteContents(cacheBaseDir);
            cacheDir = FileUtils.createDir(cacheBaseDir, PACKAGE_PARSER_CACHE_VERSION);
        }
    }
    return cacheDir;
}
#end_block

#method_before
public void shutdown() {
    mPackageUsage.writeNow(mPackages);
    mCompilerStats.writeNow();
    mDexManager.writePackageDexUsageNow();
}
#method_after
public void shutdown() {
    mPackageUsage.writeNow(mPackages);
    mCompilerStats.writeNow();
    mDexManager.writePackageDexUsageNow();
    // This is the last chance to write out pending restriction settings
    synchronized (mPackages) {
        if (mHandler.hasMessages(WRITE_PACKAGE_RESTRICTIONS)) {
            mHandler.removeMessages(WRITE_PACKAGE_RESTRICTIONS);
            for (int userId : mDirtyUsers) {
                mSettings.writePackageRestrictionsLPr(userId);
            }
            mDirtyUsers.clear();
        }
    }
}
#end_block

#method_before
@Override
public void screenTurningOn(final ScreenOnListener screenOnListener) {
    if (DEBUG_WAKEUP)
        Slog.i(TAG, "Screen turning on...");
    updateScreenOffSleepToken(false);
    synchronized (mLock) {
        mScreenOnEarly = true;
        mScreenOnFully = false;
        mKeyguardDrawComplete = false;
        mWindowManagerDrawComplete = false;
        mScreenOnListener = screenOnListener;
        if (mKeyguardDelegate != null) {
            mHandler.removeMessages(MSG_KEYGUARD_DRAWN_TIMEOUT);
            mHandler.sendEmptyMessageDelayed(MSG_KEYGUARD_DRAWN_TIMEOUT, getKeyguardDrawnTimeout());
            mKeyguardDelegate.onScreenTurningOn(mKeyguardDrawnCallback);
        } else {
            if (DEBUG_WAKEUP)
                Slog.d(TAG, "null mKeyguardDelegate: setting mKeyguardDrawComplete.");
            finishKeyguardDrawn();
        }
    }
}
#method_after
@Override
public void screenTurningOn(final ScreenOnListener screenOnListener) {
    if (DEBUG_WAKEUP)
        Slog.i(TAG, "Screen turning on...");
    updateScreenOffSleepToken(false);
    synchronized (mLock) {
        mScreenOnEarly = true;
        mScreenOnFully = false;
        mKeyguardDrawComplete = false;
        mWindowManagerDrawComplete = false;
        mScreenOnListener = screenOnListener;
        if (mKeyguardDelegate != null && mKeyguardDelegate.hasKeyguard()) {
            mHandler.removeMessages(MSG_KEYGUARD_DRAWN_TIMEOUT);
            mHandler.sendEmptyMessageDelayed(MSG_KEYGUARD_DRAWN_TIMEOUT, getKeyguardDrawnTimeout());
            mKeyguardDelegate.onScreenTurningOn(mKeyguardDrawnCallback);
        } else {
            if (DEBUG_WAKEUP)
                Slog.d(TAG, "null mKeyguardDelegate: setting mKeyguardDrawComplete.");
            finishKeyguardDrawn();
        }
    }
}
#end_block

#method_before
private void drawSizeMismatchSnapshot(GraphicBuffer buffer) {
    // check if mNativeObject of mSurface is valid or not
    if (!mSurface.isValid()) {
        throw new IllegalStateException("mSurface does not hold a valid surface.");
    }
    final SurfaceSession session = new SurfaceSession(mSurface);
    // Keep a reference to it such that it doesn't get destroyed when finalized.
    mChildSurfaceControl = new SurfaceControl(session, mTitle + " - task-snapshot-surface", buffer.getWidth(), buffer.getHeight(), buffer.getFormat(), HIDDEN);
    Surface surface = new Surface();
    surface.copyFrom(mChildSurfaceControl);
    // Clip off ugly navigation bar.
    final Rect crop = calculateSnapshotCrop();
    final Rect frame = calculateSnapshotFrame(crop);
    SurfaceControl.openTransaction();
    try {
        // We can just show the surface here as it will still be hidden as the parent is
        // still hidden.
        mChildSurfaceControl.show();
        mChildSurfaceControl.setWindowCrop(crop);
        mChildSurfaceControl.setPosition(frame.left, frame.top);
        // Scale the mismatch dimensions to fill the task bounds
        final float scale = 1 / mSnapshot.getScale();
        mChildSurfaceControl.setMatrix(scale, 0, 0, scale);
    } finally {
        SurfaceControl.closeTransaction();
    }
    surface.attachAndQueueBuffer(buffer);
    surface.release();
    final Canvas c = mSurface.lockCanvas(null);
    drawBackgroundAndBars(c, frame);
    mSurface.unlockCanvasAndPost(c);
    mSurface.release();
}
#method_after
private void drawSizeMismatchSnapshot(GraphicBuffer buffer) {
    if (!mSurface.isValid()) {
        throw new IllegalStateException("mSurface does not hold a valid surface.");
    }
    final SurfaceSession session = new SurfaceSession(mSurface);
    // Keep a reference to it such that it doesn't get destroyed when finalized.
    mChildSurfaceControl = new SurfaceControl(session, mTitle + " - task-snapshot-surface", buffer.getWidth(), buffer.getHeight(), buffer.getFormat(), HIDDEN);
    Surface surface = new Surface();
    surface.copyFrom(mChildSurfaceControl);
    // Clip off ugly navigation bar.
    final Rect crop = calculateSnapshotCrop();
    final Rect frame = calculateSnapshotFrame(crop);
    SurfaceControl.openTransaction();
    try {
        // We can just show the surface here as it will still be hidden as the parent is
        // still hidden.
        mChildSurfaceControl.show();
        mChildSurfaceControl.setWindowCrop(crop);
        mChildSurfaceControl.setPosition(frame.left, frame.top);
        // Scale the mismatch dimensions to fill the task bounds
        final float scale = 1 / mSnapshot.getScale();
        mChildSurfaceControl.setMatrix(scale, 0, 0, scale);
    } finally {
        SurfaceControl.closeTransaction();
    }
    surface.attachAndQueueBuffer(buffer);
    surface.release();
    final Canvas c = mSurface.lockCanvas(null);
    drawBackgroundAndBars(c, frame);
    mSurface.unlockCanvasAndPost(c);
    mSurface.release();
}
#end_block

#method_before
public NetworkCapabilities addCapability(@NetCapability int capability) {
    checkCapabilityRange(capability);
    mNetworkCapabilities |= 1 << capability;
    removeUnwantedCapability(capability);
    return this;
}
#method_after
public NetworkCapabilities addCapability(@NetCapability int capability) {
    checkValidCapability(capability);
    mNetworkCapabilities |= 1 << capability;
    // remove from unwanted capability list
    mUnwantedNetworkCapabilities &= ~(1 << capability);
    return this;
}
#end_block

#method_before
public void addUnwantedCapability(@NetCapability int capability) {
    checkCapabilityRange(capability);
    mUnwantedNetworkCapabilities |= 1 << capability;
    removeCapability(capability);
}
#method_after
public void addUnwantedCapability(@NetCapability int capability) {
    checkValidCapability(capability);
    mUnwantedNetworkCapabilities |= 1 << capability;
    // remove from requested capabilities
    mNetworkCapabilities &= ~(1 << capability);
}
#end_block

#method_before
public NetworkCapabilities removeCapability(@NetCapability int capability) {
    checkCapabilityRange(capability);
    mNetworkCapabilities &= ~(1 << capability);
    return this;
}
#method_after
public NetworkCapabilities removeCapability(@NetCapability int capability) {
    checkValidCapability(capability);
    final long mask = ~(1 << capability);
    mNetworkCapabilities &= mask;
    mUnwantedNetworkCapabilities &= mask;
    return this;
}
#end_block

#method_before
public void setCapabilities(@NetCapability int[] capabilities) {
    mNetworkCapabilities = BitUtils.packBits(capabilities);
    // Remove given capabilities from unwanted list
    mUnwantedNetworkCapabilities &= ~(mNetworkCapabilities & mUnwantedNetworkCapabilities);
}
#method_after
public void setCapabilities(@NetCapability int[] capabilities, @NetCapability int[] unwantedCapabilities) {
    mNetworkCapabilities = BitUtils.packBits(capabilities);
    mUnwantedNetworkCapabilities = BitUtils.packBits(unwantedCapabilities);
}
#end_block

#method_before
public void setCapabilities(@NetCapability int[] capabilities) {
    mNetworkCapabilities = BitUtils.packBits(capabilities);
    // Remove given capabilities from unwanted list
    mUnwantedNetworkCapabilities &= ~(mNetworkCapabilities & mUnwantedNetworkCapabilities);
}
#method_after
@Deprecated
public void setCapabilities(@NetCapability int[] capabilities) {
    setCapabilities(capabilities, new int[] {});
}
#end_block

#method_before
public boolean hasCapability(@NetCapability int capability) {
    if (capability < MIN_NET_CAPABILITY || capability > MAX_NET_CAPABILITY) {
        return false;
    }
    return ((mNetworkCapabilities & (1 << capability)) != 0);
}
#method_after
public boolean hasCapability(@NetCapability int capability) {
    return isValidCapability(capability) && ((mNetworkCapabilities & (1 << capability)) != 0);
}
#end_block

#method_before
public boolean hasUnwantedCapability(@NetCapability int capability) {
    if (capability < MIN_NET_CAPABILITY || capability > MAX_NET_CAPABILITY) {
        return false;
    }
    return ((mUnwantedNetworkCapabilities & (1 << capability)) != 0);
}
#method_after
public boolean hasUnwantedCapability(@NetCapability int capability) {
    return isValidCapability(capability) && ((mUnwantedNetworkCapabilities & (1 << capability)) != 0);
}
#end_block

#method_before
private void combineNetCapabilities(NetworkCapabilities nc) {
    this.mNetworkCapabilities |= nc.mNetworkCapabilities;
}
#method_after
private void combineNetCapabilities(NetworkCapabilities nc) {
    this.mNetworkCapabilities |= nc.mNetworkCapabilities;
    this.mUnwantedNetworkCapabilities |= nc.mUnwantedNetworkCapabilities;
}
#end_block

#method_before
public String describeFirstNonRequestableCapability() {
    final long nonRequestable = (mNetworkCapabilities & NON_REQUESTABLE_CAPABILITIES);
    if (nonRequestable != 0) {
        return capabilityNameOf(BitUtils.unpackBits(nonRequestable)[0]);
    }
    if (mLinkUpBandwidthKbps != 0 || mLinkDownBandwidthKbps != 0)
        return "link bandwidth";
    if (hasSignalStrength())
        return "signalStrength";
    return null;
}
#method_after
public String describeFirstNonRequestableCapability() {
    final long nonRequestable = (mNetworkCapabilities | mUnwantedNetworkCapabilities) & NON_REQUESTABLE_CAPABILITIES;
    if (nonRequestable != 0) {
        return capabilityNameOf(BitUtils.unpackBits(nonRequestable)[0]);
    }
    if (mLinkUpBandwidthKbps != 0 || mLinkDownBandwidthKbps != 0)
        return "link bandwidth";
    if (hasSignalStrength())
        return "signalStrength";
    return null;
}
#end_block

#method_before
private boolean satisfiedByNetCapabilities(NetworkCapabilities nc, boolean onlyImmutable) {
    long requestedCapabilities = mNetworkCapabilities;
    long requestedUnwantedCapabilities = mUnwantedNetworkCapabilities;
    long providedCapabilities = nc.mNetworkCapabilities;
    if (onlyImmutable) {
        requestedCapabilities &= ~MUTABLE_CAPABILITIES;
        requestedUnwantedCapabilities &= ~MUTABLE_CAPABILITIES;
        providedCapabilities &= ~MUTABLE_CAPABILITIES;
    }
    return ((providedCapabilities & requestedCapabilities) == requestedCapabilities) && ((requestedUnwantedCapabilities & providedCapabilities) == 0);
}
#method_after
private boolean satisfiedByNetCapabilities(NetworkCapabilities nc, boolean onlyImmutable) {
    long requestedCapabilities = mNetworkCapabilities;
    long requestedUnwantedCapabilities = mUnwantedNetworkCapabilities;
    long providedCapabilities = nc.mNetworkCapabilities;
    if (onlyImmutable) {
        requestedCapabilities &= ~MUTABLE_CAPABILITIES;
        requestedUnwantedCapabilities &= ~MUTABLE_CAPABILITIES;
    }
    return ((providedCapabilities & requestedCapabilities) == requestedCapabilities) && ((requestedUnwantedCapabilities & providedCapabilities) == 0);
}
#end_block

#method_before
public boolean equalsNetCapabilities(NetworkCapabilities nc) {
    return (nc.mNetworkCapabilities == this.mNetworkCapabilities);
}
#method_after
public boolean equalsNetCapabilities(NetworkCapabilities nc) {
    return (nc.mNetworkCapabilities == this.mNetworkCapabilities) && (nc.mUnwantedNetworkCapabilities == this.mUnwantedNetworkCapabilities);
}
#end_block

#method_before
private boolean equalsNetCapabilitiesRequestable(NetworkCapabilities that) {
    return ((this.mNetworkCapabilities & ~NON_REQUESTABLE_CAPABILITIES) == (that.mNetworkCapabilities & ~NON_REQUESTABLE_CAPABILITIES));
}
#method_after
private boolean equalsNetCapabilitiesRequestable(NetworkCapabilities that) {
    return ((this.mNetworkCapabilities & ~NON_REQUESTABLE_CAPABILITIES) == (that.mNetworkCapabilities & ~NON_REQUESTABLE_CAPABILITIES)) && ((this.mUnwantedNetworkCapabilities & ~NON_REQUESTABLE_CAPABILITIES) == (that.mUnwantedNetworkCapabilities & ~NON_REQUESTABLE_CAPABILITIES));
}
#end_block

#method_before
public void combineCapabilities(NetworkCapabilities nc) {
    combineNetCapabilities(nc);
    combineUnwantedNetCapabilities(nc);
    combineTransportTypes(nc);
    combineLinkBandwidths(nc);
    combineSpecifiers(nc);
    combineSignalStrength(nc);
    combineUids(nc);
}
#method_after
public void combineCapabilities(NetworkCapabilities nc) {
    combineNetCapabilities(nc);
    combineTransportTypes(nc);
    combineLinkBandwidths(nc);
    combineSpecifiers(nc);
    combineSignalStrength(nc);
    combineUids(nc);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == null || (obj instanceof NetworkCapabilities == false))
        return false;
    NetworkCapabilities that = (NetworkCapabilities) obj;
    return (equalsNetCapabilities(that) && equalsUnwantedNetCapabilities(that) && equalsTransportTypes(that) && equalsLinkBandwidths(that) && equalsSignalStrength(that) && equalsSpecifier(that) && equalsUids(that));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null || (obj instanceof NetworkCapabilities == false))
        return false;
    NetworkCapabilities that = (NetworkCapabilities) obj;
    return (equalsNetCapabilities(that) && equalsTransportTypes(that) && equalsLinkBandwidths(that) && equalsSignalStrength(that) && equalsSpecifier(that) && equalsUids(that));
}
#end_block

#method_before
@Override
public String toString() {
    // TODO: enumerate bits for transports and capabilities instead of creating arrays.
    // TODO: use a StringBuilder instead of string concatenation.
    int[] types = getTransportTypes();
    String transports = (types.length > 0) ? " Transports: " + transportNamesOf(types) : "";
    types = getCapabilities();
    String capabilities = (types.length > 0 ? " Capabilities: " : "");
    for (int i = 0; i < types.length; ) {
        capabilities += capabilityNameOf(types[i]);
        if (++i < types.length)
            capabilities += "&";
    }
    types = BitUtils.unpackBits(mUnwantedNetworkCapabilities);
    String unwantedCapabilities = (types.length > 0 ? " UnwantedCapabilities: " : "");
    unwantedCapabilities += capabilityNamesOf(types);
    String upBand = ((mLinkUpBandwidthKbps > 0) ? " LinkUpBandwidth>=" + mLinkUpBandwidthKbps + "Kbps" : "");
    String dnBand = ((mLinkDownBandwidthKbps > 0) ? " LinkDnBandwidth>=" + mLinkDownBandwidthKbps + "Kbps" : "");
    String specifier = (mNetworkSpecifier == null ? "" : " Specifier: <" + mNetworkSpecifier + ">");
    String signalStrength = (hasSignalStrength() ? " SignalStrength: " + mSignalStrength : "");
    String uids = (null != mUids ? " Uids: <" + mUids + ">" : "");
    String establishingAppUid = " EstablishingAppUid: " + mEstablishingVpnAppUid;
    return "[" + transports + capabilities + upBand + dnBand + specifier + signalStrength + uids + establishingAppUid + unwantedCapabilities + "]";
}
#method_after
@Override
public String toString() {
    final StringBuilder sb = new StringBuilder("[");
    if (0 != mTransportTypes) {
        sb.append(" Transports: ");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mTransportTypes, NetworkCapabilities::transportNameOf, "|");
    }
    if (0 != mNetworkCapabilities) {
        sb.append(" Capabilities: ");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mNetworkCapabilities, NetworkCapabilities::capabilityNameOf, "&");
    }
    if (0 != mNetworkCapabilities) {
        sb.append(" Unwanted: ");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mUnwantedNetworkCapabilities, NetworkCapabilities::capabilityNameOf, "&");
    }
    if (mLinkUpBandwidthKbps > 0) {
        sb.append(" LinkUpBandwidth>=").append(mLinkUpBandwidthKbps).append("Kbps");
    }
    if (mLinkDownBandwidthKbps > 0) {
        sb.append(" LinkDnBandwidth>=").append(mLinkDownBandwidthKbps).append("Kbps");
    }
    if (mNetworkSpecifier != null) {
        sb.append(" Specifier: <").append(mNetworkSpecifier).append(">");
    }
    if (hasSignalStrength()) {
        sb.append(" SignalStrength: ").append(mSignalStrength);
    }
    if (null != mUids) {
        if ((1 == mUids.size()) && (mUids.valueAt(0).count() == 1)) {
            sb.append(" Uid: ").append(mUids.valueAt(0).start);
        } else {
            sb.append(" Uids: <").append(mUids).append(">");
        }
    }
    if (mEstablishingVpnAppUid != INVALID_UID) {
        sb.append(" EstablishingAppUid: ").append(mEstablishingVpnAppUid);
    }
    sb.append("]");
    return sb.toString();
}
#end_block

#method_before
public static String capabilityNameOf(@NetCapability int capability) {
    switch(capability) {
        case NET_CAPABILITY_MMS:
            return "MMS";
        case NET_CAPABILITY_SUPL:
            return "SUPL";
        case NET_CAPABILITY_DUN:
            return "DUN";
        case NET_CAPABILITY_FOTA:
            return "FOTA";
        case NET_CAPABILITY_IMS:
            return "IMS";
        case NET_CAPABILITY_CBS:
            return "CBS";
        case NET_CAPABILITY_WIFI_P2P:
            return "WIFI_P2P";
        case NET_CAPABILITY_IA:
            return "IA";
        case NET_CAPABILITY_RCS:
            return "RCS";
        case NET_CAPABILITY_XCAP:
            return "XCAP";
        case NET_CAPABILITY_EIMS:
            return "EIMS";
        case NET_CAPABILITY_NOT_METERED:
            return "NOT_METERED";
        case NET_CAPABILITY_INTERNET:
            return "INTERNET";
        case NET_CAPABILITY_NOT_RESTRICTED:
            return "NOT_RESTRICTED";
        case NET_CAPABILITY_TRUSTED:
            return "TRUSTED";
        case NET_CAPABILITY_NOT_VPN:
            return "NOT_VPN";
        case NET_CAPABILITY_VALIDATED:
            return "VALIDATED";
        case NET_CAPABILITY_CAPTIVE_PORTAL:
            return "CAPTIVE_PORTAL";
        case NET_CAPABILITY_NOT_ROAMING:
            return "NOT_ROAMING";
        case NET_CAPABILITY_FOREGROUND:
            return "FOREGROUND";
        case NET_CAPABILITY_NOT_CONGESTED:
            return "NOT_CONGESTED";
        default:
            return Integer.toString(capability);
    }
}
#method_after
public static String capabilityNameOf(@NetCapability int capability) {
    switch(capability) {
        case NET_CAPABILITY_MMS:
            return "MMS";
        case NET_CAPABILITY_SUPL:
            return "SUPL";
        case NET_CAPABILITY_DUN:
            return "DUN";
        case NET_CAPABILITY_FOTA:
            return "FOTA";
        case NET_CAPABILITY_IMS:
            return "IMS";
        case NET_CAPABILITY_CBS:
            return "CBS";
        case NET_CAPABILITY_WIFI_P2P:
            return "WIFI_P2P";
        case NET_CAPABILITY_IA:
            return "IA";
        case NET_CAPABILITY_RCS:
            return "RCS";
        case NET_CAPABILITY_XCAP:
            return "XCAP";
        case NET_CAPABILITY_EIMS:
            return "EIMS";
        case NET_CAPABILITY_NOT_METERED:
            return "NOT_METERED";
        case NET_CAPABILITY_INTERNET:
            return "INTERNET";
        case NET_CAPABILITY_NOT_RESTRICTED:
            return "NOT_RESTRICTED";
        case NET_CAPABILITY_TRUSTED:
            return "TRUSTED";
        case NET_CAPABILITY_NOT_VPN:
            return "NOT_VPN";
        case NET_CAPABILITY_VALIDATED:
            return "VALIDATED";
        case NET_CAPABILITY_CAPTIVE_PORTAL:
            return "CAPTIVE_PORTAL";
        case NET_CAPABILITY_NOT_ROAMING:
            return "NOT_ROAMING";
        case NET_CAPABILITY_FOREGROUND:
            return "FOREGROUND";
        case NET_CAPABILITY_NOT_CONGESTED:
            return "NOT_CONGESTED";
        case NET_CAPABILITY_NOT_SUSPENDED:
            return "NOT_SUSPENDED";
        case NET_CAPABILITY_OEM_PAID:
            return "OEM_PAID";
        default:
            return Integer.toString(capability);
    }
}
#end_block

#method_before
@Test
public void testUnwantedCapabilities() {
    NetworkCapabilities network = new NetworkCapabilities();
    NetworkCapabilities request = new NetworkCapabilities();
    assertTrue("Request: " + request + ", Network:" + network, request.satisfiedByNetworkCapabilities(network));
    // Adding capabilities that doesn't exist in the network anyway
    request.addUnwantedCapability(NET_CAPABILITY_WIFI_P2P);
    request.addUnwantedCapability(NET_CAPABILITY_NOT_METERED);
    assertTrue(request.satisfiedByNetworkCapabilities(network));
    // This is a default capability, just want to make sure its there because we use it below.
    assertTrue(network.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    // Verify that adding unwanted capability will effectively remove it from capability list.
    request.addUnwantedCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertFalse(request.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    // Now this request won't be satisfied because network contains NOT_RESTRICTED.
    assertFalse(request.satisfiedByNetworkCapabilities(network));
    network.removeCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertTrue(request.satisfiedByNetworkCapabilities(network));
    // Verify that adding capability will effectively remove it from unwanted list
    request.addCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertFalse(request.hasUnwantedCapability(NET_CAPABILITY_NOT_RESTRICTED));
    assertFalse(request.satisfiedByNetworkCapabilities(network));
    network.addCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertTrue(request.satisfiedByNetworkCapabilities(network));
}
#method_after
@Test
public void testUnwantedCapabilities() {
    NetworkCapabilities network = new NetworkCapabilities();
    NetworkCapabilities request = new NetworkCapabilities();
    assertTrue("Request: " + request + ", Network:" + network, request.satisfiedByNetworkCapabilities(network));
    // Adding capabilities that doesn't exist in the network anyway
    request.addUnwantedCapability(NET_CAPABILITY_WIFI_P2P);
    request.addUnwantedCapability(NET_CAPABILITY_NOT_METERED);
    assertTrue(request.satisfiedByNetworkCapabilities(network));
    assertArrayEquals(new int[] { NET_CAPABILITY_WIFI_P2P, NET_CAPABILITY_NOT_METERED }, request.getUnwantedCapabilities());
    // This is a default capability, just want to make sure its there because we use it below.
    assertTrue(network.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    // Verify that adding unwanted capability will effectively remove it from capability list.
    request.addUnwantedCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertTrue(request.hasUnwantedCapability(NET_CAPABILITY_NOT_RESTRICTED));
    assertFalse(request.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    // Now this request won't be satisfied because network contains NOT_RESTRICTED.
    assertFalse(request.satisfiedByNetworkCapabilities(network));
    network.removeCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertTrue(request.satisfiedByNetworkCapabilities(network));
    // Verify that adding capability will effectively remove it from unwanted list
    request.addCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertTrue(request.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    assertFalse(request.hasUnwantedCapability(NET_CAPABILITY_NOT_RESTRICTED));
    assertFalse(request.satisfiedByNetworkCapabilities(network));
    network.addCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertTrue(request.satisfiedByNetworkCapabilities(network));
}
#end_block

#method_before
private CharSequence timeToLog(long timestamp) {
    return android.text.format.DateFormat.format("MM-dd HH:mm:ss", timestamp);
}
#method_after
private static CharSequence timeToLog(long timestamp) {
    return android.text.format.DateFormat.format("MM-dd HH:mm:ss", timestamp);
}
#end_block

#method_before
public String toString() {
    return timeToLog(mTimestamp) + (mEnable ? "  Enabled " : " Disabled ") + " due to " + getReasonString(mReason) + " by " + mPackageName;
}
#method_after
public String toString() {
    return timeToLog(mTimestamp) + (mEnable ? "  Enabled " : " Disabled ") + " due to " + getEnableDisableReasonString(mReason) + " by " + mPackageName;
}
#end_block

#method_before
@Override
public boolean isBleScanAlwaysAvailable() {
    if (isAirplaneModeOn() && !mEnable) {
        return false;
    }
    try {
        return (Settings.Global.getInt(mContentResolver, Settings.Global.BLE_SCAN_ALWAYS_AVAILABLE)) != 0;
    } catch (SettingNotFoundException e) {
    }
    return false;
}
#method_after
@Override
public boolean isBleScanAlwaysAvailable() {
    if (isAirplaneModeOn() && !mEnable) {
        return false;
    }
    try {
        return Settings.Global.getInt(mContentResolver, Settings.Global.BLE_SCAN_ALWAYS_AVAILABLE) != 0;
    } catch (SettingNotFoundException e) {
    }
    return false;
}
#end_block

#method_before
public boolean enableNoAutoConnect(String packageName) {
    if (isBluetoothDisallowed()) {
        if (DBG) {
            Slog.d(TAG, "enableNoAutoConnect(): not enabling - bluetooth disallowed");
        }
        return false;
    }
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH ADMIN permission");
    if (DBG) {
        Slog.d(TAG, "enableNoAutoConnect():  mBluetooth =" + mBluetooth + " mBinding = " + mBinding);
    }
    int callingAppId = UserHandle.getAppId(Binder.getCallingUid());
    if (callingAppId != Process.NFC_UID) {
        throw new SecurityException("no permission to enable Bluetooth quietly");
    }
    synchronized (mReceiver) {
        mQuietEnableExternal = true;
        mEnableExternal = true;
        sendEnableMsg(true, REASON_PACKAGE, packageName);
    }
    return true;
}
#method_after
public boolean enableNoAutoConnect(String packageName) {
    if (isBluetoothDisallowed()) {
        if (DBG) {
            Slog.d(TAG, "enableNoAutoConnect(): not enabling - bluetooth disallowed");
        }
        return false;
    }
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH ADMIN permission");
    if (DBG) {
        Slog.d(TAG, "enableNoAutoConnect():  mBluetooth =" + mBluetooth + " mBinding = " + mBinding);
    }
    int callingAppId = UserHandle.getAppId(Binder.getCallingUid());
    if (callingAppId != Process.NFC_UID) {
        throw new SecurityException("no permission to enable Bluetooth quietly");
    }
    synchronized (mReceiver) {
        mQuietEnableExternal = true;
        mEnableExternal = true;
        sendEnableMsg(true, BluetoothProtoEnums.ENABLE_DISABLE_REASON_APPLICATION_REQUEST, packageName);
    }
    return true;
}
#end_block

#method_before
public boolean enable(String packageName) throws RemoteException {
    final int callingUid = Binder.getCallingUid();
    final boolean callerSystem = UserHandle.getAppId(callingUid) == Process.SYSTEM_UID;
    if (isBluetoothDisallowed()) {
        if (DBG) {
            Slog.d(TAG, "enable(): not enabling - bluetooth disallowed");
        }
        return false;
    }
    if (!callerSystem) {
        if (!checkIfCallerIsForegroundUser()) {
            Slog.w(TAG, "enable(): not allowed for non-active and non system user");
            return false;
        }
        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH ADMIN permission");
        if (!isEnabled() && mPermissionReviewRequired && startConsentUiIfNeeded(packageName, callingUid, BluetoothAdapter.ACTION_REQUEST_ENABLE)) {
            return false;
        }
    }
    if (DBG) {
        Slog.d(TAG, "enable(" + packageName + "):  mBluetooth =" + mBluetooth + " mBinding = " + mBinding + " mState = " + BluetoothAdapter.nameForState(mState));
    }
    synchronized (mReceiver) {
        mQuietEnableExternal = false;
        mEnableExternal = true;
        // waive WRITE_SECURE_SETTINGS permission check
        sendEnableMsg(false, REASON_PACKAGE, packageName);
    }
    if (DBG) {
        Slog.d(TAG, "enable returning");
    }
    return true;
}
#method_after
public boolean enable(String packageName) throws RemoteException {
    final int callingUid = Binder.getCallingUid();
    final boolean callerSystem = UserHandle.getAppId(callingUid) == Process.SYSTEM_UID;
    if (isBluetoothDisallowed()) {
        if (DBG) {
            Slog.d(TAG, "enable(): not enabling - bluetooth disallowed");
        }
        return false;
    }
    if (!callerSystem) {
        if (!checkIfCallerIsForegroundUser()) {
            Slog.w(TAG, "enable(): not allowed for non-active and non system user");
            return false;
        }
        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH ADMIN permission");
        if (!isEnabled() && mPermissionReviewRequired && startConsentUiIfNeeded(packageName, callingUid, BluetoothAdapter.ACTION_REQUEST_ENABLE)) {
            return false;
        }
    }
    if (DBG) {
        Slog.d(TAG, "enable(" + packageName + "):  mBluetooth =" + mBluetooth + " mBinding = " + mBinding + " mState = " + BluetoothAdapter.nameForState(mState));
    }
    synchronized (mReceiver) {
        mQuietEnableExternal = false;
        mEnableExternal = true;
        // waive WRITE_SECURE_SETTINGS permission check
        sendEnableMsg(false, BluetoothProtoEnums.ENABLE_DISABLE_REASON_APPLICATION_REQUEST, packageName);
    }
    if (DBG) {
        Slog.d(TAG, "enable returning");
    }
    return true;
}
#end_block

#method_before
public boolean disable(String packageName, boolean persist) throws RemoteException {
    final int callingUid = Binder.getCallingUid();
    final boolean callerSystem = UserHandle.getAppId(callingUid) == Process.SYSTEM_UID;
    if (!callerSystem) {
        if (!checkIfCallerIsForegroundUser()) {
            Slog.w(TAG, "disable(): not allowed for non-active and non system user");
            return false;
        }
        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH ADMIN permission");
        if (isEnabled() && mPermissionReviewRequired && startConsentUiIfNeeded(packageName, callingUid, BluetoothAdapter.ACTION_REQUEST_DISABLE)) {
            return false;
        }
    }
    if (DBG) {
        Slog.d(TAG, "disable(): mBluetooth = " + mBluetooth + " mBinding = " + mBinding);
    }
    synchronized (mReceiver) {
        if (persist) {
            persistBluetoothSetting(BLUETOOTH_OFF);
        }
        mEnableExternal = false;
        sendDisableMsg(REASON_PACKAGE, packageName);
    }
    return true;
}
#method_after
public boolean disable(String packageName, boolean persist) throws RemoteException {
    final int callingUid = Binder.getCallingUid();
    final boolean callerSystem = UserHandle.getAppId(callingUid) == Process.SYSTEM_UID;
    if (!callerSystem) {
        if (!checkIfCallerIsForegroundUser()) {
            Slog.w(TAG, "disable(): not allowed for non-active and non system user");
            return false;
        }
        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH ADMIN permission");
        if (isEnabled() && mPermissionReviewRequired && startConsentUiIfNeeded(packageName, callingUid, BluetoothAdapter.ACTION_REQUEST_DISABLE)) {
            return false;
        }
    }
    if (DBG) {
        Slog.d(TAG, "disable(): mBluetooth = " + mBluetooth + " mBinding = " + mBinding);
    }
    synchronized (mReceiver) {
        if (persist) {
            persistBluetoothSetting(BLUETOOTH_OFF);
        }
        mEnableExternal = false;
        sendDisableMsg(BluetoothProtoEnums.ENABLE_DISABLE_REASON_APPLICATION_REQUEST, packageName);
    }
    return true;
}
#end_block

#method_before
public void handleOnBootPhase() {
    if (DBG) {
        Slog.d(TAG, "Bluetooth boot completed");
    }
    UserManagerInternal userManagerInternal = LocalServices.getService(UserManagerInternal.class);
    userManagerInternal.addUserRestrictionsListener(mUserRestrictionsListener);
    final boolean isBluetoothDisallowed = isBluetoothDisallowed();
    if (isBluetoothDisallowed) {
        return;
    }
    if (mEnableExternal && isBluetoothPersistedStateOnBluetooth()) {
        if (DBG) {
            Slog.d(TAG, "Auto-enabling Bluetooth.");
        }
        sendEnableMsg(mQuietEnableExternal, REASON_SYSTEM_BOOT, ActivityThread.currentPackageName());
    } else if (!isNameAndAddressSet()) {
        if (DBG) {
            Slog.d(TAG, "Getting adapter name and address");
        }
        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
        mHandler.sendMessage(getMsg);
    }
}
#method_after
public void handleOnBootPhase() {
    if (DBG) {
        Slog.d(TAG, "Bluetooth boot completed");
    }
    UserManagerInternal userManagerInternal = LocalServices.getService(UserManagerInternal.class);
    userManagerInternal.addUserRestrictionsListener(mUserRestrictionsListener);
    final boolean isBluetoothDisallowed = isBluetoothDisallowed();
    if (isBluetoothDisallowed) {
        return;
    }
    if (mEnableExternal && isBluetoothPersistedStateOnBluetooth()) {
        if (DBG) {
            Slog.d(TAG, "Auto-enabling Bluetooth.");
        }
        sendEnableMsg(mQuietEnableExternal, BluetoothProtoEnums.ENABLE_DISABLE_REASON_SYSTEM_BOOT, mContext.getPackageName());
    } else if (!isNameAndAddressSet()) {
        if (DBG) {
            Slog.d(TAG, "Getting adapter name and address");
        }
        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
        mHandler.sendMessage(getMsg);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MESSAGE_GET_NAME_AND_ADDRESS:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_GET_NAME_AND_ADDRESS");
            }
            try {
                mBluetoothLock.writeLock().lock();
                if ((mBluetooth == null) && (!mBinding)) {
                    if (DBG) {
                        Slog.d(TAG, "Binding to service to get name and address");
                    }
                    mGetNameAddressOnly = true;
                    Message timeoutMsg = mHandler.obtainMessage(MESSAGE_TIMEOUT_BIND);
                    mHandler.sendMessageDelayed(timeoutMsg, TIMEOUT_BIND_MS);
                    Intent i = new Intent(IBluetooth.class.getName());
                    if (!doBind(i, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT, UserHandle.CURRENT)) {
                        mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    } else {
                        mBinding = true;
                    }
                } else if (mBluetooth != null) {
                    try {
                        storeNameAndAddress(mBluetooth.getName(), mBluetooth.getAddress());
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to grab names", re);
                    }
                    if (mGetNameAddressOnly && !mEnable) {
                        unbindAndFinish();
                    }
                    mGetNameAddressOnly = false;
                }
            } finally {
                mBluetoothLock.writeLock().unlock();
            }
            break;
        case MESSAGE_ENABLE:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_ENABLE(" + msg.arg1 + "): mBluetooth = " + mBluetooth);
            }
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            mEnable = true;
            // Use service interface to get the exact state
            try {
                mBluetoothLock.readLock().lock();
                if (mBluetooth != null) {
                    int state = mBluetooth.getState();
                    if (state == BluetoothAdapter.STATE_BLE_ON) {
                        Slog.w(TAG, "BT Enable in BLE_ON State, going to ON");
                        mBluetooth.onLeServiceUp();
                        persistBluetoothSetting(BLUETOOTH_ON_BLUETOOTH);
                        break;
                    }
                }
            } catch (RemoteException e) {
                Slog.e(TAG, "", e);
            } finally {
                mBluetoothLock.readLock().unlock();
            }
            mQuietEnable = (msg.arg1 == 1);
            if (mBluetooth == null) {
                handleEnable(mQuietEnable);
            } else {
                // 
                // We need to wait until transitioned to STATE_OFF and
                // the previous Bluetooth process has exited. The
                // waiting period has three components:
                // (a) Wait until the local state is STATE_OFF. This
                // is accomplished by "waitForOnOff(false, true)".
                // (b) Wait until the STATE_OFF state is updated to
                // all components.
                // (c) Wait until the Bluetooth process exits, and
                // ActivityManager detects it.
                // The waiting for (b) and (c) is accomplished by
                // delaying the MESSAGE_RESTART_BLUETOOTH_SERVICE
                // message. On slower devices, that delay needs to be
                // on the order of (2 * SERVICE_RESTART_TIME_MS).
                // 
                waitForOnOff(false, true);
                Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
            }
            break;
        case MESSAGE_DISABLE:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_DISABLE: mBluetooth = " + mBluetooth);
            }
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            if (mEnable && mBluetooth != null) {
                waitForOnOff(true, false);
                mEnable = false;
                handleDisable();
                waitForOnOff(false, false);
            } else {
                mEnable = false;
                handleDisable();
            }
            break;
        case MESSAGE_RESTORE_USER_SETTING:
            if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) {
                if (DBG) {
                    Slog.d(TAG, "Restore Bluetooth state to disabled");
                }
                persistBluetoothSetting(BLUETOOTH_OFF);
                mEnableExternal = false;
                sendDisableMsg(REASON_RESTORE_USER_SETTING, ActivityThread.currentPackageName());
            } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) {
                if (DBG) {
                    Slog.d(TAG, "Restore Bluetooth state to enabled");
                }
                mQuietEnableExternal = false;
                mEnableExternal = true;
                // waive WRITE_SECURE_SETTINGS permission check
                sendEnableMsg(false, REASON_RESTORE_USER_SETTING, ActivityThread.currentPackageName());
            }
            break;
        case MESSAGE_REGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_ADD_PROXY_DELAYED:
            {
                ProfileServiceConnections psc = mProfileServices.get(msg.arg1);
                if (psc == null) {
                    break;
                }
                IBluetoothProfileServiceConnection proxy = (IBluetoothProfileServiceConnection) msg.obj;
                psc.addProxy(proxy);
                break;
            }
        case MESSAGE_BIND_PROFILE_SERVICE:
            {
                ProfileServiceConnections psc = (ProfileServiceConnections) msg.obj;
                removeMessages(MESSAGE_BIND_PROFILE_SERVICE, msg.obj);
                if (psc == null) {
                    break;
                }
                psc.bindService();
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_CONNECTED:
            {
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_SERVICE_CONNECTED: " + msg.arg1);
                }
                IBinder service = (IBinder) msg.obj;
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = IBluetoothGatt.Stub.asInterface(Binder.allowBlocking(service));
                        onBluetoothGattServiceUp();
                        break;
                    }
                    // else must be SERVICE_IBLUETOOTH
                    // Remove timeout
                    mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    mBinding = false;
                    mBluetoothBinder = service;
                    mBluetooth = IBluetooth.Stub.asInterface(Binder.allowBlocking(service));
                    if (!isNameAndAddressSet()) {
                        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
                        mHandler.sendMessage(getMsg);
                        if (mGetNameAddressOnly) {
                            return;
                        }
                    }
                    // Register callback object
                    try {
                        mBluetooth.registerCallback(mBluetoothCallback);
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to register BluetoothCallback", re);
                    }
                    // Inform BluetoothAdapter instances that service is up
                    sendBluetoothServiceUpCallback();
                    // Do enable request
                    try {
                        if (!mQuietEnable) {
                            if (!mBluetooth.enable()) {
                                Slog.e(TAG, "IBluetooth.enable() returned false");
                            }
                        } else {
                            if (!mBluetooth.enableNoAutoConnect()) {
                                Slog.e(TAG, "IBluetooth.enableNoAutoConnect() returned false");
                            }
                        }
                    } catch (RemoteException e) {
                        Slog.e(TAG, "Unable to call enable()", e);
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                if (!mEnable) {
                    waitForOnOff(true, false);
                    handleDisable();
                    waitForOnOff(false, false);
                }
                break;
            }
        case MESSAGE_BLUETOOTH_STATE_CHANGE:
            {
                int prevState = msg.arg1;
                int newState = msg.arg2;
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_STATE_CHANGE: " + BluetoothAdapter.nameForState(prevState) + " > " + BluetoothAdapter.nameForState(newState));
                }
                mState = newState;
                bluetoothStateChangeHandler(prevState, newState);
                // unbind and rebind bluetooth service and enable bluetooth
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_ON) && (newState == BluetoothAdapter.STATE_OFF) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(false);
                }
                if ((prevState == BluetoothAdapter.STATE_TURNING_ON) && (newState == BluetoothAdapter.STATE_BLE_ON) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(true);
                }
                // here.  This is a bit of a hack (b/29363429).
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_OFF) && (newState == BluetoothAdapter.STATE_OFF)) {
                    if (mEnable) {
                        Slog.d(TAG, "Entering STATE_OFF but mEnabled is true; restarting.");
                        waitForOnOff(false, true);
                        Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
                    }
                }
                if (newState == BluetoothAdapter.STATE_ON || newState == BluetoothAdapter.STATE_BLE_ON) {
                    // bluetooth is working, reset the counter
                    if (mErrorRecoveryRetryCounter != 0) {
                        Slog.w(TAG, "bluetooth is recovered from error");
                        mErrorRecoveryRetryCounter = 0;
                    }
                }
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED:
            {
                Slog.e(TAG, "MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED(" + msg.arg1 + ")");
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTH) {
                        // if service is unbinded already, do nothing and return
                        if (mBluetooth == null) {
                            break;
                        }
                        mBluetooth = null;
                    } else if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = null;
                        break;
                    } else {
                        Slog.e(TAG, "Unknown argument for service disconnect!");
                        break;
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                // log the unexpected crash
                addCrashLog();
                addActiveLog(REASON_UNEXPECTED, ActivityThread.currentPackageName(), false);
                if (mEnable) {
                    mEnable = false;
                    // Send a Bluetooth Restart message
                    Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                    mHandler.sendMessageDelayed(restartMsg, SERVICE_RESTART_TIME_MS);
                }
                sendBluetoothServiceDownCallback();
                // the BT icon correctly
                if ((mState == BluetoothAdapter.STATE_TURNING_ON) || (mState == BluetoothAdapter.STATE_ON)) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    mState = BluetoothAdapter.STATE_TURNING_OFF;
                }
                if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                }
                mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                mState = BluetoothAdapter.STATE_OFF;
                break;
            }
        case MESSAGE_RESTART_BLUETOOTH_SERVICE:
            {
                Slog.d(TAG, "MESSAGE_RESTART_BLUETOOTH_SERVICE");
                /* Enable without persisting the setting as
                     it doesnt change when IBluetooth
                     service restarts */
                mEnable = true;
                addActiveLog(REASON_RESTARTED, ActivityThread.currentPackageName(), true);
                handleEnable(mQuietEnable);
                break;
            }
        case MESSAGE_TIMEOUT_BIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_BIND");
                mBluetoothLock.writeLock().lock();
                mBinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_TIMEOUT_UNBIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_UNBIND");
                mBluetoothLock.writeLock().lock();
                mUnbinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_USER_SWITCHED:
            {
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_USER_SWITCHED");
                }
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                /* disable and enable BT when detect a user switch */
                if (mBluetooth != null && isEnabled()) {
                    try {
                        mBluetoothLock.readLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth.unregisterCallback(mBluetoothCallback);
                        }
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to unregister", re);
                    } finally {
                        mBluetoothLock.readLock().unlock();
                    }
                    if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                        // MESSAGE_USER_SWITCHED happened right after MESSAGE_ENABLE
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_OFF);
                        mState = BluetoothAdapter.STATE_OFF;
                    }
                    if (mState == BluetoothAdapter.STATE_OFF) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_TURNING_ON);
                        mState = BluetoothAdapter.STATE_TURNING_ON;
                    }
                    waitForOnOff(true, false);
                    if (mState == BluetoothAdapter.STATE_TURNING_ON) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_ON);
                    }
                    unbindAllBluetoothProfileServices();
                    // disable
                    addActiveLog(REASON_USER_SWITCH, ActivityThread.currentPackageName(), false);
                    handleDisable();
                    // Pbap service need receive STATE_TURNING_OFF intent to close
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    boolean didDisableTimeout = !waitForOnOff(false, true);
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                    sendBluetoothServiceDownCallback();
                    try {
                        mBluetoothLock.writeLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth = null;
                            // Unbind
                            mContext.unbindService(mConnection);
                        }
                        mBluetoothGatt = null;
                    } finally {
                        mBluetoothLock.writeLock().unlock();
                    }
                    // 
                    if (didDisableTimeout) {
                        SystemClock.sleep(3000);
                    } else {
                        SystemClock.sleep(100);
                    }
                    mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                    mState = BluetoothAdapter.STATE_OFF;
                    // enable
                    addActiveLog(REASON_USER_SWITCH, ActivityThread.currentPackageName(), true);
                    // mEnable flag could have been reset on disableBLE. Reenable it.
                    mEnable = true;
                    handleEnable(mQuietEnable);
                } else if (mBinding || mBluetooth != null) {
                    Message userMsg = mHandler.obtainMessage(MESSAGE_USER_SWITCHED);
                    userMsg.arg2 = 1 + msg.arg2;
                    // if user is switched when service is binding retry after a delay
                    mHandler.sendMessageDelayed(userMsg, USER_SWITCHED_TIME_MS);
                    if (DBG) {
                        Slog.d(TAG, "Retry MESSAGE_USER_SWITCHED " + userMsg.arg2);
                    }
                }
                break;
            }
        case MESSAGE_USER_UNLOCKED:
            {
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_USER_UNLOCKED");
                }
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                if (mEnable && !mBinding && (mBluetooth == null)) {
                    // aware, so try binding again.
                    if (DBG) {
                        Slog.d(TAG, "Enabled but not bound; retrying after unlock");
                    }
                    handleEnable(mQuietEnable);
                }
            }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MESSAGE_GET_NAME_AND_ADDRESS:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_GET_NAME_AND_ADDRESS");
            }
            try {
                mBluetoothLock.writeLock().lock();
                if ((mBluetooth == null) && (!mBinding)) {
                    if (DBG) {
                        Slog.d(TAG, "Binding to service to get name and address");
                    }
                    mGetNameAddressOnly = true;
                    Message timeoutMsg = mHandler.obtainMessage(MESSAGE_TIMEOUT_BIND);
                    mHandler.sendMessageDelayed(timeoutMsg, TIMEOUT_BIND_MS);
                    Intent i = new Intent(IBluetooth.class.getName());
                    if (!doBind(i, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT, UserHandle.CURRENT)) {
                        mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    } else {
                        mBinding = true;
                    }
                } else if (mBluetooth != null) {
                    try {
                        storeNameAndAddress(mBluetooth.getName(), mBluetooth.getAddress());
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to grab names", re);
                    }
                    if (mGetNameAddressOnly && !mEnable) {
                        unbindAndFinish();
                    }
                    mGetNameAddressOnly = false;
                }
            } finally {
                mBluetoothLock.writeLock().unlock();
            }
            break;
        case MESSAGE_ENABLE:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_ENABLE(" + msg.arg1 + "): mBluetooth = " + mBluetooth);
            }
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            mEnable = true;
            // Use service interface to get the exact state
            try {
                mBluetoothLock.readLock().lock();
                if (mBluetooth != null) {
                    int state = mBluetooth.getState();
                    if (state == BluetoothAdapter.STATE_BLE_ON) {
                        Slog.w(TAG, "BT Enable in BLE_ON State, going to ON");
                        mBluetooth.onLeServiceUp();
                        persistBluetoothSetting(BLUETOOTH_ON_BLUETOOTH);
                        break;
                    }
                }
            } catch (RemoteException e) {
                Slog.e(TAG, "", e);
            } finally {
                mBluetoothLock.readLock().unlock();
            }
            mQuietEnable = (msg.arg1 == 1);
            if (mBluetooth == null) {
                handleEnable(mQuietEnable);
            } else {
                // 
                // We need to wait until transitioned to STATE_OFF and
                // the previous Bluetooth process has exited. The
                // waiting period has three components:
                // (a) Wait until the local state is STATE_OFF. This
                // is accomplished by "waitForOnOff(false, true)".
                // (b) Wait until the STATE_OFF state is updated to
                // all components.
                // (c) Wait until the Bluetooth process exits, and
                // ActivityManager detects it.
                // The waiting for (b) and (c) is accomplished by
                // delaying the MESSAGE_RESTART_BLUETOOTH_SERVICE
                // message. On slower devices, that delay needs to be
                // on the order of (2 * SERVICE_RESTART_TIME_MS).
                // 
                waitForOnOff(false, true);
                Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
            }
            break;
        case MESSAGE_DISABLE:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_DISABLE: mBluetooth = " + mBluetooth);
            }
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            if (mEnable && mBluetooth != null) {
                waitForOnOff(true, false);
                mEnable = false;
                handleDisable();
                waitForOnOff(false, false);
            } else {
                mEnable = false;
                handleDisable();
            }
            break;
        case MESSAGE_RESTORE_USER_SETTING:
            if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) {
                if (DBG) {
                    Slog.d(TAG, "Restore Bluetooth state to disabled");
                }
                persistBluetoothSetting(BLUETOOTH_OFF);
                mEnableExternal = false;
                sendDisableMsg(BluetoothProtoEnums.ENABLE_DISABLE_REASON_RESTORE_USER_SETTING, mContext.getPackageName());
            } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) {
                if (DBG) {
                    Slog.d(TAG, "Restore Bluetooth state to enabled");
                }
                mQuietEnableExternal = false;
                mEnableExternal = true;
                // waive WRITE_SECURE_SETTINGS permission check
                sendEnableMsg(false, BluetoothProtoEnums.ENABLE_DISABLE_REASON_RESTORE_USER_SETTING, mContext.getPackageName());
            }
            break;
        case MESSAGE_REGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_ADD_PROXY_DELAYED:
            {
                ProfileServiceConnections psc = mProfileServices.get(msg.arg1);
                if (psc == null) {
                    break;
                }
                IBluetoothProfileServiceConnection proxy = (IBluetoothProfileServiceConnection) msg.obj;
                psc.addProxy(proxy);
                break;
            }
        case MESSAGE_BIND_PROFILE_SERVICE:
            {
                ProfileServiceConnections psc = (ProfileServiceConnections) msg.obj;
                removeMessages(MESSAGE_BIND_PROFILE_SERVICE, msg.obj);
                if (psc == null) {
                    break;
                }
                psc.bindService();
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_CONNECTED:
            {
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_SERVICE_CONNECTED: " + msg.arg1);
                }
                IBinder service = (IBinder) msg.obj;
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = IBluetoothGatt.Stub.asInterface(Binder.allowBlocking(service));
                        onBluetoothGattServiceUp();
                        break;
                    }
                    // else must be SERVICE_IBLUETOOTH
                    // Remove timeout
                    mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    mBinding = false;
                    mBluetoothBinder = service;
                    mBluetooth = IBluetooth.Stub.asInterface(Binder.allowBlocking(service));
                    if (!isNameAndAddressSet()) {
                        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
                        mHandler.sendMessage(getMsg);
                        if (mGetNameAddressOnly) {
                            return;
                        }
                    }
                    // Register callback object
                    try {
                        mBluetooth.registerCallback(mBluetoothCallback);
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to register BluetoothCallback", re);
                    }
                    // Inform BluetoothAdapter instances that service is up
                    sendBluetoothServiceUpCallback();
                    // Do enable request
                    try {
                        if (!mQuietEnable) {
                            if (!mBluetooth.enable()) {
                                Slog.e(TAG, "IBluetooth.enable() returned false");
                            }
                        } else {
                            if (!mBluetooth.enableNoAutoConnect()) {
                                Slog.e(TAG, "IBluetooth.enableNoAutoConnect() returned false");
                            }
                        }
                    } catch (RemoteException e) {
                        Slog.e(TAG, "Unable to call enable()", e);
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                if (!mEnable) {
                    waitForOnOff(true, false);
                    handleDisable();
                    waitForOnOff(false, false);
                }
                break;
            }
        case MESSAGE_BLUETOOTH_STATE_CHANGE:
            {
                int prevState = msg.arg1;
                int newState = msg.arg2;
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_STATE_CHANGE: " + BluetoothAdapter.nameForState(prevState) + " > " + BluetoothAdapter.nameForState(newState));
                }
                mState = newState;
                bluetoothStateChangeHandler(prevState, newState);
                // unbind and rebind bluetooth service and enable bluetooth
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_ON) && (newState == BluetoothAdapter.STATE_OFF) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(false);
                }
                if ((prevState == BluetoothAdapter.STATE_TURNING_ON) && (newState == BluetoothAdapter.STATE_BLE_ON) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(true);
                }
                // here.  This is a bit of a hack (b/29363429).
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_OFF) && (newState == BluetoothAdapter.STATE_OFF)) {
                    if (mEnable) {
                        Slog.d(TAG, "Entering STATE_OFF but mEnabled is true; restarting.");
                        waitForOnOff(false, true);
                        Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
                    }
                }
                if (newState == BluetoothAdapter.STATE_ON || newState == BluetoothAdapter.STATE_BLE_ON) {
                    // bluetooth is working, reset the counter
                    if (mErrorRecoveryRetryCounter != 0) {
                        Slog.w(TAG, "bluetooth is recovered from error");
                        mErrorRecoveryRetryCounter = 0;
                    }
                }
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED:
            {
                Slog.e(TAG, "MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED(" + msg.arg1 + ")");
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTH) {
                        // if service is unbinded already, do nothing and return
                        if (mBluetooth == null) {
                            break;
                        }
                        mBluetooth = null;
                    } else if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = null;
                        break;
                    } else {
                        Slog.e(TAG, "Unknown argument for service disconnect!");
                        break;
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                // log the unexpected crash
                addCrashLog();
                addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_CRASH, mContext.getPackageName(), false);
                if (mEnable) {
                    mEnable = false;
                    // Send a Bluetooth Restart message
                    Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                    mHandler.sendMessageDelayed(restartMsg, SERVICE_RESTART_TIME_MS);
                }
                sendBluetoothServiceDownCallback();
                // the BT icon correctly
                if ((mState == BluetoothAdapter.STATE_TURNING_ON) || (mState == BluetoothAdapter.STATE_ON)) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    mState = BluetoothAdapter.STATE_TURNING_OFF;
                }
                if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                }
                mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                mState = BluetoothAdapter.STATE_OFF;
                break;
            }
        case MESSAGE_RESTART_BLUETOOTH_SERVICE:
            {
                Slog.d(TAG, "MESSAGE_RESTART_BLUETOOTH_SERVICE");
                /* Enable without persisting the setting as
                     it doesnt change when IBluetooth
                     service restarts */
                mEnable = true;
                addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_RESTARTED, mContext.getPackageName(), true);
                handleEnable(mQuietEnable);
                break;
            }
        case MESSAGE_TIMEOUT_BIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_BIND");
                mBluetoothLock.writeLock().lock();
                mBinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_TIMEOUT_UNBIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_UNBIND");
                mBluetoothLock.writeLock().lock();
                mUnbinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_USER_SWITCHED:
            {
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_USER_SWITCHED");
                }
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                /* disable and enable BT when detect a user switch */
                if (mBluetooth != null && isEnabled()) {
                    try {
                        mBluetoothLock.readLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth.unregisterCallback(mBluetoothCallback);
                        }
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to unregister", re);
                    } finally {
                        mBluetoothLock.readLock().unlock();
                    }
                    if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                        // MESSAGE_USER_SWITCHED happened right after MESSAGE_ENABLE
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_OFF);
                        mState = BluetoothAdapter.STATE_OFF;
                    }
                    if (mState == BluetoothAdapter.STATE_OFF) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_TURNING_ON);
                        mState = BluetoothAdapter.STATE_TURNING_ON;
                    }
                    waitForOnOff(true, false);
                    if (mState == BluetoothAdapter.STATE_TURNING_ON) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_ON);
                    }
                    unbindAllBluetoothProfileServices();
                    // disable
                    addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_USER_SWITCH, mContext.getPackageName(), false);
                    handleDisable();
                    // Pbap service need receive STATE_TURNING_OFF intent to close
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    boolean didDisableTimeout = !waitForOnOff(false, true);
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                    sendBluetoothServiceDownCallback();
                    try {
                        mBluetoothLock.writeLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth = null;
                            // Unbind
                            mContext.unbindService(mConnection);
                        }
                        mBluetoothGatt = null;
                    } finally {
                        mBluetoothLock.writeLock().unlock();
                    }
                    // 
                    if (didDisableTimeout) {
                        SystemClock.sleep(3000);
                    } else {
                        SystemClock.sleep(100);
                    }
                    mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                    mState = BluetoothAdapter.STATE_OFF;
                    // enable
                    addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_USER_SWITCH, mContext.getPackageName(), true);
                    // mEnable flag could have been reset on disableBLE. Reenable it.
                    mEnable = true;
                    handleEnable(mQuietEnable);
                } else if (mBinding || mBluetooth != null) {
                    Message userMsg = mHandler.obtainMessage(MESSAGE_USER_SWITCHED);
                    userMsg.arg2 = 1 + msg.arg2;
                    // if user is switched when service is binding retry after a delay
                    mHandler.sendMessageDelayed(userMsg, USER_SWITCHED_TIME_MS);
                    if (DBG) {
                        Slog.d(TAG, "Retry MESSAGE_USER_SWITCHED " + userMsg.arg2);
                    }
                }
                break;
            }
        case MESSAGE_USER_UNLOCKED:
            {
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_USER_UNLOCKED");
                }
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                if (mEnable && !mBinding && (mBluetooth == null)) {
                    // aware, so try binding again.
                    if (DBG) {
                        Slog.d(TAG, "Enabled but not bound; retrying after unlock");
                    }
                    handleEnable(mQuietEnable);
                }
            }
    }
}
#end_block

#method_before
private void recoverBluetoothServiceFromError(boolean clearBle) {
    Slog.e(TAG, "recoverBluetoothServiceFromError");
    try {
        mBluetoothLock.readLock().lock();
        if (mBluetooth != null) {
            // Unregister callback object
            mBluetooth.unregisterCallback(mBluetoothCallback);
        }
    } catch (RemoteException re) {
        Slog.e(TAG, "Unable to unregister", re);
    } finally {
        mBluetoothLock.readLock().unlock();
    }
    SystemClock.sleep(500);
    // disable
    addActiveLog(REASON_START_CRASH, ActivityThread.currentPackageName(), false);
    handleDisable();
    waitForOnOff(false, true);
    sendBluetoothServiceDownCallback();
    try {
        mBluetoothLock.writeLock().lock();
        if (mBluetooth != null) {
            mBluetooth = null;
            // Unbind
            mContext.unbindService(mConnection);
        }
        mBluetoothGatt = null;
    } finally {
        mBluetoothLock.writeLock().unlock();
    }
    mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
    mState = BluetoothAdapter.STATE_OFF;
    if (clearBle) {
        clearBleApps();
    }
    mEnable = false;
    if (mErrorRecoveryRetryCounter++ < MAX_ERROR_RESTART_RETRIES) {
        // Send a Bluetooth Restart message to reenable bluetooth
        Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
        mHandler.sendMessageDelayed(restartMsg, ERROR_RESTART_TIME_MS);
    } else {
    // todo: notify user to power down and power up phone to make bluetooth work.
    }
}
#method_after
private void recoverBluetoothServiceFromError(boolean clearBle) {
    Slog.e(TAG, "recoverBluetoothServiceFromError");
    try {
        mBluetoothLock.readLock().lock();
        if (mBluetooth != null) {
            // Unregister callback object
            mBluetooth.unregisterCallback(mBluetoothCallback);
        }
    } catch (RemoteException re) {
        Slog.e(TAG, "Unable to unregister", re);
    } finally {
        mBluetoothLock.readLock().unlock();
    }
    SystemClock.sleep(500);
    // disable
    addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_START_ERROR, mContext.getPackageName(), false);
    handleDisable();
    waitForOnOff(false, true);
    sendBluetoothServiceDownCallback();
    try {
        mBluetoothLock.writeLock().lock();
        if (mBluetooth != null) {
            mBluetooth = null;
            // Unbind
            mContext.unbindService(mConnection);
        }
        mBluetoothGatt = null;
    } finally {
        mBluetoothLock.writeLock().unlock();
    }
    mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
    mState = BluetoothAdapter.STATE_OFF;
    if (clearBle) {
        clearBleApps();
    }
    mEnable = false;
    if (mErrorRecoveryRetryCounter++ < MAX_ERROR_RESTART_RETRIES) {
        // Send a Bluetooth Restart message to reenable bluetooth
        Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
        mHandler.sendMessageDelayed(restartMsg, ERROR_RESTART_TIME_MS);
    } else {
    // todo: notify user to power down and power up phone to make bluetooth work.
    }
}
#end_block

#method_before
private void onSimRefresh(AsyncResult ar, Integer index) {
    if (ar.exception != null) {
        Rlog.e(LOG_TAG, "Sim REFRESH with exception: " + ar.exception);
        return;
    }
    if (!isValidPhoneIndex(index)) {
        Rlog.e(LOG_TAG, "onSimRefresh: invalid index : " + index);
        return;
    }
    IccRefreshResponse resp = (IccRefreshResponse) ar.result;
    log("onSimRefresh: " + resp);
    if (resp == null) {
        Rlog.e(LOG_TAG, "onSimRefresh: received without input");
        return;
    }
    UiccCard uiccCard = getUiccCardForPhone(index);
    if (uiccCard == null) {
        Rlog.e(LOG_TAG, "onSimRefresh: refresh on null card : " + index);
        return;
    }
    log("Handling refresh: " + resp);
    boolean changed = false;
    switch(resp.refreshResult) {
        case IccRefreshResponse.REFRESH_RESULT_RESET:
        case IccRefreshResponse.REFRESH_RESULT_INIT:
            // Reset the required apps when we know about the refresh so that
            // anyone interested does not get stale state.
            changed = uiccCard.resetAppWithAid(resp.aid);
            break;
        default:
            return;
    }
    if (changed && resp.refreshResult == IccRefreshResponse.REFRESH_RESULT_RESET) {
        // if there is any change on RESET, reset carrier config as well. From carrier config
        // perspective, this can be treated as sim state unknown
        CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
        configManager.updateConfigForPhoneId(index, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN);
        boolean requirePowerOffOnSimRefreshReset = mContext.getResources().getBoolean(com.android.internal.R.bool.config_requireRadioPowerOffOnSimRefreshReset);
        if (requirePowerOffOnSimRefreshReset) {
            mCis[index].setRadioPower(false, null);
        }
    }
    // The card status could have changed. Get the latest state.
    mCis[index].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, index));
}
#method_after
private void onSimRefresh(AsyncResult ar, Integer index) {
    if (ar.exception != null) {
        Rlog.e(LOG_TAG, "Sim REFRESH with exception: " + ar.exception);
        return;
    }
    if (!isValidPhoneIndex(index)) {
        Rlog.e(LOG_TAG, "onSimRefresh: invalid index : " + index);
        return;
    }
    IccRefreshResponse resp = (IccRefreshResponse) ar.result;
    log("onSimRefresh: " + resp);
    if (resp == null) {
        Rlog.e(LOG_TAG, "onSimRefresh: received without input");
        return;
    }
    UiccCard uiccCard = getUiccCardForPhone(index);
    if (uiccCard == null) {
        Rlog.e(LOG_TAG, "onSimRefresh: refresh on null card : " + index);
        return;
    }
    log("Handling refresh: " + resp);
    boolean changed = false;
    switch(resp.refreshResult) {
        case IccRefreshResponse.REFRESH_RESULT_RESET:
        case IccRefreshResponse.REFRESH_RESULT_INIT:
            // Reset the required apps when we know about the refresh so that
            // anyone interested does not get stale state.
            changed = uiccCard.resetAppWithAid(resp.aid);
            break;
        default:
            return;
    }
    if (changed && resp.refreshResult == IccRefreshResponse.REFRESH_RESULT_RESET) {
        // If there is any change on RESET, reset carrier config as well. From carrier config
        // perspective, this is treated the same as sim state unknown
        CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
        configManager.updateConfigForPhoneId(index, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN);
        boolean requirePowerOffOnSimRefreshReset = mContext.getResources().getBoolean(com.android.internal.R.bool.config_requireRadioPowerOffOnSimRefreshReset);
        if (requirePowerOffOnSimRefreshReset) {
            mCis[index].setRadioPower(false, null);
        }
    }
    // The card status could have changed. Get the latest state.
    mCis[index].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, index));
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    MainThreadRequest request;
    Message onCompleted;
    AsyncResult ar;
    UiccCard uiccCard;
    IccAPDUArgument iccArgument;
    switch(msg.what) {
        case CMD_HANDLE_USSD_REQUEST:
            {
                request = (MainThreadRequest) msg.obj;
                final Phone phone = getPhoneFromRequest(request);
                Pair<String, ResultReceiver> ussdObject = (Pair) request.argument;
                String ussdRequest = ussdObject.first;
                ResultReceiver wrappedCallback = ussdObject.second;
                if (!isUssdApiAllowed(request.subId)) {
                    // Carrier does not support use of this API, return failure.
                    Rlog.w(LOG_TAG, "handleUssdRequest: carrier does not support USSD apis.");
                    UssdResponse response = new UssdResponse(ussdRequest, null);
                    Bundle returnData = new Bundle();
                    returnData.putParcelable(TelephonyManager.USSD_RESPONSE, response);
                    wrappedCallback.send(TelephonyManager.USSD_RETURN_FAILURE, returnData);
                    request.result = true;
                    synchronized (request) {
                        request.notifyAll();
                    }
                    return;
                }
                try {
                    request.result = phone != null ? phone.handleUssdRequest(ussdRequest, wrappedCallback) : false;
                } catch (CallStateException cse) {
                    request.result = false;
                }
                // Wake up the requesting thread
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
        case CMD_HANDLE_PIN_MMI:
            {
                request = (MainThreadRequest) msg.obj;
                final Phone phone = getPhoneFromRequest(request);
                request.result = phone != null ? getPhoneFromRequest(request).handlePinMmi((String) request.argument) : false;
                // Wake up the requesting thread
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
        case CMD_HANDLE_NEIGHBORING_CELL:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NEIGHBORING_CELL_DONE, request);
            mPhone.getNeighboringCids(onCompleted, (WorkSource) request.argument);
            break;
        case EVENT_NEIGHBORING_CELL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                // create an empty list to notify the waiting thread
                request.result = new ArrayList<NeighboringCellInfo>(0);
            }
            // Wake up the requesting thread
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_ANSWER_RINGING_CALL:
            request = (MainThreadRequest) msg.obj;
            int answer_subId = request.subId;
            answerRingingCallInternal(answer_subId);
            break;
        case CMD_END_CALL:
            request = (MainThreadRequest) msg.obj;
            int end_subId = request.subId;
            final boolean hungUp;
            Phone phone = getPhone(end_subId);
            if (phone == null) {
                if (DBG)
                    log("CMD_END_CALL: no phone for id: " + end_subId);
                break;
            }
            int phoneType = phone.getPhoneType();
            if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                // CDMA: If the user presses the Power button we treat it as
                // ending the complete call session
                hungUp = PhoneUtils.hangupRingingAndActive(getPhone(end_subId));
            } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                // GSM: End the call as per the Phone state
                hungUp = PhoneUtils.hangup(mCM);
            } else {
                throw new IllegalStateException("Unexpected phone type: " + phoneType);
            }
            if (DBG)
                log("CMD_END_CALL: " + (hungUp ? "hung up!" : "no call to hang up"));
            request.result = hungUp;
            // Wake up the requesting thread
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_TRANSMIT_APDU_LOGICAL_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccTransmitApduLogicalChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE, request);
                uiccCard.iccTransmitApduLogicalChannel(iccArgument.channel, iccArgument.cla, iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("iccTransmitApduLogicalChannel: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("iccTransmitApduLogicalChannel: CommandException: " + ar.exception);
                } else {
                    loge("iccTransmitApduLogicalChannel: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_TRANSMIT_APDU_BASIC_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccTransmitApduBasicChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE, request);
                uiccCard.iccTransmitApduBasicChannel(iccArgument.cla, iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("iccTransmitApduBasicChannel: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("iccTransmitApduBasicChannel: CommandException: " + ar.exception);
                } else {
                    loge("iccTransmitApduBasicChannel: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_EXCHANGE_SIM_IO:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccExchangeSimIO: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_EXCHANGE_SIM_IO_DONE, request);
                uiccCard.iccExchangeSimIO(iccArgument.cla, /* fileID */
                iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_EXCHANGE_SIM_IO_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6f, 0, (byte[]) null);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SEND_ENVELOPE:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("sendEnvelopeWithStatus: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_SEND_ENVELOPE_DONE, request);
                uiccCard.sendEnvelopeWithStatus((String) request.argument, onCompleted);
            }
            break;
        case EVENT_SEND_ENVELOPE_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("sendEnvelopeWithStatus: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("sendEnvelopeWithStatus: CommandException: " + ar.exception);
                } else {
                    loge("sendEnvelopeWithStatus: exception:" + ar.exception);
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_OPEN_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            Pair<String, Integer> openChannelArgs = (Pair<String, Integer>) request.argument;
            if (uiccCard == null) {
                loge("iccOpenLogicalChannel: No UICC");
                request.result = new IccOpenLogicalChannelResponse(-1, IccOpenLogicalChannelResponse.STATUS_MISSING_RESOURCE, null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_OPEN_CHANNEL_DONE, request);
                uiccCard.iccOpenLogicalChannel(openChannelArgs.first, openChannelArgs.second, onCompleted);
            }
            break;
        case EVENT_OPEN_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            IccOpenLogicalChannelResponse openChannelResp;
            if (ar.exception == null && ar.result != null) {
                int[] result = (int[]) ar.result;
                int channelId = result[0];
                byte[] selectResponse = null;
                if (result.length > 1) {
                    selectResponse = new byte[result.length - 1];
                    for (int i = 1; i < result.length; ++i) {
                        selectResponse[i - 1] = (byte) result[i];
                    }
                }
                openChannelResp = new IccOpenLogicalChannelResponse(channelId, IccOpenLogicalChannelResponse.STATUS_NO_ERROR, selectResponse);
            } else {
                if (ar.result == null) {
                    loge("iccOpenLogicalChannel: Empty response");
                }
                if (ar.exception != null) {
                    loge("iccOpenLogicalChannel: Exception: " + ar.exception);
                }
                int errorCode = IccOpenLogicalChannelResponse.STATUS_UNKNOWN_ERROR;
                if (ar.exception instanceof CommandException) {
                    CommandException.Error error = ((CommandException) (ar.exception)).getCommandError();
                    if (error == CommandException.Error.MISSING_RESOURCE) {
                        errorCode = IccOpenLogicalChannelResponse.STATUS_MISSING_RESOURCE;
                    } else if (error == CommandException.Error.NO_SUCH_ELEMENT) {
                        errorCode = IccOpenLogicalChannelResponse.STATUS_NO_SUCH_ELEMENT;
                    }
                }
                openChannelResp = new IccOpenLogicalChannelResponse(IccOpenLogicalChannelResponse.INVALID_CHANNEL, errorCode, null);
            }
            request.result = openChannelResp;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_CLOSE_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccCloseLogicalChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_CLOSE_CHANNEL_DONE, request);
                uiccCard.iccCloseLogicalChannel((Integer) request.argument, onCompleted);
            }
            break;
        case EVENT_CLOSE_CHANNEL_DONE:
            handleNullReturnEvent(msg, "iccCloseLogicalChannel");
            break;
        case CMD_NV_READ_ITEM:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_READ_ITEM_DONE, request);
            mPhone.nvReadItem((Integer) request.argument, onCompleted);
            break;
        case EVENT_NV_READ_ITEM_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                // String
                request.result = ar.result;
            } else {
                request.result = "";
                if (ar.result == null) {
                    loge("nvReadItem: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("nvReadItem: CommandException: " + ar.exception);
                } else {
                    loge("nvReadItem: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_NV_WRITE_ITEM:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_WRITE_ITEM_DONE, request);
            Pair<Integer, String> idValue = (Pair<Integer, String>) request.argument;
            mPhone.nvWriteItem(idValue.first, idValue.second, onCompleted);
            break;
        case EVENT_NV_WRITE_ITEM_DONE:
            handleNullReturnEvent(msg, "nvWriteItem");
            break;
        case CMD_NV_WRITE_CDMA_PRL:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_WRITE_CDMA_PRL_DONE, request);
            mPhone.nvWriteCdmaPrl((byte[]) request.argument, onCompleted);
            break;
        case EVENT_NV_WRITE_CDMA_PRL_DONE:
            handleNullReturnEvent(msg, "nvWriteCdmaPrl");
            break;
        case CMD_NV_RESET_CONFIG:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_RESET_CONFIG_DONE, request);
            mPhone.nvResetConfig((Integer) request.argument, onCompleted);
            break;
        case EVENT_NV_RESET_CONFIG_DONE:
            handleNullReturnEvent(msg, "nvResetConfig");
            break;
        case CMD_GET_PREFERRED_NETWORK_TYPE:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_PREFERRED_NETWORK_TYPE_DONE, request);
            getPhoneFromRequest(request).getPreferredNetworkType(onCompleted);
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                // Integer
                request.result = ar.result;
            } else {
                request.result = null;
                if (ar.result == null) {
                    loge("getPreferredNetworkType: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("getPreferredNetworkType: CommandException: " + ar.exception);
                } else {
                    loge("getPreferredNetworkType: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_PREFERRED_NETWORK_TYPE:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE_DONE, request);
            int networkType = (Integer) request.argument;
            getPhoneFromRequest(request).setPreferredNetworkType(networkType, onCompleted);
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE_DONE:
            handleNullReturnEvent(msg, "setPreferredNetworkType");
            break;
        case CMD_SET_VOICEMAIL_NUMBER:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_VOICEMAIL_NUMBER_DONE, request);
            Pair<String, String> tagNum = (Pair<String, String>) request.argument;
            getPhoneFromRequest(request).setVoiceMailNumber(tagNum.first, tagNum.second, onCompleted);
            break;
        case EVENT_SET_VOICEMAIL_NUMBER_DONE:
            handleNullReturnEvent(msg, "setVoicemailNumber");
            break;
        case CMD_SET_NETWORK_SELECTION_MODE_AUTOMATIC:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_NETWORK_SELECTION_MODE_AUTOMATIC_DONE, request);
            getPhoneFromRequest(request).setNetworkSelectionModeAutomatic(onCompleted);
            break;
        case EVENT_SET_NETWORK_SELECTION_MODE_AUTOMATIC_DONE:
            handleNullReturnEvent(msg, "setNetworkSelectionModeAutomatic");
            break;
        case CMD_PERFORM_NETWORK_SCAN:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_PERFORM_NETWORK_SCAN_DONE, request);
            getPhoneFromRequest(request).getAvailableNetworks(onCompleted);
            break;
        case EVENT_PERFORM_NETWORK_SCAN_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            CellNetworkScanResult cellScanResult;
            if (ar.exception == null && ar.result != null) {
                cellScanResult = new CellNetworkScanResult(CellNetworkScanResult.STATUS_SUCCESS, (List<OperatorInfo>) ar.result);
            } else {
                if (ar.result == null) {
                    loge("getCellNetworkScanResults: Empty response");
                }
                if (ar.exception != null) {
                    loge("getCellNetworkScanResults: Exception: " + ar.exception);
                }
                int errorCode = CellNetworkScanResult.STATUS_UNKNOWN_ERROR;
                if (ar.exception instanceof CommandException) {
                    CommandException.Error error = ((CommandException) (ar.exception)).getCommandError();
                    if (error == CommandException.Error.RADIO_NOT_AVAILABLE) {
                        errorCode = CellNetworkScanResult.STATUS_RADIO_NOT_AVAILABLE;
                    } else if (error == CommandException.Error.GENERIC_FAILURE) {
                        errorCode = CellNetworkScanResult.STATUS_RADIO_GENERIC_FAILURE;
                    }
                }
                cellScanResult = new CellNetworkScanResult(errorCode, null);
            }
            request.result = cellScanResult;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_NETWORK_SELECTION_MODE_MANUAL:
            request = (MainThreadRequest) msg.obj;
            ManualNetworkSelectionArgument selArg = (ManualNetworkSelectionArgument) request.argument;
            onCompleted = obtainMessage(EVENT_SET_NETWORK_SELECTION_MODE_MANUAL_DONE, request);
            getPhoneFromRequest(request).selectNetworkManually(selArg.operatorInfo, selArg.persistSelection, onCompleted);
            break;
        case EVENT_SET_NETWORK_SELECTION_MODE_MANUAL_DONE:
            handleNullReturnEvent(msg, "setNetworkSelectionModeManual");
            break;
        case CMD_GET_MODEM_ACTIVITY_INFO:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_MODEM_ACTIVITY_INFO_DONE, request);
            mPhone.getModemActivityInfo(onCompleted);
            break;
        case EVENT_GET_MODEM_ACTIVITY_INFO_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("queryModemActivityInfo: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("queryModemActivityInfo: CommandException: " + ar.exception);
                } else {
                    loge("queryModemActivityInfo: Unknown exception");
                }
            }
            // Result cannot be null. Return ModemActivityInfo with all fields set to 0.
            if (request.result == null) {
                request.result = new ModemActivityInfo(0, 0, 0, null, 0, 0);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_ALLOWED_CARRIERS:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_ALLOWED_CARRIERS_DONE, request);
            mPhone.setAllowedCarriers((List<CarrierIdentifier>) request.argument, onCompleted);
            break;
        case EVENT_SET_ALLOWED_CARRIERS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("setAllowedCarriers: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("setAllowedCarriers: CommandException: " + ar.exception);
                } else {
                    loge("setAllowedCarriers: Unknown exception");
                }
            }
            // Result cannot be null. Return -1 on error.
            if (request.result == null) {
                request.result = new int[] { -1 };
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_GET_ALLOWED_CARRIERS:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_ALLOWED_CARRIERS_DONE, request);
            mPhone.getAllowedCarriers(onCompleted);
            break;
        case EVENT_GET_ALLOWED_CARRIERS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("getAllowedCarriers: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("getAllowedCarriers: CommandException: " + ar.exception);
                } else {
                    loge("getAllowedCarriers: Unknown exception");
                }
            }
            // Result cannot be null. Return empty list of CarrierIdentifier.
            if (request.result == null) {
                request.result = new ArrayList<CarrierIdentifier>(0);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case EVENT_GET_FORBIDDEN_PLMNS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IllegalArgumentException("Failed to retrieve Forbidden Plmns");
                if (ar.result == null) {
                    loge("getForbiddenPlmns: Empty response");
                } else {
                    loge("getForbiddenPlmns: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_GET_FORBIDDEN_PLMNS:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("getForbiddenPlmns() UiccCard is null");
                request.result = new IllegalArgumentException("getForbiddenPlmns() UiccCard is null");
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
            Integer appType = (Integer) request.argument;
            UiccCardApplication uiccApp = uiccCard.getApplicationByType(appType);
            if (uiccApp == null) {
                loge("getForbiddenPlmns() no app with specified type -- " + appType);
                request.result = new IllegalArgumentException("Failed to get UICC App");
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            } else {
                if (DBG)
                    logv("getForbiddenPlmns() found app " + uiccApp.getAid() + " specified type -- " + appType);
            }
            onCompleted = obtainMessage(EVENT_GET_FORBIDDEN_PLMNS_DONE, request);
            ((SIMRecords) uiccApp.getIccRecords()).getForbiddenPlmns(onCompleted);
            break;
        default:
            Log.w(LOG_TAG, "MainThreadHandler: unexpected message code: " + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    MainThreadRequest request;
    Message onCompleted;
    AsyncResult ar;
    UiccCard uiccCard;
    IccAPDUArgument iccArgument;
    switch(msg.what) {
        case CMD_HANDLE_USSD_REQUEST:
            {
                request = (MainThreadRequest) msg.obj;
                final Phone phone = getPhoneFromRequest(request);
                Pair<String, ResultReceiver> ussdObject = (Pair) request.argument;
                String ussdRequest = ussdObject.first;
                ResultReceiver wrappedCallback = ussdObject.second;
                if (!isUssdApiAllowed(request.subId)) {
                    // Carrier does not support use of this API, return failure.
                    Rlog.w(LOG_TAG, "handleUssdRequest: carrier does not support USSD apis.");
                    UssdResponse response = new UssdResponse(ussdRequest, null);
                    Bundle returnData = new Bundle();
                    returnData.putParcelable(TelephonyManager.USSD_RESPONSE, response);
                    wrappedCallback.send(TelephonyManager.USSD_RETURN_FAILURE, returnData);
                    request.result = true;
                    synchronized (request) {
                        request.notifyAll();
                    }
                    return;
                }
                try {
                    request.result = phone != null ? phone.handleUssdRequest(ussdRequest, wrappedCallback) : false;
                } catch (CallStateException cse) {
                    request.result = false;
                }
                // Wake up the requesting thread
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
        case CMD_HANDLE_PIN_MMI:
            {
                request = (MainThreadRequest) msg.obj;
                final Phone phone = getPhoneFromRequest(request);
                request.result = phone != null ? getPhoneFromRequest(request).handlePinMmi((String) request.argument) : false;
                // Wake up the requesting thread
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
        case CMD_HANDLE_NEIGHBORING_CELL:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NEIGHBORING_CELL_DONE, request);
            mPhone.getNeighboringCids(onCompleted, (WorkSource) request.argument);
            break;
        case EVENT_NEIGHBORING_CELL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                // create an empty list to notify the waiting thread
                request.result = new ArrayList<NeighboringCellInfo>(0);
            }
            // Wake up the requesting thread
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_ANSWER_RINGING_CALL:
            request = (MainThreadRequest) msg.obj;
            int answer_subId = request.subId;
            answerRingingCallInternal(answer_subId);
            break;
        case CMD_END_CALL:
            request = (MainThreadRequest) msg.obj;
            int end_subId = request.subId;
            final boolean hungUp;
            Phone phone = getPhone(end_subId);
            if (phone == null) {
                if (DBG)
                    log("CMD_END_CALL: no phone for id: " + end_subId);
                break;
            }
            int phoneType = phone.getPhoneType();
            if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                // CDMA: If the user presses the Power button we treat it as
                // ending the complete call session
                hungUp = PhoneUtils.hangupRingingAndActive(getPhone(end_subId));
            } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                // GSM: End the call as per the Phone state
                hungUp = PhoneUtils.hangup(mCM);
            } else {
                throw new IllegalStateException("Unexpected phone type: " + phoneType);
            }
            if (DBG)
                log("CMD_END_CALL: " + (hungUp ? "hung up!" : "no call to hang up"));
            request.result = hungUp;
            // Wake up the requesting thread
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_TRANSMIT_APDU_LOGICAL_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccTransmitApduLogicalChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE, request);
                uiccCard.iccTransmitApduLogicalChannel(iccArgument.channel, iccArgument.cla, iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("iccTransmitApduLogicalChannel: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("iccTransmitApduLogicalChannel: CommandException: " + ar.exception);
                } else {
                    loge("iccTransmitApduLogicalChannel: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_TRANSMIT_APDU_BASIC_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccTransmitApduBasicChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE, request);
                uiccCard.iccTransmitApduBasicChannel(iccArgument.cla, iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("iccTransmitApduBasicChannel: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("iccTransmitApduBasicChannel: CommandException: " + ar.exception);
                } else {
                    loge("iccTransmitApduBasicChannel: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_EXCHANGE_SIM_IO:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccExchangeSimIO: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_EXCHANGE_SIM_IO_DONE, request);
                uiccCard.iccExchangeSimIO(iccArgument.cla, /* fileID */
                iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_EXCHANGE_SIM_IO_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6f, 0, (byte[]) null);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SEND_ENVELOPE:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("sendEnvelopeWithStatus: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_SEND_ENVELOPE_DONE, request);
                uiccCard.sendEnvelopeWithStatus((String) request.argument, onCompleted);
            }
            break;
        case EVENT_SEND_ENVELOPE_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("sendEnvelopeWithStatus: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("sendEnvelopeWithStatus: CommandException: " + ar.exception);
                } else {
                    loge("sendEnvelopeWithStatus: exception:" + ar.exception);
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_OPEN_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            Pair<String, Integer> openChannelArgs = (Pair<String, Integer>) request.argument;
            if (uiccCard == null) {
                loge("iccOpenLogicalChannel: No UICC");
                request.result = new IccOpenLogicalChannelResponse(-1, IccOpenLogicalChannelResponse.STATUS_MISSING_RESOURCE, null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_OPEN_CHANNEL_DONE, request);
                uiccCard.iccOpenLogicalChannel(openChannelArgs.first, openChannelArgs.second, onCompleted);
            }
            break;
        case EVENT_OPEN_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            IccOpenLogicalChannelResponse openChannelResp;
            if (ar.exception == null && ar.result != null) {
                int[] result = (int[]) ar.result;
                int channelId = result[0];
                byte[] selectResponse = null;
                if (result.length > 1) {
                    selectResponse = new byte[result.length - 1];
                    for (int i = 1; i < result.length; ++i) {
                        selectResponse[i - 1] = (byte) result[i];
                    }
                }
                openChannelResp = new IccOpenLogicalChannelResponse(channelId, IccOpenLogicalChannelResponse.STATUS_NO_ERROR, selectResponse);
            } else {
                if (ar.result == null) {
                    loge("iccOpenLogicalChannel: Empty response");
                }
                if (ar.exception != null) {
                    loge("iccOpenLogicalChannel: Exception: " + ar.exception);
                }
                int errorCode = IccOpenLogicalChannelResponse.STATUS_UNKNOWN_ERROR;
                if (ar.exception instanceof CommandException) {
                    CommandException.Error error = ((CommandException) (ar.exception)).getCommandError();
                    if (error == CommandException.Error.MISSING_RESOURCE) {
                        errorCode = IccOpenLogicalChannelResponse.STATUS_MISSING_RESOURCE;
                    } else if (error == CommandException.Error.NO_SUCH_ELEMENT) {
                        errorCode = IccOpenLogicalChannelResponse.STATUS_NO_SUCH_ELEMENT;
                    }
                }
                openChannelResp = new IccOpenLogicalChannelResponse(IccOpenLogicalChannelResponse.INVALID_CHANNEL, errorCode, null);
            }
            request.result = openChannelResp;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_CLOSE_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccCloseLogicalChannel: No UICC");
                request.result = false;
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_CLOSE_CHANNEL_DONE, request);
                uiccCard.iccCloseLogicalChannel((Integer) request.argument, onCompleted);
            }
            break;
        case EVENT_CLOSE_CHANNEL_DONE:
            handleNullReturnEvent(msg, "iccCloseLogicalChannel");
            break;
        case CMD_NV_READ_ITEM:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_READ_ITEM_DONE, request);
            mPhone.nvReadItem((Integer) request.argument, onCompleted);
            break;
        case EVENT_NV_READ_ITEM_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                // String
                request.result = ar.result;
            } else {
                request.result = "";
                if (ar.result == null) {
                    loge("nvReadItem: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("nvReadItem: CommandException: " + ar.exception);
                } else {
                    loge("nvReadItem: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_NV_WRITE_ITEM:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_WRITE_ITEM_DONE, request);
            Pair<Integer, String> idValue = (Pair<Integer, String>) request.argument;
            mPhone.nvWriteItem(idValue.first, idValue.second, onCompleted);
            break;
        case EVENT_NV_WRITE_ITEM_DONE:
            handleNullReturnEvent(msg, "nvWriteItem");
            break;
        case CMD_NV_WRITE_CDMA_PRL:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_WRITE_CDMA_PRL_DONE, request);
            mPhone.nvWriteCdmaPrl((byte[]) request.argument, onCompleted);
            break;
        case EVENT_NV_WRITE_CDMA_PRL_DONE:
            handleNullReturnEvent(msg, "nvWriteCdmaPrl");
            break;
        case CMD_NV_RESET_CONFIG:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_RESET_CONFIG_DONE, request);
            mPhone.nvResetConfig((Integer) request.argument, onCompleted);
            break;
        case EVENT_NV_RESET_CONFIG_DONE:
            handleNullReturnEvent(msg, "nvResetConfig");
            break;
        case CMD_GET_PREFERRED_NETWORK_TYPE:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_PREFERRED_NETWORK_TYPE_DONE, request);
            getPhoneFromRequest(request).getPreferredNetworkType(onCompleted);
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                // Integer
                request.result = ar.result;
            } else {
                request.result = null;
                if (ar.result == null) {
                    loge("getPreferredNetworkType: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("getPreferredNetworkType: CommandException: " + ar.exception);
                } else {
                    loge("getPreferredNetworkType: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_PREFERRED_NETWORK_TYPE:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE_DONE, request);
            int networkType = (Integer) request.argument;
            getPhoneFromRequest(request).setPreferredNetworkType(networkType, onCompleted);
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE_DONE:
            handleNullReturnEvent(msg, "setPreferredNetworkType");
            break;
        case CMD_SET_VOICEMAIL_NUMBER:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_VOICEMAIL_NUMBER_DONE, request);
            Pair<String, String> tagNum = (Pair<String, String>) request.argument;
            getPhoneFromRequest(request).setVoiceMailNumber(tagNum.first, tagNum.second, onCompleted);
            break;
        case EVENT_SET_VOICEMAIL_NUMBER_DONE:
            handleNullReturnEvent(msg, "setVoicemailNumber");
            break;
        case CMD_SET_NETWORK_SELECTION_MODE_AUTOMATIC:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_NETWORK_SELECTION_MODE_AUTOMATIC_DONE, request);
            getPhoneFromRequest(request).setNetworkSelectionModeAutomatic(onCompleted);
            break;
        case EVENT_SET_NETWORK_SELECTION_MODE_AUTOMATIC_DONE:
            handleNullReturnEvent(msg, "setNetworkSelectionModeAutomatic");
            break;
        case CMD_PERFORM_NETWORK_SCAN:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_PERFORM_NETWORK_SCAN_DONE, request);
            getPhoneFromRequest(request).getAvailableNetworks(onCompleted);
            break;
        case EVENT_PERFORM_NETWORK_SCAN_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            CellNetworkScanResult cellScanResult;
            if (ar.exception == null && ar.result != null) {
                cellScanResult = new CellNetworkScanResult(CellNetworkScanResult.STATUS_SUCCESS, (List<OperatorInfo>) ar.result);
            } else {
                if (ar.result == null) {
                    loge("getCellNetworkScanResults: Empty response");
                }
                if (ar.exception != null) {
                    loge("getCellNetworkScanResults: Exception: " + ar.exception);
                }
                int errorCode = CellNetworkScanResult.STATUS_UNKNOWN_ERROR;
                if (ar.exception instanceof CommandException) {
                    CommandException.Error error = ((CommandException) (ar.exception)).getCommandError();
                    if (error == CommandException.Error.RADIO_NOT_AVAILABLE) {
                        errorCode = CellNetworkScanResult.STATUS_RADIO_NOT_AVAILABLE;
                    } else if (error == CommandException.Error.GENERIC_FAILURE) {
                        errorCode = CellNetworkScanResult.STATUS_RADIO_GENERIC_FAILURE;
                    }
                }
                cellScanResult = new CellNetworkScanResult(errorCode, null);
            }
            request.result = cellScanResult;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_NETWORK_SELECTION_MODE_MANUAL:
            request = (MainThreadRequest) msg.obj;
            ManualNetworkSelectionArgument selArg = (ManualNetworkSelectionArgument) request.argument;
            onCompleted = obtainMessage(EVENT_SET_NETWORK_SELECTION_MODE_MANUAL_DONE, request);
            getPhoneFromRequest(request).selectNetworkManually(selArg.operatorInfo, selArg.persistSelection, onCompleted);
            break;
        case EVENT_SET_NETWORK_SELECTION_MODE_MANUAL_DONE:
            handleNullReturnEvent(msg, "setNetworkSelectionModeManual");
            break;
        case CMD_GET_MODEM_ACTIVITY_INFO:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_MODEM_ACTIVITY_INFO_DONE, request);
            mPhone.getModemActivityInfo(onCompleted);
            break;
        case EVENT_GET_MODEM_ACTIVITY_INFO_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("queryModemActivityInfo: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("queryModemActivityInfo: CommandException: " + ar.exception);
                } else {
                    loge("queryModemActivityInfo: Unknown exception");
                }
            }
            // Result cannot be null. Return ModemActivityInfo with all fields set to 0.
            if (request.result == null) {
                request.result = new ModemActivityInfo(0, 0, 0, null, 0, 0);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_ALLOWED_CARRIERS:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_ALLOWED_CARRIERS_DONE, request);
            mPhone.setAllowedCarriers((List<CarrierIdentifier>) request.argument, onCompleted);
            break;
        case EVENT_SET_ALLOWED_CARRIERS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("setAllowedCarriers: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("setAllowedCarriers: CommandException: " + ar.exception);
                } else {
                    loge("setAllowedCarriers: Unknown exception");
                }
            }
            // Result cannot be null. Return -1 on error.
            if (request.result == null) {
                request.result = new int[] { -1 };
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_GET_ALLOWED_CARRIERS:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_ALLOWED_CARRIERS_DONE, request);
            mPhone.getAllowedCarriers(onCompleted);
            break;
        case EVENT_GET_ALLOWED_CARRIERS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("getAllowedCarriers: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("getAllowedCarriers: CommandException: " + ar.exception);
                } else {
                    loge("getAllowedCarriers: Unknown exception");
                }
            }
            // Result cannot be null. Return empty list of CarrierIdentifier.
            if (request.result == null) {
                request.result = new ArrayList<CarrierIdentifier>(0);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case EVENT_GET_FORBIDDEN_PLMNS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IllegalArgumentException("Failed to retrieve Forbidden Plmns");
                if (ar.result == null) {
                    loge("getForbiddenPlmns: Empty response");
                } else {
                    loge("getForbiddenPlmns: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_GET_FORBIDDEN_PLMNS:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("getForbiddenPlmns() UiccCard is null");
                request.result = new IllegalArgumentException("getForbiddenPlmns() UiccCard is null");
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
            Integer appType = (Integer) request.argument;
            UiccCardApplication uiccApp = uiccCard.getApplicationByType(appType);
            if (uiccApp == null) {
                loge("getForbiddenPlmns() no app with specified type -- " + appType);
                request.result = new IllegalArgumentException("Failed to get UICC App");
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            } else {
                if (DBG)
                    logv("getForbiddenPlmns() found app " + uiccApp.getAid() + " specified type -- " + appType);
            }
            onCompleted = obtainMessage(EVENT_GET_FORBIDDEN_PLMNS_DONE, request);
            ((SIMRecords) uiccApp.getIccRecords()).getForbiddenPlmns(onCompleted);
            break;
        case CMD_SWITCH_SLOTS:
            request = (MainThreadRequest) msg.obj;
            int[] physicalSlots = (int[]) request.argument;
            onCompleted = obtainMessage(EVENT_SWITCH_SLOTS_DONE, request);
            UiccController.getInstance().switchSlots(physicalSlots, onCompleted);
            break;
        case EVENT_SWITCH_SLOTS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            request.result = (ar.exception == null);
            synchronized (request) {
                request.notifyAll();
            }
            break;
        default:
            Log.w(LOG_TAG, "MainThreadHandler: unexpected message code: " + msg.what);
            break;
    }
}
#end_block

#method_before
@Override
public boolean isOffhookForSubscriber(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "isOffhookForSubscriber")) {
        return false;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return (phone.getState() == PhoneConstants.State.OFFHOOK);
    } else {
        return false;
    }
}
#method_after
@Override
public boolean isOffhookForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "isOffhookForSubscriber")) {
        return false;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return (phone.getState() == PhoneConstants.State.OFFHOOK);
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public boolean isRingingForSubscriber(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "isRingingForSubscriber")) {
        return false;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return (phone.getState() == PhoneConstants.State.RINGING);
    } else {
        return false;
    }
}
#method_after
@Override
public boolean isRingingForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "isRingingForSubscriber")) {
        return false;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return (phone.getState() == PhoneConstants.State.RINGING);
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public boolean isIdleForSubscriber(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "isIdleForSubscriber")) {
        return false;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return (phone.getState() == PhoneConstants.State.IDLE);
    } else {
        return false;
    }
}
#method_after
@Override
public boolean isIdleForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "isIdleForSubscriber")) {
        return false;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return (phone.getState() == PhoneConstants.State.IDLE);
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public boolean isRadioOnForSubscriber(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "isRadioOnForSubscriber")) {
        return false;
    }
    return isRadioOnForSubscriber(subId);
}
#method_after
@Override
public boolean isRadioOnForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "isRadioOnForSubscriber")) {
        return false;
    }
    return isRadioOnForSubscriber(subId);
}
#end_block

#method_before
@Override
public boolean enableDataConnectivity() {
    enforceModifyPermission();
    int subId = mSubscriptionController.getDefaultDataSubId();
    final Phone phone = getPhone(subId);
    if (phone != null) {
        phone.setDataEnabled(true);
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean enableDataConnectivity() {
    enforceModifyPermission();
    int subId = mSubscriptionController.getDefaultDataSubId();
    final Phone phone = getPhone(subId);
    if (phone != null) {
        phone.setUserDataEnabled(true);
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public boolean disableDataConnectivity() {
    enforceModifyPermission();
    int subId = mSubscriptionController.getDefaultDataSubId();
    final Phone phone = getPhone(subId);
    if (phone != null) {
        phone.setDataEnabled(false);
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean disableDataConnectivity() {
    enforceModifyPermission();
    int subId = mSubscriptionController.getDefaultDataSubId();
    final Phone phone = getPhone(subId);
    if (phone != null) {
        phone.setUserDataEnabled(false);
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public Bundle getCellLocation(String callingPackage) {
    if (!LocationAccessPolicy.canAccessCellLocation(mPhone.getContext(), callingPackage, Binder.getCallingUid(), "getCellLocation")) {
        return null;
    }
    if (DBG_LOC)
        log("getCellLocation: is active user");
    Bundle data = new Bundle();
    Phone phone = getPhone(mSubscriptionController.getDefaultDataSubId());
    if (phone == null) {
        return null;
    }
    WorkSource workSource = getWorkSource(null, Binder.getCallingUid());
    phone.getCellLocation(workSource).fillInNotifierBundle(data);
    return data;
}
#method_after
@Override
public Bundle getCellLocation(String callingPackage) {
    mPhone.getContext().getSystemService(AppOpsManager.class).checkPackage(Binder.getCallingUid(), callingPackage);
    if (!LocationAccessPolicy.canAccessCellLocation(mPhone.getContext(), callingPackage, Binder.getCallingUid(), Binder.getCallingPid())) {
        return null;
    }
    if (DBG_LOC)
        log("getCellLocation: is active user");
    Bundle data = new Bundle();
    Phone phone = getPhone(mSubscriptionController.getDefaultDataSubId());
    if (phone == null) {
        return null;
    }
    WorkSource workSource = getWorkSource(null, Binder.getCallingUid());
    phone.getCellLocation(workSource).fillInNotifierBundle(data);
    return data;
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public List<NeighboringCellInfo> getNeighboringCellInfo(String callingPackage) {
    if (!LocationAccessPolicy.canAccessCellLocation(mPhone.getContext(), callingPackage, Binder.getCallingUid(), "getNeighboringCellInfo")) {
        return null;
    }
    if (mAppOps.noteOp(AppOpsManager.OP_NEIGHBORING_CELLS, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return null;
    }
    if (DBG_LOC)
        log("getNeighboringCellInfo: is active user");
    ArrayList<NeighboringCellInfo> cells = null;
    WorkSource workSource = getWorkSource(null, Binder.getCallingUid());
    try {
        cells = (ArrayList<NeighboringCellInfo>) sendRequest(CMD_HANDLE_NEIGHBORING_CELL, workSource, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
    } catch (RuntimeException e) {
        Log.e(LOG_TAG, "getNeighboringCellInfo " + e);
    }
    return cells;
}
#method_after
@Override
@SuppressWarnings("unchecked")
public List<NeighboringCellInfo> getNeighboringCellInfo(String callingPackage) {
    mPhone.getContext().getSystemService(AppOpsManager.class).checkPackage(Binder.getCallingUid(), callingPackage);
    if (!LocationAccessPolicy.canAccessCellLocation(mPhone.getContext(), callingPackage, Binder.getCallingUid(), Binder.getCallingPid())) {
        return null;
    }
    if (mAppOps.noteOp(AppOpsManager.OP_NEIGHBORING_CELLS, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return null;
    }
    if (DBG_LOC)
        log("getNeighboringCellInfo: is active user");
    ArrayList<NeighboringCellInfo> cells = null;
    WorkSource workSource = getWorkSource(null, Binder.getCallingUid());
    try {
        cells = (ArrayList<NeighboringCellInfo>) sendRequest(CMD_HANDLE_NEIGHBORING_CELL, workSource, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
    } catch (RuntimeException e) {
        Log.e(LOG_TAG, "getNeighboringCellInfo " + e);
    }
    return cells;
}
#end_block

#method_before
@Override
public List<CellInfo> getAllCellInfo(String callingPackage) {
    if (!LocationAccessPolicy.canAccessCellLocation(mPhone.getContext(), callingPackage, Binder.getCallingUid(), "getAllCellInfo")) {
        return null;
    }
    if (DBG_LOC)
        log("getAllCellInfo: is active user");
    WorkSource workSource = getWorkSource(null, Binder.getCallingUid());
    List<CellInfo> cellInfos = new ArrayList<CellInfo>();
    for (Phone phone : PhoneFactory.getPhones()) {
        final List<CellInfo> info = phone.getAllCellInfo(workSource);
        if (info != null)
            cellInfos.addAll(info);
    }
    return cellInfos;
}
#method_after
@Override
public List<CellInfo> getAllCellInfo(String callingPackage) {
    mPhone.getContext().getSystemService(AppOpsManager.class).checkPackage(Binder.getCallingUid(), callingPackage);
    if (!LocationAccessPolicy.canAccessCellLocation(mPhone.getContext(), callingPackage, Binder.getCallingUid(), Binder.getCallingPid())) {
        return null;
    }
    if (DBG_LOC)
        log("getAllCellInfo: is active user");
    WorkSource workSource = getWorkSource(null, Binder.getCallingUid());
    List<CellInfo> cellInfos = new ArrayList<CellInfo>();
    for (Phone phone : PhoneFactory.getPhones()) {
        final List<CellInfo> info = phone.getAllCellInfo(workSource);
        if (info != null)
            cellInfos.addAll(info);
    }
    return cellInfos;
}
#end_block

#method_before
@Override
public String getImeiForSlot(int slotIndex, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getImeiForSlot")) {
        return null;
    }
    Phone phone = PhoneFactory.getPhone(slotIndex);
    return phone == null ? null : phone.getImei();
}
#method_after
@Override
public String getImeiForSlot(int slotIndex, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getImeiForSlot")) {
        return null;
    }
    Phone phone = PhoneFactory.getPhone(slotIndex);
    return phone == null ? null : phone.getImei();
}
#end_block

#method_before
@Override
public String getMeidForSlot(int slotIndex, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getMeidForSlot")) {
        return null;
    }
    Phone phone = PhoneFactory.getPhone(slotIndex);
    return phone == null ? null : phone.getMeid();
}
#method_after
@Override
public String getMeidForSlot(int slotIndex, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getMeidForSlot")) {
        return null;
    }
    Phone phone = PhoneFactory.getPhone(slotIndex);
    return phone == null ? null : phone.getMeid();
}
#end_block

#method_before
@Override
public String getDeviceSoftwareVersionForSlot(int slotIndex, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getDeviceSoftwareVersionForSlot")) {
        return null;
    }
    Phone phone = PhoneFactory.getPhone(slotIndex);
    return phone == null ? null : phone.getDeviceSvn();
}
#method_after
@Override
public String getDeviceSoftwareVersionForSlot(int slotIndex, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getDeviceSoftwareVersionForSlot")) {
        return null;
    }
    Phone phone = PhoneFactory.getPhone(slotIndex);
    return phone == null ? null : phone.getDeviceSvn();
}
#end_block

#method_before
@Override
public int getCdmaEriIconIndexForSubscriber(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getCdmaEriIconIndexForSubscriber")) {
        return -1;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getCdmaEriIconIndex();
    } else {
        return -1;
    }
}
#method_after
@Override
public int getCdmaEriIconIndexForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getCdmaEriIconIndexForSubscriber")) {
        return -1;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getCdmaEriIconIndex();
    } else {
        return -1;
    }
}
#end_block

#method_before
@Override
public int getCdmaEriIconModeForSubscriber(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getCdmaEriIconModeForSubscriber")) {
        return -1;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getCdmaEriIconMode();
    } else {
        return -1;
    }
}
#method_after
@Override
public int getCdmaEriIconModeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getCdmaEriIconModeForSubscriber")) {
        return -1;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getCdmaEriIconMode();
    } else {
        return -1;
    }
}
#end_block

#method_before
@Override
public String getCdmaEriTextForSubscriber(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getCdmaEriIconTextForSubscriber")) {
        return null;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getCdmaEriText();
    } else {
        return null;
    }
}
#method_after
@Override
public String getCdmaEriTextForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getCdmaEriIconTextForSubscriber")) {
        return null;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getCdmaEriText();
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public String getCdmaMdn(int subId) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    final Phone phone = getPhone(subId);
    if (mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA && phone != null) {
        return phone.getLine1Number();
    } else {
        return null;
    }
}
#method_after
@Override
public String getCdmaMdn(int subId) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "getCdmaMdn");
    final Phone phone = getPhone(subId);
    if (mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA && phone != null) {
        return phone.getLine1Number();
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public String getCdmaMin(int subId) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    final Phone phone = getPhone(subId);
    if (phone != null && phone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
        return phone.getCdmaMin();
    } else {
        return null;
    }
}
#method_after
@Override
public String getCdmaMin(int subId) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "getCdmaMin");
    final Phone phone = getPhone(subId);
    if (phone != null && phone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
        return phone.getCdmaMin();
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public boolean setVoiceMailNumber(int subId, String alphaTag, String number) {
    enforceCarrierPrivilege(subId);
    Boolean success = (Boolean) sendRequest(CMD_SET_VOICEMAIL_NUMBER, new Pair<String, String>(alphaTag, number), new Integer(subId));
    return success;
}
#method_after
@Override
public boolean setVoiceMailNumber(int subId, String alphaTag, String number) {
    TelephonyPermissions.enforceCallingOrSelfCarrierPrivilege(subId, "setVoiceMailNumber");
    Boolean success = (Boolean) sendRequest(CMD_SET_VOICEMAIL_NUMBER, new Pair<String, String>(alphaTag, number), new Integer(subId));
    return success;
}
#end_block

#method_before
@Override
public String getVisualVoicemailPackageName(String callingPackage, int subId) {
    mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
    if (!canReadPhoneState(callingPackage, "getVisualVoicemailPackageName")) {
        return null;
    }
    return RemoteVvmTaskManager.getRemotePackage(mPhone.getContext(), subId).getPackageName();
}
#method_after
@Override
public String getVisualVoicemailPackageName(String callingPackage, int subId) {
    mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getVisualVoicemailPackageName")) {
        return null;
    }
    return RemoteVvmTaskManager.getRemotePackage(mPhone.getContext(), subId).getPackageName();
}
#end_block

#method_before
@Override
public void setVoiceActivationState(int subId, int activationState) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    final Phone phone = getPhone(subId);
    if (phone != null) {
        phone.setVoiceActivationState(activationState);
    } else {
        loge("setVoiceActivationState fails with invalid subId: " + subId);
    }
}
#method_after
@Override
public void setVoiceActivationState(int subId, int activationState) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "setVoiceActivationState");
    final Phone phone = getPhone(subId);
    if (phone != null) {
        phone.setVoiceActivationState(activationState);
    } else {
        loge("setVoiceActivationState fails with invalid subId: " + subId);
    }
}
#end_block

#method_before
@Override
public void setDataActivationState(int subId, int activationState) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    final Phone phone = getPhone(subId);
    if (phone != null) {
        phone.setDataActivationState(activationState);
    } else {
        loge("setVoiceActivationState fails with invalid subId: " + subId);
    }
}
#method_after
@Override
public void setDataActivationState(int subId, int activationState) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "setDataActivationState");
    final Phone phone = getPhone(subId);
    if (phone != null) {
        phone.setDataActivationState(activationState);
    } else {
        loge("setVoiceActivationState fails with invalid subId: " + subId);
    }
}
#end_block

#method_before
@Override
public int getVoiceActivationState(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getVoiceActivationStateForSubscriber")) {
        return TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getVoiceActivationState();
    } else {
        return TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
    }
}
#method_after
@Override
public int getVoiceActivationState(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getVoiceActivationStateForSubscriber")) {
        return TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getVoiceActivationState();
    } else {
        return TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
    }
}
#end_block

#method_before
@Override
public int getDataActivationState(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getDataActivationStateForSubscriber")) {
        return TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getDataActivationState();
    } else {
        return TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
    }
}
#method_after
@Override
public int getDataActivationState(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getDataActivationStateForSubscriber")) {
        return TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getDataActivationState();
    } else {
        return TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
    }
}
#end_block

#method_before
@Override
public void sendDialerSpecialCode(String callingPackage, String inputCode) {
    mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
    String defaultDialer = TelecomManager.from(mPhone.getContext()).getDefaultDialerPackage();
    if (!TextUtils.equals(callingPackage, defaultDialer)) {
        enforceCarrierPrivilege(getDefaultSubscription());
    }
    mPhone.sendDialerSpecialCode(inputCode);
}
#method_after
@Override
public void sendDialerSpecialCode(String callingPackage, String inputCode) {
    mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
    String defaultDialer = TelecomManager.from(mPhone.getContext()).getDefaultDialerPackage();
    if (!TextUtils.equals(callingPackage, defaultDialer)) {
        TelephonyPermissions.enforceCallingOrSelfCarrierPrivilege(getDefaultSubscription(), "sendDialerSpecialCode");
    }
    mPhone.sendDialerSpecialCode(inputCode);
}
#end_block

#method_before
@Override
public int getNetworkTypeForSubscriber(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getNetworkTypeForSubscriber")) {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getServiceState().getDataNetworkType();
    } else {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
}
#method_after
@Override
public int getNetworkTypeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getNetworkTypeForSubscriber")) {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getServiceState().getDataNetworkType();
    } else {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
}
#end_block

#method_before
@Override
public int getDataNetworkTypeForSubscriber(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getDataNetworkTypeForSubscriber")) {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getServiceState().getDataNetworkType();
    } else {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
}
#method_after
@Override
public int getDataNetworkTypeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getDataNetworkTypeForSubscriber")) {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getServiceState().getDataNetworkType();
    } else {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
}
#end_block

#method_before
@Override
public int getVoiceNetworkTypeForSubscriber(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getDataNetworkTypeForSubscriber")) {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getServiceState().getVoiceNetworkType();
    } else {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
}
#method_after
@Override
public int getVoiceNetworkTypeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getDataNetworkTypeForSubscriber")) {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getServiceState().getVoiceNetworkType();
    } else {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
}
#end_block

#method_before
@Override
public int getLteOnCdmaModeForSubscriber(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getLteOnCdmaModeForSubscriber")) {
        return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone == null) {
        return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
    } else {
        return phone.getLteOnCdmaMode();
    }
}
#method_after
@Override
public int getLteOnCdmaModeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getLteOnCdmaModeForSubscriber")) {
        return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone == null) {
        return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
    } else {
        return phone.getLteOnCdmaMode();
    }
}
#end_block

#method_before
@Override
public IccOpenLogicalChannelResponse iccOpenLogicalChannel(int subId, String callingPackage, String aid, int p2) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    if (TextUtils.equals(ISDR_AID, aid)) {
        // Only allows LPA to open logical channel to ISD-R.
        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
        ComponentInfo bestComponent = EuiccConnector.findBestComponent(mPhone.getContext().getPackageManager());
        if (bestComponent == null || !TextUtils.equals(callingPackage, bestComponent.packageName)) {
            loge("The calling package is not allowed to access ISD-R.");
            throw new SecurityException("The calling package is not allowed to access ISD-R.");
        }
    }
    if (DBG)
        log("iccOpenLogicalChannel: subId=" + subId + " aid=" + aid + " p2=" + p2);
    IccOpenLogicalChannelResponse response = (IccOpenLogicalChannelResponse) sendRequest(CMD_OPEN_CHANNEL, new Pair<String, Integer>(aid, p2), subId);
    if (DBG)
        log("iccOpenLogicalChannel: " + response);
    return response;
}
#method_after
@Override
public IccOpenLogicalChannelResponse iccOpenLogicalChannel(int subId, String callingPackage, String aid, int p2) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "iccOpenLogicalChannel");
    if (TextUtils.equals(ISDR_AID, aid)) {
        // Only allows LPA to open logical channel to ISD-R.
        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
        ComponentInfo bestComponent = EuiccConnector.findBestComponent(mPhone.getContext().getPackageManager());
        if (bestComponent == null || !TextUtils.equals(callingPackage, bestComponent.packageName)) {
            loge("The calling package is not allowed to access ISD-R.");
            throw new SecurityException("The calling package is not allowed to access ISD-R.");
        }
    }
    if (DBG)
        log("iccOpenLogicalChannel: subId=" + subId + " aid=" + aid + " p2=" + p2);
    IccOpenLogicalChannelResponse response = (IccOpenLogicalChannelResponse) sendRequest(CMD_OPEN_CHANNEL, new Pair<String, Integer>(aid, p2), subId);
    if (DBG)
        log("iccOpenLogicalChannel: " + response);
    return response;
}
#end_block

#method_before
@Override
public boolean iccCloseLogicalChannel(int subId, int channel) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    if (DBG)
        log("iccCloseLogicalChannel: subId=" + subId + " chnl=" + channel);
    if (channel < 0) {
        return false;
    }
    Boolean success = (Boolean) sendRequest(CMD_CLOSE_CHANNEL, channel, subId);
    if (DBG)
        log("iccCloseLogicalChannel: " + success);
    return success;
}
#method_after
@Override
public boolean iccCloseLogicalChannel(int subId, int channel) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "iccCloseLogicalChannel");
    if (DBG)
        log("iccCloseLogicalChannel: subId=" + subId + " chnl=" + channel);
    if (channel < 0) {
        return false;
    }
    Boolean success = (Boolean) sendRequest(CMD_CLOSE_CHANNEL, channel, subId);
    if (DBG)
        log("iccCloseLogicalChannel: " + success);
    return success;
}
#end_block

#method_before
@Override
public String iccTransmitApduLogicalChannel(int subId, int channel, int cla, int command, int p1, int p2, int p3, String data) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    if (DBG) {
        log("iccTransmitApduLogicalChannel: subId=" + subId + " chnl=" + channel + " cla=" + cla + " cmd=" + command + " p1=" + p1 + " p2=" + p2 + " p3=" + p3 + " data=" + data);
    }
    if (channel < 0) {
        return "";
    }
    IccIoResult response = (IccIoResult) sendRequest(CMD_TRANSMIT_APDU_LOGICAL_CHANNEL, new IccAPDUArgument(channel, cla, command, p1, p2, p3, data), subId);
    if (DBG)
        log("iccTransmitApduLogicalChannel: " + response);
    // Append the returned status code to the end of the response payload.
    String s = Integer.toHexString((response.sw1 << 8) + response.sw2 + 0x10000).substring(1);
    if (response.payload != null) {
        s = IccUtils.bytesToHexString(response.payload) + s;
    }
    return s;
}
#method_after
@Override
public String iccTransmitApduLogicalChannel(int subId, int channel, int cla, int command, int p1, int p2, int p3, String data) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "iccTransmitApduLogicalChannel");
    if (DBG) {
        log("iccTransmitApduLogicalChannel: subId=" + subId + " chnl=" + channel + " cla=" + cla + " cmd=" + command + " p1=" + p1 + " p2=" + p2 + " p3=" + p3 + " data=" + data);
    }
    if (channel < 0) {
        return "";
    }
    IccIoResult response = (IccIoResult) sendRequest(CMD_TRANSMIT_APDU_LOGICAL_CHANNEL, new IccAPDUArgument(channel, cla, command, p1, p2, p3, data), subId);
    if (DBG)
        log("iccTransmitApduLogicalChannel: " + response);
    // Append the returned status code to the end of the response payload.
    String s = Integer.toHexString((response.sw1 << 8) + response.sw2 + 0x10000).substring(1);
    if (response.payload != null) {
        s = IccUtils.bytesToHexString(response.payload) + s;
    }
    return s;
}
#end_block

#method_before
@Override
public String iccTransmitApduBasicChannel(int subId, int cla, int command, int p1, int p2, int p3, String data) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    if (DBG) {
        log("iccTransmitApduBasicChannel: subId=" + subId + " cla=" + cla + " cmd=" + command + " p1=" + p1 + " p2=" + p2 + " p3=" + p3 + " data=" + data);
    }
    IccIoResult response = (IccIoResult) sendRequest(CMD_TRANSMIT_APDU_BASIC_CHANNEL, new IccAPDUArgument(0, cla, command, p1, p2, p3, data), subId);
    if (DBG)
        log("iccTransmitApduBasicChannel: " + response);
    // Append the returned status code to the end of the response payload.
    String s = Integer.toHexString((response.sw1 << 8) + response.sw2 + 0x10000).substring(1);
    if (response.payload != null) {
        s = IccUtils.bytesToHexString(response.payload) + s;
    }
    return s;
}
#method_after
@Override
public String iccTransmitApduBasicChannel(int subId, String callingPackage, int cla, int command, int p1, int p2, int p3, String data) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "iccTransmitApduBasicChannel");
    if (command == SELECT_COMMAND && p1 == SELECT_P1 && p2 == SELECT_P2 && p3 == SELECT_P3 && TextUtils.equals(ISDR_AID, data)) {
        // Only allows LPA to select ISD-R.
        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
        ComponentInfo bestComponent = EuiccConnector.findBestComponent(mPhone.getContext().getPackageManager());
        if (bestComponent == null || !TextUtils.equals(callingPackage, bestComponent.packageName)) {
            loge("The calling package is not allowed to select ISD-R.");
            throw new SecurityException("The calling package is not allowed to select ISD-R.");
        }
    }
    if (DBG) {
        log("iccTransmitApduBasicChannel: subId=" + subId + " cla=" + cla + " cmd=" + command + " p1=" + p1 + " p2=" + p2 + " p3=" + p3 + " data=" + data);
    }
    IccIoResult response = (IccIoResult) sendRequest(CMD_TRANSMIT_APDU_BASIC_CHANNEL, new IccAPDUArgument(0, cla, command, p1, p2, p3, data), subId);
    if (DBG)
        log("iccTransmitApduBasicChannel: " + response);
    // Append the returned status code to the end of the response payload.
    String s = Integer.toHexString((response.sw1 << 8) + response.sw2 + 0x10000).substring(1);
    if (response.payload != null) {
        s = IccUtils.bytesToHexString(response.payload) + s;
    }
    return s;
}
#end_block

#method_before
@Override
public byte[] iccExchangeSimIO(int subId, int fileID, int command, int p1, int p2, int p3, String filePath) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    if (DBG) {
        log("Exchange SIM_IO " + subId + ":" + fileID + ":" + command + " " + p1 + " " + p2 + " " + p3 + ":" + filePath);
    }
    IccIoResult response = (IccIoResult) sendRequest(CMD_EXCHANGE_SIM_IO, new IccAPDUArgument(-1, fileID, command, p1, p2, p3, filePath), subId);
    if (DBG) {
        log("Exchange SIM_IO [R]" + response);
    }
    byte[] result = null;
    int length = 2;
    if (response.payload != null) {
        length = 2 + response.payload.length;
        result = new byte[length];
        System.arraycopy(response.payload, 0, result, 0, response.payload.length);
    } else {
        result = new byte[length];
    }
    result[length - 1] = (byte) response.sw2;
    result[length - 2] = (byte) response.sw1;
    return result;
}
#method_after
@Override
public byte[] iccExchangeSimIO(int subId, int fileID, int command, int p1, int p2, int p3, String filePath) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "iccExchangeSimIO");
    if (DBG) {
        log("Exchange SIM_IO " + subId + ":" + fileID + ":" + command + " " + p1 + " " + p2 + " " + p3 + ":" + filePath);
    }
    IccIoResult response = (IccIoResult) sendRequest(CMD_EXCHANGE_SIM_IO, new IccAPDUArgument(-1, fileID, command, p1, p2, p3, filePath), subId);
    if (DBG) {
        log("Exchange SIM_IO [R]" + response);
    }
    byte[] result = null;
    int length = 2;
    if (response.payload != null) {
        length = 2 + response.payload.length;
        result = new byte[length];
        System.arraycopy(response.payload, 0, result, 0, response.payload.length);
    } else {
        result = new byte[length];
    }
    result[length - 1] = (byte) response.sw2;
    result[length - 2] = (byte) response.sw1;
    return result;
}
#end_block

#method_before
@Override
public String sendEnvelopeWithStatus(int subId, String content) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    IccIoResult response = (IccIoResult) sendRequest(CMD_SEND_ENVELOPE, content, subId);
    if (response.payload == null) {
        return "";
    }
    // Append the returned status code to the end of the response payload.
    String s = Integer.toHexString((response.sw1 << 8) + response.sw2 + 0x10000).substring(1);
    s = IccUtils.bytesToHexString(response.payload) + s;
    return s;
}
#method_after
@Override
public String sendEnvelopeWithStatus(int subId, String content) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "sendEnvelopeWithStatus");
    IccIoResult response = (IccIoResult) sendRequest(CMD_SEND_ENVELOPE, content, subId);
    if (response.payload == null) {
        return "";
    }
    // Append the returned status code to the end of the response payload.
    String s = Integer.toHexString((response.sw1 << 8) + response.sw2 + 0x10000).substring(1);
    s = IccUtils.bytesToHexString(response.payload) + s;
    return s;
}
#end_block

#method_before
@Override
public String nvReadItem(int itemID) {
    enforceModifyPermissionOrCarrierPrivilege(getDefaultSubscription());
    if (DBG)
        log("nvReadItem: item " + itemID);
    String value = (String) sendRequest(CMD_NV_READ_ITEM, itemID);
    if (DBG)
        log("nvReadItem: item " + itemID + " is \"" + value + '"');
    return value;
}
#method_after
@Override
public String nvReadItem(int itemID) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, getDefaultSubscription(), "nvReadItem");
    if (DBG)
        log("nvReadItem: item " + itemID);
    String value = (String) sendRequest(CMD_NV_READ_ITEM, itemID);
    if (DBG)
        log("nvReadItem: item " + itemID + " is \"" + value + '"');
    return value;
}
#end_block

#method_before
@Override
public boolean nvWriteItem(int itemID, String itemValue) {
    enforceModifyPermissionOrCarrierPrivilege(getDefaultSubscription());
    if (DBG)
        log("nvWriteItem: item " + itemID + " value \"" + itemValue + '"');
    Boolean success = (Boolean) sendRequest(CMD_NV_WRITE_ITEM, new Pair<Integer, String>(itemID, itemValue));
    if (DBG)
        log("nvWriteItem: item " + itemID + ' ' + (success ? "ok" : "fail"));
    return success;
}
#method_after
@Override
public boolean nvWriteItem(int itemID, String itemValue) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, getDefaultSubscription(), "nvWriteItem");
    if (DBG)
        log("nvWriteItem: item " + itemID + " value \"" + itemValue + '"');
    Boolean success = (Boolean) sendRequest(CMD_NV_WRITE_ITEM, new Pair<Integer, String>(itemID, itemValue));
    if (DBG)
        log("nvWriteItem: item " + itemID + ' ' + (success ? "ok" : "fail"));
    return success;
}
#end_block

#method_before
@Override
public boolean nvWriteCdmaPrl(byte[] preferredRoamingList) {
    enforceModifyPermissionOrCarrierPrivilege(getDefaultSubscription());
    if (DBG)
        log("nvWriteCdmaPrl: value: " + HexDump.toHexString(preferredRoamingList));
    Boolean success = (Boolean) sendRequest(CMD_NV_WRITE_CDMA_PRL, preferredRoamingList);
    if (DBG)
        log("nvWriteCdmaPrl: " + (success ? "ok" : "fail"));
    return success;
}
#method_after
@Override
public boolean nvWriteCdmaPrl(byte[] preferredRoamingList) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, getDefaultSubscription(), "nvWriteCdmaPrl");
    if (DBG)
        log("nvWriteCdmaPrl: value: " + HexDump.toHexString(preferredRoamingList));
    Boolean success = (Boolean) sendRequest(CMD_NV_WRITE_CDMA_PRL, preferredRoamingList);
    if (DBG)
        log("nvWriteCdmaPrl: " + (success ? "ok" : "fail"));
    return success;
}
#end_block

#method_before
@Override
public boolean nvResetConfig(int resetType) {
    enforceModifyPermissionOrCarrierPrivilege(getDefaultSubscription());
    if (DBG)
        log("nvResetConfig: type " + resetType);
    Boolean success = (Boolean) sendRequest(CMD_NV_RESET_CONFIG, resetType);
    if (DBG)
        log("nvResetConfig: type " + resetType + ' ' + (success ? "ok" : "fail"));
    return success;
}
#method_after
@Override
public boolean nvResetConfig(int resetType) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, getDefaultSubscription(), "nvResetConfig");
    if (DBG)
        log("nvResetConfig: type " + resetType);
    Boolean success = (Boolean) sendRequest(CMD_NV_RESET_CONFIG, resetType);
    if (DBG)
        log("nvResetConfig: type " + resetType + ' ' + (success ? "ok" : "fail"));
    return success;
}
#end_block

#method_before
public String[] getPcscfAddress(String apnType, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getPcscfAddress")) {
        return new String[0];
    }
    return mPhone.getPcscfAddress(apnType);
}
#method_after
public String[] getPcscfAddress(String apnType, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getPcscfAddress")) {
        return new String[0];
    }
    return mPhone.getPcscfAddress(apnType);
}
#end_block

#method_before
@Override
public void setNetworkSelectionModeAutomatic(int subId) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    if (DBG)
        log("setNetworkSelectionModeAutomatic: subId " + subId);
    sendRequest(CMD_SET_NETWORK_SELECTION_MODE_AUTOMATIC, null, subId);
}
#method_after
@Override
public void setNetworkSelectionModeAutomatic(int subId) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "setNetworkSelectionModeAutomatic");
    if (DBG)
        log("setNetworkSelectionModeAutomatic: subId " + subId);
    sendRequest(CMD_SET_NETWORK_SELECTION_MODE_AUTOMATIC, null, subId);
}
#end_block

#method_before
@Override
public boolean setNetworkSelectionModeManual(int subId, String operatorNumeric, boolean persistSelection) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    OperatorInfo operator = new OperatorInfo(/* operatorAlphaLong */
    "", /* operatorAlphaShort */
    "", operatorNumeric);
    if (DBG)
        log("setNetworkSelectionModeManual: subId:" + subId + " operator:" + operator);
    ManualNetworkSelectionArgument arg = new ManualNetworkSelectionArgument(operator, persistSelection);
    return (Boolean) sendRequest(CMD_SET_NETWORK_SELECTION_MODE_MANUAL, arg, subId);
}
#method_after
@Override
public boolean setNetworkSelectionModeManual(int subId, String operatorNumeric, boolean persistSelection) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "setNetworkSelectionModeManual");
    OperatorInfo operator = new OperatorInfo(/* operatorAlphaLong */
    "", /* operatorAlphaShort */
    "", operatorNumeric);
    if (DBG)
        log("setNetworkSelectionModeManual: subId:" + subId + " operator:" + operator);
    ManualNetworkSelectionArgument arg = new ManualNetworkSelectionArgument(operator, persistSelection);
    return (Boolean) sendRequest(CMD_SET_NETWORK_SELECTION_MODE_MANUAL, arg, subId);
}
#end_block

#method_before
@Override
public CellNetworkScanResult getCellNetworkScanResults(int subId) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    if (DBG)
        log("getCellNetworkScanResults: subId " + subId);
    CellNetworkScanResult result = (CellNetworkScanResult) sendRequest(CMD_PERFORM_NETWORK_SCAN, null, subId);
    return result;
}
#method_after
@Override
public CellNetworkScanResult getCellNetworkScanResults(int subId) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "getCellNetworkScanResults");
    if (DBG)
        log("getCellNetworkScanResults: subId " + subId);
    CellNetworkScanResult result = (CellNetworkScanResult) sendRequest(CMD_PERFORM_NETWORK_SCAN, null, subId);
    return result;
}
#end_block

#method_before
@Override
public int requestNetworkScan(int subId, NetworkScanRequest request, Messenger messenger, IBinder binder) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    return mNetworkScanRequestTracker.startNetworkScan(request, messenger, binder, getPhone(subId));
}
#method_after
@Override
public int requestNetworkScan(int subId, NetworkScanRequest request, Messenger messenger, IBinder binder) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "requestNetworkScan");
    return mNetworkScanRequestTracker.startNetworkScan(request, messenger, binder, getPhone(subId));
}
#end_block

#method_before
@Override
public void stopNetworkScan(int subId, int scanId) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    mNetworkScanRequestTracker.stopNetworkScan(scanId);
}
#method_after
@Override
public void stopNetworkScan(int subId, int scanId) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "stopNetworkScan");
    mNetworkScanRequestTracker.stopNetworkScan(scanId);
}
#end_block

#method_before
@Override
public int getCalculatedPreferredNetworkType(String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getCalculatedPreferredNetworkType")) {
        return RILConstants.PREFERRED_NETWORK_MODE;
    }
    // wink FIXME: need to get SubId from somewhere.
    return PhoneFactory.calculatePreferredNetworkType(mPhone.getContext(), 0);
}
#method_after
@Override
public int getCalculatedPreferredNetworkType(String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getCalculatedPreferredNetworkType")) {
        return RILConstants.PREFERRED_NETWORK_MODE;
    }
    // wink FIXME: need to get SubId from somewhere.
    return PhoneFactory.calculatePreferredNetworkType(mPhone.getContext(), 0);
}
#end_block

#method_before
@Override
public int getPreferredNetworkType(int subId) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    if (DBG)
        log("getPreferredNetworkType");
    int[] result = (int[]) sendRequest(CMD_GET_PREFERRED_NETWORK_TYPE, null, subId);
    int networkType = (result != null ? result[0] : -1);
    if (DBG)
        log("getPreferredNetworkType: " + networkType);
    return networkType;
}
#method_after
@Override
public int getPreferredNetworkType(int subId) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "getPreferredNetworkType");
    if (DBG)
        log("getPreferredNetworkType");
    int[] result = (int[]) sendRequest(CMD_GET_PREFERRED_NETWORK_TYPE, null, subId);
    int networkType = (result != null ? result[0] : -1);
    if (DBG)
        log("getPreferredNetworkType: " + networkType);
    return networkType;
}
#end_block

#method_before
@Override
public boolean setPreferredNetworkType(int subId, int networkType) {
    enforceModifyPermissionOrCarrierPrivilege(subId);
    if (DBG)
        log("setPreferredNetworkType: subId " + subId + " type " + networkType);
    Boolean success = (Boolean) sendRequest(CMD_SET_PREFERRED_NETWORK_TYPE, networkType, subId);
    if (DBG)
        log("setPreferredNetworkType: " + (success ? "ok" : "fail"));
    if (success) {
        Settings.Global.putInt(mPhone.getContext().getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId, networkType);
        TelephonyManager.putIntAtIndex(mPhone.getContext().getContentResolver(), android.provider.Settings.Global.PREFERRED_NETWORK_MODE, mSubscriptionController.getPhoneId(subId), networkType);
    }
    return success;
}
#method_after
@Override
public boolean setPreferredNetworkType(int subId, int networkType) {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, subId, "setPreferredNetworkType");
    if (DBG)
        log("setPreferredNetworkType: subId " + subId + " type " + networkType);
    Boolean success = (Boolean) sendRequest(CMD_SET_PREFERRED_NETWORK_TYPE, networkType, subId);
    if (DBG)
        log("setPreferredNetworkType: " + (success ? "ok" : "fail"));
    if (success) {
        Settings.Global.putInt(mPhone.getContext().getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId, networkType);
    }
    return success;
}
#end_block

#method_before
@Override
public boolean getDataEnabled(int subId) {
    try {
        mApp.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_NETWORK_STATE, null);
    } catch (Exception e) {
        enforceModifyPermissionOrCarrierPrivilege(subId);
    }
    int phoneId = mSubscriptionController.getPhoneId(subId);
    if (DBG)
        log("getDataEnabled: subId=" + subId + " phoneId=" + phoneId);
    Phone phone = PhoneFactory.getPhone(phoneId);
    if (phone != null) {
        boolean retVal = phone.getDataEnabled();
        if (DBG)
            log("getDataEnabled: subId=" + subId + " retVal=" + retVal);
        return retVal;
    } else {
        if (DBG)
            loge("getDataEnabled: no phone subId=" + subId + " retVal=false");
        return false;
    }
}
#method_after
@Override
public boolean getDataEnabled(int subId) {
    return isUserDataEnabled(subId);
}
#end_block

#method_before
@Override
public boolean setLine1NumberForDisplayForSubscriber(int subId, String alphaTag, String number) {
    enforceCarrierPrivilege(subId);
    final String iccId = getIccId(subId);
    final Phone phone = getPhone(subId);
    if (phone == null) {
        return false;
    }
    final String subscriberId = phone.getSubscriberId();
    if (DBG_MERGE) {
        Slog.d(LOG_TAG, "Setting line number for ICC=" + iccId + ", subscriberId=" + subscriberId + " to " + number);
    }
    if (TextUtils.isEmpty(iccId)) {
        return false;
    }
    final SharedPreferences.Editor editor = mTelephonySharedPreferences.edit();
    final String alphaTagPrefKey = PREF_CARRIERS_ALPHATAG_PREFIX + iccId;
    if (alphaTag == null) {
        editor.remove(alphaTagPrefKey);
    } else {
        editor.putString(alphaTagPrefKey, alphaTag);
    }
    // Record both the line number and IMSI for this ICCID, since we need to
    // track all merged IMSIs based on line number
    final String numberPrefKey = PREF_CARRIERS_NUMBER_PREFIX + iccId;
    final String subscriberPrefKey = PREF_CARRIERS_SUBSCRIBER_PREFIX + iccId;
    if (number == null) {
        editor.remove(numberPrefKey);
        editor.remove(subscriberPrefKey);
    } else {
        editor.putString(numberPrefKey, number);
        editor.putString(subscriberPrefKey, subscriberId);
    }
    editor.commit();
    return true;
}
#method_after
@Override
public boolean setLine1NumberForDisplayForSubscriber(int subId, String alphaTag, String number) {
    TelephonyPermissions.enforceCallingOrSelfCarrierPrivilege(subId, "setLine1NumberForDisplayForSubscriber");
    final String iccId = getIccId(subId);
    final Phone phone = getPhone(subId);
    if (phone == null) {
        return false;
    }
    final String subscriberId = phone.getSubscriberId();
    if (DBG_MERGE) {
        Slog.d(LOG_TAG, "Setting line number for ICC=" + iccId + ", subscriberId=" + subscriberId + " to " + number);
    }
    if (TextUtils.isEmpty(iccId)) {
        return false;
    }
    final SharedPreferences.Editor editor = mTelephonySharedPreferences.edit();
    final String alphaTagPrefKey = PREF_CARRIERS_ALPHATAG_PREFIX + iccId;
    if (alphaTag == null) {
        editor.remove(alphaTagPrefKey);
    } else {
        editor.putString(alphaTagPrefKey, alphaTag);
    }
    // Record both the line number and IMSI for this ICCID, since we need to
    // track all merged IMSIs based on line number
    final String numberPrefKey = PREF_CARRIERS_NUMBER_PREFIX + iccId;
    final String subscriberPrefKey = PREF_CARRIERS_SUBSCRIBER_PREFIX + iccId;
    if (number == null) {
        editor.remove(numberPrefKey);
        editor.remove(subscriberPrefKey);
    } else {
        editor.putString(numberPrefKey, number);
        editor.putString(subscriberPrefKey, subscriberId);
    }
    editor.commit();
    return true;
}
#end_block

#method_before
@Override
public String getLine1NumberForDisplay(int subId, String callingPackage) {
    // This is open to apps with WRITE_SMS.
    if (!canReadPhoneNumber(callingPackage, "getLine1NumberForDisplay")) {
        if (DBG_MERGE)
            log("getLine1NumberForDisplay returning null due to permission");
        return null;
    }
    String iccId = getIccId(subId);
    if (iccId != null) {
        String numberPrefKey = PREF_CARRIERS_NUMBER_PREFIX + iccId;
        if (DBG_MERGE) {
            log("getLine1NumberForDisplay returning " + mTelephonySharedPreferences.getString(numberPrefKey, null));
        }
        return mTelephonySharedPreferences.getString(numberPrefKey, null);
    }
    if (DBG_MERGE)
        log("getLine1NumberForDisplay returning null as iccId is null");
    return null;
}
#method_after
@Override
public String getLine1NumberForDisplay(int subId, String callingPackage) {
    // This is open to apps with WRITE_SMS.
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneNumber(mApp, callingPackage, "getLine1NumberForDisplay")) {
        if (DBG_MERGE)
            log("getLine1NumberForDisplay returning null due to permission");
        return null;
    }
    String iccId = getIccId(subId);
    if (iccId != null) {
        String numberPrefKey = PREF_CARRIERS_NUMBER_PREFIX + iccId;
        if (DBG_MERGE) {
            log("getLine1NumberForDisplay returning " + mTelephonySharedPreferences.getString(numberPrefKey, null));
        }
        return mTelephonySharedPreferences.getString(numberPrefKey, null);
    }
    if (DBG_MERGE)
        log("getLine1NumberForDisplay returning null as iccId is null");
    return null;
}
#end_block

#method_before
@Override
public String getLine1AlphaTagForDisplay(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getLine1AlphaTagForDisplay")) {
        return null;
    }
    String iccId = getIccId(subId);
    if (iccId != null) {
        String alphaTagPrefKey = PREF_CARRIERS_ALPHATAG_PREFIX + iccId;
        return mTelephonySharedPreferences.getString(alphaTagPrefKey, null);
    }
    return null;
}
#method_after
@Override
public String getLine1AlphaTagForDisplay(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getLine1AlphaTagForDisplay")) {
        return null;
    }
    String iccId = getIccId(subId);
    if (iccId != null) {
        String alphaTagPrefKey = PREF_CARRIERS_ALPHATAG_PREFIX + iccId;
        return mTelephonySharedPreferences.getString(alphaTagPrefKey, null);
    }
    return null;
}
#end_block

#method_before
@Override
public String[] getMergedSubscriberIds(String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getMergedSubscriberIds")) {
        return null;
    }
    final Context context = mPhone.getContext();
    final TelephonyManager tele = TelephonyManager.from(context);
    final SubscriptionManager sub = SubscriptionManager.from(context);
    // Figure out what subscribers are currently active
    final ArraySet<String> activeSubscriberIds = new ArraySet<>();
    // Clear calling identity, when calling TelephonyManager, because callerUid must be
    // the process, where TelephonyManager was instantiated. Otherwise AppOps check will fail.
    final long identity = Binder.clearCallingIdentity();
    try {
        final int[] subIds = sub.getActiveSubscriptionIdList();
        for (int subId : subIds) {
            activeSubscriberIds.add(tele.getSubscriberId(subId));
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    // First pass, find a number override for an active subscriber
    String mergeNumber = null;
    final Map<String, ?> prefs = mTelephonySharedPreferences.getAll();
    for (String key : prefs.keySet()) {
        if (key.startsWith(PREF_CARRIERS_SUBSCRIBER_PREFIX)) {
            final String subscriberId = (String) prefs.get(key);
            if (activeSubscriberIds.contains(subscriberId)) {
                final String iccId = key.substring(PREF_CARRIERS_SUBSCRIBER_PREFIX.length());
                final String numberKey = PREF_CARRIERS_NUMBER_PREFIX + iccId;
                mergeNumber = (String) prefs.get(numberKey);
                if (DBG_MERGE) {
                    Slog.d(LOG_TAG, "Found line number " + mergeNumber + " for active subscriber " + subscriberId);
                }
                if (!TextUtils.isEmpty(mergeNumber)) {
                    break;
                }
            }
        }
    }
    // Shortcut when no active merged subscribers
    if (TextUtils.isEmpty(mergeNumber)) {
        return null;
    }
    // Second pass, find all subscribers under that line override
    final ArraySet<String> result = new ArraySet<>();
    for (String key : prefs.keySet()) {
        if (key.startsWith(PREF_CARRIERS_NUMBER_PREFIX)) {
            final String number = (String) prefs.get(key);
            if (mergeNumber.equals(number)) {
                final String iccId = key.substring(PREF_CARRIERS_NUMBER_PREFIX.length());
                final String subscriberKey = PREF_CARRIERS_SUBSCRIBER_PREFIX + iccId;
                final String subscriberId = (String) prefs.get(subscriberKey);
                if (!TextUtils.isEmpty(subscriberId)) {
                    result.add(subscriberId);
                }
            }
        }
    }
    final String[] resultArray = result.toArray(new String[result.size()]);
    Arrays.sort(resultArray);
    if (DBG_MERGE) {
        Slog.d(LOG_TAG, "Found subscribers " + Arrays.toString(resultArray) + " after merge");
    }
    return resultArray;
}
#method_after
@Override
public String[] getMergedSubscriberIds(String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getMergedSubscriberIds")) {
        return null;
    }
    final Context context = mPhone.getContext();
    final TelephonyManager tele = TelephonyManager.from(context);
    final SubscriptionManager sub = SubscriptionManager.from(context);
    // Figure out what subscribers are currently active
    final ArraySet<String> activeSubscriberIds = new ArraySet<>();
    // Clear calling identity, when calling TelephonyManager, because callerUid must be
    // the process, where TelephonyManager was instantiated. Otherwise AppOps check will fail.
    final long identity = Binder.clearCallingIdentity();
    try {
        final int[] subIds = sub.getActiveSubscriptionIdList();
        for (int subId : subIds) {
            activeSubscriberIds.add(tele.getSubscriberId(subId));
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    // First pass, find a number override for an active subscriber
    String mergeNumber = null;
    final Map<String, ?> prefs = mTelephonySharedPreferences.getAll();
    for (String key : prefs.keySet()) {
        if (key.startsWith(PREF_CARRIERS_SUBSCRIBER_PREFIX)) {
            final String subscriberId = (String) prefs.get(key);
            if (activeSubscriberIds.contains(subscriberId)) {
                final String iccId = key.substring(PREF_CARRIERS_SUBSCRIBER_PREFIX.length());
                final String numberKey = PREF_CARRIERS_NUMBER_PREFIX + iccId;
                mergeNumber = (String) prefs.get(numberKey);
                if (DBG_MERGE) {
                    Slog.d(LOG_TAG, "Found line number " + mergeNumber + " for active subscriber " + subscriberId);
                }
                if (!TextUtils.isEmpty(mergeNumber)) {
                    break;
                }
            }
        }
    }
    // Shortcut when no active merged subscribers
    if (TextUtils.isEmpty(mergeNumber)) {
        return null;
    }
    // Second pass, find all subscribers under that line override
    final ArraySet<String> result = new ArraySet<>();
    for (String key : prefs.keySet()) {
        if (key.startsWith(PREF_CARRIERS_NUMBER_PREFIX)) {
            final String number = (String) prefs.get(key);
            if (mergeNumber.equals(number)) {
                final String iccId = key.substring(PREF_CARRIERS_NUMBER_PREFIX.length());
                final String subscriberKey = PREF_CARRIERS_SUBSCRIBER_PREFIX + iccId;
                final String subscriberId = (String) prefs.get(subscriberKey);
                if (!TextUtils.isEmpty(subscriberId)) {
                    result.add(subscriberId);
                }
            }
        }
    }
    final String[] resultArray = result.toArray(new String[result.size()]);
    Arrays.sort(resultArray);
    if (DBG_MERGE) {
        Slog.d(LOG_TAG, "Found subscribers " + Arrays.toString(resultArray) + " after merge");
    }
    return resultArray;
}
#end_block

#method_before
@Override
public boolean setOperatorBrandOverride(int subId, String brand) {
    enforceCarrierPrivilege(subId);
    final Phone phone = getPhone(subId);
    return phone == null ? false : phone.setOperatorBrandOverride(brand);
}
#method_after
@Override
public boolean setOperatorBrandOverride(int subId, String brand) {
    TelephonyPermissions.enforceCallingOrSelfCarrierPrivilege(subId, "setOperatorBrandOverride");
    final Phone phone = getPhone(subId);
    return phone == null ? false : phone.setOperatorBrandOverride(brand);
}
#end_block

#method_before
@Override
public boolean setRoamingOverride(int subId, List<String> gsmRoamingList, List<String> gsmNonRoamingList, List<String> cdmaRoamingList, List<String> cdmaNonRoamingList) {
    enforceCarrierPrivilege(subId);
    final Phone phone = getPhone(subId);
    if (phone == null) {
        return false;
    }
    return phone.setRoamingOverride(gsmRoamingList, gsmNonRoamingList, cdmaRoamingList, cdmaNonRoamingList);
}
#method_after
@Override
public boolean setRoamingOverride(int subId, List<String> gsmRoamingList, List<String> gsmNonRoamingList, List<String> cdmaRoamingList, List<String> cdmaNonRoamingList) {
    TelephonyPermissions.enforceCallingOrSelfCarrierPrivilege(subId, "setRoamingOverride");
    final Phone phone = getPhone(subId);
    if (phone == null) {
        return false;
    }
    return phone.setRoamingOverride(gsmRoamingList, gsmNonRoamingList, cdmaRoamingList, cdmaNonRoamingList);
}
#end_block

#method_before
@Override
public int getRadioAccessFamily(int phoneId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getRadioAccessFamily")) {
        return RadioAccessFamily.RAF_UNKNOWN;
    }
    return ProxyController.getInstance().getRadioAccessFamily(phoneId);
}
#method_after
@Override
public int getRadioAccessFamily(int phoneId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getRadioAccessFamily")) {
        return RadioAccessFamily.RAF_UNKNOWN;
    }
    return ProxyController.getInstance().getRadioAccessFamily(phoneId);
}
#end_block

#method_before
@Override
public void enableVideoCalling(boolean enable) {
    enforceModifyPermission();
    ImsManager.setVtSetting(mPhone.getContext(), enable);
}
#method_after
@Override
public void enableVideoCalling(boolean enable) {
    enforceModifyPermission();
    ImsManager.getInstance(mPhone.getContext(), mPhone.getPhoneId()).setVtSetting(enable);
}
#end_block

#method_before
@Override
public boolean isVideoCallingEnabled(String callingPackage) {
    if (!canReadPhoneState(callingPackage, "isVideoCallingEnabled")) {
        return false;
    }
    // which can support video calling.
    return ImsManager.isVtEnabledByPlatform(mPhone.getContext()) && ImsManager.isEnhanced4gLteModeSettingEnabledByUser(mPhone.getContext()) && ImsManager.isVtEnabledByUser(mPhone.getContext());
}
#method_after
@Override
public boolean isVideoCallingEnabled(String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "isVideoCallingEnabled")) {
        return false;
    }
    // Check the user preference and the  system-level IMS setting. Even if the user has
    // enabled video calling, if IMS is disabled we aren't able to support video calling.
    // In the long run, we may instead need to check if there exists a connection service
    // which can support video calling.
    ImsManager imsManager = ImsManager.getInstance(mPhone.getContext(), mPhone.getPhoneId());
    return imsManager.isVtEnabledByPlatform() && imsManager.isEnhanced4gLteModeSettingEnabledByUser() && imsManager.isVtEnabledByUser();
}
#end_block

#method_before
@Override
public String getDeviceId(String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getDeviceId")) {
        return null;
    }
    final Phone phone = PhoneFactory.getPhone(0);
    if (phone != null) {
        return phone.getDeviceId();
    } else {
        return null;
    }
}
#method_after
@Override
public String getDeviceId(String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getDeviceId")) {
        return null;
    }
    final Phone phone = PhoneFactory.getPhone(0);
    if (phone != null) {
        return phone.getDeviceId();
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public boolean isImsRegistered() {
    return mPhone.isImsRegistered();
}
#method_after
public boolean isImsRegistered(int subId) {
    Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.isImsRegistered();
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean isWifiCallingAvailable() {
    return mPhone.isWifiCallingEnabled();
}
#method_after
public boolean isWifiCallingAvailable(int subId) {
    Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.isWifiCallingEnabled();
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean isVolteAvailable() {
    return mPhone.isVolteEnabled();
}
#method_after
public boolean isVolteAvailable(int subId) {
    Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.isVolteEnabled();
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean isVideoTelephonyAvailable() {
    return mPhone.isVideoEnabled();
}
#method_after
public boolean isVideoTelephonyAvailable(int subId) {
    Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.isVideoEnabled();
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public void factoryReset(int subId) {
    enforceConnectivityInternalPermission();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    final long identity = Binder.clearCallingIdentity();
    try {
        if (SubscriptionManager.isUsableSubIdValue(subId) && !mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS)) {
            // Enable data
            setDataEnabled(subId, true);
            // Set network selection mode to automatic
            setNetworkSelectionModeAutomatic(subId);
            // Set preferred mobile network type to the best available
            String defaultNetwork = TelephonyManager.getTelephonyProperty(mSubscriptionController.getPhoneId(subId), "ro.telephony.default_network", null);
            int networkType = !TextUtils.isEmpty(defaultNetwork) ? Integer.parseInt(defaultNetwork) : Phone.PREFERRED_NT_MODE;
            setPreferredNetworkType(subId, networkType);
            // Turn off roaming
            mPhone.setDataRoamingEnabled(false);
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#method_after
@Override
public void factoryReset(int subId) {
    enforceConnectivityInternalPermission();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    final long identity = Binder.clearCallingIdentity();
    try {
        if (SubscriptionManager.isUsableSubIdValue(subId) && !mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS)) {
            // Enable data
            setUserDataEnabled(subId, true);
            // Set network selection mode to automatic
            setNetworkSelectionModeAutomatic(subId);
            // Set preferred mobile network type to the best available
            String defaultNetwork = TelephonyManager.getTelephonyProperty(mSubscriptionController.getPhoneId(subId), "ro.telephony.default_network", null);
            int networkType = !TextUtils.isEmpty(defaultNetwork) ? Integer.parseInt(defaultNetwork) : Phone.PREFERRED_NT_MODE;
            setPreferredNetworkType(subId, networkType);
            // Turn off roaming
            mPhone.setDataRoamingEnabled(false);
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#end_block

#method_before
@Override
public ServiceState getServiceStateForSubscriber(int subId, String callingPackage) {
    if (!canReadPhoneState(callingPackage, "getServiceStateForSubscriber")) {
        return null;
    }
    final Phone phone = getPhone(subId);
    if (phone == null) {
        return null;
    }
    return phone.getServiceState();
}
#method_after
@Override
public ServiceState getServiceStateForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getServiceStateForSubscriber")) {
        return null;
    }
    final Phone phone = getPhone(subId);
    if (phone == null) {
        return null;
    }
    return phone.getServiceState();
}
#end_block

#method_before
@Override
public void setVoicemailRingtoneUri(String callingPackage, PhoneAccountHandle phoneAccountHandle, Uri uri) {
    mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
    if (!TextUtils.equals(callingPackage, TelecomManager.from(mPhone.getContext()).getDefaultDialerPackage())) {
        enforceModifyPermissionOrCarrierPrivilege(PhoneUtils.getSubIdForPhoneAccountHandle(phoneAccountHandle));
    }
    Phone phone = PhoneUtils.getPhoneForPhoneAccountHandle(phoneAccountHandle);
    if (phone == null) {
        phone = mPhone;
    }
    VoicemailNotificationSettingsUtil.setRingtoneUri(phone.getContext(), uri);
}
#method_after
@Override
public void setVoicemailRingtoneUri(String callingPackage, PhoneAccountHandle phoneAccountHandle, Uri uri) {
    mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
    if (!TextUtils.equals(callingPackage, TelecomManager.from(mPhone.getContext()).getDefaultDialerPackage())) {
        TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, PhoneUtils.getSubIdForPhoneAccountHandle(phoneAccountHandle), "setVoicemailRingtoneUri");
    }
    Phone phone = PhoneUtils.getPhoneForPhoneAccountHandle(phoneAccountHandle);
    if (phone == null) {
        phone = mPhone;
    }
    VoicemailNotificationSettingsUtil.setRingtoneUri(phone.getContext(), uri);
}
#end_block

#method_before
@Override
public void setVoicemailVibrationEnabled(String callingPackage, PhoneAccountHandle phoneAccountHandle, boolean enabled) {
    mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
    if (!TextUtils.equals(callingPackage, TelecomManager.from(mPhone.getContext()).getDefaultDialerPackage())) {
        enforceModifyPermissionOrCarrierPrivilege(PhoneUtils.getSubIdForPhoneAccountHandle(phoneAccountHandle));
    }
    Phone phone = PhoneUtils.getPhoneForPhoneAccountHandle(phoneAccountHandle);
    if (phone == null) {
        phone = mPhone;
    }
    VoicemailNotificationSettingsUtil.setVibrationEnabled(phone.getContext(), enabled);
}
#method_after
@Override
public void setVoicemailVibrationEnabled(String callingPackage, PhoneAccountHandle phoneAccountHandle, boolean enabled) {
    mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
    if (!TextUtils.equals(callingPackage, TelecomManager.from(mPhone.getContext()).getDefaultDialerPackage())) {
        TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, PhoneUtils.getSubIdForPhoneAccountHandle(phoneAccountHandle), "setVoicemailVibrationEnabled");
    }
    Phone phone = PhoneUtils.getPhoneForPhoneAccountHandle(phoneAccountHandle);
    if (phone == null) {
        phone = mPhone;
    }
    VoicemailNotificationSettingsUtil.setVibrationEnabled(phone.getContext(), enabled);
}
#end_block

#method_before
@Override
public List<TelephonyHistogram> getTelephonyHistograms() {
    enforceModifyPermissionOrCarrierPrivilege(getDefaultSubscription());
    return RIL.getTelephonyRILTimingHistograms();
}
#method_after
@Override
public List<TelephonyHistogram> getTelephonyHistograms() {
    TelephonyPermissions.enforceCallingOrSelfModifyPermissionOrCarrierPrivilege(mApp, getDefaultSubscription(), "getTelephonyHistograms");
    return RIL.getTelephonyRILTimingHistograms();
}
#end_block

#method_before
@Override
public List<ClientRequestStats> getClientRequestStats(String callingPackage, int subId) {
    if (!canReadPhoneState(callingPackage, "getClientRequestStats")) {
        return null;
    }
    Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getClientRequestStats();
    }
    return null;
}
#method_after
@Override
public List<ClientRequestStats> getClientRequestStats(String callingPackage, int subId) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getClientRequestStats")) {
        return null;
    }
    Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getClientRequestStats();
    }
    return null;
}
#end_block

#method_before
public static void makeDefaultPhone(Context context) {
    synchronized (sLockProxyPhones) {
        if (!sMadeDefaults) {
            sContext = context;
            // create the telephony device controller.
            TelephonyDevController.create();
            int retryCount = 0;
            for (; ; ) {
                boolean hasException = false;
                retryCount++;
                try {
                    // use UNIX domain socket to
                    // prevent subsequent initialization
                    new LocalServerSocket("com.android.internal.telephony");
                } catch (java.io.IOException ex) {
                    hasException = true;
                }
                if (!hasException) {
                    break;
                } else if (retryCount > SOCKET_OPEN_MAX_RETRY) {
                    throw new RuntimeException("PhoneFactory probably already running");
                } else {
                    try {
                        Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                    } catch (InterruptedException er) {
                    }
                }
            }
            sPhoneNotifier = new DefaultPhoneNotifier();
            int cdmaSubscription = CdmaSubscriptionSourceManager.getDefault(context);
            Rlog.i(LOG_TAG, "Cdma Subscription set to " + cdmaSubscription);
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEPHONY_EUICC)) {
                sEuiccController = EuiccController.init(context);
            }
            /* In case of multi SIM mode two instances of Phone, RIL are created,
                   where as in single SIM mode only instance. isMultiSimEnabled() function checks
                   whether it is single SIM or multi SIM mode */
            int numPhones = TelephonyManager.getDefault().getPhoneCount();
            // Start ImsResolver and bind to ImsServices.
            String defaultImsPackage = sContext.getResources().getString(com.android.internal.R.string.config_ims_package);
            Rlog.i(LOG_TAG, "ImsResolver: defaultImsPackage: " + defaultImsPackage);
            sImsResolver = new ImsResolver(sContext, defaultImsPackage, numPhones);
            sImsResolver.populateCacheAndStartBind();
            int[] networkModes = new int[numPhones];
            sPhones = new Phone[numPhones];
            sCommandsInterfaces = new RIL[numPhones];
            sTelephonyNetworkFactories = new TelephonyNetworkFactory[numPhones];
            for (int i = 0; i < numPhones; i++) {
                // reads the system properties and makes commandsinterface
                // Get preferred network type.
                networkModes[i] = RILConstants.PREFERRED_NETWORK_MODE;
                Rlog.i(LOG_TAG, "Network Mode set to " + Integer.toString(networkModes[i]));
                sCommandsInterfaces[i] = new RIL(context, networkModes[i], cdmaSubscription, i);
            }
            Rlog.i(LOG_TAG, "Creating SubscriptionController");
            SubscriptionController.init(context, sCommandsInterfaces);
            // Instantiate UiccController so that all other classes can just
            // call getInstance()
            sUiccController = UiccController.make(context, sCommandsInterfaces);
            for (int i = 0; i < numPhones; i++) {
                Phone phone = null;
                int phoneType = TelephonyManager.getPhoneType(networkModes[i]);
                if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                    phone = new GsmCdmaPhone(context, sCommandsInterfaces[i], sPhoneNotifier, i, PhoneConstants.PHONE_TYPE_GSM, TelephonyComponentFactory.getInstance());
                } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                    phone = new GsmCdmaPhone(context, sCommandsInterfaces[i], sPhoneNotifier, i, PhoneConstants.PHONE_TYPE_CDMA_LTE, TelephonyComponentFactory.getInstance());
                }
                Rlog.i(LOG_TAG, "Creating Phone with type = " + phoneType + " sub = " + i);
                sPhones[i] = phone;
            }
            // Set the default phone in base class.
            // FIXME: This is a first best guess at what the defaults will be. It
            // FIXME: needs to be done in a more controlled manner in the future.
            sPhone = sPhones[0];
            sCommandsInterface = sCommandsInterfaces[0];
            // Ensure that we have a default SMS app. Requesting the app with
            // updateIfNeeded set to true is enough to configure a default SMS app.
            ComponentName componentName = SmsApplication.getDefaultSmsApplication(context, true);
            String packageName = "NONE";
            if (componentName != null) {
                packageName = componentName.getPackageName();
            }
            Rlog.i(LOG_TAG, "defaultSmsApplication: " + packageName);
            // Set up monitor to watch for changes to SMS packages
            SmsApplication.initSmsPackageMonitor(context);
            sMadeDefaults = true;
            Rlog.i(LOG_TAG, "Creating SubInfoRecordUpdater ");
            sSubInfoRecordUpdater = new SubscriptionInfoUpdater(BackgroundThread.get().getLooper(), context, sPhones, sCommandsInterfaces);
            SubscriptionController.getInstance().updatePhonesAvailability(sPhones);
            // ImsResolver implementations of ImsService.
            for (int i = 0; i < numPhones; i++) {
                sPhones[i].startMonitoringImsService();
            }
            ITelephonyRegistry tr = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService("telephony.registry"));
            SubscriptionController sc = SubscriptionController.getInstance();
            sSubscriptionMonitor = new SubscriptionMonitor(tr, sContext, sc, numPhones);
            sPhoneSwitcher = new PhoneSwitcher(MAX_ACTIVE_PHONES, numPhones, sContext, sc, Looper.myLooper(), tr, sCommandsInterfaces, sPhones);
            sProxyController = ProxyController.getInstance(context, sPhones, sUiccController, sCommandsInterfaces, sPhoneSwitcher);
            sIntentBroadcaster = IntentBroadcaster.getInstance(context);
            sNotificationChannelController = new NotificationChannelController(context);
            sTelephonyNetworkFactories = new TelephonyNetworkFactory[numPhones];
            for (int i = 0; i < numPhones; i++) {
                sTelephonyNetworkFactories[i] = new TelephonyNetworkFactory(sPhoneSwitcher, sc, sSubscriptionMonitor, Looper.myLooper(), sContext, i, sPhones[i].mDcTracker);
            }
        }
    }
}
#method_after
public static void makeDefaultPhone(Context context) {
    synchronized (sLockProxyPhones) {
        if (!sMadeDefaults) {
            sContext = context;
            // create the telephony device controller.
            TelephonyDevController.create();
            int retryCount = 0;
            for (; ; ) {
                boolean hasException = false;
                retryCount++;
                try {
                    // use UNIX domain socket to
                    // prevent subsequent initialization
                    new LocalServerSocket("com.android.internal.telephony");
                } catch (java.io.IOException ex) {
                    hasException = true;
                }
                if (!hasException) {
                    break;
                } else if (retryCount > SOCKET_OPEN_MAX_RETRY) {
                    throw new RuntimeException("PhoneFactory probably already running");
                } else {
                    try {
                        Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                    } catch (InterruptedException er) {
                    }
                }
            }
            sPhoneNotifier = new DefaultPhoneNotifier();
            int cdmaSubscription = CdmaSubscriptionSourceManager.getDefault(context);
            Rlog.i(LOG_TAG, "Cdma Subscription set to " + cdmaSubscription);
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEPHONY_EUICC)) {
                sEuiccController = EuiccController.init(context);
                sEuiccCardController = EuiccCardController.init(context);
            }
            /* In case of multi SIM mode two instances of Phone, RIL are created,
                   where as in single SIM mode only instance. isMultiSimEnabled() function checks
                   whether it is single SIM or multi SIM mode */
            int numPhones = TelephonyManager.getDefault().getPhoneCount();
            // Return whether or not the device should use dynamic binding or the static
            // implementation (deprecated)
            boolean isDynamicBinding = sContext.getResources().getBoolean(com.android.internal.R.bool.config_dynamic_bind_ims);
            // Get the package name of the default IMS implementation.
            String defaultImsPackage = sContext.getResources().getString(com.android.internal.R.string.config_ims_package);
            // Start ImsResolver and bind to ImsServices.
            Rlog.i(LOG_TAG, "ImsResolver: defaultImsPackage: " + defaultImsPackage);
            sImsResolver = new ImsResolver(sContext, defaultImsPackage, numPhones, isDynamicBinding);
            sImsResolver.populateCacheAndStartBind();
            int[] networkModes = new int[numPhones];
            sPhones = new Phone[numPhones];
            sCommandsInterfaces = new RIL[numPhones];
            sTelephonyNetworkFactories = new TelephonyNetworkFactory[numPhones];
            for (int i = 0; i < numPhones; i++) {
                // reads the system properties and makes commandsinterface
                // Get preferred network type.
                networkModes[i] = RILConstants.PREFERRED_NETWORK_MODE;
                Rlog.i(LOG_TAG, "Network Mode set to " + Integer.toString(networkModes[i]));
                sCommandsInterfaces[i] = new RIL(context, networkModes[i], cdmaSubscription, i);
            }
            Rlog.i(LOG_TAG, "Creating SubscriptionController");
            SubscriptionController.init(context, sCommandsInterfaces);
            // Instantiate UiccController so that all other classes can just
            // call getInstance()
            sUiccController = UiccController.make(context, sCommandsInterfaces);
            for (int i = 0; i < numPhones; i++) {
                Phone phone = null;
                int phoneType = TelephonyManager.getPhoneType(networkModes[i]);
                if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                    phone = new GsmCdmaPhone(context, sCommandsInterfaces[i], sPhoneNotifier, i, PhoneConstants.PHONE_TYPE_GSM, TelephonyComponentFactory.getInstance());
                } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                    phone = new GsmCdmaPhone(context, sCommandsInterfaces[i], sPhoneNotifier, i, PhoneConstants.PHONE_TYPE_CDMA_LTE, TelephonyComponentFactory.getInstance());
                }
                Rlog.i(LOG_TAG, "Creating Phone with type = " + phoneType + " sub = " + i);
                sPhones[i] = phone;
            }
            // Set the default phone in base class.
            // FIXME: This is a first best guess at what the defaults will be. It
            // FIXME: needs to be done in a more controlled manner in the future.
            sPhone = sPhones[0];
            sCommandsInterface = sCommandsInterfaces[0];
            // Ensure that we have a default SMS app. Requesting the app with
            // updateIfNeeded set to true is enough to configure a default SMS app.
            ComponentName componentName = SmsApplication.getDefaultSmsApplication(context, true);
            String packageName = "NONE";
            if (componentName != null) {
                packageName = componentName.getPackageName();
            }
            Rlog.i(LOG_TAG, "defaultSmsApplication: " + packageName);
            // Set up monitor to watch for changes to SMS packages
            SmsApplication.initSmsPackageMonitor(context);
            sMadeDefaults = true;
            Rlog.i(LOG_TAG, "Creating SubInfoRecordUpdater ");
            sSubInfoRecordUpdater = new SubscriptionInfoUpdater(BackgroundThread.get().getLooper(), context, sPhones, sCommandsInterfaces);
            SubscriptionController.getInstance().updatePhonesAvailability(sPhones);
            // ImsResolver implementations of ImsService.
            for (int i = 0; i < numPhones; i++) {
                sPhones[i].startMonitoringImsService();
            }
            ITelephonyRegistry tr = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService("telephony.registry"));
            SubscriptionController sc = SubscriptionController.getInstance();
            sSubscriptionMonitor = new SubscriptionMonitor(tr, sContext, sc, numPhones);
            sPhoneSwitcher = new PhoneSwitcher(MAX_ACTIVE_PHONES, numPhones, sContext, sc, Looper.myLooper(), tr, sCommandsInterfaces, sPhones);
            sProxyController = ProxyController.getInstance(context, sPhones, sUiccController, sCommandsInterfaces, sPhoneSwitcher);
            sIntentBroadcaster = IntentBroadcaster.getInstance(context);
            sNotificationChannelController = new NotificationChannelController(context);
            sTelephonyNetworkFactories = new TelephonyNetworkFactory[numPhones];
            for (int i = 0; i < numPhones; i++) {
                sTelephonyNetworkFactories[i] = new TelephonyNetworkFactory(sPhoneSwitcher, sc, sSubscriptionMonitor, Looper.myLooper(), sContext, i, sPhones[i].mDcTracker);
            }
        }
    }
}
#end_block

#method_before
/**
 * Returns the preferred network type that should be set in the modem.
 *
 * @param context The current {@link Context}.
 * @return the preferred network mode that should be set.
 */
public static int calculatePreferredNetworkType(Context context, int phoneSubId) {
    int phoneId = SubscriptionController.getInstance().getPhoneId(phoneSubId);
    int phoneIdNetworkType = RILConstants.PREFERRED_NETWORK_MODE;
    try {
        phoneIdNetworkType = TelephonyManager.getIntAtIndex(context.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE, phoneId);
    } catch (SettingNotFoundException snfe) {
        Rlog.e(LOG_TAG, "Settings Exception Reading Valuefor phoneID");
    }
    int networkType = phoneIdNetworkType;
    Rlog.d(LOG_TAG, "calculatePreferredNetworkType: phoneId = " + phoneId + " phoneIdNetworkType = " + phoneIdNetworkType);
    if (SubscriptionController.getInstance().isActiveSubId(phoneSubId)) {
        networkType = android.provider.Settings.Global.getInt(context.getContentResolver(), android.provider.Settings.Global.PREFERRED_NETWORK_MODE + phoneSubId, phoneIdNetworkType);
    } else {
        Rlog.d(LOG_TAG, "calculatePreferredNetworkType: phoneSubId = " + phoneSubId + " is not a active SubId");
    }
    Rlog.d(LOG_TAG, "calculatePreferredNetworkType: phoneSubId = " + phoneSubId + " networkType = " + networkType);
    return networkType;
}
#method_after
/**
 * Returns the preferred network type that should be set in the modem.
 *
 * @param context The current {@link Context}.
 * @return the preferred network mode that should be set.
 */
public static int calculatePreferredNetworkType(Context context, int phoneSubId) {
    int networkType = android.provider.Settings.Global.getInt(context.getContentResolver(), android.provider.Settings.Global.PREFERRED_NETWORK_MODE + phoneSubId, -1);
    Rlog.d(LOG_TAG, "calculatePreferredNetworkType: phoneSubId = " + phoneSubId + " networkType = " + networkType);
    if (networkType == -1) {
        networkType = RILConstants.PREFERRED_NETWORK_MODE;
        try {
            networkType = TelephonyManager.getIntAtIndex(context.getContentResolver(), android.provider.Settings.Global.PREFERRED_NETWORK_MODE, SubscriptionController.getInstance().getPhoneId(phoneSubId));
        } catch (SettingNotFoundException retrySnfe) {
            Rlog.e(LOG_TAG, "Settings Exception Reading Value At Index for " + "Settings.Global.PREFERRED_NETWORK_MODE");
        }
    }
    return networkType;
}
#end_block

#method_before
public static void dump(FileDescriptor fd, PrintWriter printwriter, String[] args) {
    IndentingPrintWriter pw = new IndentingPrintWriter(printwriter, "  ");
    pw.println("PhoneFactory:");
    pw.println(" sMadeDefaults=" + sMadeDefaults);
    sPhoneSwitcher.dump(fd, pw, args);
    pw.println();
    Phone[] phones = (Phone[]) PhoneFactory.getPhones();
    for (int i = 0; i < phones.length; i++) {
        pw.increaseIndent();
        Phone phone = phones[i];
        try {
            phone.dump(fd, pw, args);
        } catch (Exception e) {
            pw.println("Telephony DebugService: Could not get Phone[" + i + "] e=" + e);
            continue;
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
        sTelephonyNetworkFactories[i].dump(fd, pw, args);
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
        try {
            ((IccCardProxy) phone.getIccCard()).dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.decreaseIndent();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    pw.println("SubscriptionMonitor:");
    pw.increaseIndent();
    try {
        sSubscriptionMonitor.dump(fd, pw, args);
    } catch (Exception e) {
        e.printStackTrace();
    }
    pw.decreaseIndent();
    pw.println("++++++++++++++++++++++++++++++++");
    pw.println("UiccController:");
    pw.increaseIndent();
    try {
        sUiccController.dump(fd, pw, args);
    } catch (Exception e) {
        e.printStackTrace();
    }
    pw.flush();
    pw.decreaseIndent();
    pw.println("++++++++++++++++++++++++++++++++");
    if (sEuiccController != null) {
        pw.println("EuiccController:");
        pw.increaseIndent();
        try {
            sEuiccController.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.decreaseIndent();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    pw.println("SubscriptionController:");
    pw.increaseIndent();
    try {
        SubscriptionController.getInstance().dump(fd, pw, args);
    } catch (Exception e) {
        e.printStackTrace();
    }
    pw.flush();
    pw.decreaseIndent();
    pw.println("++++++++++++++++++++++++++++++++");
    pw.println("SubInfoRecordUpdater:");
    pw.increaseIndent();
    try {
        sSubInfoRecordUpdater.dump(fd, pw, args);
    } catch (Exception e) {
        e.printStackTrace();
    }
    pw.flush();
    pw.decreaseIndent();
    pw.println("++++++++++++++++++++++++++++++++");
    pw.println("LocalLogs:");
    pw.increaseIndent();
    synchronized (sLocalLogs) {
        for (String key : sLocalLogs.keySet()) {
            pw.println(key);
            pw.increaseIndent();
            sLocalLogs.get(key).dump(fd, pw, args);
            pw.decreaseIndent();
        }
        pw.flush();
    }
    pw.decreaseIndent();
    pw.println("++++++++++++++++++++++++++++++++");
    pw.println("SharedPreferences:");
    pw.increaseIndent();
    try {
        if (sContext != null) {
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(sContext);
            Map spValues = sp.getAll();
            for (Object key : spValues.keySet()) {
                pw.println(key + " : " + spValues.get(key));
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    pw.flush();
    pw.decreaseIndent();
}
#method_after
public static void dump(FileDescriptor fd, PrintWriter printwriter, String[] args) {
    IndentingPrintWriter pw = new IndentingPrintWriter(printwriter, "  ");
    pw.println("PhoneFactory:");
    pw.println(" sMadeDefaults=" + sMadeDefaults);
    sPhoneSwitcher.dump(fd, pw, args);
    pw.println();
    Phone[] phones = (Phone[]) PhoneFactory.getPhones();
    for (int i = 0; i < phones.length; i++) {
        pw.increaseIndent();
        Phone phone = phones[i];
        try {
            phone.dump(fd, pw, args);
        } catch (Exception e) {
            pw.println("Telephony DebugService: Could not get Phone[" + i + "] e=" + e);
            continue;
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
        sTelephonyNetworkFactories[i].dump(fd, pw, args);
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
        try {
            ((UiccProfile) phone.getIccCard()).dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.decreaseIndent();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    pw.println("SubscriptionMonitor:");
    pw.increaseIndent();
    try {
        sSubscriptionMonitor.dump(fd, pw, args);
    } catch (Exception e) {
        e.printStackTrace();
    }
    pw.decreaseIndent();
    pw.println("++++++++++++++++++++++++++++++++");
    pw.println("UiccController:");
    pw.increaseIndent();
    try {
        sUiccController.dump(fd, pw, args);
    } catch (Exception e) {
        e.printStackTrace();
    }
    pw.flush();
    pw.decreaseIndent();
    pw.println("++++++++++++++++++++++++++++++++");
    if (sEuiccController != null) {
        pw.println("EuiccController:");
        pw.increaseIndent();
        try {
            sEuiccController.dump(fd, pw, args);
            sEuiccCardController.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.decreaseIndent();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    pw.println("SubscriptionController:");
    pw.increaseIndent();
    try {
        SubscriptionController.getInstance().dump(fd, pw, args);
    } catch (Exception e) {
        e.printStackTrace();
    }
    pw.flush();
    pw.decreaseIndent();
    pw.println("++++++++++++++++++++++++++++++++");
    pw.println("SubInfoRecordUpdater:");
    pw.increaseIndent();
    try {
        sSubInfoRecordUpdater.dump(fd, pw, args);
    } catch (Exception e) {
        e.printStackTrace();
    }
    pw.flush();
    pw.decreaseIndent();
    pw.println("++++++++++++++++++++++++++++++++");
    pw.println("LocalLogs:");
    pw.increaseIndent();
    synchronized (sLocalLogs) {
        for (String key : sLocalLogs.keySet()) {
            pw.println(key);
            pw.increaseIndent();
            sLocalLogs.get(key).dump(fd, pw, args);
            pw.decreaseIndent();
        }
        pw.flush();
    }
    pw.decreaseIndent();
    pw.println("++++++++++++++++++++++++++++++++");
    pw.println("SharedPreferences:");
    pw.increaseIndent();
    try {
        if (sContext != null) {
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(sContext);
            Map spValues = sp.getAll();
            for (Object key : spValues.keySet()) {
                pw.println(key + " : " + spValues.get(key));
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    pw.flush();
    pw.decreaseIndent();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_SIM_LOCKED_QUERY_ICCID_DONE:
            {
                AsyncResult ar = (AsyncResult) msg.obj;
                QueryIccIdUserObj uObj = (QueryIccIdUserObj) ar.userObj;
                int slotId = uObj.slotId;
                logd("handleMessage : <EVENT_SIM_LOCKED_QUERY_ICCID_DONE> SIM" + (slotId + 1));
                if (ar.exception == null) {
                    if (ar.result != null) {
                        byte[] data = (byte[]) ar.result;
                        mIccId[slotId] = IccUtils.bcdToString(data, 0, data.length);
                    } else {
                        logd("Null ar");
                        mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
                    }
                } else {
                    mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
                    logd("Query IccId fail: " + ar.exception);
                }
                logd("sIccId[" + slotId + "] = " + mIccId[slotId]);
                if (isAllIccIdQueryDone()) {
                    updateSubscriptionInfoByIccId();
                }
                broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED, uObj.reason);
                if (!ICCID_STRING_FOR_NO_SIM.equals(mIccId[slotId])) {
                    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED);
                }
                break;
            }
        case EVENT_GET_NETWORK_SELECTION_MODE_DONE:
            {
                AsyncResult ar = (AsyncResult) msg.obj;
                Integer slotId = (Integer) ar.userObj;
                if (ar.exception == null && ar.result != null) {
                    int[] modes = (int[]) ar.result;
                    if (modes[0] == 1) {
                        // Manual mode.
                        mPhone[slotId].setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    logd("EVENT_GET_NETWORK_SELECTION_MODE_DONE: error getting network mode.");
                }
                break;
            }
        case EVENT_SIM_LOADED:
            handleSimLoaded(msg.arg1);
            break;
        case EVENT_SIM_ABSENT:
            handleSimAbsent(msg.arg1);
            break;
        case EVENT_SIM_LOCKED:
            handleSimLocked(msg.arg1, (String) msg.obj);
            break;
        case EVENT_SIM_UNKNOWN:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN);
            break;
        case EVENT_SIM_IO_ERROR:
            handleSimError(msg.arg1);
            break;
        case EVENT_SIM_RESTRICTED:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED);
            break;
        case EVENT_REFRESH_EMBEDDED_SUBSCRIPTIONS:
            if (updateEmbeddedSubscriptions()) {
                SubscriptionController.getInstance().notifySubscriptionInfoChanged();
            }
            if (msg.obj != null) {
                ((Runnable) msg.obj).run();
            }
            break;
        default:
            logd("Unknown msg:" + msg.what);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_GET_NETWORK_SELECTION_MODE_DONE:
            {
                AsyncResult ar = (AsyncResult) msg.obj;
                Integer slotId = (Integer) ar.userObj;
                if (ar.exception == null && ar.result != null) {
                    int[] modes = (int[]) ar.result;
                    if (modes[0] == 1) {
                        // Manual mode.
                        mPhone[slotId].setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    logd("EVENT_GET_NETWORK_SELECTION_MODE_DONE: error getting network mode.");
                }
                break;
            }
        case EVENT_SIM_LOADED:
            handleSimLoaded(msg.arg1);
            break;
        case EVENT_SIM_ABSENT:
            handleSimAbsent(msg.arg1);
            break;
        case EVENT_SIM_LOCKED:
            handleSimLocked(msg.arg1, (String) msg.obj);
            break;
        case EVENT_SIM_UNKNOWN:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN);
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN, null);
            broadcastSimCardStateChanged(msg.arg1, TelephonyManager.SIM_STATE_UNKNOWN);
            broadcastSimApplicationStateChanged(msg.arg1, TelephonyManager.SIM_STATE_UNKNOWN);
            break;
        case EVENT_SIM_IO_ERROR:
            handleSimError(msg.arg1);
            break;
        case EVENT_SIM_RESTRICTED:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED);
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED);
            broadcastSimCardStateChanged(msg.arg1, TelephonyManager.SIM_STATE_CARD_RESTRICTED);
            broadcastSimApplicationStateChanged(msg.arg1, TelephonyManager.SIM_STATE_NOT_READY);
            break;
        case EVENT_SIM_READY:
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_READY, null);
            broadcastSimCardStateChanged(msg.arg1, TelephonyManager.SIM_STATE_PRESENT);
            broadcastSimApplicationStateChanged(msg.arg1, TelephonyManager.SIM_STATE_NOT_READY);
            break;
        case EVENT_SIM_IMSI:
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_IMSI, null);
            break;
        case EVENT_SIM_NOT_READY:
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_NOT_READY, null);
            broadcastSimCardStateChanged(msg.arg1, TelephonyManager.SIM_STATE_PRESENT);
            broadcastSimApplicationStateChanged(msg.arg1, TelephonyManager.SIM_STATE_NOT_READY);
        case EVENT_REFRESH_EMBEDDED_SUBSCRIPTIONS:
            if (updateEmbeddedSubscriptions()) {
                SubscriptionController.getInstance().notifySubscriptionInfoChanged();
            }
            if (msg.obj != null) {
                ((Runnable) msg.obj).run();
            }
            break;
        default:
            logd("Unknown msg:" + msg.what);
    }
}
#end_block

#method_before
private void handleSimLocked(int slotId, String reason) {
    if (mIccId[slotId] != null && mIccId[slotId].equals(ICCID_STRING_FOR_NO_SIM)) {
        logd("SIM" + (slotId + 1) + " hot plug in");
        mIccId[slotId] = null;
    }
    IccFileHandler fileHandler = mPhone[slotId].getIccCard() == null ? null : mPhone[slotId].getIccCard().getIccFileHandler();
    if (fileHandler != null) {
        String iccId = mIccId[slotId];
        if (iccId == null) {
            logd("Querying IccId");
            fileHandler.loadEFTransparent(IccConstants.EF_ICCID, obtainMessage(EVENT_SIM_LOCKED_QUERY_ICCID_DONE, new QueryIccIdUserObj(reason, slotId)));
        } else {
            logd("NOT Querying IccId its already set sIccid[" + slotId + "]=" + iccId);
            updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED);
            broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED, reason);
        }
    } else {
        logd("sFh[" + slotId + "] is null, ignore");
    }
}
#method_after
private void handleSimLocked(int slotId, String reason) {
    if (mIccId[slotId] != null && mIccId[slotId].equals(ICCID_STRING_FOR_NO_SIM)) {
        logd("SIM" + (slotId + 1) + " hot plug in");
        mIccId[slotId] = null;
    }
    String iccId = mIccId[slotId];
    if (iccId == null) {
        IccCard iccCard = mPhone[slotId].getIccCard();
        if (iccCard == null) {
            logd("handleSimLoaded: IccCard null");
            return;
        }
        IccRecords records = iccCard.getIccRecords();
        if (records == null) {
            logd("handleSimLoaded: IccRecords null");
            return;
        }
        if (IccUtils.stripTrailingFs(records.getFullIccId()) == null) {
            logd("handleSimLocked: IccID null");
            return;
        }
        mIccId[slotId] = IccUtils.stripTrailingFs(records.getFullIccId());
    } else {
        logd("NOT Querying IccId its already set sIccid[" + slotId + "]=" + iccId);
    }
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED);
    broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED, reason);
    broadcastSimCardStateChanged(slotId, TelephonyManager.SIM_STATE_PRESENT);
    broadcastSimApplicationStateChanged(slotId, getSimStateFromLockedReason(reason));
}
#end_block

#method_before
private void handleSimLoaded(int slotId) {
    logd("handleSimLoaded: slotId: " + slotId);
    // The SIM should be loaded at this state, but it is possible in cases such as SIM being
    // removed or a refresh RESET that the IccRecords could be null. The right behavior is to
    // not broadcast the SIM loaded.
    int loadedSlotId = slotId;
    IccRecords records = mPhone[slotId].getIccCard().getIccRecords();
    if (records == null) {
        // Possibly a race condition.
        logd("handleSimLoaded: IccRecords null");
        return;
    }
    if (records.getIccId() == null) {
        logd("handleSimLoaded: IccID null");
        return;
    }
    mIccId[slotId] = records.getIccId();
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
        int[] subIds = mSubscriptionManager.getActiveSubscriptionIdList();
        for (int subId : subIds) {
            TelephonyManager tm = TelephonyManager.getDefault();
            String operator = tm.getSimOperatorNumeric(subId);
            slotId = SubscriptionController.getInstance().getPhoneId(subId);
            if (!TextUtils.isEmpty(operator)) {
                if (subId == SubscriptionController.getInstance().getDefaultSubId()) {
                    MccTable.updateMccMncConfiguration(mContext, operator, false);
                }
                SubscriptionController.getInstance().setMccMnc(operator, subId);
            } else {
                logd("EVENT_RECORDS_LOADED Operator name is null");
            }
            String msisdn = tm.getLine1Number(subId);
            ContentResolver contentResolver = mContext.getContentResolver();
            if (msisdn != null) {
                ContentValues number = new ContentValues(1);
                number.put(SubscriptionManager.NUMBER, msisdn);
                contentResolver.update(SubscriptionManager.CONTENT_URI, number, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
            }
            SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
            String nameToSet;
            String simCarrierName = tm.getSimOperatorName(subId);
            ContentValues name = new ContentValues(1);
            if (subInfo != null && subInfo.getNameSource() != SubscriptionManager.NAME_SOURCE_USER_INPUT) {
                if (!TextUtils.isEmpty(simCarrierName)) {
                    nameToSet = simCarrierName;
                } else {
                    nameToSet = "CARD " + Integer.toString(slotId + 1);
                }
                name.put(SubscriptionManager.DISPLAY_NAME, nameToSet);
                logd("sim name = " + nameToSet);
                contentResolver.update(SubscriptionManager.CONTENT_URI, name, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
            }
            /* Update preferred network type and network selection mode on SIM change.
                 * Storing last subId in SharedPreference for now to detect SIM change. */
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
            int storedSubId = sp.getInt(CURR_SUBID + slotId, -1);
            if (storedSubId != subId) {
                int networkType = RILConstants.PREFERRED_NETWORK_MODE;
                // assigned, use the N/W mode which assigned to it.
                try {
                    networkType = android.provider.Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId);
                } catch (SettingNotFoundException snfe) {
                    logd("Settings Exception reading value at subid for " + "Settings.Global.PREFERRED_NETWORK_MODE");
                    // to be more relevant instead of default mode.
                    try {
                        networkType = TelephonyManager.getIntAtIndex(mContext.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE, slotId);
                    } catch (SettingNotFoundException retrySnfe) {
                        Rlog.e(LOG_TAG, "Settings Exception Reading Value At Index for " + "Settings.Global.PREFERRED_NETWORK_MODE");
                    }
                }
                // Set the modem network mode
                mPhone[slotId].setPreferredNetworkType(networkType, null);
                Settings.Global.putInt(mPhone[slotId].getContext().getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId, networkType);
                // Only support automatic selection mode on SIM change.
                mPhone[slotId].getNetworkSelectionMode(obtainMessage(EVENT_GET_NETWORK_SELECTION_MODE_DONE, new Integer(slotId)));
                // Update stored subId
                SharedPreferences.Editor editor = sp.edit();
                editor.putInt(CURR_SUBID + slotId, subId);
                editor.apply();
            }
        }
    }
    // Update set of enabled carrier apps now that the privilege rules may have changed.
    CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), mPackageManager, TelephonyManager.getDefault(), mContext.getContentResolver(), mCurrentlyActiveUserId);
    broadcastSimStateChanged(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED, null);
    updateCarrierServices(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED);
}
#method_after
private void handleSimLoaded(int slotId) {
    logd("handleSimLoaded: slotId: " + slotId);
    // The SIM should be loaded at this state, but it is possible in cases such as SIM being
    // removed or a refresh RESET that the IccRecords could be null. The right behavior is to
    // not broadcast the SIM loaded.
    int loadedSlotId = slotId;
    IccCard iccCard = mPhone[slotId].getIccCard();
    if (iccCard == null) {
        // Possibly a race condition.
        logd("handleSimLoaded: IccCard null");
        return;
    }
    IccRecords records = iccCard.getIccRecords();
    if (records == null) {
        // Possibly a race condition.
        logd("handleSimLoaded: IccRecords null");
        return;
    }
    if (IccUtils.stripTrailingFs(records.getFullIccId()) == null) {
        logd("handleSimLoaded: IccID null");
        return;
    }
    mIccId[slotId] = IccUtils.stripTrailingFs(records.getFullIccId());
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
        int[] subIds = mSubscriptionManager.getActiveSubscriptionIdList();
        for (int subId : subIds) {
            TelephonyManager tm = TelephonyManager.getDefault();
            String operator = tm.getSimOperatorNumeric(subId);
            slotId = SubscriptionController.getInstance().getPhoneId(subId);
            if (!TextUtils.isEmpty(operator)) {
                if (subId == SubscriptionController.getInstance().getDefaultSubId()) {
                    MccTable.updateMccMncConfiguration(mContext, operator, false);
                }
                SubscriptionController.getInstance().setMccMnc(operator, subId);
            } else {
                logd("EVENT_RECORDS_LOADED Operator name is null");
            }
            String msisdn = tm.getLine1Number(subId);
            ContentResolver contentResolver = mContext.getContentResolver();
            if (msisdn != null) {
                ContentValues number = new ContentValues(1);
                number.put(SubscriptionManager.NUMBER, msisdn);
                contentResolver.update(SubscriptionManager.CONTENT_URI, number, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
                // refresh Cached Active Subscription Info List
                SubscriptionController.getInstance().refreshCachedActiveSubscriptionInfoList();
            }
            SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
            String nameToSet;
            String simCarrierName = tm.getSimOperatorName(subId);
            ContentValues name = new ContentValues(1);
            if (subInfo != null && subInfo.getNameSource() != SubscriptionManager.NAME_SOURCE_USER_INPUT) {
                if (!TextUtils.isEmpty(simCarrierName)) {
                    nameToSet = simCarrierName;
                } else {
                    nameToSet = "CARD " + Integer.toString(slotId + 1);
                }
                name.put(SubscriptionManager.DISPLAY_NAME, nameToSet);
                logd("sim name = " + nameToSet);
                contentResolver.update(SubscriptionManager.CONTENT_URI, name, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
                // refresh Cached Active Subscription Info List
                SubscriptionController.getInstance().refreshCachedActiveSubscriptionInfoList();
            }
            /* Update preferred network type and network selection mode on SIM change.
                 * Storing last subId in SharedPreference for now to detect SIM change. */
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
            int storedSubId = sp.getInt(CURR_SUBID + slotId, -1);
            if (storedSubId != subId) {
                int networkType = Settings.Global.getInt(mPhone[slotId].getContext().getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId, -1);
                if (networkType == -1) {
                    networkType = RILConstants.PREFERRED_NETWORK_MODE;
                    try {
                        networkType = TelephonyManager.getIntAtIndex(mContext.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE, slotId);
                    } catch (SettingNotFoundException retrySnfe) {
                        Rlog.e(LOG_TAG, "Settings Exception Reading Value At Index for " + "Settings.Global.PREFERRED_NETWORK_MODE");
                    }
                    Settings.Global.putInt(mPhone[slotId].getContext().getContentResolver(), Global.PREFERRED_NETWORK_MODE + subId, networkType);
                }
                // Set the modem network mode
                mPhone[slotId].setPreferredNetworkType(networkType, null);
                // Only support automatic selection mode on SIM change.
                mPhone[slotId].getNetworkSelectionMode(obtainMessage(EVENT_GET_NETWORK_SELECTION_MODE_DONE, new Integer(slotId)));
                // Update stored subId
                SharedPreferences.Editor editor = sp.edit();
                editor.putInt(CURR_SUBID + slotId, subId);
                editor.apply();
            }
        }
    }
    // Update set of enabled carrier apps now that the privilege rules may have changed.
    CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), mPackageManager, TelephonyManager.getDefault(), mContext.getContentResolver(), mCurrentlyActiveUserId);
    broadcastSimStateChanged(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED, null);
    broadcastSimCardStateChanged(loadedSlotId, TelephonyManager.SIM_STATE_PRESENT);
    broadcastSimApplicationStateChanged(loadedSlotId, TelephonyManager.SIM_STATE_LOADED);
    updateCarrierServices(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED);
}
#end_block

#method_before
private void handleSimAbsent(int slotId) {
    if (mIccId[slotId] != null && !mIccId[slotId].equals(ICCID_STRING_FOR_NO_SIM)) {
        logd("SIM" + (slotId + 1) + " hot plug out");
    }
    mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_ABSENT);
}
#method_after
private void handleSimAbsent(int slotId) {
    if (mIccId[slotId] != null && !mIccId[slotId].equals(ICCID_STRING_FOR_NO_SIM)) {
        logd("SIM" + (slotId + 1) + " hot plug out");
    }
    mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_ABSENT);
    broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_ABSENT, null);
    broadcastSimCardStateChanged(slotId, TelephonyManager.SIM_STATE_ABSENT);
    broadcastSimApplicationStateChanged(slotId, TelephonyManager.SIM_STATE_NOT_READY);
}
#end_block

#method_before
private void handleSimError(int slotId) {
    if (mIccId[slotId] != null && !mIccId[slotId].equals(ICCID_STRING_FOR_NO_SIM)) {
        logd("SIM" + (slotId + 1) + " Error ");
    }
    mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR);
}
#method_after
private void handleSimError(int slotId) {
    if (mIccId[slotId] != null && !mIccId[slotId].equals(ICCID_STRING_FOR_NO_SIM)) {
        logd("SIM" + (slotId + 1) + " Error ");
    }
    mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR);
    broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR, IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR);
    broadcastSimCardStateChanged(slotId, TelephonyManager.SIM_STATE_CARD_IO_ERROR);
    broadcastSimApplicationStateChanged(slotId, TelephonyManager.SIM_STATE_NOT_READY);
}
#end_block

#method_before
synchronized private void updateSubscriptionInfoByIccId() {
    logd("updateSubscriptionInfoByIccId:+ Start");
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        mInsertSimState[i] = SIM_NOT_CHANGE;
    }
    int insertedSimCount = PROJECT_SIM_NUM;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (ICCID_STRING_FOR_NO_SIM.equals(mIccId[i])) {
            insertedSimCount--;
            mInsertSimState[i] = SIM_NOT_INSERT;
        }
    }
    logd("insertedSimCount = " + insertedSimCount);
    // rebuilding the map.
    if (SubscriptionController.getInstance().getActiveSubIdList().length > insertedSimCount) {
        SubscriptionController.getInstance().clearSubInfo();
    }
    int index = 0;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_NOT_INSERT) {
            continue;
        }
        index = 2;
        for (int j = i + 1; j < PROJECT_SIM_NUM; j++) {
            if (mInsertSimState[j] == SIM_NOT_CHANGE && mIccId[i].equals(mIccId[j])) {
                mInsertSimState[i] = 1;
                mInsertSimState[j] = index;
                index++;
            }
        }
    }
    ContentResolver contentResolver = mContext.getContentResolver();
    String[] oldIccId = new String[PROJECT_SIM_NUM];
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        oldIccId[i] = null;
        List<SubscriptionInfo> oldSubInfo = SubscriptionController.getInstance().getSubInfoUsingSlotIndexWithCheck(i, false, mContext.getOpPackageName());
        if (oldSubInfo != null && oldSubInfo.size() > 0) {
            oldIccId[i] = oldSubInfo.get(0).getIccId();
            logd("updateSubscriptionInfoByIccId: oldSubId = " + oldSubInfo.get(0).getSubscriptionId());
            if (mInsertSimState[i] == SIM_NOT_CHANGE && !mIccId[i].equals(oldIccId[i])) {
                mInsertSimState[i] = SIM_CHANGED;
            }
            if (mInsertSimState[i] != SIM_NOT_CHANGE) {
                ContentValues value = new ContentValues(1);
                value.put(SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.INVALID_SIM_SLOT_INDEX);
                contentResolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Integer.toString(oldSubInfo.get(0).getSubscriptionId()), null);
            }
        } else {
            if (mInsertSimState[i] == SIM_NOT_CHANGE) {
                // no SIM inserted last time, but there is one SIM inserted now
                mInsertSimState[i] = SIM_CHANGED;
            }
            oldIccId[i] = ICCID_STRING_FOR_NO_SIM;
            logd("updateSubscriptionInfoByIccId: No SIM in slot " + i + " last time");
        }
    }
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        logd("updateSubscriptionInfoByIccId: oldIccId[" + i + "] = " + oldIccId[i] + ", sIccId[" + i + "] = " + mIccId[i]);
    }
    // check if the inserted SIM is new SIM
    int nNewCardCount = 0;
    int nNewSimStatus = 0;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_NOT_INSERT) {
            logd("updateSubscriptionInfoByIccId: No SIM inserted in slot " + i + " this time");
        } else {
            if (mInsertSimState[i] > 0) {
                // some special SIMs may have the same IccIds, add suffix to distinguish them
                // FIXME: addSubInfoRecord can return an error.
                mSubscriptionManager.addSubscriptionInfoRecord(mIccId[i] + Integer.toString(mInsertSimState[i]), i);
                logd("SUB" + (i + 1) + " has invalid IccId");
            } else /*if (sInsertSimState[i] != SIM_NOT_INSERT)*/
            {
                mSubscriptionManager.addSubscriptionInfoRecord(mIccId[i], i);
            }
            if (isNewSim(mIccId[i], oldIccId)) {
                nNewCardCount++;
                switch(i) {
                    case PhoneConstants.SUB1:
                        nNewSimStatus |= STATUS_SIM1_INSERTED;
                        break;
                    case PhoneConstants.SUB2:
                        nNewSimStatus |= STATUS_SIM2_INSERTED;
                        break;
                    case PhoneConstants.SUB3:
                        nNewSimStatus |= STATUS_SIM3_INSERTED;
                        break;
                }
                mInsertSimState[i] = SIM_NEW;
            }
        }
    }
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_CHANGED) {
            mInsertSimState[i] = SIM_REPOSITION;
        }
        logd("updateSubscriptionInfoByIccId: sInsertSimState[" + i + "] = " + mInsertSimState[i]);
    }
    List<SubscriptionInfo> subInfos = mSubscriptionManager.getActiveSubscriptionInfoList();
    int nSubCount = (subInfos == null) ? 0 : subInfos.size();
    logd("updateSubscriptionInfoByIccId: nSubCount = " + nSubCount);
    for (int i = 0; i < nSubCount; i++) {
        SubscriptionInfo temp = subInfos.get(i);
        String msisdn = TelephonyManager.getDefault().getLine1Number(temp.getSubscriptionId());
        if (msisdn != null) {
            ContentValues value = new ContentValues(1);
            value.put(SubscriptionManager.NUMBER, msisdn);
            contentResolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Integer.toString(temp.getSubscriptionId()), null);
        }
    }
    // Ensure the modems are mapped correctly
    mSubscriptionManager.setDefaultDataSubId(mSubscriptionManager.getDefaultDataSubscriptionId());
    // No need to check return value here as we notify for the above changes anyway.
    updateEmbeddedSubscriptions();
    SubscriptionController.getInstance().notifySubscriptionInfoChanged();
    logd("updateSubscriptionInfoByIccId:- SubscriptionInfo update complete");
}
#method_after
synchronized private void updateSubscriptionInfoByIccId() {
    logd("updateSubscriptionInfoByIccId:+ Start");
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        mInsertSimState[i] = SIM_NOT_CHANGE;
    }
    int insertedSimCount = PROJECT_SIM_NUM;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (ICCID_STRING_FOR_NO_SIM.equals(mIccId[i])) {
            insertedSimCount--;
            mInsertSimState[i] = SIM_NOT_INSERT;
        }
    }
    logd("insertedSimCount = " + insertedSimCount);
    // rebuilding the map.
    if (SubscriptionController.getInstance().getActiveSubIdList().length > insertedSimCount) {
        SubscriptionController.getInstance().clearSubInfo();
    }
    int index = 0;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_NOT_INSERT) {
            continue;
        }
        index = 2;
        for (int j = i + 1; j < PROJECT_SIM_NUM; j++) {
            if (mInsertSimState[j] == SIM_NOT_CHANGE && mIccId[i].equals(mIccId[j])) {
                mInsertSimState[i] = 1;
                mInsertSimState[j] = index;
                index++;
            }
        }
    }
    ContentResolver contentResolver = mContext.getContentResolver();
    String[] oldIccId = new String[PROJECT_SIM_NUM];
    String[] decIccId = new String[PROJECT_SIM_NUM];
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        oldIccId[i] = null;
        List<SubscriptionInfo> oldSubInfo = SubscriptionController.getInstance().getSubInfoUsingSlotIndexWithCheck(i, false, mContext.getOpPackageName());
        decIccId[i] = IccUtils.getDecimalSubstring(mIccId[i]);
        if (oldSubInfo != null && oldSubInfo.size() > 0) {
            oldIccId[i] = oldSubInfo.get(0).getIccId();
            logd("updateSubscriptionInfoByIccId: oldSubId = " + oldSubInfo.get(0).getSubscriptionId());
            if (mInsertSimState[i] == SIM_NOT_CHANGE && !(mIccId[i].equals(oldIccId[i]) || (decIccId[i] != null && decIccId[i].equals(oldIccId[i])))) {
                mInsertSimState[i] = SIM_CHANGED;
            }
            if (mInsertSimState[i] != SIM_NOT_CHANGE) {
                ContentValues value = new ContentValues(1);
                value.put(SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.INVALID_SIM_SLOT_INDEX);
                contentResolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Integer.toString(oldSubInfo.get(0).getSubscriptionId()), null);
                // refresh Cached Active Subscription Info List
                SubscriptionController.getInstance().refreshCachedActiveSubscriptionInfoList();
            }
        } else {
            if (mInsertSimState[i] == SIM_NOT_CHANGE) {
                // no SIM inserted last time, but there is one SIM inserted now
                mInsertSimState[i] = SIM_CHANGED;
            }
            oldIccId[i] = ICCID_STRING_FOR_NO_SIM;
            logd("updateSubscriptionInfoByIccId: No SIM in slot " + i + " last time");
        }
    }
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        logd("updateSubscriptionInfoByIccId: oldIccId[" + i + "] = " + oldIccId[i] + ", sIccId[" + i + "] = " + mIccId[i]);
    }
    // check if the inserted SIM is new SIM
    int nNewCardCount = 0;
    int nNewSimStatus = 0;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_NOT_INSERT) {
            logd("updateSubscriptionInfoByIccId: No SIM inserted in slot " + i + " this time");
        } else {
            if (mInsertSimState[i] > 0) {
                // some special SIMs may have the same IccIds, add suffix to distinguish them
                // FIXME: addSubInfoRecord can return an error.
                mSubscriptionManager.addSubscriptionInfoRecord(mIccId[i] + Integer.toString(mInsertSimState[i]), i);
                logd("SUB" + (i + 1) + " has invalid IccId");
            } else /*if (sInsertSimState[i] != SIM_NOT_INSERT)*/
            {
                mSubscriptionManager.addSubscriptionInfoRecord(mIccId[i], i);
            }
            if (isNewSim(mIccId[i], decIccId[i], oldIccId)) {
                nNewCardCount++;
                switch(i) {
                    case PhoneConstants.SUB1:
                        nNewSimStatus |= STATUS_SIM1_INSERTED;
                        break;
                    case PhoneConstants.SUB2:
                        nNewSimStatus |= STATUS_SIM2_INSERTED;
                        break;
                    case PhoneConstants.SUB3:
                        nNewSimStatus |= STATUS_SIM3_INSERTED;
                        break;
                }
                mInsertSimState[i] = SIM_NEW;
            }
        }
    }
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (mInsertSimState[i] == SIM_CHANGED) {
            mInsertSimState[i] = SIM_REPOSITION;
        }
        logd("updateSubscriptionInfoByIccId: sInsertSimState[" + i + "] = " + mInsertSimState[i]);
    }
    List<SubscriptionInfo> subInfos = mSubscriptionManager.getActiveSubscriptionInfoList();
    int nSubCount = (subInfos == null) ? 0 : subInfos.size();
    logd("updateSubscriptionInfoByIccId: nSubCount = " + nSubCount);
    for (int i = 0; i < nSubCount; i++) {
        SubscriptionInfo temp = subInfos.get(i);
        String msisdn = TelephonyManager.getDefault().getLine1Number(temp.getSubscriptionId());
        if (msisdn != null) {
            ContentValues value = new ContentValues(1);
            value.put(SubscriptionManager.NUMBER, msisdn);
            contentResolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Integer.toString(temp.getSubscriptionId()), null);
            // refresh Cached Active Subscription Info List
            SubscriptionController.getInstance().refreshCachedActiveSubscriptionInfoList();
        }
    }
    // Ensure the modems are mapped correctly
    mSubscriptionManager.setDefaultDataSubId(mSubscriptionManager.getDefaultDataSubscriptionId());
    // No need to check return value here as we notify for the above changes anyway.
    updateEmbeddedSubscriptions();
    SubscriptionController.getInstance().notifySubscriptionInfoChanged();
    logd("updateSubscriptionInfoByIccId:- SubscriptionInfo update complete");
}
#end_block

#method_before
@VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
public boolean updateEmbeddedSubscriptions() {
    // are filtered out of list calls as long as EuiccManager.isEnabled returns false).
    if (!mEuiccManager.isEnabled()) {
        return false;
    }
    GetEuiccProfileInfoListResult result = EuiccController.get().blockingGetEuiccProfileInfoList();
    if (result == null) {
        // IPC to the eUICC controller failed.
        return false;
    }
    final EuiccProfileInfo[] embeddedProfiles;
    if (result.result == EuiccService.RESULT_OK) {
        embeddedProfiles = result.profiles;
    } else {
        logd("updatedEmbeddedSubscriptions: error " + result.result + " listing profiles");
        // If there's an error listing profiles, treat it equivalently to a successful
        // listing which returned no profiles under the assumption that none are currently
        // accessible.
        embeddedProfiles = new EuiccProfileInfo[0];
    }
    final boolean isRemovable = result.isRemovable;
    final String[] embeddedIccids = new String[embeddedProfiles.length];
    for (int i = 0; i < embeddedProfiles.length; i++) {
        embeddedIccids[i] = embeddedProfiles[i].iccid;
    }
    // Note that this only tracks whether we make any writes to the DB. It's possible this will
    // be set to true for an update even when the row contents remain exactly unchanged from
    // before, since we don't compare against the previous value. Since this is only intended to
    // avoid some spurious broadcasts (particularly for users who don't use eSIM at all), this
    // is fine.
    boolean hasChanges = false;
    // Update or insert records for all embedded subscriptions (except non-removable ones if the
    // current eUICC is non-removable, since we assume these are still accessible though not
    // returned by the eUICC controller).
    List<SubscriptionInfo> existingSubscriptions = SubscriptionController.getInstance().getSubscriptionInfoListForEmbeddedSubscriptionUpdate(embeddedIccids, isRemovable);
    ContentResolver contentResolver = mContext.getContentResolver();
    for (EuiccProfileInfo embeddedProfile : embeddedProfiles) {
        int index = findSubscriptionInfoForIccid(existingSubscriptions, embeddedProfile.iccid);
        if (index < 0) {
            // No existing entry for this ICCID; create an empty one.
            SubscriptionController.getInstance().insertEmptySubInfoRecord(embeddedProfile.iccid, SubscriptionManager.SIM_NOT_INSERTED);
        } else {
            existingSubscriptions.remove(index);
        }
        ContentValues values = new ContentValues();
        values.put(SubscriptionManager.IS_EMBEDDED, 1);
        values.put(SubscriptionManager.ACCESS_RULES, embeddedProfile.accessRules == null ? null : UiccAccessRule.encodeRules(embeddedProfile.accessRules));
        values.put(SubscriptionManager.IS_REMOVABLE, isRemovable);
        values.put(SubscriptionManager.DISPLAY_NAME, embeddedProfile.nickname);
        values.put(SubscriptionManager.NAME_SOURCE, SubscriptionManager.NAME_SOURCE_USER_INPUT);
        hasChanges = true;
        contentResolver.update(SubscriptionManager.CONTENT_URI, values, SubscriptionManager.ICC_ID + "=\"" + embeddedProfile.iccid + "\"", null);
    }
    // SIM being removed and reinserted).
    if (!existingSubscriptions.isEmpty()) {
        List<String> iccidsToRemove = new ArrayList<>();
        for (int i = 0; i < existingSubscriptions.size(); i++) {
            SubscriptionInfo info = existingSubscriptions.get(i);
            if (info.isEmbedded()) {
                iccidsToRemove.add("\"" + info.getIccId() + "\"");
            }
        }
        String whereClause = SubscriptionManager.ICC_ID + " IN (" + TextUtils.join(",", iccidsToRemove) + ")";
        ContentValues values = new ContentValues();
        values.put(SubscriptionManager.IS_EMBEDDED, 0);
        hasChanges = true;
        contentResolver.update(SubscriptionManager.CONTENT_URI, values, whereClause, null);
    }
    return hasChanges;
}
#method_after
@VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
public boolean updateEmbeddedSubscriptions() {
    // are filtered out of list calls as long as EuiccManager.isEnabled returns false).
    if (!mEuiccManager.isEnabled()) {
        return false;
    }
    GetEuiccProfileInfoListResult result = EuiccController.get().blockingGetEuiccProfileInfoList();
    if (result == null) {
        // IPC to the eUICC controller failed.
        return false;
    }
    final EuiccProfileInfo[] embeddedProfiles;
    if (result.getResult() == EuiccService.RESULT_OK) {
        List<EuiccProfileInfo> list = result.getProfiles();
        if (list == null || list.size() == 0) {
            embeddedProfiles = new EuiccProfileInfo[0];
        } else {
            embeddedProfiles = list.toArray(new EuiccProfileInfo[list.size()]);
        }
    } else {
        logd("updatedEmbeddedSubscriptions: error " + result.getResult() + " listing profiles");
        // If there's an error listing profiles, treat it equivalently to a successful
        // listing which returned no profiles under the assumption that none are currently
        // accessible.
        embeddedProfiles = new EuiccProfileInfo[0];
    }
    final boolean isRemovable = result.getIsRemovable();
    final String[] embeddedIccids = new String[embeddedProfiles.length];
    for (int i = 0; i < embeddedProfiles.length; i++) {
        embeddedIccids[i] = embeddedProfiles[i].getIccid();
    }
    // Note that this only tracks whether we make any writes to the DB. It's possible this will
    // be set to true for an update even when the row contents remain exactly unchanged from
    // before, since we don't compare against the previous value. Since this is only intended to
    // avoid some spurious broadcasts (particularly for users who don't use eSIM at all), this
    // is fine.
    boolean hasChanges = false;
    // Update or insert records for all embedded subscriptions (except non-removable ones if the
    // current eUICC is non-removable, since we assume these are still accessible though not
    // returned by the eUICC controller).
    List<SubscriptionInfo> existingSubscriptions = SubscriptionController.getInstance().getSubscriptionInfoListForEmbeddedSubscriptionUpdate(embeddedIccids, isRemovable);
    ContentResolver contentResolver = mContext.getContentResolver();
    for (EuiccProfileInfo embeddedProfile : embeddedProfiles) {
        int index = findSubscriptionInfoForIccid(existingSubscriptions, embeddedProfile.getIccid());
        if (index < 0) {
            // No existing entry for this ICCID; create an empty one.
            SubscriptionController.getInstance().insertEmptySubInfoRecord(embeddedProfile.getIccid(), SubscriptionManager.SIM_NOT_INSERTED);
        } else {
            existingSubscriptions.remove(index);
        }
        ContentValues values = new ContentValues();
        values.put(SubscriptionManager.IS_EMBEDDED, 1);
        List<UiccAccessRule> ruleList = embeddedProfile.getUiccAccessRules();
        boolean isRuleListEmpty = false;
        if (ruleList == null || ruleList.size() == 0) {
            isRuleListEmpty = true;
        }
        values.put(SubscriptionManager.ACCESS_RULES, isRuleListEmpty ? null : UiccAccessRule.encodeRules(ruleList.toArray(new UiccAccessRule[ruleList.size()])));
        values.put(SubscriptionManager.IS_REMOVABLE, isRemovable);
        values.put(SubscriptionManager.DISPLAY_NAME, embeddedProfile.getNickname());
        values.put(SubscriptionManager.NAME_SOURCE, SubscriptionManager.NAME_SOURCE_USER_INPUT);
        hasChanges = true;
        contentResolver.update(SubscriptionManager.CONTENT_URI, values, SubscriptionManager.ICC_ID + "=\"" + embeddedProfile.getIccid() + "\"", null);
        // refresh Cached Active Subscription Info List
        SubscriptionController.getInstance().refreshCachedActiveSubscriptionInfoList();
    }
    // SIM being removed and reinserted).
    if (!existingSubscriptions.isEmpty()) {
        List<String> iccidsToRemove = new ArrayList<>();
        for (int i = 0; i < existingSubscriptions.size(); i++) {
            SubscriptionInfo info = existingSubscriptions.get(i);
            if (info.isEmbedded()) {
                iccidsToRemove.add("\"" + info.getIccId() + "\"");
            }
        }
        String whereClause = SubscriptionManager.ICC_ID + " IN (" + TextUtils.join(",", iccidsToRemove) + ")";
        ContentValues values = new ContentValues();
        values.put(SubscriptionManager.IS_EMBEDDED, 0);
        hasChanges = true;
        contentResolver.update(SubscriptionManager.CONTENT_URI, values, whereClause, null);
        // refresh Cached Active Subscription Info List
        SubscriptionController.getInstance().refreshCachedActiveSubscriptionInfoList();
    }
    return hasChanges;
}
#end_block

#method_before
private boolean isNewSim(String iccId, String[] oldIccId) {
    boolean newSim = true;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (iccId.equals(oldIccId[i])) {
            newSim = false;
            break;
        }
    }
    logd("newSim = " + newSim);
    return newSim;
}
#method_after
private boolean isNewSim(String iccId, String decIccId, String[] oldIccId) {
    boolean newSim = true;
    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
        if (iccId.equals(oldIccId[i])) {
            newSim = false;
            break;
        } else if (decIccId != null && decIccId.equals(oldIccId[i])) {
            newSim = false;
            break;
        }
    }
    logd("newSim = " + newSim);
    return newSim;
}
#end_block

#method_before
private void loadGlobalSettings(SQLiteDatabase db) {
    SQLiteStatement stmt = null;
    try {
        stmt = db.compileStatement("INSERT OR IGNORE INTO global(name,value)" + " VALUES(?,?);");
        // --- Previously in 'system'
        loadBooleanSetting(stmt, Settings.Global.AIRPLANE_MODE_ON, R.bool.def_airplane_mode_on);
        loadBooleanSetting(stmt, Settings.Global.THEATER_MODE_ON, R.bool.def_theater_mode_on);
        loadStringSetting(stmt, Settings.Global.AIRPLANE_MODE_RADIOS, R.string.def_airplane_mode_radios);
        loadStringSetting(stmt, Settings.Global.AIRPLANE_MODE_TOGGLEABLE_RADIOS, R.string.airplane_mode_toggleable_radios);
        loadBooleanSetting(stmt, Settings.Global.ASSISTED_GPS_ENABLED, R.bool.assisted_gps_enabled);
        loadBooleanSetting(stmt, Settings.Global.AUTO_TIME, // Sync time to NITZ
        R.bool.def_auto_time);
        loadBooleanSetting(stmt, Settings.Global.AUTO_TIME_ZONE, // Sync timezone to NITZ
        R.bool.def_auto_time_zone);
        loadSetting(stmt, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, ("1".equals(SystemProperties.get("ro.kernel.qemu")) || mContext.getResources().getBoolean(R.bool.def_stay_on_while_plugged_in)) ? 1 : 0);
        loadIntegerSetting(stmt, Settings.Global.WIFI_SLEEP_POLICY, R.integer.def_wifi_sleep_policy);
        loadSetting(stmt, Settings.Global.MODE_RINGER, AudioManager.RINGER_MODE_NORMAL);
        // --- Previously in 'secure'
        loadBooleanSetting(stmt, Settings.Global.PACKAGE_VERIFIER_ENABLE, R.bool.def_package_verifier_enable);
        loadBooleanSetting(stmt, Settings.Global.WIFI_ON, R.bool.def_wifi_on);
        loadBooleanSetting(stmt, Settings.Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON, R.bool.def_networks_available_notification_on);
        loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_ON, R.bool.def_bluetooth_on);
        // Enable or disable Cell Broadcast SMS
        loadSetting(stmt, Settings.Global.CDMA_CELL_BROADCAST_SMS, RILConstants.CDMA_CELL_BROADCAST_SMS_DISABLED);
        // Data roaming default, based on build
        loadSetting(stmt, Settings.Global.DATA_ROAMING, "true".equalsIgnoreCase(SystemProperties.get("ro.com.android.dataroaming", "false")) ? 1 : 0);
        loadBooleanSetting(stmt, Settings.Global.DEVICE_PROVISIONED, R.bool.def_device_provisioned);
        final int maxBytes = mContext.getResources().getInteger(R.integer.def_download_manager_max_bytes_over_mobile);
        if (maxBytes > 0) {
            loadSetting(stmt, Settings.Global.DOWNLOAD_MAX_BYTES_OVER_MOBILE, Integer.toString(maxBytes));
        }
        final int recommendedMaxBytes = mContext.getResources().getInteger(R.integer.def_download_manager_recommended_max_bytes_over_mobile);
        if (recommendedMaxBytes > 0) {
            loadSetting(stmt, Settings.Global.DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE, Integer.toString(recommendedMaxBytes));
        }
        // Mobile Data default, based on build
        loadSetting(stmt, Settings.Global.MOBILE_DATA, "true".equalsIgnoreCase(SystemProperties.get("ro.com.android.mobiledata", "true")) ? 1 : 0);
        loadBooleanSetting(stmt, Settings.Global.NETSTATS_ENABLED, R.bool.def_netstats_enabled);
        loadBooleanSetting(stmt, Settings.Global.USB_MASS_STORAGE_ENABLED, R.bool.def_usb_mass_storage_enabled);
        loadIntegerSetting(stmt, Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT, R.integer.def_max_dhcp_retries);
        loadBooleanSetting(stmt, Settings.Global.WIFI_DISPLAY_ON, R.bool.def_wifi_display_on);
        loadStringSetting(stmt, Settings.Global.LOCK_SOUND, R.string.def_lock_sound);
        loadStringSetting(stmt, Settings.Global.UNLOCK_SOUND, R.string.def_unlock_sound);
        loadStringSetting(stmt, Settings.Global.TRUSTED_SOUND, R.string.def_trusted_sound);
        loadIntegerSetting(stmt, Settings.Global.POWER_SOUNDS_ENABLED, R.integer.def_power_sounds_enabled);
        loadStringSetting(stmt, Settings.Global.LOW_BATTERY_SOUND, R.string.def_low_battery_sound);
        loadIntegerSetting(stmt, Settings.Global.DOCK_SOUNDS_ENABLED, R.integer.def_dock_sounds_enabled);
        loadIntegerSetting(stmt, Settings.Global.DOCK_SOUNDS_ENABLED_WHEN_ACCESSIBILITY, R.integer.def_dock_sounds_enabled_when_accessibility);
        loadStringSetting(stmt, Settings.Global.DESK_DOCK_SOUND, R.string.def_desk_dock_sound);
        loadStringSetting(stmt, Settings.Global.DESK_UNDOCK_SOUND, R.string.def_desk_undock_sound);
        loadStringSetting(stmt, Settings.Global.CAR_DOCK_SOUND, R.string.def_car_dock_sound);
        loadStringSetting(stmt, Settings.Global.CAR_UNDOCK_SOUND, R.string.def_car_undock_sound);
        loadStringSetting(stmt, Settings.Global.WIRELESS_CHARGING_STARTED_SOUND, R.string.def_wireless_charging_started_sound);
        loadIntegerSetting(stmt, Settings.Global.DOCK_AUDIO_MEDIA_ENABLED, R.integer.def_dock_audio_media_enabled);
        loadSetting(stmt, Settings.Global.SET_INSTALL_LOCATION, 0);
        loadSetting(stmt, Settings.Global.DEFAULT_INSTALL_LOCATION, PackageHelper.APP_INSTALL_AUTO);
        // Set default cdma emergency tone
        loadSetting(stmt, Settings.Global.EMERGENCY_TONE, 0);
        // Set default cdma call auto retry
        loadSetting(stmt, Settings.Global.CALL_AUTO_RETRY, 0);
        // Set the preferred network mode to target desired value or Default
        // value defined in system property
        String val = "";
        String mode = "";
        for (int phoneId = 0; phoneId < TelephonyManager.getDefault().getPhoneCount(); phoneId++) {
            mode = TelephonyManager.getTelephonyProperty(phoneId, "ro.telephony.default_network", Integer.toString(RILConstants.PREFERRED_NETWORK_MODE));
            if (phoneId == 0) {
                val = mode;
            } else {
                val = val + "," + mode;
            }
        }
        loadSetting(stmt, Settings.Global.PREFERRED_NETWORK_MODE, val);
        // Set the preferred cdma subscription source to target desired value or default
        // value defined in Phone
        int type;
        type = SystemProperties.getInt("ro.telephony.default_cdma_sub", Phone.PREFERRED_CDMA_SUBSCRIPTION);
        loadSetting(stmt, Settings.Global.CDMA_SUBSCRIPTION_MODE, type);
        loadIntegerSetting(stmt, Settings.Global.LOW_BATTERY_SOUND_TIMEOUT, R.integer.def_low_battery_sound_timeout);
        loadIntegerSetting(stmt, Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE, R.integer.def_wifi_scan_always_available);
        loadIntegerSetting(stmt, Global.HEADS_UP_NOTIFICATIONS_ENABLED, R.integer.def_heads_up_enabled);
        loadSetting(stmt, Settings.Global.DEVICE_NAME, getDefaultDeviceName());
        loadSetting(stmt, Settings.Global.ENHANCED_4G_MODE_ENABLED, ImsConfig.FeatureValueConstants.ON);
    /*
             * IMPORTANT: Do not add any more upgrade steps here as the global,
             * secure, and system settings are no longer stored in a database
             * but are kept in memory and persisted to XML.
             *
             * See: SettingsProvider.UpgradeController#onUpgradeLocked
             */
    } finally {
        if (stmt != null)
            stmt.close();
    }
}
#method_after
private void loadGlobalSettings(SQLiteDatabase db) {
    SQLiteStatement stmt = null;
    try {
        stmt = db.compileStatement("INSERT OR IGNORE INTO global(name,value)" + " VALUES(?,?);");
        // --- Previously in 'system'
        loadBooleanSetting(stmt, Settings.Global.AIRPLANE_MODE_ON, R.bool.def_airplane_mode_on);
        loadBooleanSetting(stmt, Settings.Global.THEATER_MODE_ON, R.bool.def_theater_mode_on);
        loadStringSetting(stmt, Settings.Global.AIRPLANE_MODE_RADIOS, R.string.def_airplane_mode_radios);
        loadStringSetting(stmt, Settings.Global.AIRPLANE_MODE_TOGGLEABLE_RADIOS, R.string.airplane_mode_toggleable_radios);
        loadBooleanSetting(stmt, Settings.Global.ASSISTED_GPS_ENABLED, R.bool.assisted_gps_enabled);
        loadBooleanSetting(stmt, Settings.Global.AUTO_TIME, // Sync time to NITZ
        R.bool.def_auto_time);
        loadBooleanSetting(stmt, Settings.Global.AUTO_TIME_ZONE, // Sync timezone to NITZ
        R.bool.def_auto_time_zone);
        loadSetting(stmt, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, ("1".equals(SystemProperties.get("ro.kernel.qemu")) || mContext.getResources().getBoolean(R.bool.def_stay_on_while_plugged_in)) ? 1 : 0);
        loadIntegerSetting(stmt, Settings.Global.WIFI_SLEEP_POLICY, R.integer.def_wifi_sleep_policy);
        loadSetting(stmt, Settings.Global.MODE_RINGER, AudioManager.RINGER_MODE_NORMAL);
        // --- Previously in 'secure'
        loadBooleanSetting(stmt, Settings.Global.PACKAGE_VERIFIER_ENABLE, R.bool.def_package_verifier_enable);
        loadBooleanSetting(stmt, Settings.Global.WIFI_ON, R.bool.def_wifi_on);
        loadBooleanSetting(stmt, Settings.Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON, R.bool.def_networks_available_notification_on);
        loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_ON, R.bool.def_bluetooth_on);
        // Enable or disable Cell Broadcast SMS
        loadSetting(stmt, Settings.Global.CDMA_CELL_BROADCAST_SMS, RILConstants.CDMA_CELL_BROADCAST_SMS_DISABLED);
        // Data roaming default, based on build
        loadSetting(stmt, Settings.Global.DATA_ROAMING, "true".equalsIgnoreCase(SystemProperties.get("ro.com.android.dataroaming", "false")) ? 1 : 0);
        loadBooleanSetting(stmt, Settings.Global.DEVICE_PROVISIONED, R.bool.def_device_provisioned);
        final int maxBytes = mContext.getResources().getInteger(R.integer.def_download_manager_max_bytes_over_mobile);
        if (maxBytes > 0) {
            loadSetting(stmt, Settings.Global.DOWNLOAD_MAX_BYTES_OVER_MOBILE, Integer.toString(maxBytes));
        }
        final int recommendedMaxBytes = mContext.getResources().getInteger(R.integer.def_download_manager_recommended_max_bytes_over_mobile);
        if (recommendedMaxBytes > 0) {
            loadSetting(stmt, Settings.Global.DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE, Integer.toString(recommendedMaxBytes));
        }
        // Mobile Data default, based on build
        loadSetting(stmt, Settings.Global.MOBILE_DATA, "true".equalsIgnoreCase(SystemProperties.get("ro.com.android.mobiledata", "true")) ? 1 : 0);
        loadBooleanSetting(stmt, Settings.Global.NETSTATS_ENABLED, R.bool.def_netstats_enabled);
        loadBooleanSetting(stmt, Settings.Global.USB_MASS_STORAGE_ENABLED, R.bool.def_usb_mass_storage_enabled);
        loadIntegerSetting(stmt, Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT, R.integer.def_max_dhcp_retries);
        loadBooleanSetting(stmt, Settings.Global.WIFI_DISPLAY_ON, R.bool.def_wifi_display_on);
        loadStringSetting(stmt, Settings.Global.LOCK_SOUND, R.string.def_lock_sound);
        loadStringSetting(stmt, Settings.Global.UNLOCK_SOUND, R.string.def_unlock_sound);
        loadStringSetting(stmt, Settings.Global.TRUSTED_SOUND, R.string.def_trusted_sound);
        loadIntegerSetting(stmt, Settings.Global.POWER_SOUNDS_ENABLED, R.integer.def_power_sounds_enabled);
        loadStringSetting(stmt, Settings.Global.LOW_BATTERY_SOUND, R.string.def_low_battery_sound);
        loadIntegerSetting(stmt, Settings.Global.DOCK_SOUNDS_ENABLED, R.integer.def_dock_sounds_enabled);
        loadIntegerSetting(stmt, Settings.Global.DOCK_SOUNDS_ENABLED_WHEN_ACCESSIBILITY, R.integer.def_dock_sounds_enabled_when_accessibility);
        loadStringSetting(stmt, Settings.Global.DESK_DOCK_SOUND, R.string.def_desk_dock_sound);
        loadStringSetting(stmt, Settings.Global.DESK_UNDOCK_SOUND, R.string.def_desk_undock_sound);
        loadStringSetting(stmt, Settings.Global.CAR_DOCK_SOUND, R.string.def_car_dock_sound);
        loadStringSetting(stmt, Settings.Global.CAR_UNDOCK_SOUND, R.string.def_car_undock_sound);
        loadStringSetting(stmt, Settings.Global.WIRELESS_CHARGING_STARTED_SOUND, R.string.def_wireless_charging_started_sound);
        loadIntegerSetting(stmt, Settings.Global.DOCK_AUDIO_MEDIA_ENABLED, R.integer.def_dock_audio_media_enabled);
        loadSetting(stmt, Settings.Global.SET_INSTALL_LOCATION, 0);
        loadSetting(stmt, Settings.Global.DEFAULT_INSTALL_LOCATION, PackageHelper.APP_INSTALL_AUTO);
        // Set default cdma emergency tone
        loadSetting(stmt, Settings.Global.EMERGENCY_TONE, 0);
        // Set default cdma call auto retry
        loadSetting(stmt, Settings.Global.CALL_AUTO_RETRY, 0);
        // Set the preferred network mode to target desired value or Default
        // value defined in system property
        String val = "";
        String mode;
        for (int phoneId = 0; phoneId < TelephonyManager.getDefault().getPhoneCount(); phoneId++) {
            mode = TelephonyManager.getTelephonyProperty(phoneId, "ro.telephony.default_network", Integer.toString(RILConstants.PREFERRED_NETWORK_MODE));
            if (phoneId == 0) {
                val = mode;
            } else {
                val = val + "," + mode;
            }
        }
        loadSetting(stmt, Settings.Global.PREFERRED_NETWORK_MODE, val);
        // Set the preferred cdma subscription source to target desired value or default
        // value defined in Phone
        int type = SystemProperties.getInt("ro.telephony.default_cdma_sub", Phone.PREFERRED_CDMA_SUBSCRIPTION);
        loadSetting(stmt, Settings.Global.CDMA_SUBSCRIPTION_MODE, type);
        loadIntegerSetting(stmt, Settings.Global.LOW_BATTERY_SOUND_TIMEOUT, R.integer.def_low_battery_sound_timeout);
        loadIntegerSetting(stmt, Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE, R.integer.def_wifi_scan_always_available);
        loadIntegerSetting(stmt, Global.HEADS_UP_NOTIFICATIONS_ENABLED, R.integer.def_heads_up_enabled);
        loadSetting(stmt, Settings.Global.DEVICE_NAME, getDefaultDeviceName());
        loadSetting(stmt, Settings.Global.ENHANCED_4G_MODE_ENABLED, ImsConfig.FeatureValueConstants.ON);
    /*
             * IMPORTANT: Do not add any more upgrade steps here as the global,
             * secure, and system settings are no longer stored in a database
             * but are kept in memory and persisted to XML.
             *
             * See: SettingsProvider.UpgradeController#onUpgradeLocked
             */
    } finally {
        if (stmt != null)
            stmt.close();
    }
}
#end_block

#method_before
private static void computeApkVerityDigest(DataSource beforeCentralDir, DataSource centralDir, DataSource eocd, Map<ContentDigestAlgorithm, byte[]> outputContentDigests) throws IOException, NoSuchAlgorithmException {
    // FORMAT:
    // OFFSET       DATA TYPE  DESCRIPTION
    // * @+0  bytes uint8[32]  Merkle tree root hash of SHA-256
    // * @+32 bytes int64      Length of source data
    byte[] backBuffer = new byte[ContentDigestAlgorithm.VERITY_CHUNKED_SHA256.getChunkDigestOutputSizeBytes() + Long.SIZE / 8];
    ByteBuffer encoded = ByteBuffer.wrap(backBuffer);
    encoded.order(ByteOrder.LITTLE_ENDIAN);
    // Use 0s as salt for now.  This also needs to be consistent in the fsverify header for
    // kernel to use.
    VerityTreeBuilder builder = new VerityTreeBuilder(new byte[8]);
    byte[] rootHash = builder.generateVerityTreeRootHash(beforeCentralDir, centralDir, eocd);
    encoded.put(rootHash);
    encoded.putLong(beforeCentralDir.size() + centralDir.size() + eocd.size());
    outputContentDigests.put(ContentDigestAlgorithm.VERITY_CHUNKED_SHA256, backBuffer);
}
#method_after
private static void computeApkVerityDigest(DataSource beforeCentralDir, DataSource centralDir, DataSource eocd, Map<ContentDigestAlgorithm, byte[]> outputContentDigests) throws IOException, NoSuchAlgorithmException {
    // FORMAT:
    // OFFSET       DATA TYPE  DESCRIPTION
    // * @+0  bytes uint8[32]  Merkle tree root hash of SHA-256
    // * @+32 bytes int64      Length of source data
    int backBufferSize = ContentDigestAlgorithm.VERITY_CHUNKED_SHA256.getChunkDigestOutputSizeBytes() + Long.SIZE / Byte.SIZE;
    ByteBuffer encoded = ByteBuffer.allocate(backBufferSize);
    encoded.order(ByteOrder.LITTLE_ENDIAN);
    // Use 0s as salt for now.  This also needs to be consistent in the fsverify header for
    // kernel to use.
    VerityTreeBuilder builder = new VerityTreeBuilder(new byte[8]);
    byte[] rootHash = builder.generateVerityTreeRootHash(beforeCentralDir, centralDir, eocd);
    encoded.put(rootHash);
    encoded.putLong(beforeCentralDir.size() + centralDir.size() + eocd.size());
    outputContentDigests.put(ContentDigestAlgorithm.VERITY_CHUNKED_SHA256, encoded.array());
}
#end_block

#method_before
public static boolean updateBandwidths(int[] bandwidths, ServiceState serviceState) {
    if (bandwidths == null) {
        return false;
    }
    int ssAggregateBandwidth = 0;
    int[] ssBandwidths = serviceState.getCellBandwidths();
    if (ssBandwidths != null) {
        for (int bw : ssBandwidths) {
            ssAggregateBandwidth += bw;
        }
    }
    int newAggregateBandwidth = 0;
    for (int bw : bandwidths) {
        newAggregateBandwidth += bw;
    }
    if (newAggregateBandwidth > ssAggregateBandwidth) {
        serviceState.setCellBandwidths(bandwidths);
        return true;
    }
    return false;
}
#method_after
public static boolean updateBandwidths(int[] bandwidths, ServiceState serviceState) {
    if (bandwidths == null) {
        return false;
    }
    int ssAggregateBandwidth = Arrays.stream(serviceState.getCellBandwidths()).sum();
    int newAggregateBandwidth = Arrays.stream(bandwidths).sum();
    if (newAggregateBandwidth > ssAggregateBandwidth) {
        serviceState.setCellBandwidths(bandwidths);
        return true;
    }
    return false;
}
#end_block

#method_before
public void ratchet(ServiceState oldSS, ServiceState newSS) {
    int newVoiceRat = ratchetRat(oldSS.getRilVoiceRadioTechnology(), newSS.getRilVoiceRadioTechnology());
    int newDataRat = ratchetRat(oldSS.getRilDataRadioTechnology(), newSS.getRilDataRadioTechnology());
    boolean newUsingCA = oldSS.isUsingCarrierAggregation() || newSS.isUsingCarrierAggregation();
    if (isSameRatFamily(oldSS, newSS)) {
        updateBandwidths(oldSS.getCellBandwidths(), newSS);
    }
    newSS.setRilVoiceRadioTechnology(newVoiceRat);
    newSS.setRilDataRadioTechnology(newDataRat);
    newSS.setIsUsingCarrierAggregation(newUsingCA);
}
#method_after
public void ratchet(ServiceState oldSS, ServiceState newSS) {
    int newVoiceRat = ratchetRat(oldSS.getRilVoiceRadioTechnology(), newSS.getRilVoiceRadioTechnology());
    int newDataRat = ratchetRat(oldSS.getRilDataRadioTechnology(), newSS.getRilDataRadioTechnology());
    if (isSameRatFamily(oldSS, newSS)) {
        updateBandwidths(oldSS.getCellBandwidths(), newSS);
    }
    boolean newUsingCA = oldSS.isUsingCarrierAggregation() || newSS.isUsingCarrierAggregation() || newSS.getCellBandwidths().length > 1;
    newSS.setRilVoiceRadioTechnology(newVoiceRat);
    newSS.setRilDataRadioTechnology(newDataRat);
    newSS.setIsUsingCarrierAggregation(newUsingCA);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    if (VDBG)
        log("received event " + msg.what);
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            if (mUiccApplcation != null && mUiccApplcation.getState() != AppState.APPSTATE_READY) {
                mIsSimReady = false;
                updateSpnDisplay();
            }
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        case EVENT_RADIO_POWER_OFF_DONE:
            if (DBG)
                log("EVENT_RADIO_POWER_OFF_DONE");
            if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
                // during shutdown the modem may not send radio state changed event
                // as a result of radio power request
                // Hence, issuing shut down regardless of radio power response
                mCi.requestShutdown(null);
            }
            break;
        // GSM
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            mIsSimReady = true;
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                CellIdentity cellIdentity = ((NetworkRegistrationState) ar.result).getCellIdentity();
                processCellLocationInfo(mCellLoc, cellIdentity);
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mRegStateManagers.get(AccessNetworkConstants.TransportType.WWAN).getNetworkRegistrationState(NetworkRegistrationState.DOMAIN_CS, obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_SIM_NOT_INSERTED:
            if (DBG)
                log("EVENT_SIM_NOT_INSERTED");
            cancelAllNotifications();
            mMdn = null;
            mMin = null;
            mIsMinInfoReady = false;
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        case EVENT_IMS_SERVICE_STATE_CHANGED:
            if (DBG)
                log("EVENT_IMS_SERVICE_STATE_CHANGED");
            // GsmCdma phone is not STATE_IN_SERVICE.
            if (mSS.getState() != ServiceState.STATE_IN_SERVICE) {
                mPhone.notifyServiceStateChanged(mPhone.getServiceState());
            }
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        case EVENT_RADIO_POWER_FROM_CARRIER:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                boolean enable = (boolean) ar.result;
                if (DBG)
                    log("EVENT_RADIO_POWER_FROM_CARRIER: " + enable);
                setRadioPowerFromCarrier(enable);
            }
            break;
        case EVENT_PHYSICAL_CHANNEL_CONFIG:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                List<PhysicalChannelConfig> list = (List<PhysicalChannelConfig>) ar.result;
                if (VDBG) {
                    log("EVENT_PHYSICAL_CHANNEL_CONFIG: size=" + list.size() + " list=" + list);
                }
                mPhone.notifyPhysicalChannelConfiguration(list);
                int[] bandwidths = new int[list.size()];
                for (int i = 0; i < bandwidths.length; i++) {
                    bandwidths[i] = list.get(i).getCellBandwidthDownlink();
                }
                // only notify if bandwidths changed
                if (RatRatcheter.updateBandwidths(bandwidths, mSS)) {
                    mPhone.notifyServiceStateChanged(mSS);
                }
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    if (VDBG)
        log("received event " + msg.what);
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            if (mUiccApplcation != null && mUiccApplcation.getState() != AppState.APPSTATE_READY) {
                mIsSimReady = false;
                updateSpnDisplay();
            }
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        case EVENT_RADIO_POWER_OFF_DONE:
            if (DBG)
                log("EVENT_RADIO_POWER_OFF_DONE");
            if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
                // during shutdown the modem may not send radio state changed event
                // as a result of radio power request
                // Hence, issuing shut down regardless of radio power response
                mCi.requestShutdown(null);
            }
            break;
        // GSM
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            mIsSimReady = true;
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                CellIdentity cellIdentity = ((NetworkRegistrationState) ar.result).getCellIdentity();
                processCellLocationInfo(mCellLoc, cellIdentity);
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mRegStateManagers.get(AccessNetworkConstants.TransportType.WWAN).getNetworkRegistrationState(NetworkRegistrationState.DOMAIN_CS, obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_SIM_NOT_INSERTED:
            if (DBG)
                log("EVENT_SIM_NOT_INSERTED");
            cancelAllNotifications();
            mMdn = null;
            mMin = null;
            mIsMinInfoReady = false;
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        case EVENT_IMS_SERVICE_STATE_CHANGED:
            if (DBG)
                log("EVENT_IMS_SERVICE_STATE_CHANGED");
            // GsmCdma phone is not STATE_IN_SERVICE.
            if (mSS.getState() != ServiceState.STATE_IN_SERVICE) {
                mPhone.notifyServiceStateChanged(mPhone.getServiceState());
            }
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        case EVENT_RADIO_POWER_FROM_CARRIER:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                boolean enable = (boolean) ar.result;
                if (DBG)
                    log("EVENT_RADIO_POWER_FROM_CARRIER: " + enable);
                setRadioPowerFromCarrier(enable);
            }
            break;
        case EVENT_PHYSICAL_CHANNEL_CONFIG:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                List<PhysicalChannelConfig> list = (List<PhysicalChannelConfig>) ar.result;
                if (VDBG) {
                    log("EVENT_PHYSICAL_CHANNEL_CONFIG: size=" + list.size() + " list=" + list);
                }
                mPhone.notifyPhysicalChannelConfiguration(list);
                // only notify if bandwidths changed
                if (RatRatcheter.updateBandwidths(getBandwidthsFromConfigs(list), mSS)) {
                    mPhone.notifyServiceStateChanged(mSS);
                }
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#end_block

#method_before
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (Build.IS_DEBUGGABLE && mPhone.mTelephonyTester != null) {
        mPhone.mTelephonyTester.overrideServiceState(mNewSS);
    }
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // ratchet the new tech up through it's rat family but don't drop back down
    // until cell change or device is OOS
    boolean isDataInService = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    if (!hasLocationChanged && isDataInService) {
        mRatRatcheter.ratchet(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    ServiceState oldMergedSS = mPhone.getServiceState();
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        mNitzState.handleNetworkAvailable();
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
        mNitzState.handleNetworkUnavailable();
    }
    if (hasRejectCauseChanged) {
        setNotification(CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String prevCountryIsoCode = tm.getNetworkCountryIso(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mNitzState.handleNetworkUnavailable();
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update IDD.
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            // Update ISO.
            String countryIsoCode = "";
            try {
                String mcc = operatorNumeric.substring(0, 3);
                countryIsoCode = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), countryIsoCode);
            // Update Time Zone.
            boolean iccCardExists = iccCardExists();
            boolean networkIsoChanged = networkCountryIsoChanged(countryIsoCode, prevCountryIsoCode);
            // Determine countryChanged: networkIso is only reliable if there's an ICC card.
            boolean countryChanged = iccCardExists && networkIsoChanged;
            if (DBG) {
                long ctm = System.currentTimeMillis();
                log("Before handleNetworkCountryCodeKnown:" + " countryChanged=" + countryChanged + " iccCardExist=" + iccCardExists + " countryIsoChanged=" + networkIsoChanged + " operatorNumeric=" + operatorNumeric + " prevOperatorNumeric=" + prevOperatorNumeric + " countryIsoCode=" + countryIsoCode + " prevCountryIsoCode=" + prevCountryIsoCode + " ltod=" + TimeUtils.logTimeOfDay(ctm));
            }
            mNitzState.handleNetworkCountryCodeSet(countryChanged);
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify service state changed only if the merged service state is changed.
        if (!oldMergedSS.equals(mPhone.getServiceState())) {
            mPhone.notifyServiceStateChanged(mPhone.getServiceState());
        }
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#method_after
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (Build.IS_DEBUGGABLE && mPhone.mTelephonyTester != null) {
        mPhone.mTelephonyTester.overrideServiceState(mNewSS);
    }
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // ratchet the new tech up through its rat family but don't drop back down
    // until cell change or device is OOS
    boolean isDataInService = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    if (!hasLocationChanged && isDataInService) {
        mRatRatcheter.ratchet(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    ServiceState oldMergedSS = mPhone.getServiceState();
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        mNitzState.handleNetworkAvailable();
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
        mNitzState.handleNetworkUnavailable();
    }
    if (hasRejectCauseChanged) {
        setNotification(CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String prevCountryIsoCode = tm.getNetworkCountryIso(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mNitzState.handleNetworkUnavailable();
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update IDD.
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            // Update ISO.
            String countryIsoCode = "";
            try {
                String mcc = operatorNumeric.substring(0, 3);
                countryIsoCode = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), countryIsoCode);
            // Update Time Zone.
            boolean iccCardExists = iccCardExists();
            boolean networkIsoChanged = networkCountryIsoChanged(countryIsoCode, prevCountryIsoCode);
            // Determine countryChanged: networkIso is only reliable if there's an ICC card.
            boolean countryChanged = iccCardExists && networkIsoChanged;
            if (DBG) {
                long ctm = System.currentTimeMillis();
                log("Before handleNetworkCountryCodeKnown:" + " countryChanged=" + countryChanged + " iccCardExist=" + iccCardExists + " countryIsoChanged=" + networkIsoChanged + " operatorNumeric=" + operatorNumeric + " prevOperatorNumeric=" + prevOperatorNumeric + " countryIsoCode=" + countryIsoCode + " prevCountryIsoCode=" + prevCountryIsoCode + " ltod=" + TimeUtils.logTimeOfDay(ctm));
            }
            mNitzState.handleNetworkCountryCodeSet(countryChanged);
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify service state changed only if the merged service state is changed.
        if (!oldMergedSS.equals(mPhone.getServiceState())) {
            mPhone.notifyServiceStateChanged(mPhone.getServiceState());
        }
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#end_block

#method_before
@Override
public void updatePackagesIfNeeded() {
    enforceSystemOrRoot("Only the system can request package update");
    // We need to re-extract after an OTA.
    boolean causeUpgrade = isUpgrade();
    // First boot or factory reset.
    // Note: we also handle devices that are upgrading to N right now as if it is their
    // first boot, as they do not have profile data.
    boolean causeFirstBoot = isFirstBoot() || mIsPreNUpgrade;
    // We need to re-extract after a pruned cache, as AoT-ed files will be out of date.
    boolean causePrunedCache = VMRuntime.didPruneDalvikCache();
    if (!causeUpgrade && !causeFirstBoot && !causePrunedCache) {
        return;
    }
    List<PackageParser.Package> pkgs;
    synchronized (mPackages) {
        pkgs = PackageManagerServiceUtils.getPackagesForDexopt(mPackages.values(), this);
    }
    final long startTime = System.nanoTime();
    final int[] stats = performDexOptUpgrade(pkgs, mIsPreNUpgrade, /* showDialog */
    getCompilerFilterForReason(causeFirstBoot ? REASON_FIRST_BOOT : REASON_BOOT), false);
    final int elapsedTimeSeconds = (int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime);
    MetricsLogger.histogram(mContext, "opt_dialog_num_dexopted", stats[0]);
    MetricsLogger.histogram(mContext, "opt_dialog_num_skipped", stats[1]);
    MetricsLogger.histogram(mContext, "opt_dialog_num_failed", stats[2]);
    MetricsLogger.histogram(mContext, "opt_dialog_num_total", getOptimizablePackages().size());
    MetricsLogger.histogram(mContext, "opt_dialog_time_s", elapsedTimeSeconds);
}
#method_after
@Override
public void updatePackagesIfNeeded() {
    enforceSystemOrRoot("Only the system can request package update");
    // We need to re-extract after an OTA.
    boolean causeUpgrade = isUpgrade();
    // First boot or factory reset.
    // Note: we also handle devices that are upgrading to N right now as if it is their
    // first boot, as they do not have profile data.
    boolean causeFirstBoot = isFirstBoot() || mIsPreNUpgrade;
    // We need to re-extract after a pruned cache, as AoT-ed files will be out of date.
    boolean causePrunedCache = VMRuntime.didPruneDalvikCache();
    if (!causeUpgrade && !causeFirstBoot && !causePrunedCache) {
        return;
    }
    List<PackageParser.Package> pkgs;
    synchronized (mPackages) {
        pkgs = PackageManagerServiceUtils.getPackagesForDexopt(mPackages.values(), this);
    }
    final long startTime = System.nanoTime();
    final int[] stats = performDexOptUpgrade(pkgs, mIsPreNUpgrade, /* showDialog */
    causeFirstBoot ? REASON_FIRST_BOOT : REASON_BOOT, false);
    final int elapsedTimeSeconds = (int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime);
    MetricsLogger.histogram(mContext, "opt_dialog_num_dexopted", stats[0]);
    MetricsLogger.histogram(mContext, "opt_dialog_num_skipped", stats[1]);
    MetricsLogger.histogram(mContext, "opt_dialog_num_failed", stats[2]);
    MetricsLogger.histogram(mContext, "opt_dialog_num_total", getOptimizablePackages().size());
    MetricsLogger.histogram(mContext, "opt_dialog_time_s", elapsedTimeSeconds);
}
#end_block

#method_before
private int[] performDexOptUpgrade(List<PackageParser.Package> pkgs, boolean showDialog, final String compilerFilter, boolean bootComplete) {
    int numberOfPackagesVisited = 0;
    int numberOfPackagesOptimized = 0;
    int numberOfPackagesSkipped = 0;
    int numberOfPackagesFailed = 0;
    final int numberOfPackagesToDexopt = pkgs.size();
    for (PackageParser.Package pkg : pkgs) {
        numberOfPackagesVisited++;
        boolean useProfileForDexopt = false;
        if ((isFirstBoot() || isUpgrade()) && isSystemApp(pkg)) {
            // Copy over initial preopt profiles since we won't get any JIT samples for methods
            // that are already compiled.
            File profileFile = new File(getPrebuildProfilePath(pkg));
            // Copy profile if it exists.
            if (profileFile.exists()) {
                try {
                    // is that we don't have a good way to say "do this only once".
                    if (!mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName)) {
                        Log.e(TAG, "Installer failed to copy system profile!");
                    } else {
                    // Disabled as this causes speed-profile compilation during first boot
                    // even if things are already compiled.
                    // useProfileForDexopt = true;
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e);
                }
            } else {
                PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                // The other paths will not change the filter.
                if (disabledPs != null && disabledPs.pkg.isStub) {
                    // The package is the stub one, remove the stub suffix to get the normal
                    // package and APK names.
                    String systemProfilePath = getPrebuildProfilePath(disabledPs.pkg).replace(STUB_SUFFIX, "");
                    profileFile = new File(systemProfilePath);
                    // directories are not set up at that point.
                    if (profileFile.exists()) {
                        try {
                            // once".
                            if (!mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName)) {
                                Log.e(TAG, "Failed to copy system profile for stub package!");
                            } else {
                                useProfileForDexopt = true;
                            }
                        } catch (Exception e) {
                            Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e);
                        }
                    }
                }
            }
        }
        if (!PackageDexOptimizer.canOptimizePackage(pkg)) {
            if (DEBUG_DEXOPT) {
                Log.i(TAG, "Skipping update of of non-optimizable app " + pkg.packageName);
            }
            numberOfPackagesSkipped++;
            continue;
        }
        if (DEBUG_DEXOPT) {
            Log.i(TAG, "Updating app " + numberOfPackagesVisited + " of " + numberOfPackagesToDexopt + ": " + pkg.packageName);
        }
        if (showDialog) {
            try {
                ActivityManager.getService().showBootMessage(mContext.getResources().getString(R.string.android_upgrading_apk, numberOfPackagesVisited, numberOfPackagesToDexopt), true);
            } catch (RemoteException e) {
            }
            synchronized (mPackages) {
                mDexOptDialogShown = true;
            }
        }
        String pkgCompilerFilter = compilerFilter;
        if (useProfileForDexopt) {
            // Use background dexopt mode to try and use the profile. Note that this does not
            // guarantee usage of the profile.
            pkgCompilerFilter = PackageManagerServiceCompilerMapping.getCompilerFilterForReason(PackageManagerService.REASON_BACKGROUND_DEXOPT);
        }
        // checkProfiles is false to avoid merging profiles during boot which
        // might interfere with background compilation (b/28612421).
        // Unfortunately this will also means that "pm.dexopt.boot=speed-profile" will
        // behave differently than "pm.dexopt.bg-dexopt=speed-profile" but that's a
        // trade-off worth doing to save boot time work.
        int dexoptFlags = bootComplete ? DexoptOptions.DEXOPT_BOOT_COMPLETE : 0;
        int primaryDexOptStaus = performDexOptTraced(new DexoptOptions(pkg.packageName, pkgCompilerFilter, dexoptFlags));
        switch(primaryDexOptStaus) {
            case PackageDexOptimizer.DEX_OPT_PERFORMED:
                numberOfPackagesOptimized++;
                break;
            case PackageDexOptimizer.DEX_OPT_SKIPPED:
                numberOfPackagesSkipped++;
                break;
            case PackageDexOptimizer.DEX_OPT_FAILED:
                numberOfPackagesFailed++;
                break;
            default:
                Log.e(TAG, "Unexpected dexopt return code " + primaryDexOptStaus);
                break;
        }
    }
    return new int[] { numberOfPackagesOptimized, numberOfPackagesSkipped, numberOfPackagesFailed };
}
#method_after
private int[] performDexOptUpgrade(List<PackageParser.Package> pkgs, boolean showDialog, final int compilationReason, boolean bootComplete) {
    int numberOfPackagesVisited = 0;
    int numberOfPackagesOptimized = 0;
    int numberOfPackagesSkipped = 0;
    int numberOfPackagesFailed = 0;
    final int numberOfPackagesToDexopt = pkgs.size();
    for (PackageParser.Package pkg : pkgs) {
        numberOfPackagesVisited++;
        boolean useProfileForDexopt = false;
        if ((isFirstBoot() || isUpgrade()) && isSystemApp(pkg)) {
            // Copy over initial preopt profiles since we won't get any JIT samples for methods
            // that are already compiled.
            File profileFile = new File(getPrebuildProfilePath(pkg));
            // Copy profile if it exists.
            if (profileFile.exists()) {
                try {
                    // is that we don't have a good way to say "do this only once".
                    if (!mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName(null))) {
                        Log.e(TAG, "Installer failed to copy system profile!");
                    } else {
                    // Disabled as this causes speed-profile compilation during first boot
                    // even if things are already compiled.
                    // useProfileForDexopt = true;
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e);
                }
            } else {
                PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                // The other paths will not change the filter.
                if (disabledPs != null && disabledPs.pkg.isStub) {
                    // The package is the stub one, remove the stub suffix to get the normal
                    // package and APK names.
                    String systemProfilePath = getPrebuildProfilePath(disabledPs.pkg).replace(STUB_SUFFIX, "");
                    profileFile = new File(systemProfilePath);
                    // directories are not set up at that point.
                    if (profileFile.exists()) {
                        try {
                            // once".
                            if (!mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName(null))) {
                                Log.e(TAG, "Failed to copy system profile for stub package!");
                            } else {
                                useProfileForDexopt = true;
                            }
                        } catch (Exception e) {
                            Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e);
                        }
                    }
                }
            }
        }
        if (!PackageDexOptimizer.canOptimizePackage(pkg)) {
            if (DEBUG_DEXOPT) {
                Log.i(TAG, "Skipping update of of non-optimizable app " + pkg.packageName);
            }
            numberOfPackagesSkipped++;
            continue;
        }
        if (DEBUG_DEXOPT) {
            Log.i(TAG, "Updating app " + numberOfPackagesVisited + " of " + numberOfPackagesToDexopt + ": " + pkg.packageName);
        }
        if (showDialog) {
            try {
                ActivityManager.getService().showBootMessage(mContext.getResources().getString(R.string.android_upgrading_apk, numberOfPackagesVisited, numberOfPackagesToDexopt), true);
            } catch (RemoteException e) {
            }
            synchronized (mPackages) {
                mDexOptDialogShown = true;
            }
        }
        int pkgCompilationReason = compilationReason;
        if (useProfileForDexopt) {
            // Use background dexopt mode to try and use the profile. Note that this does not
            // guarantee usage of the profile.
            pkgCompilationReason = PackageManagerService.REASON_BACKGROUND_DEXOPT;
        }
        // checkProfiles is false to avoid merging profiles during boot which
        // might interfere with background compilation (b/28612421).
        // Unfortunately this will also means that "pm.dexopt.boot=speed-profile" will
        // behave differently than "pm.dexopt.bg-dexopt=speed-profile" but that's a
        // trade-off worth doing to save boot time work.
        int dexoptFlags = bootComplete ? DexoptOptions.DEXOPT_BOOT_COMPLETE : 0;
        if (compilationReason == REASON_FIRST_BOOT) {
            // TODO: This doesn't cover the upgrade case, we should check for this too.
            dexoptFlags |= DexoptOptions.DEXOPT_INSTALL_WITH_DEX_METADATA_FILE;
        }
        int primaryDexOptStaus = performDexOptTraced(new DexoptOptions(pkg.packageName, pkgCompilationReason, dexoptFlags));
        switch(primaryDexOptStaus) {
            case PackageDexOptimizer.DEX_OPT_PERFORMED:
                numberOfPackagesOptimized++;
                break;
            case PackageDexOptimizer.DEX_OPT_SKIPPED:
                numberOfPackagesSkipped++;
                break;
            case PackageDexOptimizer.DEX_OPT_FAILED:
                numberOfPackagesFailed++;
                break;
            default:
                Log.e(TAG, "Unexpected dexopt return code " + primaryDexOptStaus);
                break;
        }
    }
    return new int[] { numberOfPackagesOptimized, numberOfPackagesSkipped, numberOfPackagesFailed };
}
#end_block

#method_before
@Override
public boolean performDexOptMode(String packageName, boolean checkProfiles, String targetCompilerFilter, boolean force, boolean bootComplete, String splitName) {
    int flags = (checkProfiles ? DexoptOptions.DEXOPT_CHECK_FOR_PROFILES_UPDATES : 0) | (force ? DexoptOptions.DEXOPT_FORCE : 0) | (bootComplete ? DexoptOptions.DEXOPT_BOOT_COMPLETE : 0);
    return performDexOpt(new DexoptOptions(packageName, targetCompilerFilter, splitName, flags));
}
#method_after
@Override
public boolean performDexOptMode(String packageName, boolean checkProfiles, String targetCompilerFilter, boolean force, boolean bootComplete, String splitName) {
    int flags = (checkProfiles ? DexoptOptions.DEXOPT_CHECK_FOR_PROFILES_UPDATES : 0) | (force ? DexoptOptions.DEXOPT_FORCE : 0) | (bootComplete ? DexoptOptions.DEXOPT_BOOT_COMPLETE : 0);
    return performDexOpt(new DexoptOptions(packageName, REASON_UNKNOWN, targetCompilerFilter, splitName, flags));
}
#end_block

#method_before
private int performDexOptInternalWithDependenciesLI(PackageParser.Package p, DexoptOptions options) {
    // Select the dex optimizer based on the force parameter.
    // Note: The force option is rarely used (cmdline input for testing, mostly), so it's OK to
    // allocate an object here.
    PackageDexOptimizer pdo = options.isForce() ? new PackageDexOptimizer.ForcedUpdatePackageDexOptimizer(mPackageDexOptimizer) : mPackageDexOptimizer;
    // Dexopt all dependencies first. Note: we ignore the return value and march on
    // on errors.
    // Note that we are going to call performDexOpt on those libraries as many times as
    // they are referenced in packages. When we do a batch of performDexOpt (for example
    // at boot, or background job), the passed 'targetCompilerFilter' stays the same,
    // and the first package that uses the library will dexopt it. The
    // others will see that the compiled code for the library is up to date.
    Collection<PackageParser.Package> deps = findSharedNonSystemLibraries(p);
    final String[] instructionSets = getAppDexInstructionSets(p.applicationInfo);
    if (!deps.isEmpty()) {
        DexoptOptions libraryOptions = new DexoptOptions(options.getPackageName(), options.getCompilerFilter(), options.getSplitName(), options.getFlags() | DexoptOptions.DEXOPT_AS_SHARED_LIBRARY);
        for (PackageParser.Package depPackage : deps) {
            // TODO: Analyze and investigate if we (should) profile libraries.
            pdo.performDexOpt(depPackage, null, /* sharedLibraries */
            instructionSets, getOrCreateCompilerPackageStats(depPackage), mDexManager.getPackageUseInfoOrDefault(depPackage.packageName), libraryOptions);
        }
    }
    return pdo.performDexOpt(p, p.usesLibraryFiles, instructionSets, getOrCreateCompilerPackageStats(p), mDexManager.getPackageUseInfoOrDefault(p.packageName), options);
}
#method_after
private int performDexOptInternalWithDependenciesLI(PackageParser.Package p, DexoptOptions options) {
    // Select the dex optimizer based on the force parameter.
    // Note: The force option is rarely used (cmdline input for testing, mostly), so it's OK to
    // allocate an object here.
    PackageDexOptimizer pdo = options.isForce() ? new PackageDexOptimizer.ForcedUpdatePackageDexOptimizer(mPackageDexOptimizer) : mPackageDexOptimizer;
    // Dexopt all dependencies first. Note: we ignore the return value and march on
    // on errors.
    // Note that we are going to call performDexOpt on those libraries as many times as
    // they are referenced in packages. When we do a batch of performDexOpt (for example
    // at boot, or background job), the passed 'targetCompilerFilter' stays the same,
    // and the first package that uses the library will dexopt it. The
    // others will see that the compiled code for the library is up to date.
    Collection<PackageParser.Package> deps = findSharedNonSystemLibraries(p);
    final String[] instructionSets = getAppDexInstructionSets(p.applicationInfo);
    if (!deps.isEmpty()) {
        DexoptOptions libraryOptions = new DexoptOptions(options.getPackageName(), options.getCompilationReason(), options.getCompilerFilter(), options.getSplitName(), options.getFlags() | DexoptOptions.DEXOPT_AS_SHARED_LIBRARY);
        for (PackageParser.Package depPackage : deps) {
            // TODO: Analyze and investigate if we (should) profile libraries.
            pdo.performDexOpt(depPackage, null, /* sharedLibraries */
            instructionSets, getOrCreateCompilerPackageStats(depPackage), mDexManager.getPackageUseInfoOrDefault(depPackage.packageName), libraryOptions);
        }
    }
    return pdo.performDexOpt(p, p.usesLibraryFiles, instructionSets, getOrCreateCompilerPackageStats(p), mDexManager.getPackageUseInfoOrDefault(p.packageName), options);
}
#end_block

#method_before
public void shutdown() {
    mPackageUsage.writeNow(mPackages);
    mCompilerStats.writeNow();
    mDexManager.writePackageDexUsageNow();
    // This is the last chance to write out pending restriction settings.
    if (mHandler.hasMessages(WRITE_PACKAGE_RESTRICTIONS)) {
        mHandler.removeMessages(WRITE_PACKAGE_RESTRICTIONS);
        mHandler.sendEmptyMessage(WRITE_PACKAGE_RESTRICTIONS);
    }
}
#method_after
public void shutdown() {
    mPackageUsage.writeNow(mPackages);
    mCompilerStats.writeNow();
    mDexManager.writePackageDexUsageNow();
    // This is the last chance to write out pending restriction settings
    synchronized (mPackages) {
        if (mHandler.hasMessages(WRITE_PACKAGE_RESTRICTIONS)) {
            mHandler.removeMessages(WRITE_PACKAGE_RESTRICTIONS);
            for (int userId : mDirtyUsers) {
                mSettings.writePackageRestrictionsLPr(userId);
            }
            mDirtyUsers.clear();
        }
    }
}
#end_block

#method_before
@Override
public void dumpProfiles(String packageName) {
    PackageParser.Package pkg;
    synchronized (mPackages) {
        pkg = mPackages.get(packageName);
        if (pkg == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
    }
    /* Only the shell, root, or the app user should be able to dump profiles. */
    int callingUid = Binder.getCallingUid();
    if (callingUid != Process.SHELL_UID && callingUid != Process.ROOT_UID && callingUid != pkg.applicationInfo.uid) {
        throw new SecurityException("dumpProfiles");
    }
    synchronized (mInstallLock) {
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "dump profiles");
        final int sharedGid = UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
        try {
            List<String> allCodePaths = pkg.getAllCodePathsExcludingResourceOnly();
            String codePaths = TextUtils.join(";", allCodePaths);
            mInstaller.dumpProfiles(sharedGid, packageName, codePaths);
        } catch (InstallerException e) {
            Slog.w(TAG, "Failed to dump profiles", e);
        }
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
}
#method_after
@Override
public void dumpProfiles(String packageName) {
    PackageParser.Package pkg;
    synchronized (mPackages) {
        pkg = mPackages.get(packageName);
        if (pkg == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
    }
    /* Only the shell, root, or the app user should be able to dump profiles. */
    int callingUid = Binder.getCallingUid();
    if (callingUid != Process.SHELL_UID && callingUid != Process.ROOT_UID && callingUid != pkg.applicationInfo.uid) {
        throw new SecurityException("dumpProfiles");
    }
    synchronized (mInstallLock) {
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "dump profiles");
        mArtManagerService.dumpProfiles(pkg);
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
}
#end_block

#method_before
private void clearAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
    if (pkg == null) {
        Slog.wtf(TAG, "Package was null!", new Throwable());
        return;
    }
    clearAppDataLeafLIF(pkg, userId, flags);
    final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
    for (int i = 0; i < childCount; i++) {
        clearAppDataLeafLIF(pkg.childPackages.get(i), userId, flags);
    }
}
#method_after
private void clearAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
    if (pkg == null) {
        Slog.wtf(TAG, "Package was null!", new Throwable());
        return;
    }
    clearAppDataLeafLIF(pkg, userId, flags);
    final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
    for (int i = 0; i < childCount; i++) {
        clearAppDataLeafLIF(pkg.childPackages.get(i), userId, flags);
    }
    clearAppProfilesLIF(pkg, UserHandle.USER_ALL);
}
#end_block

#method_before
private void clearAppProfilesLIF(PackageParser.Package pkg, int userId) {
    if (pkg == null) {
        Slog.wtf(TAG, "Package was null!", new Throwable());
        return;
    }
    clearAppProfilesLeafLIF(pkg);
    final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
    for (int i = 0; i < childCount; i++) {
        clearAppProfilesLeafLIF(pkg.childPackages.get(i));
    }
}
#method_after
private void clearAppProfilesLIF(PackageParser.Package pkg, int userId) {
    if (pkg == null) {
        Slog.wtf(TAG, "Package was null!", new Throwable());
        return;
    }
    mArtManagerService.clearAppProfiles(pkg);
    final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
    for (int i = 0; i < childCount; i++) {
        mArtManagerService.clearAppProfiles(pkg.childPackages.get(i));
    }
}
#end_block

#method_before
private void replaceNonSystemPackageLIF(PackageParser.Package deletedPackage, PackageParser.Package pkg, final int policyFlags, int scanFlags, UserHandle user, int[] allUsers, String installerPackageName, PackageInstalledInfo res, int installReason) {
    if (DEBUG_INSTALL)
        Slog.d(TAG, "replaceNonSystemPackageLI: new=" + pkg + ", old=" + deletedPackage);
    String pkgName = deletedPackage.packageName;
    boolean deletedPkg = true;
    boolean addedPkg = false;
    boolean updatedSettings = false;
    final boolean killApp = (scanFlags & SCAN_DONT_KILL_APP) == 0;
    final int deleteFlags = PackageManager.DELETE_KEEP_DATA | (killApp ? 0 : PackageManager.DELETE_DONT_KILL_APP);
    final long origUpdateTime = (pkg.mExtras != null) ? ((PackageSetting) pkg.mExtras).lastUpdateTime : 0;
    // First delete the existing package while retaining the data directory
    if (!deletePackageLIF(pkgName, null, true, allUsers, deleteFlags, res.removedInfo, true, pkg)) {
        // If the existing package wasn't successfully deleted
        res.setError(INSTALL_FAILED_REPLACE_COULDNT_DELETE, "replaceNonSystemPackageLI");
        deletedPkg = false;
    } else {
        // relinquish resources before killing.
        if (deletedPackage.isForwardLocked() || isExternal(deletedPackage)) {
            if (DEBUG_INSTALL) {
                Slog.i(TAG, "upgrading pkg " + deletedPackage + " is ASEC-hosted -> UNAVAILABLE");
            }
            final int[] uidArray = new int[] { deletedPackage.applicationInfo.uid };
            final ArrayList<String> pkgList = new ArrayList<String>(1);
            pkgList.add(deletedPackage.applicationInfo.packageName);
            sendResourcesChangedBroadcast(false, true, pkgList, uidArray, null);
        }
        clearAppDataLIF(pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);
        clearAppProfilesLIF(deletedPackage, UserHandle.USER_ALL);
        try {
            final PackageParser.Package newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags | SCAN_UPDATE_TIME, System.currentTimeMillis(), user);
            updateSettingsLI(newPackage, installerPackageName, allUsers, res, user, installReason);
            // Update the in-memory copy of the previous code paths.
            PackageSetting ps = mSettings.mPackages.get(pkgName);
            if (!killApp) {
                if (ps.oldCodePaths == null) {
                    ps.oldCodePaths = new ArraySet<>();
                }
                Collections.addAll(ps.oldCodePaths, deletedPackage.baseCodePath);
                if (deletedPackage.splitCodePaths != null) {
                    Collections.addAll(ps.oldCodePaths, deletedPackage.splitCodePaths);
                }
            } else {
                ps.oldCodePaths = null;
            }
            if (ps.childPackageNames != null) {
                for (int i = ps.childPackageNames.size() - 1; i >= 0; --i) {
                    final String childPkgName = ps.childPackageNames.get(i);
                    final PackageSetting childPs = mSettings.mPackages.get(childPkgName);
                    childPs.oldCodePaths = ps.oldCodePaths;
                }
            }
            // set instant app status, but, only if it's explicitly specified
            final boolean instantApp = (scanFlags & SCAN_AS_INSTANT_APP) != 0;
            final boolean fullApp = (scanFlags & SCAN_AS_FULL_APP) != 0;
            setInstantAppForUser(ps, user.getIdentifier(), instantApp, fullApp);
            prepareAppDataAfterInstallLIF(newPackage);
            addedPkg = true;
            mDexManager.notifyPackageUpdated(newPackage.packageName, newPackage.baseCodePath, newPackage.splitCodePaths);
        } catch (PackageManagerException e) {
            res.setError("Package couldn't be installed in " + pkg.codePath, e);
        }
    }
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        if (DEBUG_INSTALL)
            Slog.d(TAG, "Install failed, rolling pack: " + pkgName);
        // Revert all internal state mutations and added folders for the failed install
        if (addedPkg) {
            deletePackageLIF(pkgName, null, true, allUsers, deleteFlags, res.removedInfo, true, null);
        }
        // Restore the old package
        if (deletedPkg) {
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Install failed, reinstalling: " + deletedPackage);
            File restoreFile = new File(deletedPackage.codePath);
            // Parse old package
            boolean oldExternal = isExternal(deletedPackage);
            int oldParseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | (deletedPackage.isForwardLocked() ? PackageParser.PARSE_FORWARD_LOCK : 0) | (oldExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0);
            int oldScanFlags = SCAN_UPDATE_SIGNATURE | SCAN_UPDATE_TIME;
            try {
                scanPackageTracedLI(restoreFile, oldParseFlags, oldScanFlags, origUpdateTime, null);
            } catch (PackageManagerException e) {
                Slog.e(TAG, "Failed to restore package : " + pkgName + " after failed upgrade: " + e.getMessage());
                return;
            }
            synchronized (mPackages) {
                // Ensure the installer package name up to date
                setInstallerPackageNameLPw(deletedPackage, installerPackageName);
                // Update permissions for restored package
                updatePermissionsLPw(deletedPackage, UPDATE_PERMISSIONS_ALL);
                mSettings.writeLPr();
            }
            Slog.i(TAG, "Successfully restored package : " + pkgName + " after failed upgrade");
        }
    } else {
        synchronized (mPackages) {
            PackageSetting ps = mSettings.getPackageLPr(pkg.packageName);
            if (ps != null) {
                res.removedInfo.removedForAllUsers = mPackages.get(ps.name) == null;
                if (res.removedInfo.removedChildPackages != null) {
                    final int childCount = res.removedInfo.removedChildPackages.size();
                    // Iterate in reverse as we may modify the collection
                    for (int i = childCount - 1; i >= 0; i--) {
                        String childPackageName = res.removedInfo.removedChildPackages.keyAt(i);
                        if (res.addedChildPackages.containsKey(childPackageName)) {
                            res.removedInfo.removedChildPackages.removeAt(i);
                        } else {
                            PackageRemovedInfo childInfo = res.removedInfo.removedChildPackages.valueAt(i);
                            childInfo.removedForAllUsers = mPackages.get(childInfo.removedPackage) == null;
                        }
                    }
                }
            }
        }
    }
}
#method_after
private void replaceNonSystemPackageLIF(PackageParser.Package deletedPackage, PackageParser.Package pkg, final int policyFlags, int scanFlags, UserHandle user, int[] allUsers, String installerPackageName, PackageInstalledInfo res, int installReason) {
    if (DEBUG_INSTALL)
        Slog.d(TAG, "replaceNonSystemPackageLI: new=" + pkg + ", old=" + deletedPackage);
    String pkgName = deletedPackage.packageName;
    boolean deletedPkg = true;
    boolean addedPkg = false;
    boolean updatedSettings = false;
    final boolean killApp = (scanFlags & SCAN_DONT_KILL_APP) == 0;
    final int deleteFlags = PackageManager.DELETE_KEEP_DATA | (killApp ? 0 : PackageManager.DELETE_DONT_KILL_APP);
    final long origUpdateTime = (pkg.mExtras != null) ? ((PackageSetting) pkg.mExtras).lastUpdateTime : 0;
    // First delete the existing package while retaining the data directory
    if (!deletePackageLIF(pkgName, null, true, allUsers, deleteFlags, res.removedInfo, true, pkg)) {
        // If the existing package wasn't successfully deleted
        res.setError(INSTALL_FAILED_REPLACE_COULDNT_DELETE, "replaceNonSystemPackageLI");
        deletedPkg = false;
    } else {
        // relinquish resources before killing.
        if (deletedPackage.isForwardLocked() || isExternal(deletedPackage)) {
            if (DEBUG_INSTALL) {
                Slog.i(TAG, "upgrading pkg " + deletedPackage + " is ASEC-hosted -> UNAVAILABLE");
            }
            final int[] uidArray = new int[] { deletedPackage.applicationInfo.uid };
            final ArrayList<String> pkgList = new ArrayList<String>(1);
            pkgList.add(deletedPackage.applicationInfo.packageName);
            sendResourcesChangedBroadcast(false, true, pkgList, uidArray, null);
        }
        clearAppDataLIF(pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);
        try {
            final PackageParser.Package newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags | SCAN_UPDATE_TIME, System.currentTimeMillis(), user);
            updateSettingsLI(newPackage, installerPackageName, allUsers, res, user, installReason);
            // Update the in-memory copy of the previous code paths.
            PackageSetting ps = mSettings.mPackages.get(pkgName);
            if (!killApp) {
                if (ps.oldCodePaths == null) {
                    ps.oldCodePaths = new ArraySet<>();
                }
                Collections.addAll(ps.oldCodePaths, deletedPackage.baseCodePath);
                if (deletedPackage.splitCodePaths != null) {
                    Collections.addAll(ps.oldCodePaths, deletedPackage.splitCodePaths);
                }
            } else {
                ps.oldCodePaths = null;
            }
            if (ps.childPackageNames != null) {
                for (int i = ps.childPackageNames.size() - 1; i >= 0; --i) {
                    final String childPkgName = ps.childPackageNames.get(i);
                    final PackageSetting childPs = mSettings.mPackages.get(childPkgName);
                    childPs.oldCodePaths = ps.oldCodePaths;
                }
            }
            // set instant app status, but, only if it's explicitly specified
            final boolean instantApp = (scanFlags & SCAN_AS_INSTANT_APP) != 0;
            final boolean fullApp = (scanFlags & SCAN_AS_FULL_APP) != 0;
            setInstantAppForUser(ps, user.getIdentifier(), instantApp, fullApp);
            prepareAppDataAfterInstallLIF(newPackage);
            addedPkg = true;
            mDexManager.notifyPackageUpdated(newPackage.packageName, newPackage.baseCodePath, newPackage.splitCodePaths);
        } catch (PackageManagerException e) {
            res.setError("Package couldn't be installed in " + pkg.codePath, e);
        }
    }
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        if (DEBUG_INSTALL)
            Slog.d(TAG, "Install failed, rolling pack: " + pkgName);
        // Revert all internal state mutations and added folders for the failed install
        if (addedPkg) {
            deletePackageLIF(pkgName, null, true, allUsers, deleteFlags, res.removedInfo, true, null);
        }
        // Restore the old package
        if (deletedPkg) {
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Install failed, reinstalling: " + deletedPackage);
            File restoreFile = new File(deletedPackage.codePath);
            // Parse old package
            boolean oldExternal = isExternal(deletedPackage);
            int oldParseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | (deletedPackage.isForwardLocked() ? PackageParser.PARSE_FORWARD_LOCK : 0) | (oldExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0);
            int oldScanFlags = SCAN_UPDATE_SIGNATURE | SCAN_UPDATE_TIME;
            try {
                scanPackageTracedLI(restoreFile, oldParseFlags, oldScanFlags, origUpdateTime, null);
            } catch (PackageManagerException e) {
                Slog.e(TAG, "Failed to restore package : " + pkgName + " after failed upgrade: " + e.getMessage());
                return;
            }
            synchronized (mPackages) {
                // Ensure the installer package name up to date
                setInstallerPackageNameLPw(deletedPackage, installerPackageName);
                // Update permissions for restored package
                updatePermissionsLPw(deletedPackage, UPDATE_PERMISSIONS_ALL);
                mSettings.writeLPr();
            }
            Slog.i(TAG, "Successfully restored package : " + pkgName + " after failed upgrade");
        }
    } else {
        synchronized (mPackages) {
            PackageSetting ps = mSettings.getPackageLPr(pkg.packageName);
            if (ps != null) {
                res.removedInfo.removedForAllUsers = mPackages.get(ps.name) == null;
                if (res.removedInfo.removedChildPackages != null) {
                    final int childCount = res.removedInfo.removedChildPackages.size();
                    // Iterate in reverse as we may modify the collection
                    for (int i = childCount - 1; i >= 0; i--) {
                        String childPackageName = res.removedInfo.removedChildPackages.keyAt(i);
                        if (res.addedChildPackages.containsKey(childPackageName)) {
                            res.removedInfo.removedChildPackages.removeAt(i);
                        } else {
                            PackageRemovedInfo childInfo = res.removedInfo.removedChildPackages.valueAt(i);
                            childInfo.removedForAllUsers = mPackages.get(childInfo.removedPackage) == null;
                        }
                    }
                }
            }
        }
    }
}
#end_block

#method_before
private void replaceSystemPackageLIF(PackageParser.Package deletedPackage, PackageParser.Package pkg, final int policyFlags, int scanFlags, UserHandle user, int[] allUsers, String installerPackageName, PackageInstalledInfo res, int installReason) {
    if (DEBUG_INSTALL)
        Slog.d(TAG, "replaceSystemPackageLI: new=" + pkg + ", old=" + deletedPackage);
    final boolean disabledSystem;
    // Remove existing system package
    removePackageLI(deletedPackage, true);
    synchronized (mPackages) {
        disabledSystem = disableSystemPackageLPw(deletedPackage, pkg);
    }
    if (!disabledSystem) {
        // We didn't need to disable the .apk as a current system package,
        // which means we are replacing another update that is already
        // installed.  We need to make sure to delete the older one's .apk.
        res.removedInfo.args = createInstallArgsForExisting(0, deletedPackage.applicationInfo.getCodePath(), deletedPackage.applicationInfo.getResourcePath(), getAppDexInstructionSets(deletedPackage.applicationInfo));
    } else {
        res.removedInfo.args = null;
    }
    // Successfully disabled the old package. Now proceed with re-installation
    clearAppDataLIF(pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);
    clearAppProfilesLIF(deletedPackage, UserHandle.USER_ALL);
    res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
    pkg.setApplicationInfoFlags(ApplicationInfo.FLAG_UPDATED_SYSTEM_APP, ApplicationInfo.FLAG_UPDATED_SYSTEM_APP);
    PackageParser.Package newPackage = null;
    try {
        // Add the package to the internal data structures
        newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags, 0, user);
        // Set the update and install times
        PackageSetting deletedPkgSetting = (PackageSetting) deletedPackage.mExtras;
        setInstallAndUpdateTime(newPackage, deletedPkgSetting.firstInstallTime, System.currentTimeMillis());
        // Update the package dynamic state if succeeded
        if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
            // Now that the install succeeded make sure we remove data
            // directories for any child package the update removed.
            final int deletedChildCount = (deletedPackage.childPackages != null) ? deletedPackage.childPackages.size() : 0;
            final int newChildCount = (newPackage.childPackages != null) ? newPackage.childPackages.size() : 0;
            for (int i = 0; i < deletedChildCount; i++) {
                PackageParser.Package deletedChildPkg = deletedPackage.childPackages.get(i);
                boolean childPackageDeleted = true;
                for (int j = 0; j < newChildCount; j++) {
                    PackageParser.Package newChildPkg = newPackage.childPackages.get(j);
                    if (deletedChildPkg.packageName.equals(newChildPkg.packageName)) {
                        childPackageDeleted = false;
                        break;
                    }
                }
                if (childPackageDeleted) {
                    PackageSetting ps = mSettings.getDisabledSystemPkgLPr(deletedChildPkg.packageName);
                    if (ps != null && res.removedInfo.removedChildPackages != null) {
                        PackageRemovedInfo removedChildRes = res.removedInfo.removedChildPackages.get(deletedChildPkg.packageName);
                        removePackageDataLIF(ps, allUsers, removedChildRes, 0, false);
                        removedChildRes.removedForAllUsers = mPackages.get(ps.name) == null;
                    }
                }
            }
            updateSettingsLI(newPackage, installerPackageName, allUsers, res, user, installReason);
            prepareAppDataAfterInstallLIF(newPackage);
            mDexManager.notifyPackageUpdated(newPackage.packageName, newPackage.baseCodePath, newPackage.splitCodePaths);
        }
    } catch (PackageManagerException e) {
        res.setReturnCode(INSTALL_FAILED_INTERNAL_ERROR);
        res.setError("Package couldn't be installed in " + pkg.codePath, e);
    }
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        // Remove new pkg information
        if (newPackage != null) {
            removeInstalledPackageLI(newPackage, true);
        }
        // Add back the old system package
        try {
            scanPackageTracedLI(deletedPackage, policyFlags, SCAN_UPDATE_SIGNATURE, 0, user);
        } catch (PackageManagerException e) {
            Slog.e(TAG, "Failed to restore original package: " + e.getMessage());
        }
        synchronized (mPackages) {
            if (disabledSystem) {
                enableSystemPackageLPw(deletedPackage);
            }
            // Ensure the installer package name up to date
            setInstallerPackageNameLPw(deletedPackage, installerPackageName);
            // Update permissions for restored package
            updatePermissionsLPw(deletedPackage, UPDATE_PERMISSIONS_ALL);
            mSettings.writeLPr();
        }
        Slog.i(TAG, "Successfully restored package : " + deletedPackage.packageName + " after failed upgrade");
    }
}
#method_after
private void replaceSystemPackageLIF(PackageParser.Package deletedPackage, PackageParser.Package pkg, final int policyFlags, int scanFlags, UserHandle user, int[] allUsers, String installerPackageName, PackageInstalledInfo res, int installReason) {
    if (DEBUG_INSTALL)
        Slog.d(TAG, "replaceSystemPackageLI: new=" + pkg + ", old=" + deletedPackage);
    final boolean disabledSystem;
    // Remove existing system package
    removePackageLI(deletedPackage, true);
    synchronized (mPackages) {
        disabledSystem = disableSystemPackageLPw(deletedPackage, pkg);
    }
    if (!disabledSystem) {
        // We didn't need to disable the .apk as a current system package,
        // which means we are replacing another update that is already
        // installed.  We need to make sure to delete the older one's .apk.
        res.removedInfo.args = createInstallArgsForExisting(0, deletedPackage.applicationInfo.getCodePath(), deletedPackage.applicationInfo.getResourcePath(), getAppDexInstructionSets(deletedPackage.applicationInfo));
    } else {
        res.removedInfo.args = null;
    }
    // Successfully disabled the old package. Now proceed with re-installation
    clearAppDataLIF(pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);
    res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
    pkg.setApplicationInfoFlags(ApplicationInfo.FLAG_UPDATED_SYSTEM_APP, ApplicationInfo.FLAG_UPDATED_SYSTEM_APP);
    PackageParser.Package newPackage = null;
    try {
        // Add the package to the internal data structures
        newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags, 0, user);
        // Set the update and install times
        PackageSetting deletedPkgSetting = (PackageSetting) deletedPackage.mExtras;
        setInstallAndUpdateTime(newPackage, deletedPkgSetting.firstInstallTime, System.currentTimeMillis());
        // Update the package dynamic state if succeeded
        if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
            // Now that the install succeeded make sure we remove data
            // directories for any child package the update removed.
            final int deletedChildCount = (deletedPackage.childPackages != null) ? deletedPackage.childPackages.size() : 0;
            final int newChildCount = (newPackage.childPackages != null) ? newPackage.childPackages.size() : 0;
            for (int i = 0; i < deletedChildCount; i++) {
                PackageParser.Package deletedChildPkg = deletedPackage.childPackages.get(i);
                boolean childPackageDeleted = true;
                for (int j = 0; j < newChildCount; j++) {
                    PackageParser.Package newChildPkg = newPackage.childPackages.get(j);
                    if (deletedChildPkg.packageName.equals(newChildPkg.packageName)) {
                        childPackageDeleted = false;
                        break;
                    }
                }
                if (childPackageDeleted) {
                    PackageSetting ps = mSettings.getDisabledSystemPkgLPr(deletedChildPkg.packageName);
                    if (ps != null && res.removedInfo.removedChildPackages != null) {
                        PackageRemovedInfo removedChildRes = res.removedInfo.removedChildPackages.get(deletedChildPkg.packageName);
                        removePackageDataLIF(ps, allUsers, removedChildRes, 0, false);
                        removedChildRes.removedForAllUsers = mPackages.get(ps.name) == null;
                    }
                }
            }
            updateSettingsLI(newPackage, installerPackageName, allUsers, res, user, installReason);
            prepareAppDataAfterInstallLIF(newPackage);
            mDexManager.notifyPackageUpdated(newPackage.packageName, newPackage.baseCodePath, newPackage.splitCodePaths);
        }
    } catch (PackageManagerException e) {
        res.setReturnCode(INSTALL_FAILED_INTERNAL_ERROR);
        res.setError("Package couldn't be installed in " + pkg.codePath, e);
    }
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        // Remove new pkg information
        if (newPackage != null) {
            removeInstalledPackageLI(newPackage, true);
        }
        // Add back the old system package
        try {
            scanPackageTracedLI(deletedPackage, policyFlags, SCAN_UPDATE_SIGNATURE, 0, user);
        } catch (PackageManagerException e) {
            Slog.e(TAG, "Failed to restore original package: " + e.getMessage());
        }
        synchronized (mPackages) {
            if (disabledSystem) {
                enableSystemPackageLPw(deletedPackage);
            }
            // Ensure the installer package name up to date
            setInstallerPackageNameLPw(deletedPackage, installerPackageName);
            // Update permissions for restored package
            updatePermissionsLPw(deletedPackage, UPDATE_PERMISSIONS_ALL);
            mSettings.writeLPr();
        }
        Slog.i(TAG, "Successfully restored package : " + deletedPackage.packageName + " after failed upgrade");
    }
}
#end_block

#method_before
private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
    final int installFlags = args.installFlags;
    final String installerPackageName = args.installerPackageName;
    final String volumeUuid = args.volumeUuid;
    final File tmpPackageFile = new File(args.getCodePath());
    final boolean forwardLocked = ((installFlags & PackageManager.INSTALL_FORWARD_LOCK) != 0);
    final boolean onExternal = (((installFlags & PackageManager.INSTALL_EXTERNAL) != 0) || (args.volumeUuid != null));
    final boolean instantApp = ((installFlags & PackageManager.INSTALL_INSTANT_APP) != 0);
    final boolean fullApp = ((installFlags & PackageManager.INSTALL_FULL_APP) != 0);
    final boolean forceSdk = ((installFlags & PackageManager.INSTALL_FORCE_SDK) != 0);
    final boolean virtualPreload = ((installFlags & PackageManager.INSTALL_VIRTUAL_PRELOAD) != 0);
    boolean replace = false;
    int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;
    if (args.move != null) {
        // moving a complete application; perform an initial scan on the new install location
        scanFlags |= SCAN_INITIAL;
    }
    if ((installFlags & PackageManager.INSTALL_DONT_KILL_APP) != 0) {
        scanFlags |= SCAN_DONT_KILL_APP;
    }
    if (instantApp) {
        scanFlags |= SCAN_AS_INSTANT_APP;
    }
    if (fullApp) {
        scanFlags |= SCAN_AS_FULL_APP;
    }
    if (virtualPreload) {
        scanFlags |= SCAN_AS_VIRTUAL_PRELOAD;
    }
    // Result object to be returned
    res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
    res.installerPackageName = installerPackageName;
    if (DEBUG_INSTALL)
        Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile);
    // Sanity check
    if (instantApp && (forwardLocked || onExternal)) {
        Slog.i(TAG, "Incompatible ephemeral install; fwdLocked=" + forwardLocked + " external=" + onExternal);
        res.setReturnCode(PackageManager.INSTALL_FAILED_INSTANT_APP_INVALID);
        return;
    }
    // Retrieve PackageSettings and parse package
    final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0) | (instantApp ? PackageParser.PARSE_IS_EPHEMERAL : 0) | (forceSdk ? PackageParser.PARSE_FORCE_SDK : 0);
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setDisplayMetrics(mMetrics);
    pp.setCallback(mPackageParserCallback);
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "parsePackage");
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(tmpPackageFile, parseFlags);
    } catch (PackageParserException e) {
        res.setError("Failed parse during installPackageLI", e);
        return;
    } finally {
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // Instant apps must have target SDK >= O and have targetSanboxVersion >= 2
    if (instantApp && pkg.applicationInfo.targetSdkVersion <= Build.VERSION_CODES.N_MR1) {
        Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target O");
        res.setError(INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Instant app package must target O");
        return;
    }
    if (instantApp && pkg.applicationInfo.targetSandboxVersion != 2) {
        Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target targetSandboxVersion 2");
        res.setError(INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Instant app package must use targetSanboxVersion 2");
        return;
    }
    if (pkg.applicationInfo.isStaticSharedLibrary()) {
        // Static shared libraries have synthetic package names
        renameStaticSharedLibraryPackage(pkg);
        // No static shared libs on external storage
        if (onExternal) {
            Slog.i(TAG, "Static shared libs can only be installed on internal storage.");
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Packages declaring static-shared libs cannot be updated");
            return;
        }
    }
    // If we are installing a clustered package add results for the children
    if (pkg.childPackages != null) {
        synchronized (mPackages) {
            final int childCount = pkg.childPackages.size();
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = pkg.childPackages.get(i);
                PackageInstalledInfo childRes = new PackageInstalledInfo();
                childRes.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
                childRes.pkg = childPkg;
                childRes.name = childPkg.packageName;
                PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
                if (childPs != null) {
                    childRes.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                }
                if ((mPackages.containsKey(childPkg.packageName))) {
                    childRes.removedInfo = new PackageRemovedInfo(this);
                    childRes.removedInfo.removedPackage = childPkg.packageName;
                    childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                }
                if (res.addedChildPackages == null) {
                    res.addedChildPackages = new ArrayMap<>();
                }
                res.addedChildPackages.put(childPkg.packageName, childRes);
            }
        }
    }
    // time CPU ABI override.
    if (TextUtils.isEmpty(pkg.cpuAbiOverride)) {
        pkg.cpuAbiOverride = args.abiOverride;
    }
    String pkgName = res.name = pkg.packageName;
    if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0) {
        if ((installFlags & PackageManager.INSTALL_ALLOW_TEST) == 0) {
            res.setError(INSTALL_FAILED_TEST_ONLY, "installPackageLI");
            return;
        }
    }
    try {
        // either use what we've been given or parse directly from the APK
        if (args.certificates != null) {
            try {
                PackageParser.populateCertificates(pkg, args.certificates);
            } catch (PackageParserException e) {
                // there was something wrong with the certificates we were given;
                // try to pull them from the APK
                PackageParser.collectCertificates(pkg, parseFlags);
            }
        } else {
            PackageParser.collectCertificates(pkg, parseFlags);
        }
    } catch (PackageParserException e) {
        res.setError("Failed collect during installPackageLI", e);
        return;
    }
    // Get rid of all references to package scan path via parser.
    pp = null;
    String oldCodePath = null;
    boolean systemApp = false;
    synchronized (mPackages) {
        // Check if installing already existing package
        if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
            String oldName = mSettings.getRenamedPackageLPr(pkgName);
            if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName) && mPackages.containsKey(oldName)) {
                // This package is derived from an original package,
                // and this device has been updating from that original
                // name.  We must continue using the original name, so
                // rename the new package here.
                pkg.setPackageName(oldName);
                pkgName = pkg.packageName;
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replacing existing renamed package: oldName=" + oldName + " pkgName=" + pkgName);
            } else if (mPackages.containsKey(pkgName)) {
                // This package, under its official name, already exists
                // on the device; we should replace it.
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replace existing pacakge: " + pkgName);
            }
            // Child packages are installed through the parent package
            if (pkg.parentPackage != null) {
                res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + pkg.parentPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                return;
            }
            if (replace) {
                // Prevent apps opting out from runtime permissions
                PackageParser.Package oldPackage = mPackages.get(pkgName);
                final int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                final int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                if (oldTargetSdk > Build.VERSION_CODES.LOLLIPOP_MR1 && newTargetSdk <= Build.VERSION_CODES.LOLLIPOP_MR1) {
                    res.setError(PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE, "Package " + pkg.packageName + " new target SDK " + newTargetSdk + " doesn't support runtime permissions but the old" + " target SDK " + oldTargetSdk + " does.");
                    return;
                }
                // Prevent persistent apps from being updated
                if ((oldPackage.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) != 0) {
                    res.setError(PackageManager.INSTALL_FAILED_INVALID_APK, "Package " + oldPackage.packageName + " is a persistent app. " + "Persistent apps are not updateable.");
                    return;
                }
                // Prevent apps from downgrading their targetSandbox.
                final int oldTargetSandbox = oldPackage.applicationInfo.targetSandboxVersion;
                final int newTargetSandbox = pkg.applicationInfo.targetSandboxVersion;
                if (oldTargetSandbox == 2 && newTargetSandbox != 2) {
                    res.setError(PackageManager.INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Package " + pkg.packageName + " new target sandbox " + newTargetSandbox + " is incompatible with the previous value of" + oldTargetSandbox + ".");
                    return;
                }
                // Prevent installing of child packages
                if (oldPackage.parentPackage != null) {
                    res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + oldPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                    return;
                }
            }
        }
        PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Existing package: " + ps);
            // Static shared libs have same package with different versions where
            // we internally use a synthetic package name to allow multiple versions
            // of the same package, therefore we need to compare signatures against
            // the package setting for the latest library version.
            PackageSetting signatureCheckPs = ps;
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pkg);
                if (libraryEntry != null) {
                    signatureCheckPs = mSettings.getPackageLPr(libraryEntry.apk);
                }
            }
            // bail early here before tripping over redefined permissions.
            if (shouldCheckUpgradeKeySetLP(signatureCheckPs, scanFlags)) {
                if (!checkUpgradeKeySetLP(signatureCheckPs, pkg)) {
                    res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                    return;
                }
            } else {
                try {
                    verifySignaturesLP(signatureCheckPs, pkg);
                } catch (PackageManagerException e) {
                    res.setError(e.error, e.getMessage());
                    return;
                }
            }
            oldCodePath = mSettings.mPackages.get(pkgName).codePathString;
            if (ps.pkg != null && ps.pkg.applicationInfo != null) {
                systemApp = (ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
            }
            res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
        }
        int N = pkg.permissions.size();
        for (int i = N - 1; i >= 0; i--) {
            PackageParser.Permission perm = pkg.permissions.get(i);
            BasePermission bp = mSettings.mPermissions.get(perm.info.name);
            // Don't allow anyone but the system to define ephemeral permissions.
            if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0 && !systemApp) {
                Slog.w(TAG, "Non-System package " + pkg.packageName + " attempting to delcare ephemeral permission " + perm.info.name + "; Removing ephemeral.");
                perm.info.protectionLevel &= ~PermissionInfo.PROTECTION_FLAG_INSTANT;
            }
            // Check whether the newly-scanned package wants to define an already-defined perm
            if (bp != null) {
                // If the defining package is signed with our cert, it's okay.  This
                // also includes the "updating the same package" case, of course.
                // "updating same package" could also involve key-rotation.
                final boolean sigsOk;
                if (bp.sourcePackage.equals(pkg.packageName) && (bp.packageSetting instanceof PackageSetting) && (shouldCheckUpgradeKeySetLP((PackageSetting) bp.packageSetting, scanFlags))) {
                    sigsOk = checkUpgradeKeySetLP((PackageSetting) bp.packageSetting, pkg);
                } else {
                    sigsOk = compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH;
                }
                if (!sigsOk) {
                    // redefinitions.
                    if (!bp.sourcePackage.equals("android")) {
                        res.setError(INSTALL_FAILED_DUPLICATE_PERMISSION, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + bp.sourcePackage);
                        res.origPermission = perm.info.name;
                        res.origPackage = bp.sourcePackage;
                        return;
                    } else {
                        Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                        pkg.permissions.remove(i);
                    }
                } else if (!PLATFORM_PACKAGE_NAME.equals(pkg.packageName)) {
                    // it as dangerous leading to the group auto-grant.
                    if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE) == PermissionInfo.PROTECTION_DANGEROUS) {
                        if (bp != null && !bp.isRuntime()) {
                            Slog.w(TAG, "Package " + pkg.packageName + " trying to change a " + "non-runtime permission " + perm.info.name + " to runtime; keeping old protection level");
                            perm.info.protectionLevel = bp.protectionLevel;
                        }
                    }
                }
            }
        }
    }
    if (systemApp) {
        if (onExternal) {
            // Abort update; system app can't be replaced with app on sdcard
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Cannot install updates to system apps on sdcard");
            return;
        } else if (instantApp) {
            // Abort update; system app can't be replaced with an instant app
            res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Cannot update a system app with an instant app");
            return;
        }
    }
    if (args.move != null) {
        // We did an in-place move, so dex is ready to roll
        scanFlags |= SCAN_NO_DEX;
        scanFlags |= SCAN_MOVE;
        synchronized (mPackages) {
            final PackageSetting ps = mSettings.mPackages.get(pkgName);
            if (ps == null) {
                res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Missing settings for moved package " + pkgName);
            }
            // We moved the entire application as-is, so bring over the
            // previously derived ABI information.
            pkg.applicationInfo.primaryCpuAbi = ps.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = ps.secondaryCpuAbiString;
        }
    } else if (!forwardLocked && !pkg.applicationInfo.isExternalAsec()) {
        // Enable SCAN_NO_DEX flag to skip dexopt at a later stage
        scanFlags |= SCAN_NO_DEX;
        try {
            String abiOverride = (TextUtils.isEmpty(pkg.cpuAbiOverride) ? args.abiOverride : pkg.cpuAbiOverride);
            final boolean extractNativeLibs = !pkg.isLibrary();
            derivePackageAbi(pkg, new File(pkg.codePath), abiOverride, extractNativeLibs, mAppLib32InstallDir);
        } catch (PackageManagerException pme) {
            Slog.e(TAG, "Error deriving application ABI", pme);
            res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Error deriving application ABI");
            return;
        }
        // Shared libraries for the package need to be updated.
        synchronized (mPackages) {
            try {
                updateSharedLibrariesLPr(pkg, null);
            } catch (PackageManagerException e) {
                Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
            }
        }
    }
    if (!args.doRename(res.returnCode, pkg, oldCodePath)) {
        res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Failed rename");
        return;
    }
    if (!instantApp) {
        startIntentFilterVerifications(args.user.getIdentifier(), replace, pkg);
    } else {
        if (DEBUG_DOMAIN_VERIFICATION) {
            Slog.d(TAG, "Not verifying instant app install for app links: " + pkgName);
        }
    }
    try (PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags, "installPackageLI")) {
        if (replace) {
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                // Static libs have a synthetic package name containing the version
                // and cannot be updated as an update would get a new package name,
                // unless this is the exact same version code which is useful for
                // development.
                PackageParser.Package existingPkg = mPackages.get(pkg.packageName);
                if (existingPkg != null && existingPkg.mVersionCode != pkg.mVersionCode) {
                    res.setError(INSTALL_FAILED_DUPLICATE_PACKAGE, "Packages declaring " + "static-shared libs cannot be updated");
                    return;
                }
            }
            replacePackageLIF(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user, installerPackageName, res, args.installReason);
        } else {
            installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, volumeUuid, res, args.installReason);
        }
    }
    // Check whether we need to dexopt the app.
    // 
    // NOTE: it is IMPORTANT to call dexopt:
    // - after doRename which will sync the package data from PackageParser.Package and its
    // corresponding ApplicationInfo.
    // - after installNewPackageLIF or replacePackageLIF which will update result with the
    // uid of the application (pkg.applicationInfo.uid).
    // This update happens in place!
    // 
    // We only need to dexopt if the package meets ALL of the following conditions:
    // 1) it is not forward locked.
    // 2) it is not on on an external ASEC container.
    // 3) it is not an instant app or if it is then dexopt is enabled via gservices.
    // 
    // Note that we do not dexopt instant apps by default. dexopt can take some time to
    // complete, so we skip this step during installation. Instead, we'll take extra time
    // the first time the instant app starts. It's preferred to do it this way to provide
    // continuous progress to the useur instead of mysteriously blocking somewhere in the
    // middle of running an instant app. The default behaviour can be overridden
    // via gservices.
    final boolean performDexopt = (res.returnCode == PackageManager.INSTALL_SUCCEEDED) && !forwardLocked && !pkg.applicationInfo.isExternalAsec() && (!instantApp || Global.getInt(mContext.getContentResolver(), Global.INSTANT_APP_DEXOPT_ENABLED, 0) != 0);
    if (performDexopt) {
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "dexopt");
        // Do not run PackageDexOptimizer through the local performDexOpt
        // method because `pkg` may not be in `mPackages` yet.
        // 
        // Also, don't fail application installs if the dexopt step fails.
        DexoptOptions dexoptOptions = new DexoptOptions(pkg.packageName, REASON_INSTALL, DexoptOptions.DEXOPT_BOOT_COMPLETE);
        mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryFiles, null, /* instructionSets */
        getOrCreateCompilerPackageStats(pkg), mDexManager.getPackageUseInfoOrDefault(pkg.packageName), dexoptOptions);
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // Notify BackgroundDexOptService that the package has been changed.
    // If this is an update of a package which used to fail to compile,
    // BackgroundDexOptService will remove it from its blacklist.
    // TODO: Layering violation
    BackgroundDexOptService.notifyPackageChanged(pkg.packageName);
    synchronized (mPackages) {
        final PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
            ps.setUpdateAvailable(false);
        }
        final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = pkg.childPackages.get(i);
            PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName);
            PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
            if (childPs != null) {
                childRes.newUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
            }
        }
        if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
            updateSequenceNumberLP(ps, res.newUsers);
            updateInstantAppInstallerLocked(pkgName);
        }
    }
}
#method_after
private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
    final int installFlags = args.installFlags;
    final String installerPackageName = args.installerPackageName;
    final String volumeUuid = args.volumeUuid;
    final File tmpPackageFile = new File(args.getCodePath());
    final boolean forwardLocked = ((installFlags & PackageManager.INSTALL_FORWARD_LOCK) != 0);
    final boolean onExternal = (((installFlags & PackageManager.INSTALL_EXTERNAL) != 0) || (args.volumeUuid != null));
    final boolean instantApp = ((installFlags & PackageManager.INSTALL_INSTANT_APP) != 0);
    final boolean fullApp = ((installFlags & PackageManager.INSTALL_FULL_APP) != 0);
    final boolean forceSdk = ((installFlags & PackageManager.INSTALL_FORCE_SDK) != 0);
    final boolean virtualPreload = ((installFlags & PackageManager.INSTALL_VIRTUAL_PRELOAD) != 0);
    boolean replace = false;
    int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;
    if (args.move != null) {
        // moving a complete application; perform an initial scan on the new install location
        scanFlags |= SCAN_INITIAL;
    }
    if ((installFlags & PackageManager.INSTALL_DONT_KILL_APP) != 0) {
        scanFlags |= SCAN_DONT_KILL_APP;
    }
    if (instantApp) {
        scanFlags |= SCAN_AS_INSTANT_APP;
    }
    if (fullApp) {
        scanFlags |= SCAN_AS_FULL_APP;
    }
    if (virtualPreload) {
        scanFlags |= SCAN_AS_VIRTUAL_PRELOAD;
    }
    // Result object to be returned
    res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
    res.installerPackageName = installerPackageName;
    if (DEBUG_INSTALL)
        Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile);
    // Sanity check
    if (instantApp && (forwardLocked || onExternal)) {
        Slog.i(TAG, "Incompatible ephemeral install; fwdLocked=" + forwardLocked + " external=" + onExternal);
        res.setReturnCode(PackageManager.INSTALL_FAILED_INSTANT_APP_INVALID);
        return;
    }
    // Retrieve PackageSettings and parse package
    final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0) | (instantApp ? PackageParser.PARSE_IS_EPHEMERAL : 0) | (forceSdk ? PackageParser.PARSE_FORCE_SDK : 0);
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setDisplayMetrics(mMetrics);
    pp.setCallback(mPackageParserCallback);
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "parsePackage");
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(tmpPackageFile, parseFlags);
        DexMetadataHelper.validatePackageDexMetadata(pkg);
    } catch (PackageParserException e) {
        res.setError("Failed parse during installPackageLI", e);
        return;
    } finally {
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // Instant apps must have target SDK >= O and have targetSanboxVersion >= 2
    if (instantApp && pkg.applicationInfo.targetSdkVersion <= Build.VERSION_CODES.N_MR1) {
        Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target O");
        res.setError(INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Instant app package must target O");
        return;
    }
    if (instantApp && pkg.applicationInfo.targetSandboxVersion != 2) {
        Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target targetSandboxVersion 2");
        res.setError(INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Instant app package must use targetSanboxVersion 2");
        return;
    }
    if (pkg.applicationInfo.isStaticSharedLibrary()) {
        // Static shared libraries have synthetic package names
        renameStaticSharedLibraryPackage(pkg);
        // No static shared libs on external storage
        if (onExternal) {
            Slog.i(TAG, "Static shared libs can only be installed on internal storage.");
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Packages declaring static-shared libs cannot be updated");
            return;
        }
    }
    // If we are installing a clustered package add results for the children
    if (pkg.childPackages != null) {
        synchronized (mPackages) {
            final int childCount = pkg.childPackages.size();
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = pkg.childPackages.get(i);
                PackageInstalledInfo childRes = new PackageInstalledInfo();
                childRes.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
                childRes.pkg = childPkg;
                childRes.name = childPkg.packageName;
                PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
                if (childPs != null) {
                    childRes.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                }
                if ((mPackages.containsKey(childPkg.packageName))) {
                    childRes.removedInfo = new PackageRemovedInfo(this);
                    childRes.removedInfo.removedPackage = childPkg.packageName;
                    childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                }
                if (res.addedChildPackages == null) {
                    res.addedChildPackages = new ArrayMap<>();
                }
                res.addedChildPackages.put(childPkg.packageName, childRes);
            }
        }
    }
    // time CPU ABI override.
    if (TextUtils.isEmpty(pkg.cpuAbiOverride)) {
        pkg.cpuAbiOverride = args.abiOverride;
    }
    String pkgName = res.name = pkg.packageName;
    if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0) {
        if ((installFlags & PackageManager.INSTALL_ALLOW_TEST) == 0) {
            res.setError(INSTALL_FAILED_TEST_ONLY, "installPackageLI");
            return;
        }
    }
    try {
        // either use what we've been given or parse directly from the APK
        if (args.certificates != null) {
            try {
                PackageParser.populateCertificates(pkg, args.certificates);
            } catch (PackageParserException e) {
                // there was something wrong with the certificates we were given;
                // try to pull them from the APK
                PackageParser.collectCertificates(pkg, parseFlags);
            }
        } else {
            PackageParser.collectCertificates(pkg, parseFlags);
        }
    } catch (PackageParserException e) {
        res.setError("Failed collect during installPackageLI", e);
        return;
    }
    // Get rid of all references to package scan path via parser.
    pp = null;
    String oldCodePath = null;
    boolean systemApp = false;
    synchronized (mPackages) {
        // Check if installing already existing package
        if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
            String oldName = mSettings.getRenamedPackageLPr(pkgName);
            if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName) && mPackages.containsKey(oldName)) {
                // This package is derived from an original package,
                // and this device has been updating from that original
                // name.  We must continue using the original name, so
                // rename the new package here.
                pkg.setPackageName(oldName);
                pkgName = pkg.packageName;
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replacing existing renamed package: oldName=" + oldName + " pkgName=" + pkgName);
            } else if (mPackages.containsKey(pkgName)) {
                // This package, under its official name, already exists
                // on the device; we should replace it.
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replace existing pacakge: " + pkgName);
            }
            // Child packages are installed through the parent package
            if (pkg.parentPackage != null) {
                res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + pkg.parentPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                return;
            }
            if (replace) {
                // Prevent apps opting out from runtime permissions
                PackageParser.Package oldPackage = mPackages.get(pkgName);
                final int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                final int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                if (oldTargetSdk > Build.VERSION_CODES.LOLLIPOP_MR1 && newTargetSdk <= Build.VERSION_CODES.LOLLIPOP_MR1) {
                    res.setError(PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE, "Package " + pkg.packageName + " new target SDK " + newTargetSdk + " doesn't support runtime permissions but the old" + " target SDK " + oldTargetSdk + " does.");
                    return;
                }
                // Prevent persistent apps from being updated
                if ((oldPackage.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) != 0) {
                    res.setError(PackageManager.INSTALL_FAILED_INVALID_APK, "Package " + oldPackage.packageName + " is a persistent app. " + "Persistent apps are not updateable.");
                    return;
                }
                // Prevent apps from downgrading their targetSandbox.
                final int oldTargetSandbox = oldPackage.applicationInfo.targetSandboxVersion;
                final int newTargetSandbox = pkg.applicationInfo.targetSandboxVersion;
                if (oldTargetSandbox == 2 && newTargetSandbox != 2) {
                    res.setError(PackageManager.INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Package " + pkg.packageName + " new target sandbox " + newTargetSandbox + " is incompatible with the previous value of" + oldTargetSandbox + ".");
                    return;
                }
                // Prevent installing of child packages
                if (oldPackage.parentPackage != null) {
                    res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + oldPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                    return;
                }
            }
        }
        PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Existing package: " + ps);
            // Static shared libs have same package with different versions where
            // we internally use a synthetic package name to allow multiple versions
            // of the same package, therefore we need to compare signatures against
            // the package setting for the latest library version.
            PackageSetting signatureCheckPs = ps;
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pkg);
                if (libraryEntry != null) {
                    signatureCheckPs = mSettings.getPackageLPr(libraryEntry.apk);
                }
            }
            // bail early here before tripping over redefined permissions.
            if (shouldCheckUpgradeKeySetLP(signatureCheckPs, scanFlags)) {
                if (!checkUpgradeKeySetLP(signatureCheckPs, pkg)) {
                    res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                    return;
                }
            } else {
                try {
                    verifySignaturesLP(signatureCheckPs, pkg);
                } catch (PackageManagerException e) {
                    res.setError(e.error, e.getMessage());
                    return;
                }
            }
            oldCodePath = mSettings.mPackages.get(pkgName).codePathString;
            if (ps.pkg != null && ps.pkg.applicationInfo != null) {
                systemApp = (ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
            }
            res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
        }
        int N = pkg.permissions.size();
        for (int i = N - 1; i >= 0; i--) {
            PackageParser.Permission perm = pkg.permissions.get(i);
            BasePermission bp = mSettings.mPermissions.get(perm.info.name);
            // Don't allow anyone but the system to define ephemeral permissions.
            if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0 && !systemApp) {
                Slog.w(TAG, "Non-System package " + pkg.packageName + " attempting to delcare ephemeral permission " + perm.info.name + "; Removing ephemeral.");
                perm.info.protectionLevel &= ~PermissionInfo.PROTECTION_FLAG_INSTANT;
            }
            // Check whether the newly-scanned package wants to define an already-defined perm
            if (bp != null) {
                // If the defining package is signed with our cert, it's okay.  This
                // also includes the "updating the same package" case, of course.
                // "updating same package" could also involve key-rotation.
                final boolean sigsOk;
                if (bp.sourcePackage.equals(pkg.packageName) && (bp.packageSetting instanceof PackageSetting) && (shouldCheckUpgradeKeySetLP((PackageSetting) bp.packageSetting, scanFlags))) {
                    sigsOk = checkUpgradeKeySetLP((PackageSetting) bp.packageSetting, pkg);
                } else {
                    sigsOk = compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH;
                }
                if (!sigsOk) {
                    // redefinitions.
                    if (!bp.sourcePackage.equals("android")) {
                        res.setError(INSTALL_FAILED_DUPLICATE_PERMISSION, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + bp.sourcePackage);
                        res.origPermission = perm.info.name;
                        res.origPackage = bp.sourcePackage;
                        return;
                    } else {
                        Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                        pkg.permissions.remove(i);
                    }
                } else if (!PLATFORM_PACKAGE_NAME.equals(pkg.packageName)) {
                    // it as dangerous leading to the group auto-grant.
                    if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE) == PermissionInfo.PROTECTION_DANGEROUS) {
                        if (bp != null && !bp.isRuntime()) {
                            Slog.w(TAG, "Package " + pkg.packageName + " trying to change a " + "non-runtime permission " + perm.info.name + " to runtime; keeping old protection level");
                            perm.info.protectionLevel = bp.protectionLevel;
                        }
                    }
                }
            }
        }
    }
    if (systemApp) {
        if (onExternal) {
            // Abort update; system app can't be replaced with app on sdcard
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Cannot install updates to system apps on sdcard");
            return;
        } else if (instantApp) {
            // Abort update; system app can't be replaced with an instant app
            res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Cannot update a system app with an instant app");
            return;
        }
    }
    if (args.move != null) {
        // We did an in-place move, so dex is ready to roll
        scanFlags |= SCAN_NO_DEX;
        scanFlags |= SCAN_MOVE;
        synchronized (mPackages) {
            final PackageSetting ps = mSettings.mPackages.get(pkgName);
            if (ps == null) {
                res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Missing settings for moved package " + pkgName);
            }
            // We moved the entire application as-is, so bring over the
            // previously derived ABI information.
            pkg.applicationInfo.primaryCpuAbi = ps.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = ps.secondaryCpuAbiString;
        }
    } else if (!forwardLocked && !pkg.applicationInfo.isExternalAsec()) {
        // Enable SCAN_NO_DEX flag to skip dexopt at a later stage
        scanFlags |= SCAN_NO_DEX;
        try {
            String abiOverride = (TextUtils.isEmpty(pkg.cpuAbiOverride) ? args.abiOverride : pkg.cpuAbiOverride);
            final boolean extractNativeLibs = !pkg.isLibrary();
            derivePackageAbi(pkg, new File(pkg.codePath), abiOverride, extractNativeLibs, mAppLib32InstallDir);
        } catch (PackageManagerException pme) {
            Slog.e(TAG, "Error deriving application ABI", pme);
            res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Error deriving application ABI");
            return;
        }
        // Shared libraries for the package need to be updated.
        synchronized (mPackages) {
            try {
                updateSharedLibrariesLPr(pkg, null);
            } catch (PackageManagerException e) {
                Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
            }
        }
    }
    if (!args.doRename(res.returnCode, pkg, oldCodePath)) {
        res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Failed rename");
        return;
    }
    if (!instantApp) {
        startIntentFilterVerifications(args.user.getIdentifier(), replace, pkg);
    } else {
        if (DEBUG_DOMAIN_VERIFICATION) {
            Slog.d(TAG, "Not verifying instant app install for app links: " + pkgName);
        }
    }
    try (PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags, "installPackageLI")) {
        if (replace) {
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                // Static libs have a synthetic package name containing the version
                // and cannot be updated as an update would get a new package name,
                // unless this is the exact same version code which is useful for
                // development.
                PackageParser.Package existingPkg = mPackages.get(pkg.packageName);
                if (existingPkg != null && existingPkg.mVersionCode != pkg.mVersionCode) {
                    res.setError(INSTALL_FAILED_DUPLICATE_PACKAGE, "Packages declaring " + "static-shared libs cannot be updated");
                    return;
                }
            }
            replacePackageLIF(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user, installerPackageName, res, args.installReason);
        } else {
            installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, volumeUuid, res, args.installReason);
        }
    }
    // Prepare the application profiles for the new code paths.
    // This needs to be done before invoking dexopt so that any install-time profile
    // can be used for optimizations.
    mArtManagerService.prepareAppProfiles(pkg, resolveUserIds(args.user.getIdentifier()));
    // Check whether we need to dexopt the app.
    // 
    // NOTE: it is IMPORTANT to call dexopt:
    // - after doRename which will sync the package data from PackageParser.Package and its
    // corresponding ApplicationInfo.
    // - after installNewPackageLIF or replacePackageLIF which will update result with the
    // uid of the application (pkg.applicationInfo.uid).
    // This update happens in place!
    // 
    // We only need to dexopt if the package meets ALL of the following conditions:
    // 1) it is not forward locked.
    // 2) it is not on on an external ASEC container.
    // 3) it is not an instant app or if it is then dexopt is enabled via gservices.
    // 
    // Note that we do not dexopt instant apps by default. dexopt can take some time to
    // complete, so we skip this step during installation. Instead, we'll take extra time
    // the first time the instant app starts. It's preferred to do it this way to provide
    // continuous progress to the useur instead of mysteriously blocking somewhere in the
    // middle of running an instant app. The default behaviour can be overridden
    // via gservices.
    final boolean performDexopt = (res.returnCode == PackageManager.INSTALL_SUCCEEDED) && !forwardLocked && !pkg.applicationInfo.isExternalAsec() && (!instantApp || Global.getInt(mContext.getContentResolver(), Global.INSTANT_APP_DEXOPT_ENABLED, 0) != 0);
    if (performDexopt) {
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "dexopt");
        // Do not run PackageDexOptimizer through the local performDexOpt
        // method because `pkg` may not be in `mPackages` yet.
        // 
        // Also, don't fail application installs if the dexopt step fails.
        DexoptOptions dexoptOptions = new DexoptOptions(pkg.packageName, REASON_INSTALL, DexoptOptions.DEXOPT_BOOT_COMPLETE | DexoptOptions.DEXOPT_INSTALL_WITH_DEX_METADATA_FILE);
        mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryFiles, null, /* instructionSets */
        getOrCreateCompilerPackageStats(pkg), mDexManager.getPackageUseInfoOrDefault(pkg.packageName), dexoptOptions);
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // Notify BackgroundDexOptService that the package has been changed.
    // If this is an update of a package which used to fail to compile,
    // BackgroundDexOptService will remove it from its blacklist.
    // TODO: Layering violation
    BackgroundDexOptService.notifyPackageChanged(pkg.packageName);
    synchronized (mPackages) {
        final PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
            ps.setUpdateAvailable(false);
        }
        final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = pkg.childPackages.get(i);
            PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName);
            PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
            if (childPs != null) {
                childRes.newUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
            }
        }
        if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
            updateSequenceNumberLP(ps, res.newUsers);
            updateInstantAppInstallerLocked(pkgName);
        }
    }
}
#end_block

#method_before
private void setEnabledSetting(final String packageName, String className, int newState, final int flags, int userId, String callingPackage) {
    if (!(newState == COMPONENT_ENABLED_STATE_DEFAULT || newState == COMPONENT_ENABLED_STATE_ENABLED || newState == COMPONENT_ENABLED_STATE_DISABLED || newState == COMPONENT_ENABLED_STATE_DISABLED_USER || newState == COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED)) {
        throw new IllegalArgumentException("Invalid new component state: " + newState);
    }
    PackageSetting pkgSetting;
    final int callingUid = Binder.getCallingUid();
    final int permission;
    if (callingUid == Process.SYSTEM_UID) {
        permission = PackageManager.PERMISSION_GRANTED;
    } else {
        permission = mContext.checkCallingOrSelfPermission(android.Manifest.permission.CHANGE_COMPONENT_ENABLED_STATE);
    }
    enforceCrossUserPermission(callingUid, userId, false, /* requireFullPermission */
    true, /* checkShell */
    "set enabled");
    final boolean allowedByPermission = (permission == PackageManager.PERMISSION_GRANTED);
    boolean sendNow = false;
    boolean isApp = (className == null);
    final boolean isCallerInstantApp = (getInstantAppPackageName(callingUid) != null);
    String componentName = isApp ? packageName : className;
    int packageUid = -1;
    ArrayList<String> components;
    // reader
    synchronized (mPackages) {
        pkgSetting = mSettings.mPackages.get(packageName);
        if (pkgSetting == null) {
            if (!isCallerInstantApp) {
                if (className == null) {
                    throw new IllegalArgumentException("Unknown package: " + packageName);
                }
                throw new IllegalArgumentException("Unknown component: " + packageName + "/" + className);
            } else {
                // throw SecurityException to prevent leaking package information
                throw new SecurityException("Attempt to change component state; " + "pid=" + Binder.getCallingPid() + ", uid=" + callingUid + (className == null ? ", package=" + packageName : ", component=" + packageName + "/" + className));
            }
        }
    }
    // Limit who can change which apps
    if (!UserHandle.isSameApp(callingUid, pkgSetting.appId)) {
        // Don't allow apps that don't have permission to modify other apps
        if (!allowedByPermission || filterAppAccessLPr(pkgSetting, callingUid, userId)) {
            throw new SecurityException("Attempt to change component state; " + "pid=" + Binder.getCallingPid() + ", uid=" + callingUid + (className == null ? ", package=" + packageName : ", component=" + packageName + "/" + className));
        }
        // Don't allow changing protected packages.
        if (mProtectedPackages.isPackageStateProtected(userId, packageName)) {
            throw new SecurityException("Cannot disable a protected package: " + packageName);
        }
    }
    synchronized (mPackages) {
        if (callingUid == Process.SHELL_UID && (pkgSetting.pkgFlags & ApplicationInfo.FLAG_TEST_ONLY) == 0) {
            // Shell can only change whole packages between ENABLED and DISABLED_USER states
            // unless it is a test package.
            int oldState = pkgSetting.getEnabled(userId);
            if (className == null && (oldState == COMPONENT_ENABLED_STATE_DISABLED_USER || oldState == COMPONENT_ENABLED_STATE_DEFAULT || oldState == COMPONENT_ENABLED_STATE_ENABLED) && (newState == COMPONENT_ENABLED_STATE_DISABLED_USER || newState == COMPONENT_ENABLED_STATE_DEFAULT || newState == COMPONENT_ENABLED_STATE_ENABLED)) {
            // ok
            } else {
                throw new SecurityException("Shell cannot change component state for " + packageName + "/" + className + " to " + newState);
            }
        }
    }
    if (className == null) {
        // We're dealing with an application/package level state change
        synchronized (mPackages) {
            if (pkgSetting.getEnabled(userId) == newState) {
                // Nothing to do
                return;
            }
        }
        // If we're enabling a system stub, there's a little more work to do.
        // Prior to enabling the package, we need to decompress the APK(s) to the
        // data partition and then replace the version on the system partition.
        final PackageParser.Package deletedPkg = pkgSetting.pkg;
        final boolean isSystemStub = deletedPkg.isStub && deletedPkg.isSystemApp();
        if (isSystemStub && (newState == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT || newState == PackageManager.COMPONENT_ENABLED_STATE_ENABLED)) {
            final File codePath = decompressPackage(deletedPkg);
            if (codePath == null) {
                Slog.e(TAG, "couldn't decompress pkg: " + pkgSetting.name);
                return;
            }
            // TODO remove direct parsing of the package object during internal cleanup
            // of scan package
            // We need to call parse directly here for no other reason than we need
            // the new package in order to disable the old one [we use the information
            // for some internal optimization to optionally create a new package setting
            // object on replace]. However, we can't get the package from the scan
            // because the scan modifies live structures and we need to remove the
            // old [system] package from the system before a scan can be attempted.
            // Once scan is indempotent we can remove this parse and use the package
            // object we scanned, prior to adding it to package settings.
            final PackageParser pp = new PackageParser();
            pp.setSeparateProcesses(mSeparateProcesses);
            pp.setDisplayMetrics(mMetrics);
            pp.setCallback(mPackageParserCallback);
            final PackageParser.Package tmpPkg;
            try {
                final int parseFlags = mDefParseFlags | PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR;
                tmpPkg = pp.parsePackage(codePath, parseFlags);
            } catch (PackageParserException e) {
                Slog.w(TAG, "Failed to parse compressed system package:" + pkgSetting.name, e);
                return;
            }
            synchronized (mInstallLock) {
                // Disable the stub and remove any package entries
                removePackageLI(deletedPkg, true);
                synchronized (mPackages) {
                    disableSystemPackageLPw(deletedPkg, tmpPkg);
                }
                final PackageParser.Package newPkg;
                try (PackageFreezer freezer = freezePackage(deletedPkg.packageName, "setEnabledSetting")) {
                    final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE;
                    newPkg = scanPackageTracedLI(codePath, parseFlags, 0, /*scanFlags*/
                    0, /*currentTime*/
                    null);
                    prepareAppDataAfterInstallLIF(newPkg);
                    synchronized (mPackages) {
                        try {
                            updateSharedLibrariesLPr(newPkg, null);
                        } catch (PackageManagerException e) {
                            Slog.e(TAG, "updateAllSharedLibrariesLPw failed: ", e);
                        }
                        updatePermissionsLPw(newPkg.packageName, newPkg, UPDATE_PERMISSIONS_ALL | UPDATE_PERMISSIONS_REPLACE_PKG);
                        mSettings.writeLPr();
                    }
                } catch (PackageManagerException e) {
                    // Whoops! Something went wrong; try to roll back to the stub
                    Slog.w(TAG, "Failed to install compressed system package:" + pkgSetting.name, e);
                    // Remove the failed install
                    removeCodePathLI(codePath);
                    // Install the system package
                    try (PackageFreezer freezer = freezePackage(deletedPkg.packageName, "setEnabledSetting")) {
                        synchronized (mPackages) {
                            // NOTE: The system package always needs to be enabled; even
                            // if it's for a compressed stub. If we don't, installing the
                            // system package fails during scan [scanning checks the disabled
                            // packages]. We will reverse this later, after we've "installed"
                            // the stub.
                            // This leaves us in a fragile state; the stub should never be
                            // enabled, so, cross your fingers and hope nothing goes wrong
                            // until we can disable the package later.
                            enableSystemPackageLPw(deletedPkg);
                        }
                        installPackageFromSystemLIF(new File(deletedPkg.codePath), false, /*isPrivileged*/
                        null, /*allUserHandles*/
                        null, /*origUserHandles*/
                        null, /*origPermissionsState*/
                        true);
                    } catch (PackageManagerException pme) {
                        Slog.w(TAG, "Failed to restore system package:" + deletedPkg.packageName, pme);
                    } finally {
                        synchronized (mPackages) {
                            mSettings.disableSystemPackageLPw(deletedPkg.packageName, true);
                            mSettings.writeLPr();
                        }
                    }
                    return;
                }
                clearAppDataLIF(newPkg, UserHandle.USER_ALL, FLAG_STORAGE_DE | FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);
                clearAppProfilesLIF(newPkg, UserHandle.USER_ALL);
                mDexManager.notifyPackageUpdated(newPkg.packageName, newPkg.baseCodePath, newPkg.splitCodePaths);
            }
        }
        if (newState == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT || newState == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
            // Don't care about who enables an app.
            callingPackage = null;
        }
        synchronized (mPackages) {
            pkgSetting.setEnabled(newState, userId, callingPackage);
        }
    } else {
        synchronized (mPackages) {
            // We're dealing with a component level state change
            // First, verify that this is a valid class name.
            PackageParser.Package pkg = pkgSetting.pkg;
            if (pkg == null || !pkg.hasComponentClassName(className)) {
                if (pkg != null && pkg.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
                    throw new IllegalArgumentException("Component class " + className + " does not exist in " + packageName);
                } else {
                    Slog.w(TAG, "Failed setComponentEnabledSetting: component class " + className + " does not exist in " + packageName);
                }
            }
            switch(newState) {
                case COMPONENT_ENABLED_STATE_ENABLED:
                    if (!pkgSetting.enableComponentLPw(className, userId)) {
                        return;
                    }
                    break;
                case COMPONENT_ENABLED_STATE_DISABLED:
                    if (!pkgSetting.disableComponentLPw(className, userId)) {
                        return;
                    }
                    break;
                case COMPONENT_ENABLED_STATE_DEFAULT:
                    if (!pkgSetting.restoreComponentLPw(className, userId)) {
                        return;
                    }
                    break;
                default:
                    Slog.e(TAG, "Invalid new component state: " + newState);
                    return;
            }
        }
    }
    synchronized (mPackages) {
        scheduleWritePackageRestrictionsLocked(userId);
        updateSequenceNumberLP(pkgSetting, new int[] { userId });
        final long callingId = Binder.clearCallingIdentity();
        try {
            updateInstantAppInstallerLocked(packageName);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
        components = mPendingBroadcasts.get(userId, packageName);
        final boolean newPackage = components == null;
        if (newPackage) {
            components = new ArrayList<String>();
        }
        if (!components.contains(componentName)) {
            components.add(componentName);
        }
        if ((flags & PackageManager.DONT_KILL_APP) == 0) {
            sendNow = true;
            // Purge entry from pending broadcast list if another one exists already
            // since we are sending one right away.
            mPendingBroadcasts.remove(userId, packageName);
        } else {
            if (newPackage) {
                mPendingBroadcasts.put(userId, packageName, components);
            }
            if (!mHandler.hasMessages(SEND_PENDING_BROADCAST)) {
                // Schedule a message
                mHandler.sendEmptyMessageDelayed(SEND_PENDING_BROADCAST, BROADCAST_DELAY);
            }
        }
    }
    long callingId = Binder.clearCallingIdentity();
    try {
        if (sendNow) {
            packageUid = UserHandle.getUid(userId, pkgSetting.appId);
            sendPackageChangedBroadcast(packageName, (flags & PackageManager.DONT_KILL_APP) != 0, components, packageUid);
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
#method_after
private void setEnabledSetting(final String packageName, String className, int newState, final int flags, int userId, String callingPackage) {
    if (!(newState == COMPONENT_ENABLED_STATE_DEFAULT || newState == COMPONENT_ENABLED_STATE_ENABLED || newState == COMPONENT_ENABLED_STATE_DISABLED || newState == COMPONENT_ENABLED_STATE_DISABLED_USER || newState == COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED)) {
        throw new IllegalArgumentException("Invalid new component state: " + newState);
    }
    PackageSetting pkgSetting;
    final int callingUid = Binder.getCallingUid();
    final int permission;
    if (callingUid == Process.SYSTEM_UID) {
        permission = PackageManager.PERMISSION_GRANTED;
    } else {
        permission = mContext.checkCallingOrSelfPermission(android.Manifest.permission.CHANGE_COMPONENT_ENABLED_STATE);
    }
    enforceCrossUserPermission(callingUid, userId, false, /* requireFullPermission */
    true, /* checkShell */
    "set enabled");
    final boolean allowedByPermission = (permission == PackageManager.PERMISSION_GRANTED);
    boolean sendNow = false;
    boolean isApp = (className == null);
    final boolean isCallerInstantApp = (getInstantAppPackageName(callingUid) != null);
    String componentName = isApp ? packageName : className;
    int packageUid = -1;
    ArrayList<String> components;
    // reader
    synchronized (mPackages) {
        pkgSetting = mSettings.mPackages.get(packageName);
        if (pkgSetting == null) {
            if (!isCallerInstantApp) {
                if (className == null) {
                    throw new IllegalArgumentException("Unknown package: " + packageName);
                }
                throw new IllegalArgumentException("Unknown component: " + packageName + "/" + className);
            } else {
                // throw SecurityException to prevent leaking package information
                throw new SecurityException("Attempt to change component state; " + "pid=" + Binder.getCallingPid() + ", uid=" + callingUid + (className == null ? ", package=" + packageName : ", component=" + packageName + "/" + className));
            }
        }
    }
    // Limit who can change which apps
    if (!UserHandle.isSameApp(callingUid, pkgSetting.appId)) {
        // Don't allow apps that don't have permission to modify other apps
        if (!allowedByPermission || filterAppAccessLPr(pkgSetting, callingUid, userId)) {
            throw new SecurityException("Attempt to change component state; " + "pid=" + Binder.getCallingPid() + ", uid=" + callingUid + (className == null ? ", package=" + packageName : ", component=" + packageName + "/" + className));
        }
        // Don't allow changing protected packages.
        if (mProtectedPackages.isPackageStateProtected(userId, packageName)) {
            throw new SecurityException("Cannot disable a protected package: " + packageName);
        }
    }
    synchronized (mPackages) {
        if (callingUid == Process.SHELL_UID && (pkgSetting.pkgFlags & ApplicationInfo.FLAG_TEST_ONLY) == 0) {
            // Shell can only change whole packages between ENABLED and DISABLED_USER states
            // unless it is a test package.
            int oldState = pkgSetting.getEnabled(userId);
            if (className == null && (oldState == COMPONENT_ENABLED_STATE_DISABLED_USER || oldState == COMPONENT_ENABLED_STATE_DEFAULT || oldState == COMPONENT_ENABLED_STATE_ENABLED) && (newState == COMPONENT_ENABLED_STATE_DISABLED_USER || newState == COMPONENT_ENABLED_STATE_DEFAULT || newState == COMPONENT_ENABLED_STATE_ENABLED)) {
            // ok
            } else {
                throw new SecurityException("Shell cannot change component state for " + packageName + "/" + className + " to " + newState);
            }
        }
    }
    if (className == null) {
        // We're dealing with an application/package level state change
        synchronized (mPackages) {
            if (pkgSetting.getEnabled(userId) == newState) {
                // Nothing to do
                return;
            }
        }
        // If we're enabling a system stub, there's a little more work to do.
        // Prior to enabling the package, we need to decompress the APK(s) to the
        // data partition and then replace the version on the system partition.
        final PackageParser.Package deletedPkg = pkgSetting.pkg;
        final boolean isSystemStub = deletedPkg.isStub && deletedPkg.isSystemApp();
        if (isSystemStub && (newState == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT || newState == PackageManager.COMPONENT_ENABLED_STATE_ENABLED)) {
            final File codePath = decompressPackage(deletedPkg);
            if (codePath == null) {
                Slog.e(TAG, "couldn't decompress pkg: " + pkgSetting.name);
                return;
            }
            // TODO remove direct parsing of the package object during internal cleanup
            // of scan package
            // We need to call parse directly here for no other reason than we need
            // the new package in order to disable the old one [we use the information
            // for some internal optimization to optionally create a new package setting
            // object on replace]. However, we can't get the package from the scan
            // because the scan modifies live structures and we need to remove the
            // old [system] package from the system before a scan can be attempted.
            // Once scan is indempotent we can remove this parse and use the package
            // object we scanned, prior to adding it to package settings.
            final PackageParser pp = new PackageParser();
            pp.setSeparateProcesses(mSeparateProcesses);
            pp.setDisplayMetrics(mMetrics);
            pp.setCallback(mPackageParserCallback);
            final PackageParser.Package tmpPkg;
            try {
                final int parseFlags = mDefParseFlags | PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR;
                tmpPkg = pp.parsePackage(codePath, parseFlags);
            } catch (PackageParserException e) {
                Slog.w(TAG, "Failed to parse compressed system package:" + pkgSetting.name, e);
                return;
            }
            synchronized (mInstallLock) {
                // Disable the stub and remove any package entries
                removePackageLI(deletedPkg, true);
                synchronized (mPackages) {
                    disableSystemPackageLPw(deletedPkg, tmpPkg);
                }
                final PackageParser.Package newPkg;
                try (PackageFreezer freezer = freezePackage(deletedPkg.packageName, "setEnabledSetting")) {
                    final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE;
                    newPkg = scanPackageTracedLI(codePath, parseFlags, 0, /*scanFlags*/
                    0, /*currentTime*/
                    null);
                    prepareAppDataAfterInstallLIF(newPkg);
                    synchronized (mPackages) {
                        try {
                            updateSharedLibrariesLPr(newPkg, null);
                        } catch (PackageManagerException e) {
                            Slog.e(TAG, "updateAllSharedLibrariesLPw failed: ", e);
                        }
                        updatePermissionsLPw(newPkg.packageName, newPkg, UPDATE_PERMISSIONS_ALL | UPDATE_PERMISSIONS_REPLACE_PKG);
                        mSettings.writeLPr();
                    }
                } catch (PackageManagerException e) {
                    // Whoops! Something went wrong; try to roll back to the stub
                    Slog.w(TAG, "Failed to install compressed system package:" + pkgSetting.name, e);
                    // Remove the failed install
                    removeCodePathLI(codePath);
                    // Install the system package
                    try (PackageFreezer freezer = freezePackage(deletedPkg.packageName, "setEnabledSetting")) {
                        synchronized (mPackages) {
                            // NOTE: The system package always needs to be enabled; even
                            // if it's for a compressed stub. If we don't, installing the
                            // system package fails during scan [scanning checks the disabled
                            // packages]. We will reverse this later, after we've "installed"
                            // the stub.
                            // This leaves us in a fragile state; the stub should never be
                            // enabled, so, cross your fingers and hope nothing goes wrong
                            // until we can disable the package later.
                            enableSystemPackageLPw(deletedPkg);
                        }
                        installPackageFromSystemLIF(new File(deletedPkg.codePath), false, /*isPrivileged*/
                        null, /*allUserHandles*/
                        null, /*origUserHandles*/
                        null, /*origPermissionsState*/
                        true);
                    } catch (PackageManagerException pme) {
                        Slog.w(TAG, "Failed to restore system package:" + deletedPkg.packageName, pme);
                    } finally {
                        synchronized (mPackages) {
                            mSettings.disableSystemPackageLPw(deletedPkg.packageName, true);
                            mSettings.writeLPr();
                        }
                    }
                    return;
                }
                clearAppDataLIF(newPkg, UserHandle.USER_ALL, FLAG_STORAGE_DE | FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);
                mDexManager.notifyPackageUpdated(newPkg.packageName, newPkg.baseCodePath, newPkg.splitCodePaths);
            }
        }
        if (newState == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT || newState == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
            // Don't care about who enables an app.
            callingPackage = null;
        }
        synchronized (mPackages) {
            pkgSetting.setEnabled(newState, userId, callingPackage);
        }
    } else {
        synchronized (mPackages) {
            // We're dealing with a component level state change
            // First, verify that this is a valid class name.
            PackageParser.Package pkg = pkgSetting.pkg;
            if (pkg == null || !pkg.hasComponentClassName(className)) {
                if (pkg != null && pkg.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
                    throw new IllegalArgumentException("Component class " + className + " does not exist in " + packageName);
                } else {
                    Slog.w(TAG, "Failed setComponentEnabledSetting: component class " + className + " does not exist in " + packageName);
                }
            }
            switch(newState) {
                case COMPONENT_ENABLED_STATE_ENABLED:
                    if (!pkgSetting.enableComponentLPw(className, userId)) {
                        return;
                    }
                    break;
                case COMPONENT_ENABLED_STATE_DISABLED:
                    if (!pkgSetting.disableComponentLPw(className, userId)) {
                        return;
                    }
                    break;
                case COMPONENT_ENABLED_STATE_DEFAULT:
                    if (!pkgSetting.restoreComponentLPw(className, userId)) {
                        return;
                    }
                    break;
                default:
                    Slog.e(TAG, "Invalid new component state: " + newState);
                    return;
            }
        }
    }
    synchronized (mPackages) {
        scheduleWritePackageRestrictionsLocked(userId);
        updateSequenceNumberLP(pkgSetting, new int[] { userId });
        final long callingId = Binder.clearCallingIdentity();
        try {
            updateInstantAppInstallerLocked(packageName);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
        components = mPendingBroadcasts.get(userId, packageName);
        final boolean newPackage = components == null;
        if (newPackage) {
            components = new ArrayList<String>();
        }
        if (!components.contains(componentName)) {
            components.add(componentName);
        }
        if ((flags & PackageManager.DONT_KILL_APP) == 0) {
            sendNow = true;
            // Purge entry from pending broadcast list if another one exists already
            // since we are sending one right away.
            mPendingBroadcasts.remove(userId, packageName);
        } else {
            if (newPackage) {
                mPendingBroadcasts.put(userId, packageName, components);
            }
            if (!mHandler.hasMessages(SEND_PENDING_BROADCAST)) {
                // Schedule a message
                mHandler.sendEmptyMessageDelayed(SEND_PENDING_BROADCAST, BROADCAST_DELAY);
            }
        }
    }
    long callingId = Binder.clearCallingIdentity();
    try {
        if (sendNow) {
            packageUid = UserHandle.getUid(userId, pkgSetting.appId);
            sendPackageChangedBroadcast(packageName, (flags & PackageManager.DONT_KILL_APP) != 0, components, packageUid);
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
#end_block

#method_before
private void prepareAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
    if (DEBUG_APP_DATA) {
        Slog.v(TAG, "prepareAppData for " + pkg.packageName + " u" + userId + " 0x" + Integer.toHexString(flags));
    }
    final String volumeUuid = pkg.volumeUuid;
    final String packageName = pkg.packageName;
    final ApplicationInfo app = pkg.applicationInfo;
    final int appId = UserHandle.getAppId(app.uid);
    Preconditions.checkNotNull(app.seInfo);
    long ceDataInode = -1;
    try {
        ceDataInode = mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, app.seInfo, app.targetSdkVersion);
    } catch (InstallerException e) {
        if (app.isSystemApp()) {
            logCriticalInfo(Log.ERROR, "Failed to create app data for " + packageName + ", but trying to recover: " + e);
            destroyAppDataLeafLIF(pkg, userId, flags);
            try {
                ceDataInode = mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, app.seInfo, app.targetSdkVersion);
                logCriticalInfo(Log.DEBUG, "Recovery succeeded!");
            } catch (InstallerException e2) {
                logCriticalInfo(Log.DEBUG, "Recovery failed!");
            }
        } else {
            Slog.e(TAG, "Failed to create app data for " + packageName + ": " + e);
        }
    }
    if ((flags & StorageManager.FLAG_STORAGE_CE) != 0 && ceDataInode != -1) {
        // TODO: mark this structure as dirty so we persist it!
        synchronized (mPackages) {
            final PackageSetting ps = mSettings.mPackages.get(packageName);
            if (ps != null) {
                ps.setCeDataInode(ceDataInode, userId);
            }
        }
    }
    prepareAppDataContentsLeafLIF(pkg, userId, flags);
}
#method_after
private void prepareAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
    if (DEBUG_APP_DATA) {
        Slog.v(TAG, "prepareAppData for " + pkg.packageName + " u" + userId + " 0x" + Integer.toHexString(flags));
    }
    final String volumeUuid = pkg.volumeUuid;
    final String packageName = pkg.packageName;
    final ApplicationInfo app = pkg.applicationInfo;
    final int appId = UserHandle.getAppId(app.uid);
    Preconditions.checkNotNull(app.seInfo);
    long ceDataInode = -1;
    try {
        ceDataInode = mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, app.seInfo, app.targetSdkVersion);
    } catch (InstallerException e) {
        if (app.isSystemApp()) {
            logCriticalInfo(Log.ERROR, "Failed to create app data for " + packageName + ", but trying to recover: " + e);
            destroyAppDataLeafLIF(pkg, userId, flags);
            try {
                ceDataInode = mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, app.seInfo, app.targetSdkVersion);
                logCriticalInfo(Log.DEBUG, "Recovery succeeded!");
            } catch (InstallerException e2) {
                logCriticalInfo(Log.DEBUG, "Recovery failed!");
            }
        } else {
            Slog.e(TAG, "Failed to create app data for " + packageName + ": " + e);
        }
    }
    // Prepare the application profiles.
    mArtManagerService.prepareAppProfiles(pkg, userId);
    if ((flags & StorageManager.FLAG_STORAGE_CE) != 0 && ceDataInode != -1) {
        // TODO: mark this structure as dirty so we persist it!
        synchronized (mPackages) {
            final PackageSetting ps = mSettings.mPackages.get(packageName);
            if (ps != null) {
                ps.setCeDataInode(ceDataInode, userId);
            }
        }
    }
    prepareAppDataContentsLeafLIF(pkg, userId, flags);
}
#end_block

#method_before
synchronized void recordScanStart(ScanSettings settings, boolean filtered, int scannerId) {
    LastScan existingScan = getScanFromScannerId(scannerId);
    if (existingScan != null) {
        return;
    }
    this.mScansStarted++;
    startTime = SystemClock.elapsedRealtime();
    LastScan scan = new LastScan(startTime, 0, false, false, filtered, scannerId);
    if (settings != null) {
        scan.opportunistic = settings.getScanMode() == ScanSettings.SCAN_MODE_OPPORTUNISTIC;
        scan.background = (settings.getCallbackType() & ScanSettings.CALLBACK_TYPE_FIRST_MATCH) != 0;
    }
    BluetoothMetricsProto.ScanEvent scanEvent = BluetoothMetricsProto.ScanEvent.newBuilder().setScanEventType(BluetoothMetricsProto.ScanEvent.ScanEventType.SCAN_EVENT_START).setScanTechnologyType(BluetoothMetricsProto.ScanEvent.ScanTechnologyType.SCAN_TECH_TYPE_LE).setEventTimeMillis(System.currentTimeMillis()).setInitiator(truncateAppName(appName)).build();
    mGattService.addScanEvent(scanEvent);
    mSessionNumScanResults = 0;
    if (!isScanning()) {
        mScanStartTime = startTime;
    }
    try {
        boolean isUnoptimized = !(scan.filtered || scan.background || scan.opportunistic);
        mBatteryStats.noteBleScanStarted(workSource, isUnoptimized);
    } catch (RemoteException e) {
    /* ignore */
    }
    mOngoingScans.put(scannerId, scan);
}
#method_after
synchronized void recordScanStart(ScanSettings settings, boolean filtered, int scannerId) {
    LastScan existingScan = getScanFromScannerId(scannerId);
    if (existingScan != null) {
        return;
    }
    this.mScansStarted++;
    startTime = SystemClock.elapsedRealtime();
    LastScan scan = new LastScan(startTime, 0, false, false, filtered, scannerId);
    if (settings != null) {
        scan.opportunistic = settings.getScanMode() == ScanSettings.SCAN_MODE_OPPORTUNISTIC;
        scan.background = (settings.getCallbackType() & ScanSettings.CALLBACK_TYPE_FIRST_MATCH) != 0;
    }
    BluetoothMetricsProto.ScanEvent scanEvent = BluetoothMetricsProto.ScanEvent.newBuilder().setScanEventType(BluetoothMetricsProto.ScanEvent.ScanEventType.SCAN_EVENT_START).setScanTechnologyType(BluetoothMetricsProto.ScanEvent.ScanTechnologyType.SCAN_TECH_TYPE_LE).setEventTimeMillis(System.currentTimeMillis()).setInitiator(truncateAppName(appName)).build();
    mGattService.addScanEvent(scanEvent);
    if (!isScanning()) {
        mScanStartTime = startTime;
    }
    try {
        boolean isUnoptimized = !(scan.filtered || scan.background || scan.opportunistic);
        mBatteryStats.noteBleScanStarted(workSource, isUnoptimized);
    } catch (RemoteException e) {
    /* ignore */
    }
    mOngoingScans.put(scannerId, scan);
}
#end_block

#method_before
synchronized void recordScanStop(int scannerId) {
    LastScan scan = getScanFromScannerId(scannerId);
    if (scan == null) {
        return;
    }
    this.mScansStopped++;
    stopTime = SystemClock.elapsedRealtime();
    long scanDuration = stopTime - scan.timestamp;
    scan.duration = scanDuration;
    if (scan.isSuspended) {
        long suspendDuration = stopTime - scan.suspendStartTime;
        scan.suspendDuration += suspendDuration;
        mTotalSuspendTime += suspendDuration;
    }
    mOngoingScans.remove(scannerId);
    if (mLastScans.size() >= NUM_SCAN_DURATIONS_KEPT) {
        mLastScans.remove(0);
    }
    mLastScans.add(scan);
    BluetoothMetricsProto.ScanEvent scanEvent = BluetoothMetricsProto.ScanEvent.newBuilder().setScanEventType(BluetoothMetricsProto.ScanEvent.ScanEventType.SCAN_EVENT_STOP).setScanTechnologyType(BluetoothMetricsProto.ScanEvent.ScanTechnologyType.SCAN_TECH_TYPE_LE).setEventTimeMillis(System.currentTimeMillis()).setInitiator(truncateAppName(appName)).setNumberResults(mSessionNumScanResults).build();
    mGattService.addScanEvent(scanEvent);
    mSessionNumScanResults = 0;
    if (!isScanning()) {
        long totalDuration = stopTime - mScanStartTime;
        mTotalScanTime += totalDuration;
        mMinScanTime = Math.min(totalDuration, mMinScanTime);
        mMaxScanTime = Math.max(totalDuration, mMaxScanTime);
    }
    try {
        // Inform battery stats of any results it might be missing on
        // scan stop
        boolean isUnoptimized = !(scan.filtered || scan.background || scan.opportunistic);
        mBatteryStats.noteBleScanResults(workSource, scan.results % 100);
        mBatteryStats.noteBleScanStopped(workSource, isUnoptimized);
    } catch (RemoteException e) {
    /* ignore */
    }
}
#method_after
synchronized void recordScanStop(int scannerId) {
    LastScan scan = getScanFromScannerId(scannerId);
    if (scan == null) {
        return;
    }
    this.mScansStopped++;
    stopTime = SystemClock.elapsedRealtime();
    long scanDuration = stopTime - scan.timestamp;
    scan.duration = scanDuration;
    if (scan.isSuspended) {
        long suspendDuration = stopTime - scan.suspendStartTime;
        scan.suspendDuration += suspendDuration;
        mTotalSuspendTime += suspendDuration;
    }
    mOngoingScans.remove(scannerId);
    if (mLastScans.size() >= NUM_SCAN_DURATIONS_KEPT) {
        mLastScans.remove(0);
    }
    mLastScans.add(scan);
    BluetoothMetricsProto.ScanEvent scanEvent = BluetoothMetricsProto.ScanEvent.newBuilder().setScanEventType(BluetoothMetricsProto.ScanEvent.ScanEventType.SCAN_EVENT_STOP).setScanTechnologyType(BluetoothMetricsProto.ScanEvent.ScanTechnologyType.SCAN_TECH_TYPE_LE).setEventTimeMillis(System.currentTimeMillis()).setInitiator(truncateAppName(appName)).setNumberResults(scan.results).build();
    mGattService.addScanEvent(scanEvent);
    if (!isScanning()) {
        long totalDuration = stopTime - mScanStartTime;
        mTotalScanTime += totalDuration;
        mMinScanTime = Math.min(totalDuration, mMinScanTime);
        mMaxScanTime = Math.max(totalDuration, mMaxScanTime);
    }
    try {
        // Inform battery stats of any results it might be missing on
        // scan stop
        boolean isUnoptimized = !(scan.filtered || scan.background || scan.opportunistic);
        mBatteryStats.noteBleScanResults(workSource, scan.results % 100);
        mBatteryStats.noteBleScanStopped(workSource, isUnoptimized);
    } catch (RemoteException e) {
    /* ignore */
    }
}
#end_block

#method_before
private void dumpMetrics(FileDescriptor fd) {
    BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder = BluetoothMetricsProto.BluetoothLog.newBuilder();
    metricsBuilder.setNumBondedDevices(getBondedDevices().length);
    for (ProfileService profile : mRegisteredProfiles) {
        profile.dumpProto(metricsBuilder);
    }
    byte[] nativeMetricsBytes = dumpMetricsNative();
    debugLog("dumpMetrics: native metrics size is " + nativeMetricsBytes.length);
    if (nativeMetricsBytes.length > 0) {
        try {
            metricsBuilder.mergeFrom(nativeMetricsBytes);
        } catch (InvalidProtocolBufferException ex) {
            Log.w(TAG, "dumpMetrics: problem parsing metrics protobuf, " + ex.getMessage());
            return;
        }
    }
    byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);
    debugLog("dumpMetrics: combined metrics size is " + metricsBytes.length);
    try (FileOutputStream protoOut = new FileOutputStream(fd)) {
        protoOut.write(metricsBytes);
    } catch (IOException e) {
        errorLog("dumpMetrics: error writing combined protobuf to fd, " + e.getMessage());
    }
}
#method_after
private void dumpMetrics(FileDescriptor fd) {
    BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder = BluetoothMetricsProto.BluetoothLog.newBuilder();
    byte[] nativeMetricsBytes = dumpMetricsNative();
    debugLog("dumpMetrics: native metrics size is " + nativeMetricsBytes.length);
    if (nativeMetricsBytes.length > 0) {
        try {
            metricsBuilder.mergeFrom(nativeMetricsBytes);
        } catch (InvalidProtocolBufferException ex) {
            Log.w(TAG, "dumpMetrics: problem parsing metrics protobuf, " + ex.getMessage());
            return;
        }
    }
    metricsBuilder.setNumBondedDevices(getBondedDevices().length);
    for (ProfileService profile : mRegisteredProfiles) {
        profile.dumpProto(metricsBuilder);
    }
    byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);
    debugLog("dumpMetrics: combined metrics size is " + metricsBytes.length);
    try (FileOutputStream protoOut = new FileOutputStream(fd)) {
        protoOut.write(metricsBytes);
    } catch (IOException e) {
        errorLog("dumpMetrics: error writing combined protobuf to fd, " + e.getMessage());
    }
}
#end_block

#method_before
public SigningCertificateLineage build() throws CertificateEncodingException, InvalidKeyException, NoSuchAlgorithmException, SignatureException {
    if (mMinSdkVersion < AndroidSdkVersion.P) {
        mMinSdkVersion = AndroidSdkVersion.P;
    }
    if (mOriginalCapabilities == null) {
        mOriginalCapabilities = new SignerCapabilities.Builder().build();
    }
    if (mNewCapabilities == null) {
        mNewCapabilities = new SignerCapabilities.Builder().build();
    }
    return createSigningLineage(mMinSdkVersion, mOriginalSignerConfig, mOriginalCapabilities, mNewSignerConfig, mNewCapabilities);
}
#method_after
public SignerCapabilities build() {
    return new SignerCapabilities(mFlags);
}
#end_block

#method_before
public SigningCertificateLineage build() throws CertificateEncodingException, InvalidKeyException, NoSuchAlgorithmException, SignatureException {
    if (mMinSdkVersion < AndroidSdkVersion.P) {
        mMinSdkVersion = AndroidSdkVersion.P;
    }
    if (mOriginalCapabilities == null) {
        mOriginalCapabilities = new SignerCapabilities.Builder().build();
    }
    if (mNewCapabilities == null) {
        mNewCapabilities = new SignerCapabilities.Builder().build();
    }
    return createSigningLineage(mMinSdkVersion, mOriginalSignerConfig, mOriginalCapabilities, mNewSignerConfig, mNewCapabilities);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mPrivateKey, mCertificate);
}
#end_block

#method_before
public final void writeObject(Object obj) throws IOException {
    if (enableOverride) {
        writeObjectOverride(obj);
        return;
    }
    try {
        writeObject0(obj, false);
    } catch (IOException ex) {
        if (depth == 0) {
            // writeFatalException(ex);
            try {
                writeFatalException(ex);
            } catch (IOException ex2) {
            // If writing the exception to the output stream causes another exception there
            // is no need to propagate the second exception or generate a third exception,
            // both of which might obscure details of the root cause.
            }
        // END Android-changed: Nested exceptions handling.
        }
        throw ex;
    }
}
#method_after
public final void writeObject(Object obj) throws IOException {
    if (enableOverride) {
        writeObjectOverride(obj);
        return;
    }
    try {
        writeObject0(obj, false);
    } catch (IOException ex) {
        if (depth == 0) {
            // writeFatalException(ex);
            try {
                writeFatalException(ex);
            } catch (IOException ex2) {
            // If writing the exception to the output stream causes another exception there
            // is no need to propagate the second exception or generate a third exception,
            // both of which might obscure details of the root cause.
            }
        // END Android-changed: Ignore secondary exceptions during writeObject().
        }
        throw ex;
    }
}
#end_block

#method_before
protected void writeObjectOverride(Object obj) throws IOException {
    // BEGIN Android-added: Throw IOException if not overriden
    if (!enableOverride) {
        // Subclasses must override.
        throw new IOException();
    }
// END Android-added: Throw IOException if not overriden
}
#method_after
protected void writeObjectOverride(Object obj) throws IOException {
    // BEGIN Android-added: Let writeObjectOverride throw IOException if !enableOverride.
    if (!enableOverride) {
        // Subclasses must override.
        throw new IOException();
    }
// END Android-added: Let writeObjectOverride throw IOException if !enableOverride.
}
#end_block

#method_before
public void close() throws IOException {
    flush();
    // Android-removed: b/28159133, prevent the handle table reset.
    // clear();
    bout.close();
}
#method_after
public void close() throws IOException {
    flush();
    // Android-removed:  Don't clear() during close(), keep the handle table. http://b/28159133
    // clear();
    bout.close();
}
#end_block

#method_before
private void writeObject0(Object obj, boolean unshared) throws IOException {
    boolean oldMode = bout.setBlockDataMode(false);
    depth++;
    try {
        // handle previously written and non-replaceable objects
        int h;
        if ((obj = subs.lookup(obj)) == null) {
            writeNull();
            return;
        } else if (!unshared && (h = handles.lookup(obj)) != -1) {
            writeHandle(h);
            return;
        // BEGIN Android-changed:  Make Class and ObjectStreamClass replacable.
        /*
            } else if (obj instanceof Class) {
                writeClass((Class) obj, unshared);
                return;
            } else if (obj instanceof ObjectStreamClass) {
                writeClassDesc((ObjectStreamClass) obj, unshared);
                return;
            */
        // END Android-changed:  Make Class and ObjectStreamClass replacable.
        }
        // check for replacement object
        Object orig = obj;
        Class<?> cl = obj.getClass();
        ObjectStreamClass desc;
        // BEGIN Android-changed: Make only one call to writeReplace.
        /*
            for (;;) {
                // REMIND: skip this check for strings/arrays?
                Class<?> repCl;
                desc = ObjectStreamClass.lookup(cl, true);
                if (!desc.hasWriteReplaceMethod() ||
                    (obj = desc.invokeWriteReplace(obj)) == null ||
                    (repCl = obj.getClass()) == cl)
                {
                    break;
                }
                cl = repCl;
                desc = ObjectStreamClass.lookup(cl, true);
                break;
            }
            */
        // Do only one replace pass
        Class repCl;
        desc = ObjectStreamClass.lookup(cl, true);
        if (desc.hasWriteReplaceMethod() && (obj = desc.invokeWriteReplace(obj)) != null && (repCl = obj.getClass()) != cl) {
            cl = repCl;
            desc = ObjectStreamClass.lookup(cl, true);
        }
        if (enableReplace) {
            Object rep = replaceObject(obj);
            if (rep != obj && rep != null) {
                cl = rep.getClass();
                desc = ObjectStreamClass.lookup(cl, true);
            }
            obj = rep;
        }
        // if object replaced, run through original checks a second time
        if (obj != orig) {
            subs.assign(orig, obj);
            if (obj == null) {
                writeNull();
                return;
            } else if (!unshared && (h = handles.lookup(obj)) != -1) {
                writeHandle(h);
                return;
            // BEGIN Android-changed:  Make Class and ObjectStreamClass replacable.
            /*
                } else if (obj instanceof Class) {
                    writeClass((Class) obj, unshared);
                    return;
                } else if (obj instanceof ObjectStreamClass) {
                    writeClassDesc((ObjectStreamClass) obj, unshared);
                    return;
*/
            // END Android-changed:  Make Class and ObjectStreamClass replacable.
            }
        }
        // BEGIN Android-changed: Make Class and ObjectStreamClass replacable.
        if (obj instanceof Class) {
            writeClass((Class) obj, unshared);
        } else if (obj instanceof ObjectStreamClass) {
            writeClassDesc((ObjectStreamClass) obj, unshared);
        // END Android-changed:  Make Class and ObjectStreamClass replacable.
        } else if (obj instanceof String) {
            writeString((String) obj, unshared);
        } else if (cl.isArray()) {
            writeArray(obj, desc, unshared);
        } else if (obj instanceof Enum) {
            writeEnum((Enum<?>) obj, desc, unshared);
        } else if (obj instanceof Serializable) {
            writeOrdinaryObject(obj, desc, unshared);
        } else {
            if (extendedDebugInfo) {
                throw new NotSerializableException(cl.getName() + "\n" + debugInfoStack.toString());
            } else {
                throw new NotSerializableException(cl.getName());
            }
        }
    } finally {
        depth--;
        bout.setBlockDataMode(oldMode);
    }
}
#method_after
private void writeObject0(Object obj, boolean unshared) throws IOException {
    boolean oldMode = bout.setBlockDataMode(false);
    depth++;
    try {
        // handle previously written and non-replaceable objects
        int h;
        if ((obj = subs.lookup(obj)) == null) {
            writeNull();
            return;
        } else if (!unshared && (h = handles.lookup(obj)) != -1) {
            writeHandle(h);
            return;
        // BEGIN Android-changed:  Make Class and ObjectStreamClass replaceable.
        /*
            } else if (obj instanceof Class) {
                writeClass((Class) obj, unshared);
                return;
            } else if (obj instanceof ObjectStreamClass) {
                writeClassDesc((ObjectStreamClass) obj, unshared);
                return;
            */
        // END Android-changed:  Make Class and ObjectStreamClass replaceable.
        }
        // check for replacement object
        Object orig = obj;
        Class<?> cl = obj.getClass();
        ObjectStreamClass desc;
        // BEGIN Android-changed: Make only one call to writeReplace.
        /*
            for (;;) {
                // REMIND: skip this check for strings/arrays?
                Class<?> repCl;
                desc = ObjectStreamClass.lookup(cl, true);
                if (!desc.hasWriteReplaceMethod() ||
                    (obj = desc.invokeWriteReplace(obj)) == null ||
                    (repCl = obj.getClass()) == cl)
                {
                    break;
                }
                cl = repCl;
                desc = ObjectStreamClass.lookup(cl, true);
                break;
            }
            */
        // Do only one replace pass
        Class repCl;
        desc = ObjectStreamClass.lookup(cl, true);
        if (desc.hasWriteReplaceMethod() && (obj = desc.invokeWriteReplace(obj)) != null && (repCl = obj.getClass()) != cl) {
            cl = repCl;
            desc = ObjectStreamClass.lookup(cl, true);
        }
        if (enableReplace) {
            Object rep = replaceObject(obj);
            if (rep != obj && rep != null) {
                cl = rep.getClass();
                desc = ObjectStreamClass.lookup(cl, true);
            }
            obj = rep;
        }
        // if object replaced, run through original checks a second time
        if (obj != orig) {
            subs.assign(orig, obj);
            if (obj == null) {
                writeNull();
                return;
            } else if (!unshared && (h = handles.lookup(obj)) != -1) {
                writeHandle(h);
                return;
            // BEGIN Android-changed:  Make Class and ObjectStreamClass replaceable.
            /*
                } else if (obj instanceof Class) {
                    writeClass((Class) obj, unshared);
                    return;
                } else if (obj instanceof ObjectStreamClass) {
                    writeClassDesc((ObjectStreamClass) obj, unshared);
                    return;
*/
            // END Android-changed:  Make Class and ObjectStreamClass replaceable.
            }
        }
        // BEGIN Android-changed: Make Class and ObjectStreamClass replaceable.
        if (obj instanceof Class) {
            writeClass((Class) obj, unshared);
        } else if (obj instanceof ObjectStreamClass) {
            writeClassDesc((ObjectStreamClass) obj, unshared);
        // END Android-changed:  Make Class and ObjectStreamClass replaceable.
        } else if (obj instanceof String) {
            writeString((String) obj, unshared);
        } else if (cl.isArray()) {
            writeArray(obj, desc, unshared);
        } else if (obj instanceof Enum) {
            writeEnum((Enum<?>) obj, desc, unshared);
        } else if (obj instanceof Serializable) {
            writeOrdinaryObject(obj, desc, unshared);
        } else {
            if (extendedDebugInfo) {
                throw new NotSerializableException(cl.getName() + "\n" + debugInfoStack.toString());
            } else {
                throw new NotSerializableException(cl.getName());
            }
        }
    } finally {
        depth--;
        bout.setBlockDataMode(oldMode);
    }
}
#end_block

#method_before
private IOException readFatalException() throws IOException {
    if (bin.readByte() != TC_EXCEPTION) {
        throw new InternalError();
    }
    clear();
    // BEGIN Android-changed: Fix SerializaitonStressTest#test_2_writeReplace.
    IOException e = (IOException) readObject0(false);
    // Clear after read required for proper exception handling
    clear();
    return e;
// END Android-changed: Fix SerializaitonStressTest#test_2_writeReplace.
}
#method_after
private IOException readFatalException() throws IOException {
    if (bin.readByte() != TC_EXCEPTION) {
        throw new InternalError();
    }
    clear();
    // BEGIN Android-changed: Fix SerializationStressTest#test_2_writeReplace.
    IOException e = (IOException) readObject0(false);
    // If we want to continue reading from same stream after fatal exception, we
    // need to clear internal data structures.
    clear();
    return e;
// END Android-changed: Fix SerializationStressTest#test_2_writeReplace.
}
#end_block

#method_before
@Override
public void addOnSubscriptionsChangedListener(String callingPackage, IOnSubscriptionsChangedListener callback) {
    int callerUserId = UserHandle.getCallingUserId();
    if (VDBG) {
        log("listen oscl: E pkg=" + callingPackage + " myUserId=" + UserHandle.myUserId() + " callerUserId=" + callerUserId + " callback=" + callback + " callback.asBinder=" + callback.asBinder());
    }
    try {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, "addOnSubscriptionsChangedListener");
    // SKIP checking for run-time permission since caller or self has PRIVILEGED permission
    } catch (SecurityException e) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE, "addOnSubscriptionsChangedListener");
        if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
            return;
        }
    }
    Record r;
    synchronized (mRecords) {
        // register
        find_and_add: {
            IBinder b = callback.asBinder();
            final int N = mRecords.size();
            for (int i = 0; i < N; i++) {
                r = mRecords.get(i);
                if (b == r.binder) {
                    break find_and_add;
                }
            }
            r = new Record();
            r.binder = b;
            mRecords.add(r);
            if (DBG)
                log("listen oscl: add new record");
        }
        r.onSubscriptionsChangedListenerCallback = callback;
        r.callingPackage = callingPackage;
        r.callerUserId = callerUserId;
        r.events = 0;
        // permission has been enforced above
        r.canReadPhoneState = true;
        if (DBG) {
            log("listen oscl:  Register r=" + r);
        }
        // Always notify when registration occurs if there has been a notification.
        if (hasNotifySubscriptionInfoChangedOccurred) {
            try {
                if (VDBG)
                    log("listen oscl: send to r=" + r);
                r.onSubscriptionsChangedListenerCallback.onSubscriptionsChanged();
                if (VDBG)
                    log("listen oscl: sent to r=" + r);
            } catch (RemoteException e) {
                if (VDBG)
                    log("listen oscl: remote exception sending to r=" + r + " e=" + e);
                remove(r.binder);
            }
        } else {
            log("listen oscl: hasNotifySubscriptionInfoChangedOccurred==false no callback");
        }
    }
}
#method_after
@Override
public void addOnSubscriptionsChangedListener(String callingPackage, IOnSubscriptionsChangedListener callback) {
    int callerUserId = UserHandle.getCallingUserId();
    if (VDBG) {
        log("listen oscl: E pkg=" + callingPackage + " myUserId=" + UserHandle.myUserId() + " callerUserId=" + callerUserId + " callback=" + callback + " callback.asBinder=" + callback.asBinder());
    }
    try {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, "addOnSubscriptionsChangedListener");
    // SKIP checking for run-time permission since caller or self has PRIVILEGED permission
    } catch (SecurityException e) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE, "addOnSubscriptionsChangedListener");
        if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
            return;
        }
    }
    synchronized (mRecords) {
        // register
        IBinder b = callback.asBinder();
        Record r = add(b);
        if (r == null) {
            return;
        }
        r.onSubscriptionsChangedListenerCallback = callback;
        r.callingPackage = callingPackage;
        r.callerUserId = callerUserId;
        r.events = 0;
        // permission has been enforced above
        r.canReadPhoneState = true;
        if (DBG) {
            log("listen oscl:  Register r=" + r);
        }
        // Always notify when registration occurs if there has been a notification.
        if (hasNotifySubscriptionInfoChangedOccurred) {
            try {
                if (VDBG)
                    log("listen oscl: send to r=" + r);
                r.onSubscriptionsChangedListenerCallback.onSubscriptionsChanged();
                if (VDBG)
                    log("listen oscl: sent to r=" + r);
            } catch (RemoteException e) {
                if (VDBG)
                    log("listen oscl: remote exception sending to r=" + r + " e=" + e);
                remove(r.binder);
            }
        } else {
            log("listen oscl: hasNotifySubscriptionInfoChangedOccurred==false no callback");
        }
    }
}
#end_block

#method_before
private void listen(String callingPackage, IPhoneStateListener callback, int events, boolean notifyNow, int subId) {
    int callerUserId = UserHandle.getCallingUserId();
    if (VDBG) {
        log("listen: E pkg=" + callingPackage + " events=0x" + Integer.toHexString(events) + " notifyNow=" + notifyNow + " subId=" + subId + " myUserId=" + UserHandle.myUserId() + " callerUserId=" + callerUserId);
    }
    if (events != PhoneStateListener.LISTEN_NONE) {
        /* Checks permission and throws Security exception */
        checkListenerPermission(events);
        if ((events & ENFORCE_PHONE_STATE_PERMISSION_MASK) != 0) {
            try {
                mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, null);
            // SKIP checking for run-time permission since caller or self has PRIVILEGED
            // permission
            } catch (SecurityException e) {
                if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
                    return;
                }
            }
        }
        synchronized (mRecords) {
            // register
            Record r;
            find_and_add: {
                IBinder b = callback.asBinder();
                final int N = mRecords.size();
                for (int i = 0; i < N; i++) {
                    r = mRecords.get(i);
                    if (b == r.binder) {
                        break find_and_add;
                    }
                }
                r = new Record();
                r.binder = b;
                mRecords.add(r);
                if (DBG)
                    log("listen: add new record");
            }
            r.callback = callback;
            r.callingPackage = callingPackage;
            r.callerUserId = callerUserId;
            boolean isPhoneStateEvent = (events & (CHECK_PHONE_STATE_PERMISSION_MASK | ENFORCE_PHONE_STATE_PERMISSION_MASK)) != 0;
            r.canReadPhoneState = isPhoneStateEvent && canReadPhoneState(callingPackage);
            // force all illegal subId to SubscriptionManager.DEFAULT_SUB_ID
            if (!SubscriptionManager.isValidSubscriptionId(subId)) {
                r.subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
            } else {
                // APP specify subID
                r.subId = subId;
            }
            r.phoneId = SubscriptionManager.getPhoneId(r.subId);
            int phoneId = r.phoneId;
            r.events = events;
            if (DBG) {
                log("listen:  Register r=" + r + " r.subId=" + r.subId + " phoneId=" + phoneId);
            }
            if (notifyNow && validatePhoneId(phoneId)) {
                if ((events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
                    try {
                        if (VDBG)
                            log("listen: call onSSC state=" + mServiceState[phoneId]);
                        r.callback.onServiceStateChanged(new ServiceState(mServiceState[phoneId]));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTH) != 0) {
                    try {
                        int gsmSignalStrength = mSignalStrength[phoneId].getGsmSignalStrength();
                        r.callback.onSignalStrengthChanged((gsmSignalStrength == 99 ? -1 : gsmSignalStrength));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR) != 0) {
                    try {
                        r.callback.onMessageWaitingIndicatorChanged(mMessageWaiting[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR) != 0) {
                    try {
                        r.callback.onCallForwardingIndicatorChanged(mCallForwarding[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_LOCATION)) {
                    try {
                        if (DBG_LOC)
                            log("listen: mCellLocation = " + mCellLocation[phoneId]);
                        r.callback.onCellLocationChanged(new Bundle(mCellLocation[phoneId]));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0) {
                    try {
                        r.callback.onCallStateChanged(mCallState[phoneId], getCallIncomingNumber(r, phoneId));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_CONNECTION_STATE) != 0) {
                    try {
                        r.callback.onDataConnectionStateChanged(mDataConnectionState[phoneId], mDataConnectionNetworkType[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_ACTIVITY) != 0) {
                    try {
                        r.callback.onDataActivity(mDataActivity[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTHS) != 0) {
                    try {
                        r.callback.onSignalStrengthsChanged(mSignalStrength[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_OTASP_CHANGED) != 0) {
                    try {
                        r.callback.onOtaspChanged(mOtaspMode);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_INFO)) {
                    try {
                        if (DBG_LOC)
                            log("listen: mCellInfo[" + phoneId + "] = " + mCellInfo.get(phoneId));
                        r.callback.onCellInfoChanged(mCellInfo.get(phoneId));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_PRECISE_CALL_STATE) != 0) {
                    try {
                        r.callback.onPreciseCallStateChanged(mPreciseCallState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_PRECISE_DATA_CONNECTION_STATE) != 0) {
                    try {
                        r.callback.onPreciseDataConnectionStateChanged(mPreciseDataConnectionState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CARRIER_NETWORK_CHANGE) != 0) {
                    try {
                        r.callback.onCarrierNetworkChange(mCarrierNetworkChangeState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_VOICE_ACTIVATION_STATE) != 0) {
                    try {
                        r.callback.onVoiceActivationStateChanged(mVoiceActivationState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_ACTIVATION_STATE) != 0) {
                    try {
                        r.callback.onDataActivationStateChanged(mDataActivationState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_USER_MOBILE_DATA_STATE) != 0) {
                    try {
                        r.callback.onUserMobileDataStateChanged(mUserMobileDataState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_PHYSICAL_CHANNEL_CONFIGURATION) != 0) {
                    try {
                        r.callback.onPhysicalChannelConfigurationChanged(mPhysicalChannelConfigs.get(phoneId));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
            }
        }
    } else {
        if (DBG)
            log("listen: Unregister");
        remove(callback.asBinder());
    }
}
#method_after
private void listen(String callingPackage, IPhoneStateListener callback, int events, boolean notifyNow, int subId) {
    int callerUserId = UserHandle.getCallingUserId();
    if (VDBG) {
        log("listen: E pkg=" + callingPackage + " events=0x" + Integer.toHexString(events) + " notifyNow=" + notifyNow + " subId=" + subId + " myUserId=" + UserHandle.myUserId() + " callerUserId=" + callerUserId);
    }
    if (events != PhoneStateListener.LISTEN_NONE) {
        /* Checks permission and throws Security exception */
        checkListenerPermission(events);
        if ((events & ENFORCE_PHONE_STATE_PERMISSION_MASK) != 0) {
            try {
                mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, null);
            // SKIP checking for run-time permission since caller or self has PRIVILEGED
            // permission
            } catch (SecurityException e) {
                if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
                    return;
                }
            }
        }
        synchronized (mRecords) {
            // register
            IBinder b = callback.asBinder();
            Record r = add(b);
            if (r == null) {
                return;
            }
            r.callback = callback;
            r.callingPackage = callingPackage;
            r.callerUserId = callerUserId;
            boolean isPhoneStateEvent = (events & (CHECK_PHONE_STATE_PERMISSION_MASK | ENFORCE_PHONE_STATE_PERMISSION_MASK)) != 0;
            r.canReadPhoneState = isPhoneStateEvent && canReadPhoneState(callingPackage);
            // force all illegal subId to SubscriptionManager.DEFAULT_SUB_ID
            if (!SubscriptionManager.isValidSubscriptionId(subId)) {
                r.subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
            } else {
                // APP specify subID
                r.subId = subId;
            }
            r.phoneId = SubscriptionManager.getPhoneId(r.subId);
            int phoneId = r.phoneId;
            r.events = events;
            if (DBG) {
                log("listen:  Register r=" + r + " r.subId=" + r.subId + " phoneId=" + phoneId);
            }
            if (notifyNow && validatePhoneId(phoneId)) {
                if ((events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
                    try {
                        if (VDBG)
                            log("listen: call onSSC state=" + mServiceState[phoneId]);
                        r.callback.onServiceStateChanged(new ServiceState(mServiceState[phoneId]));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTH) != 0) {
                    try {
                        int gsmSignalStrength = mSignalStrength[phoneId].getGsmSignalStrength();
                        r.callback.onSignalStrengthChanged((gsmSignalStrength == 99 ? -1 : gsmSignalStrength));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR) != 0) {
                    try {
                        r.callback.onMessageWaitingIndicatorChanged(mMessageWaiting[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR) != 0) {
                    try {
                        r.callback.onCallForwardingIndicatorChanged(mCallForwarding[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_LOCATION)) {
                    try {
                        if (DBG_LOC)
                            log("listen: mCellLocation = " + mCellLocation[phoneId]);
                        r.callback.onCellLocationChanged(new Bundle(mCellLocation[phoneId]));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0) {
                    try {
                        r.callback.onCallStateChanged(mCallState[phoneId], getCallIncomingNumber(r, phoneId));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_CONNECTION_STATE) != 0) {
                    try {
                        r.callback.onDataConnectionStateChanged(mDataConnectionState[phoneId], mDataConnectionNetworkType[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_ACTIVITY) != 0) {
                    try {
                        r.callback.onDataActivity(mDataActivity[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTHS) != 0) {
                    try {
                        r.callback.onSignalStrengthsChanged(mSignalStrength[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_OTASP_CHANGED) != 0) {
                    try {
                        r.callback.onOtaspChanged(mOtaspMode);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_INFO)) {
                    try {
                        if (DBG_LOC)
                            log("listen: mCellInfo[" + phoneId + "] = " + mCellInfo.get(phoneId));
                        r.callback.onCellInfoChanged(mCellInfo.get(phoneId));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_PRECISE_CALL_STATE) != 0) {
                    try {
                        r.callback.onPreciseCallStateChanged(mPreciseCallState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_PRECISE_DATA_CONNECTION_STATE) != 0) {
                    try {
                        r.callback.onPreciseDataConnectionStateChanged(mPreciseDataConnectionState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CARRIER_NETWORK_CHANGE) != 0) {
                    try {
                        r.callback.onCarrierNetworkChange(mCarrierNetworkChangeState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_VOICE_ACTIVATION_STATE) != 0) {
                    try {
                        r.callback.onVoiceActivationStateChanged(mVoiceActivationState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_ACTIVATION_STATE) != 0) {
                    try {
                        r.callback.onDataActivationStateChanged(mDataActivationState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_USER_MOBILE_DATA_STATE) != 0) {
                    try {
                        r.callback.onUserMobileDataStateChanged(mUserMobileDataState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_PHYSICAL_CHANNEL_CONFIGURATION) != 0) {
                    try {
                        r.callback.onPhysicalChannelConfigurationChanged(mPhysicalChannelConfigs.get(phoneId));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
            }
        }
    } else {
        if (DBG)
            log("listen: Unregister");
        remove(callback.asBinder());
    }
}
#end_block

#method_before
private void remove(IBinder binder) {
    synchronized (mRecords) {
        final int recordCount = mRecords.size();
        for (int i = 0; i < recordCount; i++) {
            if (mRecords.get(i).binder == binder) {
                if (DBG) {
                    Record r = mRecords.get(i);
                    log("remove: binder=" + binder + "r.callingPackage" + r.callingPackage + "r.callback" + r.callback);
                }
                mRecords.remove(i);
                return;
            }
        }
    }
}
#method_after
private void remove(IBinder binder) {
    synchronized (mRecords) {
        final int recordCount = mRecords.size();
        for (int i = 0; i < recordCount; i++) {
            Record r = mRecords.get(i);
            if (r.binder == binder) {
                if (DBG) {
                    log("remove: binder=" + binder + " r.callingPackage " + r.callingPackage + " r.callback " + r.callback);
                }
                if (r.deathRecipient != null) {
                    try {
                        binder.unlinkToDeath(r.deathRecipient, 0);
                    } catch (NoSuchElementException e) {
                        if (VDBG)
                            log("UnlinkToDeath NoSuchElementException sending to r=" + r + " e=" + e);
                    }
                }
                mRecords.remove(i);
                return;
            }
        }
    }
}
#end_block

#method_before
public void notifyPhysicalChannelConfigurationForSubscriber(int subId, List<PhysicalChannelConfig> configs) {
    if (!checkNotifyPermission("notifyPhysicalChannelConfiguration()")) {
        return;
    }
    if (VDBG) {
        log("notifyPhysicalChannelConfiguration: subId=" + subId + " configs=" + configs);
    }
    synchronized (mRecords) {
        int phoneId = SubscriptionManager.getPhoneId(subId);
        if (validatePhoneId(phoneId)) {
            mPhysicalChannelConfigs.set(phoneId, configs);
            for (Record r : mRecords) {
                if (r.matchPhoneStateListenerEvent(PhoneStateListener.LISTEN_PHYSICAL_CHANNEL_CONFIGURATION) && idMatch(r.subId, subId, phoneId)) {
                    try {
                        if (DBG_LOC) {
                            log("notifyPhysicalChannelConfiguration: mPhysicalChannelConfigu=" + configs + " r=" + r);
                        }
                        r.callback.onPhysicalChannelConfigurationChanged(configs);
                    } catch (RemoteException ex) {
                        mRemoveList.add(r.binder);
                    }
                }
            }
        }
        handleRemoveListLocked();
    }
}
#method_after
public void notifyPhysicalChannelConfigurationForSubscriber(int subId, List<PhysicalChannelConfig> configs) {
    if (!checkNotifyPermission("notifyPhysicalChannelConfiguration()")) {
        return;
    }
    if (VDBG) {
        log("notifyPhysicalChannelConfiguration: subId=" + subId + " configs=" + configs);
    }
    synchronized (mRecords) {
        int phoneId = SubscriptionManager.getPhoneId(subId);
        if (validatePhoneId(phoneId)) {
            mPhysicalChannelConfigs.set(phoneId, configs);
            for (Record r : mRecords) {
                if (r.matchPhoneStateListenerEvent(PhoneStateListener.LISTEN_PHYSICAL_CHANNEL_CONFIGURATION) && idMatch(r.subId, subId, phoneId)) {
                    try {
                        if (DBG_LOC) {
                            log("notifyPhysicalChannelConfiguration: mPhysicalChannelConfigs=" + configs + " r=" + r);
                        }
                        r.callback.onPhysicalChannelConfigurationChanged(configs);
                    } catch (RemoteException ex) {
                        mRemoveList.add(r.binder);
                    }
                }
            }
        }
        handleRemoveListLocked();
    }
}
#end_block

#method_before
private void processCellLocationInfo(CellLocation cellLocation, VoiceRegStateResult voiceRegStateResult) {
    if (mPhone.isPhoneTypeGsm()) {
        int psc = -1;
        int cid = -1;
        int lac = -1;
        switch(voiceRegStateResult.cellIdentity.cellInfoType) {
            case CellInfoType.GSM:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityGsm.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityGsm cellIdentityGsm = voiceRegStateResult.cellIdentity.cellIdentityGsm.get(0);
                        cid = cellIdentityGsm.cid;
                        lac = cellIdentityGsm.lac;
                    }
                    break;
                }
            case CellInfoType.WCDMA:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityWcdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityWcdma cellIdentityWcdma = voiceRegStateResult.cellIdentity.cellIdentityWcdma.get(0);
                        cid = cellIdentityWcdma.cid;
                        lac = cellIdentityWcdma.lac;
                        psc = cellIdentityWcdma.psc;
                    }
                    break;
                }
            case CellInfoType.TD_SCDMA:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityTdscdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityTdscdma cellIdentityTdscdma = voiceRegStateResult.cellIdentity.cellIdentityTdscdma.get(0);
                        cid = cellIdentityTdscdma.cid;
                        lac = cellIdentityTdscdma.lac;
                    }
                    break;
                }
            case CellInfoType.LTE:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityLte.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityLte cellIdentityLte = voiceRegStateResult.cellIdentity.cellIdentityLte.get(0);
                        cid = cellIdentityLte.ci;
                        /* Continuing the historical behaviour of using tac as lac. */
                        lac = cellIdentityLte.tac;
                    }
                    break;
                }
            default:
                {
                    break;
                }
        }
        // LAC and CID are -1 if not avail
        ((GsmCellLocation) cellLocation).setLacAndCid(lac, cid);
        ((GsmCellLocation) cellLocation).setPsc(psc);
    } else {
        int baseStationId = -1;
        int baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
        int baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
        int systemId = 0;
        int networkId = 0;
        switch(voiceRegStateResult.cellIdentity.cellInfoType) {
            case CellInfoType.CDMA:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        baseStationId = cellIdentityCdma.baseStationId;
                        baseStationLatitude = cellIdentityCdma.latitude;
                        baseStationLongitude = cellIdentityCdma.longitude;
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    break;
                }
            default:
                {
                    break;
                }
        }
        // Some carriers only return lat-lngs of 0,0
        if (baseStationLatitude == 0 && baseStationLongitude == 0) {
            baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
            baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
        }
        // Values are -1 if not available.
        ((CdmaCellLocation) cellLocation).setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
    }
}
#method_after
private void processCellLocationInfo(CellLocation cellLocation, CellIdentity cellIdentity) {
    if (mPhone.isPhoneTypeGsm()) {
        int psc = -1;
        int cid = -1;
        int lac = -1;
        if (cellIdentity != null) {
            switch(cellIdentity.getType()) {
                case CellInfoType.GSM:
                    {
                        cid = ((CellIdentityGsm) cellIdentity).getCid();
                        lac = ((CellIdentityGsm) cellIdentity).getLac();
                        break;
                    }
                case CellInfoType.WCDMA:
                    {
                        cid = ((CellIdentityWcdma) cellIdentity).getCid();
                        lac = ((CellIdentityWcdma) cellIdentity).getLac();
                        psc = ((CellIdentityWcdma) cellIdentity).getPsc();
                        break;
                    }
                case CellInfoType.TD_SCDMA:
                    {
                        cid = ((CellIdentityTdscdma) cellIdentity).getCid();
                        lac = ((CellIdentityTdscdma) cellIdentity).getLac();
                        break;
                    }
                case CellInfoType.LTE:
                    {
                        cid = ((CellIdentityLte) cellIdentity).getCi();
                        lac = ((CellIdentityLte) cellIdentity).getTac();
                        break;
                    }
                default:
                    {
                        break;
                    }
            }
        }
        // LAC and CID are -1 if not avail
        ((GsmCellLocation) cellLocation).setLacAndCid(lac, cid);
        ((GsmCellLocation) cellLocation).setPsc(psc);
    } else {
        int baseStationId = -1;
        int baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
        int baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
        int systemId = 0;
        int networkId = 0;
        if (cellIdentity != null) {
            switch(cellIdentity.getType()) {
                case CellInfoType.CDMA:
                    {
                        baseStationId = ((CellIdentityCdma) cellIdentity).getBasestationId();
                        baseStationLatitude = ((CellIdentityCdma) cellIdentity).getLatitude();
                        baseStationLongitude = ((CellIdentityCdma) cellIdentity).getLongitude();
                        systemId = ((CellIdentityCdma) cellIdentity).getSystemId();
                        networkId = ((CellIdentityCdma) cellIdentity).getNetworkId();
                        break;
                    }
                default:
                    {
                        break;
                    }
            }
        }
        // Some carriers only return lat-lngs of 0,0
        if (baseStationLatitude == 0 && baseStationLongitude == 0) {
            baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
            baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
        }
        // Values are -1 if not available.
        ((CdmaCellLocation) cellLocation).setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
    }
}
#end_block

#method_before
private int getLteEarfcn(DataRegStateResult dataRegStateResult) {
    int lteEarfcn = INVALID_LTE_EARFCN;
    switch(dataRegStateResult.cellIdentity.cellInfoType) {
        case CellInfoType.LTE:
            {
                if (dataRegStateResult.cellIdentity.cellIdentityLte.size() == 1) {
                    android.hardware.radio.V1_0.CellIdentityLte cellIdentityLte = dataRegStateResult.cellIdentity.cellIdentityLte.get(0);
                    lteEarfcn = cellIdentityLte.earfcn;
                }
                break;
            }
        default:
            {
                break;
            }
    }
    return lteEarfcn;
}
#method_after
private int getLteEarfcn(CellIdentity cellIdentity) {
    int lteEarfcn = INVALID_LTE_EARFCN;
    if (cellIdentity != null) {
        switch(cellIdentity.getType()) {
            case CellInfoType.LTE:
                {
                    lteEarfcn = ((CellIdentityLte) cellIdentity).getEarfcn();
                    break;
                }
            default:
                {
                    break;
                }
        }
    }
    return lteEarfcn;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    if (VDBG)
        log("received event " + msg.what);
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            if (mUiccApplcation != null && mUiccApplcation.getState() != AppState.APPSTATE_READY) {
                mIsSimReady = false;
                updateSpnDisplay();
            }
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        case EVENT_RADIO_POWER_OFF_DONE:
            if (DBG)
                log("EVENT_RADIO_POWER_OFF_DONE");
            if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
                // during shutdown the modem may not send radio state changed event
                // as a result of radio power request
                // Hence, issuing shut down regardless of radio power response
                mCi.requestShutdown(null);
            }
            break;
        // GSM
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            mIsSimReady = true;
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                processCellLocationInfo(mCellLoc, (VoiceRegStateResult) ar.result);
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mCi.getVoiceRegistrationState(obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_SIM_NOT_INSERTED:
            if (DBG)
                log("EVENT_SIM_NOT_INSERTED");
            cancelAllNotifications();
            mMdn = null;
            mMin = null;
            mIsMinInfoReady = false;
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        case EVENT_IMS_SERVICE_STATE_CHANGED:
            if (DBG)
                log("EVENT_IMS_SERVICE_STATE_CHANGED");
            // GsmCdma phone is not STATE_IN_SERVICE.
            if (mSS.getState() != ServiceState.STATE_IN_SERVICE) {
                mPhone.notifyServiceStateChanged(mPhone.getServiceState());
            }
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        case EVENT_RADIO_POWER_FROM_CARRIER:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                boolean enable = (boolean) ar.result;
                if (DBG)
                    log("EVENT_RADIO_POWER_FROM_CARRIER: " + enable);
                setRadioPowerFromCarrier(enable);
            }
            break;
        case EVENT_PHYSICAL_CHANNEL_CONFIG:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                List<PhysicalChannelConfig> list = (List<PhysicalChannelConfig>) ar.result;
                if (VDBG) {
                    log("EVENT_PHYSICAL_CHANNEL_CONFIG: size=" + list.size() + " list=" + list);
                }
                mPhone.notifyPhysicalChannelConfiguration(list);
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    if (VDBG)
        log("received event " + msg.what);
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            if (mUiccApplcation != null && mUiccApplcation.getState() != AppState.APPSTATE_READY) {
                mIsSimReady = false;
                updateSpnDisplay();
            }
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        case EVENT_RADIO_POWER_OFF_DONE:
            if (DBG)
                log("EVENT_RADIO_POWER_OFF_DONE");
            if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
                // during shutdown the modem may not send radio state changed event
                // as a result of radio power request
                // Hence, issuing shut down regardless of radio power response
                mCi.requestShutdown(null);
            }
            break;
        // GSM
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            mIsSimReady = true;
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                CellIdentity cellIdentity = ((NetworkRegistrationState) ar.result).getCellIdentity();
                processCellLocationInfo(mCellLoc, cellIdentity);
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mRegStateManagers.get(AccessNetworkConstants.TransportType.WWAN).getNetworkRegistrationState(NetworkRegistrationState.DOMAIN_CS, obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_SIM_NOT_INSERTED:
            if (DBG)
                log("EVENT_SIM_NOT_INSERTED");
            cancelAllNotifications();
            mMdn = null;
            mMin = null;
            mIsMinInfoReady = false;
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        case EVENT_IMS_SERVICE_STATE_CHANGED:
            if (DBG)
                log("EVENT_IMS_SERVICE_STATE_CHANGED");
            // GsmCdma phone is not STATE_IN_SERVICE.
            if (mSS.getState() != ServiceState.STATE_IN_SERVICE) {
                mPhone.notifyServiceStateChanged(mPhone.getServiceState());
            }
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        case EVENT_RADIO_POWER_FROM_CARRIER:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                boolean enable = (boolean) ar.result;
                if (DBG)
                    log("EVENT_RADIO_POWER_FROM_CARRIER: " + enable);
                setRadioPowerFromCarrier(enable);
            }
            break;
        case EVENT_PHYSICAL_CHANNEL_CONFIG:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                List<PhysicalChannelConfig> list = (List<PhysicalChannelConfig>) ar.result;
                if (VDBG) {
                    log("EVENT_PHYSICAL_CHANNEL_CONFIG: size=" + list.size() + " list=" + list);
                }
                mPhone.notifyPhysicalChannelConfiguration(list);
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#end_block

#method_before
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                VoiceRegStateResult voiceRegStateResult = (VoiceRegStateResult) ar.result;
                int registrationState = getRegStateFromHalRegState(voiceRegStateResult.regState);
                int cssIndicator = voiceRegStateResult.cssSupported ? 1 : 0;
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setCssIndicator(cssIndicator);
                mNewSS.setRilVoiceRadioTechnology(voiceRegStateResult.rat);
                // Denial reason if registrationState = 3
                int reasonForDenial = voiceRegStateResult.reasonForDenial;
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    mNewRejectCode = reasonForDenial;
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    if (((registrationState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED)) && isVoiceCapable) {
                        mEmergencyOnly = true;
                    } else {
                        mEmergencyOnly = false;
                    }
                } else {
                    int roamingIndicator = voiceRegStateResult.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceRegStateResult.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceRegStateResult.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    if (voiceRegStateResult.cellIdentity.cellInfoType == CellInfoType.CDMA && voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, voiceRegStateResult);
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result;
                int regState = getRegStateFromHalRegState(dataRegStateResult.regState);
                int dataRegState = regCodeToServiceState(regState);
                int newDataRat = dataRegStateResult.rat;
                mNewSS.setDataRegState(dataRegState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = dataRegStateResult.reasonDataDenied;
                    mNewMaxDataCalls = dataRegStateResult.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(regState);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(mDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    boolean isDataRoaming = regCodeIsRoaming(regState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    boolean isDataRoaming = regCodeIsRoaming(regState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(dataRegStateResult));
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (mPhone.shouldForceAutoNetworkSelect())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#method_after
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                NetworkRegistrationState networkRegState = (NetworkRegistrationState) ar.result;
                VoiceSpecificRegistrationStates voiceSpecificStates = networkRegState.getVoiceSpecificStates();
                int registrationState = networkRegState.getRegState();
                int cssIndicator = voiceSpecificStates.cssSupported ? 1 : 0;
                int newVoiceRat = ServiceState.networkTypeToRilRadioTechnology(networkRegState.getAccessNetworkTechnology());
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setCssIndicator(cssIndicator);
                mNewSS.setRilVoiceRadioTechnology(newVoiceRat);
                mNewSS.addNetworkRegistrationState(networkRegState);
                // Denial reason if registrationState = 3
                int reasonForDenial = networkRegState.getReasonForDenial();
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    mNewRejectCode = reasonForDenial;
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    mEmergencyOnly = networkRegState.isEmergencyEnabled();
                } else {
                    int roamingIndicator = voiceSpecificStates.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceSpecificStates.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceSpecificStates.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    CellIdentity cellIdentity = networkRegState.getCellIdentity();
                    if (cellIdentity != null && cellIdentity.getType() == CellInfoType.CDMA) {
                        systemId = ((CellIdentityCdma) cellIdentity).getSystemId();
                        networkId = ((CellIdentityCdma) cellIdentity).getNetworkId();
                    }
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, networkRegState.getCellIdentity());
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + newVoiceRat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                NetworkRegistrationState networkRegState = (NetworkRegistrationState) ar.result;
                DataSpecificRegistrationStates dataSpecificStates = networkRegState.getDataSpecificStates();
                int registrationState = networkRegState.getRegState();
                int serviceState = regCodeToServiceState(registrationState);
                int newDataRat = ServiceState.networkTypeToRilRadioTechnology(networkRegState.getAccessNetworkTechnology());
                mNewSS.setDataRegState(serviceState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                mNewSS.addNetworkRegistrationState(networkRegState);
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = networkRegState.getReasonForDenial();
                    mNewMaxDataCalls = dataSpecificStates.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(registrationState);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(mDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST dataServiceState=" + serviceState + " regState=" + registrationState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    boolean isDataRoaming = regCodeIsRoaming(registrationState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma dataServiceState=" + serviceState + " regState=" + registrationState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    boolean isDataRoaming = regCodeIsRoaming(registrationState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST dataServiceState=" + serviceState + " registrationState=" + registrationState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(networkRegState.getCellIdentity()));
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (mPhone.shouldForceAutoNetworkSelect())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#end_block

#method_before
protected final void log(String s) {
    Rlog.d(LOG_TAG, s);
}
#method_after
protected final void log(String s) {
    Rlog.d(LOG_TAG, "[" + mPhone.getPhoneId() + "] " + s);
}
#end_block

#method_before
protected final void loge(String s) {
    Rlog.e(LOG_TAG, s);
}
#method_after
protected final void loge(String s) {
    Rlog.e(LOG_TAG, "[" + mPhone.getPhoneId() + "] " + s);
}
#end_block

#method_before
public void pollState(boolean modemTriggered) {
    mPollingContext = new int[1];
    mPollingContext[0] = 0;
    log("pollState: modemTriggered=" + modemTriggered);
    switch(mCi.getRadioState()) {
        case RADIO_UNAVAILABLE:
            mNewSS.setStateOutOfService();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mNitzState.handleNetworkUnavailable();
            pollStateDone();
            break;
        case RADIO_OFF:
            mNewSS.setStateOff();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mNitzState.handleNetworkUnavailable();
            // (they sent us new radio data) and current network is not IWLAN
            if (mDeviceShuttingDown || (!modemTriggered && ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN != mSS.getRilDataRadioTechnology())) {
                pollStateDone();
                break;
            }
        default:
            // Issue all poll-related commands at once then count down the responses, which
            // are allowed to arrive out-of-order
            mPollingContext[0]++;
            mCi.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR, mPollingContext));
            mPollingContext[0]++;
            mCi.getDataRegistrationState(obtainMessage(EVENT_POLL_STATE_GPRS, mPollingContext));
            mPollingContext[0]++;
            mCi.getVoiceRegistrationState(obtainMessage(EVENT_POLL_STATE_REGISTRATION, mPollingContext));
            if (mPhone.isPhoneTypeGsm()) {
                mPollingContext[0]++;
                mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE, mPollingContext));
            }
            break;
    }
}
#method_after
public void pollState(boolean modemTriggered) {
    mPollingContext = new int[1];
    mPollingContext[0] = 0;
    log("pollState: modemTriggered=" + modemTriggered);
    switch(mCi.getRadioState()) {
        case RADIO_UNAVAILABLE:
            mNewSS.setStateOutOfService();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mNitzState.handleNetworkUnavailable();
            pollStateDone();
            break;
        case RADIO_OFF:
            mNewSS.setStateOff();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mNitzState.handleNetworkUnavailable();
            // (they sent us new radio data) and current network is not IWLAN
            if (mDeviceShuttingDown || (!modemTriggered && ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN != mSS.getRilDataRadioTechnology())) {
                pollStateDone();
                break;
            }
        default:
            // Issue all poll-related commands at once then count down the responses, which
            // are allowed to arrive out-of-order
            // TODO: Add WLAN support.
            mPollingContext[0]++;
            mCi.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR, mPollingContext));
            mPollingContext[0]++;
            mRegStateManagers.get(AccessNetworkConstants.TransportType.WWAN).getNetworkRegistrationState(NetworkRegistrationState.DOMAIN_PS, obtainMessage(EVENT_POLL_STATE_GPRS, mPollingContext));
            mPollingContext[0]++;
            mRegStateManagers.get(AccessNetworkConstants.TransportType.WWAN).getNetworkRegistrationState(NetworkRegistrationState.DOMAIN_CS, obtainMessage(EVENT_POLL_STATE_REGISTRATION, mPollingContext));
            if (mPhone.isPhoneTypeGsm()) {
                mPollingContext[0]++;
                mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE, mPollingContext));
            }
            break;
    }
}
#end_block

#method_before
protected void setOperatorIdd(String operatorNumeric) {
    // Retrieve the current country information
    // with the MCC got from opeatorNumeric.
    String idd = mHbpcdUtils.getIddByMcc(Integer.parseInt(operatorNumeric.substring(0, 3)));
    if (idd != null && !idd.isEmpty()) {
        mPhone.setSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, idd);
    } else {
        // use default "+", since we don't know the current IDP
        mPhone.setSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, "+");
    }
}
#method_after
protected void setOperatorIdd(String operatorNumeric) {
    // Retrieve the current country information
    // with the MCC got from opeatorNumeric.
    String idd = mHbpcdUtils.getIddByMcc(Integer.parseInt(operatorNumeric.substring(0, 3)));
    if (idd != null && !idd.isEmpty()) {
        mPhone.setGlobalSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, idd);
    } else {
        // use default "+", since we don't know the current IDP
        mPhone.setGlobalSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, "+");
    }
}
#end_block

#method_before
private int regCodeToServiceState(int code) {
    switch(code) {
        case ServiceState.RIL_REG_STATE_HOME:
        case ServiceState.RIL_REG_STATE_ROAMING:
            return ServiceState.STATE_IN_SERVICE;
        default:
            return ServiceState.STATE_OUT_OF_SERVICE;
    }
}
#method_after
private int regCodeToServiceState(int code) {
    switch(code) {
        case NetworkRegistrationState.REG_STATE_HOME:
        case NetworkRegistrationState.REG_STATE_ROAMING:
            return ServiceState.STATE_IN_SERVICE;
        default:
            return ServiceState.STATE_OUT_OF_SERVICE;
    }
}
#end_block

#method_before
private boolean regCodeIsRoaming(int code) {
    return ServiceState.RIL_REG_STATE_ROAMING == code;
}
#method_after
private boolean regCodeIsRoaming(int code) {
    return NetworkRegistrationState.REG_STATE_ROAMING == code;
}
#end_block

#method_before
public void currentPhysicalChannelConfigs(int indicationType, ArrayList<android.hardware.radio.V1_2.PhysicalChannelConfig> configs) {
    List<PhysicalChannelConfig> response = RIL.convertHalPhysicalChannelConfigs(configs);
    mRil.mPhysicalChannelConfigurationRegistrants.notifyRegistrants(new AsyncResult(null, response, null));
}
#method_after
public void currentPhysicalChannelConfigs(int indicationType, ArrayList<android.hardware.radio.V1_2.PhysicalChannelConfig> configs) {
    List<PhysicalChannelConfig> response = new ArrayList<>(configs.size());
    for (android.hardware.radio.V1_2.PhysicalChannelConfig config : configs) {
        int status;
        switch(config.status) {
            case CellConnectionStatus.PRIMARY_SERVING:
                status = PhysicalChannelConfig.CONNECTION_PRIMARY_SERVING;
                break;
            case CellConnectionStatus.SECONDARY_SERVING:
                status = PhysicalChannelConfig.CONNECTION_SECONDARY_SERVING;
                break;
            default:
                // only PRIMARY_SERVING and SECONDARY_SERVING are supported.
                mRil.riljLoge("Unsupported CellConnectionStatus in PhysicalChannelConfig: " + config.status);
                status = PhysicalChannelConfig.CONNECTION_UNKNOWN;
                break;
        }
        response.add(new PhysicalChannelConfig(status, config.cellBandwidthDownlink));
    }
    mRil.mPhysicalChannelConfigurationRegistrants.notifyRegistrants(new AsyncResult(null, response, null));
}
#end_block

#method_before
public void dataCallListChanged(int indicationType, ArrayList<SetupDataCallResult> dcList) {
    mRil.processIndication(indicationType);
    ArrayList<DataCallResponse> response = new ArrayList<>();
    for (SetupDataCallResult dcResult : dcList) {
        response.add(RIL.convertDataCallResult(dcResult));
    }
    if (RIL.RILJ_LOGD)
        mRil.unsljLogRet(RIL_UNSOL_DATA_CALL_LIST_CHANGED, response);
    mRil.mDataCallListChangedRegistrants.notifyRegistrants(new AsyncResult(null, response, null));
}
#method_after
public void dataCallListChanged(int indicationType, ArrayList<SetupDataCallResult> dcList) {
    mRil.processIndication(indicationType);
    if (RIL.RILJ_LOGD)
        mRil.unsljLogRet(RIL_UNSOL_DATA_CALL_LIST_CHANGED, dcList);
    mRil.mDataCallListChangedRegistrants.notifyRegistrants(new AsyncResult(null, dcList, null));
}
#end_block

#method_before
public void keepaliveStatus(int indicationType, KeepaliveStatus keepaliveStatus) {
    throw new UnsupportedOperationException("keepaliveStatus Indications are not implemented");
}
#method_after
public void keepaliveStatus(int indicationType, android.hardware.radio.V1_1.KeepaliveStatus halStatus) {
    mRil.processIndication(indicationType);
    if (RIL.RILJ_LOGD) {
        mRil.unsljLogRet(RIL_UNSOL_KEEPALIVE_STATUS, "handle=" + halStatus.sessionHandle + " code=" + halStatus.code);
    }
    KeepaliveStatus ks = new KeepaliveStatus(halStatus.sessionHandle, halStatus.code);
    mRil.mNattKeepaliveStatusRegistrants.notifyRegistrants(new AsyncResult(null, ks, null));
}
#end_block

#method_before
/**
 * Set a system property, unless we're in unit test mode
 */
public void setSystemProperty(String property, String value) {
    if (getUnitTestMode()) {
        return;
    }
    SystemProperties.set(property, value);
}
#method_after
/**
 * Set a system property for the current phone, unless we're in unit test mode
 */
public void setSystemProperty(String property, String value) {
    if (getUnitTestMode()) {
        return;
    }
    TelephonyManager.setTelephonyProperty(mPhoneId, property, value);
}
#end_block

#method_before
public void startMonitoringImsService() {
    if (getPhoneType() == PhoneConstants.PHONE_TYPE_SIP) {
        return;
    }
    synchronized (Phone.lockForRadioTechnologyChange) {
        IntentFilter filter = new IntentFilter();
        ImsManager imsManager = ImsManager.getInstance(mContext, getPhoneId());
        // Don't listen to deprecated intents using the new dynamic binding.
        if (imsManager != null && !imsManager.isDynamicBinding()) {
            filter.addAction(ImsManager.ACTION_IMS_SERVICE_UP);
            filter.addAction(ImsManager.ACTION_IMS_SERVICE_DOWN);
        }
        filter.addAction(ImsConfig.ACTION_IMS_CONFIG_CHANGED);
        mContext.registerReceiver(mImsIntentReceiver, filter);
        // so start trying to bind.
        if (imsManager != null) {
            // the service to be available.
            if (imsManager.isDynamicBinding() || imsManager.isServiceAvailable()) {
                mImsServiceReady = true;
                updateImsPhone();
            }
        }
    }
}
#method_after
public void startMonitoringImsService() {
    if (getPhoneType() == PhoneConstants.PHONE_TYPE_SIP) {
        return;
    }
    synchronized (Phone.lockForRadioTechnologyChange) {
        IntentFilter filter = new IntentFilter();
        ImsManager imsManager = ImsManager.getInstance(mContext, getPhoneId());
        // Don't listen to deprecated intents using the new dynamic binding.
        if (imsManager != null && !imsManager.isDynamicBinding()) {
            filter.addAction(ImsManager.ACTION_IMS_SERVICE_UP);
            filter.addAction(ImsManager.ACTION_IMS_SERVICE_DOWN);
        }
        mContext.registerReceiver(mImsIntentReceiver, filter);
        // so start trying to bind.
        if (imsManager != null) {
            // the service to be available.
            if (imsManager.isDynamicBinding() || imsManager.isServiceAvailable()) {
                mImsServiceReady = true;
                updateImsPhone();
            }
        }
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    // resources of the phone being destroyed
    switch(msg.what) {
        // handle the select network completion callbacks.
        case EVENT_SET_NETWORK_MANUAL_COMPLETE:
        case EVENT_SET_NETWORK_AUTOMATIC_COMPLETE:
            handleSetSelectNetwork((AsyncResult) msg.obj);
            return;
    }
    switch(msg.what) {
        case EVENT_CALL_RING:
            Rlog.d(LOG_TAG, "Event EVENT_CALL_RING Received state=" + getState());
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                PhoneConstants.State state = getState();
                if ((!mDoesRilSendMultipleCallRing) && ((state == PhoneConstants.State.RINGING) || (state == PhoneConstants.State.IDLE))) {
                    mCallRingContinueToken += 1;
                    sendIncomingCallRingNotification(mCallRingContinueToken);
                } else {
                    notifyIncomingRing();
                }
            }
            break;
        case EVENT_CALL_RING_CONTINUE:
            Rlog.d(LOG_TAG, "Event EVENT_CALL_RING_CONTINUE Received state=" + getState());
            if (getState() == PhoneConstants.State.RINGING) {
                sendIncomingCallRingNotification(msg.arg1);
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            break;
        case EVENT_INITIATE_SILENT_REDIAL:
            Rlog.d(LOG_TAG, "Event EVENT_INITIATE_SILENT_REDIAL Received");
            ar = (AsyncResult) msg.obj;
            if ((ar.exception == null) && (ar.result != null)) {
                String dialString = (String) ar.result;
                if (TextUtils.isEmpty(dialString))
                    return;
                try {
                    dialInternal(dialString, null, VideoProfile.STATE_AUDIO_ONLY, null);
                } catch (CallStateException e) {
                    Rlog.e(LOG_TAG, "silent redial failed: " + e);
                }
            }
            break;
        case EVENT_SRVCC_STATE_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                handleSrvccStateChanged((int[]) ar.result);
            } else {
                Rlog.e(LOG_TAG, "Srvcc exception: " + ar.exception);
            }
            break;
        case EVENT_CONFIG_LCE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                Rlog.d(LOG_TAG, "config LCE service failed: " + ar.exception);
            } else {
                final ArrayList<Integer> statusInfo = (ArrayList<Integer>) ar.result;
                mLceStatus = statusInfo.get(0);
            }
            break;
        case EVENT_CHECK_FOR_NETWORK_AUTOMATIC:
            {
                onCheckForNetworkSelectionModeAutomatic(msg);
                break;
            }
        default:
            throw new RuntimeException("unexpected event not handled");
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    // resources of the phone being destroyed
    switch(msg.what) {
        // handle the select network completion callbacks.
        case EVENT_SET_NETWORK_MANUAL_COMPLETE:
        case EVENT_SET_NETWORK_AUTOMATIC_COMPLETE:
            handleSetSelectNetwork((AsyncResult) msg.obj);
            return;
    }
    switch(msg.what) {
        case EVENT_CALL_RING:
            Rlog.d(LOG_TAG, "Event EVENT_CALL_RING Received state=" + getState());
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                PhoneConstants.State state = getState();
                if ((!mDoesRilSendMultipleCallRing) && ((state == PhoneConstants.State.RINGING) || (state == PhoneConstants.State.IDLE))) {
                    mCallRingContinueToken += 1;
                    sendIncomingCallRingNotification(mCallRingContinueToken);
                } else {
                    notifyIncomingRing();
                }
            }
            break;
        case EVENT_CALL_RING_CONTINUE:
            Rlog.d(LOG_TAG, "Event EVENT_CALL_RING_CONTINUE Received state=" + getState());
            if (getState() == PhoneConstants.State.RINGING) {
                sendIncomingCallRingNotification(msg.arg1);
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            break;
        case EVENT_INITIATE_SILENT_REDIAL:
            Rlog.d(LOG_TAG, "Event EVENT_INITIATE_SILENT_REDIAL Received");
            ar = (AsyncResult) msg.obj;
            if ((ar.exception == null) && (ar.result != null)) {
                String dialString = (String) ar.result;
                if (TextUtils.isEmpty(dialString))
                    return;
                try {
                    dialInternal(dialString, new DialArgs.Builder().build());
                } catch (CallStateException e) {
                    Rlog.e(LOG_TAG, "silent redial failed: " + e);
                }
            }
            break;
        case EVENT_SRVCC_STATE_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                handleSrvccStateChanged((int[]) ar.result);
            } else {
                Rlog.e(LOG_TAG, "Srvcc exception: " + ar.exception);
            }
            break;
        case EVENT_CONFIG_LCE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                Rlog.d(LOG_TAG, "config LCE service failed: " + ar.exception);
            } else {
                final ArrayList<Integer> statusInfo = (ArrayList<Integer>) ar.result;
                mLceStatus = statusInfo.get(0);
            }
            break;
        case EVENT_CHECK_FOR_NETWORK_AUTOMATIC:
            {
                onCheckForNetworkSelectionModeAutomatic(msg);
                break;
            }
        default:
            throw new RuntimeException("unexpected event not handled");
    }
}
#end_block

#method_before
public void setIsInEcm(boolean isInEcm) {
    setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE, String.valueOf(isInEcm));
    mIsPhoneInEcmState = isInEcm;
}
#method_after
public void setIsInEcm(boolean isInEcm) {
    setGlobalSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE, String.valueOf(isInEcm));
    mIsPhoneInEcmState = isInEcm;
}
#end_block

#method_before
protected Connection dialInternal(String dialString, UUSInfo uusInfo, int videoState, Bundle intentExtras) throws CallStateException {
    // dialInternal shall be overriden by GsmCdmaPhone
    return null;
}
#method_after
protected Connection dialInternal(String dialString, DialArgs dialArgs) throws CallStateException {
    // dialInternal shall be overriden by GsmCdmaPhone
    return null;
}
#end_block

#method_before
@Override
public void notifyPhysicalChannelConfiguration(Phone sender, List<PhysicalChannelConfig> configs) {
    int subId = sender.getSubId();
    try {
        if (mRegistry != null) {
            mRegistry.notifyPhysicalChannelConfigurationForSubscriber(subId, configs);
        }
    } catch (RemoteException ex) {
    }
}
#method_after
@Override
public void notifyPhysicalChannelConfiguration(Phone sender, List<PhysicalChannelConfig> configs) {
    int subId = sender.getSubId();
    try {
        if (mRegistry != null) {
            mRegistry.notifyPhysicalChannelConfigurationForSubscriber(subId, configs);
        }
    } catch (RemoteException ex) {
    // system process is dead
    }
}
#end_block

#method_before
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
}
#method_after
@Override
public void setupDataCall(int accessNetworkType, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, int reason, LinkProperties linkProperties, Message result) {
}
#end_block

#method_before
public BluetoothLeAdvertiser getBluetoothLeAdvertiser() {
    if (!getLeAccess())
        return null;
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}
#method_after
public BluetoothLeAdvertiser getBluetoothLeAdvertiser() {
    if (!getLeAccess()) {
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}
#end_block

#method_before
public BluetoothLeScanner getBluetoothLeScanner() {
    if (!getLeAccess())
        return null;
    synchronized (mLock) {
        if (sBluetoothLeScanner == null) {
            sBluetoothLeScanner = new BluetoothLeScanner(mManagerService);
        }
    }
    return sBluetoothLeScanner;
}
#method_after
public BluetoothLeScanner getBluetoothLeScanner() {
    if (!getLeAccess()) {
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeScanner == null) {
            sBluetoothLeScanner = new BluetoothLeScanner(mManagerService);
        }
    }
    return sBluetoothLeScanner;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public boolean isEnabled() {
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isEnabled();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
public boolean isEnabled() {
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isEnabled();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
@SystemApi
public boolean isLeEnabled() {
    final int state = getLeState();
    if (DBG)
        Log.d(TAG, "isLeEnabled(): " + BluetoothAdapter.nameForState(state));
    return (state == BluetoothAdapter.STATE_ON || state == BluetoothAdapter.STATE_BLE_ON);
}
#method_after
@SystemApi
public boolean isLeEnabled() {
    final int state = getLeState();
    if (DBG) {
        Log.d(TAG, "isLeEnabled(): " + BluetoothAdapter.nameForState(state));
    }
    return (state == BluetoothAdapter.STATE_ON || state == BluetoothAdapter.STATE_BLE_ON);
}
#end_block

#method_before
@SystemApi
public boolean disableBLE() {
    if (!isBleScanAlwaysAvailable())
        return false;
    int state = getLeState();
    if (state == BluetoothAdapter.STATE_ON || state == BluetoothAdapter.STATE_BLE_ON) {
        String packageName = ActivityThread.currentPackageName();
        if (DBG)
            Log.d(TAG, "disableBLE(): de-registering " + packageName);
        try {
            mManagerService.updateBleAppCount(mToken, false, packageName);
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
        }
        return true;
    }
    if (DBG)
        Log.d(TAG, "disableBLE(): Already disabled");
    return false;
}
#method_after
@SystemApi
public boolean disableBLE() {
    if (!isBleScanAlwaysAvailable()) {
        return false;
    }
    int state = getLeState();
    if (state == BluetoothAdapter.STATE_ON || state == BluetoothAdapter.STATE_BLE_ON) {
        String packageName = ActivityThread.currentPackageName();
        if (DBG) {
            Log.d(TAG, "disableBLE(): de-registering " + packageName);
        }
        try {
            mManagerService.updateBleAppCount(mToken, false, packageName);
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
        }
        return true;
    }
    if (DBG) {
        Log.d(TAG, "disableBLE(): Already disabled");
    }
    return false;
}
#end_block

#method_before
@SystemApi
public boolean enableBLE() {
    if (!isBleScanAlwaysAvailable())
        return false;
    try {
        String packageName = ActivityThread.currentPackageName();
        mManagerService.updateBleAppCount(mToken, true, packageName);
        if (isLeEnabled()) {
            if (DBG)
                Log.d(TAG, "enableBLE(): Bluetooth already enabled");
            return true;
        }
        if (DBG)
            Log.d(TAG, "enableBLE(): Calling enable");
        return mManagerService.enable(packageName);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@SystemApi
public boolean enableBLE() {
    if (!isBleScanAlwaysAvailable()) {
        return false;
    }
    try {
        String packageName = ActivityThread.currentPackageName();
        mManagerService.updateBleAppCount(mToken, true, packageName);
        if (isLeEnabled()) {
            if (DBG) {
                Log.d(TAG, "enableBLE(): Bluetooth already enabled");
            }
            return true;
        }
        if (DBG) {
            Log.d(TAG, "enableBLE(): Calling enable");
        }
        return mManagerService.enable(packageName);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
@AdapterState
public int getLeState() {
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            state = mService.getState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    if (VDBG)
        Log.d(TAG, "getLeState() returning " + BluetoothAdapter.nameForState(state));
    return state;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
@AdapterState
public int getLeState() {
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            state = mService.getState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    if (VDBG) {
        Log.d(TAG, "getLeState() returning " + BluetoothAdapter.nameForState(state));
    }
    return state;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean enable() {
    if (isEnabled()) {
        if (DBG)
            Log.d(TAG, "enable(): BT already enabled!");
        return true;
    }
    try {
        return mManagerService.enable(ActivityThread.currentPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean enable() {
    if (isEnabled()) {
        if (DBG) {
            Log.d(TAG, "enable(): BT already enabled!");
        }
        return true;
    }
    try {
        return mManagerService.enable(ActivityThread.currentPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
public ParcelUuid[] getUuids() {
    if (getState() != STATE_ON)
        return null;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getUuids();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}
#method_after
public ParcelUuid[] getUuids() {
    if (getState() != STATE_ON) {
        return null;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getUuids();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean setName(String name) {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.setName(name);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean setName(String name) {
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.setName(name);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public BluetoothClass getBluetoothClass() {
    if (getState() != STATE_ON)
        return null;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getBluetoothClass();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public BluetoothClass getBluetoothClass() {
    if (getState() != STATE_ON) {
        return null;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getBluetoothClass();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_PRIVILEGED)
public boolean setBluetoothClass(BluetoothClass bluetoothClass) {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.setBluetoothClass(bluetoothClass);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_PRIVILEGED)
public boolean setBluetoothClass(BluetoothClass bluetoothClass) {
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.setBluetoothClass(bluetoothClass);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
@ScanMode
public int getScanMode() {
    if (getState() != STATE_ON)
        return SCAN_MODE_NONE;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getScanMode();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return SCAN_MODE_NONE;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
@ScanMode
public int getScanMode() {
    if (getState() != STATE_ON) {
        return SCAN_MODE_NONE;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getScanMode();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return SCAN_MODE_NONE;
}
#end_block

#method_before
public boolean setScanMode(@ScanMode int mode, int duration) {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.setScanMode(mode, duration);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
public boolean setScanMode(@ScanMode int mode, int duration) {
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.setScanMode(mode, duration);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public boolean setScanMode(int mode) {
    if (getState() != STATE_ON)
        return false;
    /* getDiscoverableTimeout() to use the latest from NV than use 0 */
    return setScanMode(mode, getDiscoverableTimeout());
}
#method_after
public boolean setScanMode(int mode) {
    if (getState() != STATE_ON) {
        return false;
    }
    /* getDiscoverableTimeout() to use the latest from NV than use 0 */
    return setScanMode(mode, getDiscoverableTimeout());
}
#end_block

#method_before
public int getDiscoverableTimeout() {
    if (getState() != STATE_ON)
        return -1;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getDiscoverableTimeout();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return -1;
}
#method_after
public int getDiscoverableTimeout() {
    if (getState() != STATE_ON) {
        return -1;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getDiscoverableTimeout();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return -1;
}
#end_block

#method_before
public void setDiscoverableTimeout(int timeout) {
    if (getState() != STATE_ON)
        return;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            mService.setDiscoverableTimeout(timeout);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
}
#method_after
public void setDiscoverableTimeout(int timeout) {
    if (getState() != STATE_ON) {
        return;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            mService.setDiscoverableTimeout(timeout);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
}
#end_block

#method_before
public long getDiscoveryEndMillis() {
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getDiscoveryEndMillis();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return -1;
}
#method_after
public long getDiscoveryEndMillis() {
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getDiscoveryEndMillis();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return -1;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean startDiscovery() {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.startDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean startDiscovery() {
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.startDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean cancelDiscovery() {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.cancelDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean cancelDiscovery() {
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.cancelDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public boolean isDiscovering() {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isDiscovering();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
public boolean isDiscovering() {
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isDiscovering();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public boolean isMultipleAdvertisementSupported() {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isMultiAdvertisementSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isMultipleAdvertisementSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
public boolean isMultipleAdvertisementSupported() {
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isMultiAdvertisementSupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isMultipleAdvertisementSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public boolean isOffloadedFilteringSupported() {
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isOffloadedFilteringSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedFilteringSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
public boolean isOffloadedFilteringSupported() {
    if (!getLeAccess()) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isOffloadedFilteringSupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedFilteringSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public boolean isOffloadedScanBatchingSupported() {
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isOffloadedScanBatchingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedScanBatchingSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
public boolean isOffloadedScanBatchingSupported() {
    if (!getLeAccess()) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isOffloadedScanBatchingSupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedScanBatchingSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public boolean isLe2MPhySupported() {
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isLe2MPhySupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isExtendedAdvertisingSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
public boolean isLe2MPhySupported() {
    if (!getLeAccess()) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isLe2MPhySupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isExtendedAdvertisingSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public boolean isLeCodedPhySupported() {
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isLeCodedPhySupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isLeCodedPhySupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
public boolean isLeCodedPhySupported() {
    if (!getLeAccess()) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isLeCodedPhySupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isLeCodedPhySupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public boolean isLeExtendedAdvertisingSupported() {
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isLeExtendedAdvertisingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isLeExtendedAdvertisingSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
public boolean isLeExtendedAdvertisingSupported() {
    if (!getLeAccess()) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isLeExtendedAdvertisingSupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isLeExtendedAdvertisingSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public boolean isLePeriodicAdvertisingSupported() {
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isLePeriodicAdvertisingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isLePeriodicAdvertisingSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
public boolean isLePeriodicAdvertisingSupported() {
    if (!getLeAccess()) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isLePeriodicAdvertisingSupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isLePeriodicAdvertisingSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public int getLeMaximumAdvertisingDataLength() {
    if (!getLeAccess())
        return 0;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getLeMaximumAdvertisingDataLength();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get getLeMaximumAdvertisingDataLength, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return 0;
}
#method_after
public int getLeMaximumAdvertisingDataLength() {
    if (!getLeAccess()) {
        return 0;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getLeMaximumAdvertisingDataLength();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get getLeMaximumAdvertisingDataLength, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return 0;
}
#end_block

#method_before
public boolean isHardwareTrackingFiltersAvailable() {
    if (!getLeAccess())
        return false;
    try {
        IBluetoothGatt iGatt = mManagerService.getBluetoothGatt();
        if (iGatt == null) {
            // BLE is not supported
            return false;
        }
        return (iGatt.numHwTrackFiltersAvailable() != 0);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
public boolean isHardwareTrackingFiltersAvailable() {
    if (!getLeAccess()) {
        return false;
    }
    try {
        IBluetoothGatt iGatt = mManagerService.getBluetoothGatt();
        if (iGatt == null) {
            // BLE is not supported
            return false;
        }
        return (iGatt.numHwTrackFiltersAvailable() != 0);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public Set<BluetoothDevice> getBondedDevices() {
    if (getState() != STATE_ON) {
        return toDeviceSet(new BluetoothDevice[0]);
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return toDeviceSet(mService.getBondedDevices());
        return toDeviceSet(new BluetoothDevice[0]);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
public Set<BluetoothDevice> getBondedDevices() {
    if (getState() != STATE_ON) {
        return toDeviceSet(new BluetoothDevice[0]);
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return toDeviceSet(mService.getBondedDevices());
        }
        return toDeviceSet(new BluetoothDevice[0]);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}
#end_block

#method_before
public int getConnectionState() {
    if (getState() != STATE_ON)
        return BluetoothAdapter.STATE_DISCONNECTED;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getAdapterConnectionState();
    } catch (RemoteException e) {
        Log.e(TAG, "getConnectionState:", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothAdapter.STATE_DISCONNECTED;
}
#method_after
public int getConnectionState() {
    if (getState() != STATE_ON) {
        return BluetoothAdapter.STATE_DISCONNECTED;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getAdapterConnectionState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getConnectionState:", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothAdapter.STATE_DISCONNECTED;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public int getProfileConnectionState(int profile) {
    if (getState() != STATE_ON)
        return BluetoothProfile.STATE_DISCONNECTED;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getProfileConnectionState(profile);
    } catch (RemoteException e) {
        Log.e(TAG, "getProfileConnectionState:", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
public int getProfileConnectionState(int profile) {
    if (getState() != STATE_ON) {
        return BluetoothProfile.STATE_DISCONNECTED;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getProfileConnectionState(profile);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getProfileConnectionState:", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
#end_block

#method_before
public BluetoothServerSocket listenUsingL2capOn(int port, boolean mitm, boolean min16DigitPin) throws IOException {
    BluetoothServerSocket socket = new BluetoothServerSocket(BluetoothSocket.TYPE_L2CAP, true, true, port, mitm, min16DigitPin);
    int errno = socket.mSocket.bindListen();
    if (port == SOCKET_CHANNEL_AUTO_STATIC_NO_SDP) {
        socket.setChannel(socket.mSocket.getPort());
    }
    if (errno != 0) {
        // socket.mSocket.throwErrnoNative(errno);
        throw new IOException("Error: " + errno);
    }
    return socket;
}
#method_after
public BluetoothServerSocket listenUsingL2capOn(int port, boolean mitm, boolean min16DigitPin) throws IOException {
    BluetoothServerSocket socket = new BluetoothServerSocket(BluetoothSocket.TYPE_L2CAP, true, true, port, mitm, min16DigitPin);
    int errno = socket.mSocket.bindListen();
    if (port == SOCKET_CHANNEL_AUTO_STATIC_NO_SDP) {
        int assignedChannel = socket.mSocket.getPort();
        if (DBG)
            Log.d(TAG, "listenUsingL2capOn: set assigned channel to " + assignedChannel);
        socket.setChannel(assignedChannel);
    }
    if (errno != 0) {
        // socket.mSocket.throwErrnoNative(errno);
        throw new IOException("Error: " + errno);
    }
    return socket;
}
#end_block

#method_before
public BluetoothServerSocket listenUsingInsecureL2capOn(int port) throws IOException {
    BluetoothServerSocket socket = new BluetoothServerSocket(BluetoothSocket.TYPE_L2CAP, false, false, port, false, false);
    int errno = socket.mSocket.bindListen();
    if (port == SOCKET_CHANNEL_AUTO_STATIC_NO_SDP) {
        socket.setChannel(socket.mSocket.getPort());
    }
    if (errno != 0) {
        // socket.mSocket.throwErrnoNative(errno);
        throw new IOException("Error: " + errno);
    }
    return socket;
}
#method_after
public BluetoothServerSocket listenUsingInsecureL2capOn(int port) throws IOException {
    Log.d(TAG, "listenUsingInsecureL2capOn: port=" + port);
    BluetoothServerSocket socket = new BluetoothServerSocket(BluetoothSocket.TYPE_L2CAP, false, false, port, false, false);
    int errno = socket.mSocket.bindListen();
    if (port == SOCKET_CHANNEL_AUTO_STATIC_NO_SDP) {
        int assignedChannel = socket.mSocket.getPort();
        if (DBG) {
            Log.d(TAG, "listenUsingInsecureL2capOn: set assigned channel to " + assignedChannel);
        }
        socket.setChannel(assignedChannel);
    }
    if (errno != 0) {
        // socket.mSocket.throwErrnoNative(errno);
        throw new IOException("Error: " + errno);
    }
    return socket;
}
#end_block

#method_before
public boolean getProfileProxy(Context context, BluetoothProfile.ServiceListener listener, int profile) {
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_HOST) {
        BluetoothHidHost iDev = new BluetoothHidHost(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_DEVICE) {
        BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEARING_AID) {
        BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
        return true;
    } else {
        return false;
    }
}
#method_after
public boolean getProfileProxy(Context context, BluetoothProfile.ServiceListener listener, int profile) {
    if (context == null || listener == null) {
        return false;
    }
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_HOST) {
        BluetoothHidHost iDev = new BluetoothHidHost(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_DEVICE) {
        BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEARING_AID) {
        BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
public void closeProfileProxy(int profile, BluetoothProfile proxy) {
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
        case BluetoothProfile.HEARING_AID:
            BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
            hearingAid.close();
    }
}
#method_after
public void closeProfileProxy(int profile, BluetoothProfile proxy) {
    if (proxy == null) {
        return;
    }
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
        case BluetoothProfile.HEARING_AID:
            BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
            hearingAid.close();
    }
}
#end_block

#method_before
public boolean enableNoAutoConnect() {
    if (isEnabled()) {
        if (DBG)
            Log.d(TAG, "enableNoAutoConnect(): BT already enabled!");
        return true;
    }
    try {
        return mManagerService.enableNoAutoConnect(ActivityThread.currentPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.BLUETOOTH_ADMIN)
public boolean enableNoAutoConnect() {
    if (isEnabled()) {
        if (DBG) {
            Log.d(TAG, "enableNoAutoConnect(): BT already enabled!");
        }
        return true;
    }
    try {
        return mManagerService.enableNoAutoConnect(ActivityThread.currentPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
@Deprecated
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean startLeScan(final UUID[] serviceUuids, final LeScanCallback callback) {
    if (DBG)
        Log.d(TAG, "startLeScan(): " + Arrays.toString(serviceUuids));
    if (callback == null) {
        if (DBG)
            Log.e(TAG, "startLeScan: null callback");
        return false;
    }
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        if (DBG)
            Log.e(TAG, "startLeScan: cannot get BluetoothLeScanner");
        return false;
    }
    synchronized (mLeScanClients) {
        if (mLeScanClients.containsKey(callback)) {
            if (DBG)
                Log.e(TAG, "LE Scan has already started");
            return false;
        }
        try {
            IBluetoothGatt iGatt = mManagerService.getBluetoothGatt();
            if (iGatt == null) {
                // BLE is not supported
                return false;
            }
            ScanCallback scanCallback = new ScanCallback() {

                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    if (callbackType != ScanSettings.CALLBACK_TYPE_ALL_MATCHES) {
                        // Should not happen.
                        Log.e(TAG, "LE Scan has already started");
                        return;
                    }
                    ScanRecord scanRecord = result.getScanRecord();
                    if (scanRecord == null) {
                        return;
                    }
                    if (serviceUuids != null) {
                        List<ParcelUuid> uuids = new ArrayList<ParcelUuid>();
                        for (UUID uuid : serviceUuids) {
                            uuids.add(new ParcelUuid(uuid));
                        }
                        List<ParcelUuid> scanServiceUuids = scanRecord.getServiceUuids();
                        if (scanServiceUuids == null || !scanServiceUuids.containsAll(uuids)) {
                            if (DBG)
                                Log.d(TAG, "uuids does not match");
                            return;
                        }
                    }
                    callback.onLeScan(result.getDevice(), result.getRssi(), scanRecord.getBytes());
                }
            };
            ScanSettings settings = new ScanSettings.Builder().setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES).setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
            List<ScanFilter> filters = new ArrayList<ScanFilter>();
            if (serviceUuids != null && serviceUuids.length > 0) {
                // Note scan filter does not support matching an UUID array so we put one
                // UUID to hardware and match the whole array in callback.
                ScanFilter filter = new ScanFilter.Builder().setServiceUuid(new ParcelUuid(serviceUuids[0])).build();
                filters.add(filter);
            }
            scanner.startScan(filters, settings, scanCallback);
            mLeScanClients.put(callback, scanCallback);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
        }
    }
    return false;
}
#method_after
@Deprecated
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean startLeScan(final UUID[] serviceUuids, final LeScanCallback callback) {
    if (DBG) {
        Log.d(TAG, "startLeScan(): " + Arrays.toString(serviceUuids));
    }
    if (callback == null) {
        if (DBG) {
            Log.e(TAG, "startLeScan: null callback");
        }
        return false;
    }
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        if (DBG) {
            Log.e(TAG, "startLeScan: cannot get BluetoothLeScanner");
        }
        return false;
    }
    synchronized (mLeScanClients) {
        if (mLeScanClients.containsKey(callback)) {
            if (DBG) {
                Log.e(TAG, "LE Scan has already started");
            }
            return false;
        }
        try {
            IBluetoothGatt iGatt = mManagerService.getBluetoothGatt();
            if (iGatt == null) {
                // BLE is not supported
                return false;
            }
            ScanCallback scanCallback = new ScanCallback() {

                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    if (callbackType != ScanSettings.CALLBACK_TYPE_ALL_MATCHES) {
                        // Should not happen.
                        Log.e(TAG, "LE Scan has already started");
                        return;
                    }
                    ScanRecord scanRecord = result.getScanRecord();
                    if (scanRecord == null) {
                        return;
                    }
                    if (serviceUuids != null) {
                        List<ParcelUuid> uuids = new ArrayList<ParcelUuid>();
                        for (UUID uuid : serviceUuids) {
                            uuids.add(new ParcelUuid(uuid));
                        }
                        List<ParcelUuid> scanServiceUuids = scanRecord.getServiceUuids();
                        if (scanServiceUuids == null || !scanServiceUuids.containsAll(uuids)) {
                            if (DBG) {
                                Log.d(TAG, "uuids does not match");
                            }
                            return;
                        }
                    }
                    callback.onLeScan(result.getDevice(), result.getRssi(), scanRecord.getBytes());
                }
            };
            ScanSettings settings = new ScanSettings.Builder().setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES).setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
            List<ScanFilter> filters = new ArrayList<ScanFilter>();
            if (serviceUuids != null && serviceUuids.length > 0) {
                // Note scan filter does not support matching an UUID array so we put one
                // UUID to hardware and match the whole array in callback.
                ScanFilter filter = new ScanFilter.Builder().setServiceUuid(new ParcelUuid(serviceUuids[0])).build();
                filters.add(filter);
            }
            scanner.startScan(filters, settings, scanCallback);
            mLeScanClients.put(callback, scanCallback);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
        }
    }
    return false;
}
#end_block

#method_before
@Deprecated
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public void stopLeScan(LeScanCallback callback) {
    if (DBG)
        Log.d(TAG, "stopLeScan()");
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        return;
    }
    synchronized (mLeScanClients) {
        ScanCallback scanCallback = mLeScanClients.remove(callback);
        if (scanCallback == null) {
            if (DBG)
                Log.d(TAG, "scan not started yet");
            return;
        }
        scanner.stopScan(scanCallback);
    }
}
#method_after
@Deprecated
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public void stopLeScan(LeScanCallback callback) {
    if (DBG) {
        Log.d(TAG, "stopLeScan()");
    }
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        return;
    }
    synchronized (mLeScanClients) {
        ScanCallback scanCallback = mLeScanClients.remove(callback);
        if (scanCallback == null) {
            if (DBG) {
                Log.d(TAG, "scan not started yet");
            }
            return;
        }
        scanner.stopScan(scanCallback);
    }
}
#end_block

#method_before
boolean doBind() {
    Intent intent = new Intent(IBluetoothHearingAid.class.getName());
    ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
    intent.setComponent(comp);
    if (comp == null || !mContext.bindServiceAsUser(intent, mConnection, 0, android.os.Process.myUserHandle())) {
        Log.e(TAG, "Could not bind to Bluetooth Hearing Aid Service with " + intent);
        return false;
    }
    return true;
}
#method_after
void doBind() {
    Intent intent = new Intent(IBluetoothHearingAid.class.getName());
    ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
    intent.setComponent(comp);
    if (comp == null || !mContext.bindServiceAsUser(intent, mConnection, 0, android.os.Process.myUserHandle())) {
        Log.e(TAG, "Could not bind to Bluetooth Hearing Aid Service with " + intent);
        return;
    }
}
#end_block

#method_before
synchronized void updateProfiles(ParcelUuid[] uuids, ParcelUuid[] localUuids, Collection<LocalBluetoothProfile> profiles, Collection<LocalBluetoothProfile> removedProfiles, boolean isPanNapConnected, BluetoothDevice device) {
    // Copy previous profile list into removedProfiles
    removedProfiles.clear();
    removedProfiles.addAll(profiles);
    if (DEBUG) {
        Log.d(TAG, "Current Profiles" + profiles.toString());
    }
    profiles.clear();
    if (uuids == null) {
        return;
    }
    if (mHeadsetProfile != null) {
        if ((BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.HSP_AG) && BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP)) || (BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.Handsfree_AG) && BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree))) {
            profiles.add(mHeadsetProfile);
            removedProfiles.remove(mHeadsetProfile);
        }
    }
    if ((mHfpClientProfile != null) && BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree_AG) && BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.Handsfree)) {
        profiles.add(mHfpClientProfile);
        removedProfiles.remove(mHfpClientProfile);
    }
    if (BluetoothUuid.containsAnyUuid(uuids, A2dpProfile.SINK_UUIDS) && mA2dpProfile != null) {
        profiles.add(mA2dpProfile);
        removedProfiles.remove(mA2dpProfile);
    }
    if (BluetoothUuid.containsAnyUuid(uuids, A2dpSinkProfile.SRC_UUIDS) && mA2dpSinkProfile != null) {
        profiles.add(mA2dpSinkProfile);
        removedProfiles.remove(mA2dpSinkProfile);
    }
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.ObexObjectPush) && mOppProfile != null) {
        profiles.add(mOppProfile);
        removedProfiles.remove(mOppProfile);
    }
    if ((BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Hid) || BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Hogp)) && mHidProfile != null) {
        profiles.add(mHidProfile);
        removedProfiles.remove(mHidProfile);
    }
    if (isPanNapConnected)
        if (DEBUG)
            Log.d(TAG, "Valid PAN-NAP connection exists.");
    if ((BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.NAP) && mPanProfile != null) || isPanNapConnected) {
        profiles.add(mPanProfile);
        removedProfiles.remove(mPanProfile);
    }
    if ((mMapProfile != null) && (mMapProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
        profiles.add(mMapProfile);
        removedProfiles.remove(mMapProfile);
        mMapProfile.setPreferred(device, true);
    }
    if (mMapClientProfile != null) {
        profiles.add(mMapClientProfile);
        removedProfiles.remove(mMapClientProfile);
    }
    if (mUsePbapPce) {
        profiles.add(mPbapClientProfile);
        removedProfiles.remove(mPbapClientProfile);
        profiles.remove(mPbapProfile);
        removedProfiles.add(mPbapProfile);
    }
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HearingAid) && mHearingAidProfile != null) {
        profiles.add(mHearingAidProfile);
        removedProfiles.remove(mHearingAidProfile);
    }
    if (DEBUG) {
        Log.d(TAG, "New Profiles" + profiles.toString());
    }
}
#method_after
synchronized void updateProfiles(ParcelUuid[] uuids, ParcelUuid[] localUuids, Collection<LocalBluetoothProfile> profiles, Collection<LocalBluetoothProfile> removedProfiles, boolean isPanNapConnected, BluetoothDevice device) {
    // Copy previous profile list into removedProfiles
    removedProfiles.clear();
    removedProfiles.addAll(profiles);
    if (DEBUG) {
        Log.d(TAG, "Current Profiles" + profiles.toString());
    }
    profiles.clear();
    if (uuids == null) {
        return;
    }
    if (mHeadsetProfile != null) {
        if ((BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.HSP_AG) && BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP)) || (BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.Handsfree_AG) && BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree))) {
            profiles.add(mHeadsetProfile);
            removedProfiles.remove(mHeadsetProfile);
        }
    }
    if ((mHfpClientProfile != null) && BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree_AG) && BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.Handsfree)) {
        profiles.add(mHfpClientProfile);
        removedProfiles.remove(mHfpClientProfile);
    }
    if (BluetoothUuid.containsAnyUuid(uuids, A2dpProfile.SINK_UUIDS) && mA2dpProfile != null) {
        profiles.add(mA2dpProfile);
        removedProfiles.remove(mA2dpProfile);
    }
    if (BluetoothUuid.containsAnyUuid(uuids, A2dpSinkProfile.SRC_UUIDS) && mA2dpSinkProfile != null) {
        profiles.add(mA2dpSinkProfile);
        removedProfiles.remove(mA2dpSinkProfile);
    }
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.ObexObjectPush) && mOppProfile != null) {
        profiles.add(mOppProfile);
        removedProfiles.remove(mOppProfile);
    }
    if ((BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Hid) || BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Hogp)) && mHidProfile != null) {
        profiles.add(mHidProfile);
        removedProfiles.remove(mHidProfile);
    }
    if (isPanNapConnected)
        if (DEBUG)
            Log.d(TAG, "Valid PAN-NAP connection exists.");
    if ((BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.NAP) && mPanProfile != null) || isPanNapConnected) {
        profiles.add(mPanProfile);
        removedProfiles.remove(mPanProfile);
    }
    if ((mMapProfile != null) && (mMapProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
        profiles.add(mMapProfile);
        removedProfiles.remove(mMapProfile);
        mMapProfile.setPreferred(device, true);
    }
    if ((mPbapProfile != null) && (mPbapProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
        profiles.add(mPbapProfile);
        removedProfiles.remove(mPbapProfile);
        mPbapProfile.setPreferred(device, true);
    }
    if (mMapClientProfile != null) {
        profiles.add(mMapClientProfile);
        removedProfiles.remove(mMapClientProfile);
    }
    if (mUsePbapPce) {
        profiles.add(mPbapClientProfile);
        removedProfiles.remove(mPbapClientProfile);
    }
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HearingAid) && mHearingAidProfile != null) {
        profiles.add(mHearingAidProfile);
        removedProfiles.remove(mHearingAidProfile);
    }
    if (DEBUG) {
        Log.d(TAG, "New Profiles" + profiles.toString());
    }
}
#end_block

#method_before
public boolean connect(BluetoothDevice device) {
    if (mService == null)
        return false;
    List<BluetoothDevice> sinks = getConnectedDevices();
    if (sinks != null) {
        for (BluetoothDevice sink : sinks) {
            if (sink.equals(device)) {
                Log.w(TAG, "Connecting to device " + device + " : disconnect skipped");
                continue;
            }
            mService.disconnect(sink);
        }
    }
    return mService.connect(device);
}
#method_after
public boolean connect(BluetoothDevice device) {
    if (mService == null)
        return false;
    return mService.connect(device);
}
#end_block

#method_before
public boolean disconnect(BluetoothDevice device) {
    if (mService == null)
        return false;
    // Downgrade priority as user is disconnecting the headset.
    if (mService.getPriority(device) > BluetoothProfile.PRIORITY_ON) {
        mService.setPriority(device, BluetoothProfile.PRIORITY_ON);
    }
    return mService.disconnect(device);
}
#method_after
public boolean disconnect(BluetoothDevice device) {
    if (mService == null)
        return false;
    // Downgrade priority as user is disconnecting the hearing aid.
    if (mService.getPriority(device) > BluetoothProfile.PRIORITY_ON) {
        mService.setPriority(device, BluetoothProfile.PRIORITY_ON);
    }
    return mService.disconnect(device);
}
#end_block

#method_before
public int getDrawableResource(BluetoothClass btClass) {
    // TODO: get an icon for hearing aid. For now reuse hadphones
    return R.drawable.ic_bt_headphones_a2dp;
}
#method_after
public int getDrawableResource(BluetoothClass btClass) {
    return R.drawable.ic_bt_hearing_aid;
}
#end_block

#method_before
private void connectDevice(BluetoothDevice device) {
    A2dpStackEvent connCompletedEvent;
    // Update the device priority so okToConnect() returns true
    mA2dpService.setPriority(device, BluetoothProfile.PRIORITY_ON);
    doReturn(true).when(mA2dpNativeInterface).connectA2dp(device);
    doReturn(true).when(mA2dpNativeInterface).disconnectA2dp(device);
    // Send a connect request
    Assert.assertTrue("Connect failed", mA2dpService.connect(device));
    // Verify the connection state broadcast, and that we are in Connecting state
    verifyConnectionStateIntent(TIMEOUT_MS, device, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTED);
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTING, mA2dpService.getConnectionState(device));
    // Send a message to trigger connection completed
    connCompletedEvent = new A2dpStackEvent(A2dpStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED);
    connCompletedEvent.device = device;
    connCompletedEvent.valueInt = A2dpStackEvent.CONNECTION_STATE_CONNECTED;
    mA2dpService.messageFromNative(connCompletedEvent);
    // Verify the connection state broadcast, and that we are in Connected state
    verifyConnectionStateIntent(TIMEOUT_MS, device, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING);
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mA2dpService.getConnectionState(device));
    // Verify the list of connected devices
    Assert.assertTrue(mA2dpService.getConnectedDevices().contains(device));
}
#method_after
private void connectDevice(BluetoothDevice device) {
    A2dpStackEvent connCompletedEvent;
    List<BluetoothDevice> prevConnectedDevices = mA2dpService.getConnectedDevices();
    // Update the device priority so okToConnect() returns true
    mA2dpService.setPriority(device, BluetoothProfile.PRIORITY_ON);
    doReturn(true).when(mA2dpNativeInterface).connectA2dp(device);
    doReturn(true).when(mA2dpNativeInterface).disconnectA2dp(device);
    // Send a connect request
    Assert.assertTrue("Connect failed", mA2dpService.connect(device));
    // Verify the connection state broadcast, and that we are in Connecting state
    verifyConnectionStateIntent(TIMEOUT_MS, device, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTED);
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTING, mA2dpService.getConnectionState(device));
    // Send a message to trigger connection completed
    connCompletedEvent = new A2dpStackEvent(A2dpStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED);
    connCompletedEvent.device = device;
    connCompletedEvent.valueInt = A2dpStackEvent.CONNECTION_STATE_CONNECTED;
    mA2dpService.messageFromNative(connCompletedEvent);
    // Verify the connection state broadcast, and that we are in Connected state
    verifyConnectionStateIntent(TIMEOUT_MS, device, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING);
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mA2dpService.getConnectionState(device));
    // Verify that the device is in the list of connected devices
    Assert.assertTrue(mA2dpService.getConnectedDevices().contains(device));
    // Verify the list of previously connected devices
    for (BluetoothDevice prevDevice : prevConnectedDevices) {
        Assert.assertTrue(mA2dpService.getConnectedDevices().contains(prevDevice));
    }
}
#end_block

#method_before
public void clearAll() {
    mNetworkCapabilities = mTransportTypes = 0;
    mLinkUpBandwidthKbps = mLinkDownBandwidthKbps = LINK_BANDWIDTH_UNSPECIFIED;
    mNetworkSpecifier = null;
    mSignalStrength = SIGNAL_STRENGTH_UNSPECIFIED;
    mUids = null;
    mEstablishingVpnAppUid = INVALID_UID;
    mUnwantedNetworkCapabilities = 0;
}
#method_after
public void clearAll() {
    mNetworkCapabilities = mTransportTypes = 0;
    mLinkUpBandwidthKbps = mLinkDownBandwidthKbps = LINK_BANDWIDTH_UNSPECIFIED;
    mNetworkSpecifier = null;
    mSignalStrength = SIGNAL_STRENGTH_UNSPECIFIED;
    mUids = null;
    mEstablishingVpnAppUid = INVALID_UID;
}
#end_block

#method_before
public NetworkCapabilities addCapability(@NetCapability int capability) {
    if (capability < MIN_NET_CAPABILITY || capability > MAX_NET_CAPABILITY) {
        throw new IllegalArgumentException("NetworkCapability out of range");
    }
    mNetworkCapabilities |= 1 << capability;
    removeUnwantedCapability(capability);
    return this;
}
#method_after
public NetworkCapabilities addCapability(@NetCapability int capability) {
    if (capability < MIN_NET_CAPABILITY || capability > MAX_NET_CAPABILITY) {
        throw new IllegalArgumentException("NetworkCapability out of range");
    }
    mNetworkCapabilities |= 1 << capability;
    return this;
}
#end_block

#method_before
private boolean satisfiedByNetCapabilities(NetworkCapabilities nc, boolean onlyImmutable) {
    long networkCapabilities = this.mNetworkCapabilities;
    if (onlyImmutable) {
        networkCapabilities = networkCapabilities & ~MUTABLE_CAPABILITIES;
    }
    if ((mUnwantedNetworkCapabilities & nc.mNetworkCapabilities) > 0) {
        // Can't be satisfied because given Network contains unwanted capabilities.
        return false;
    }
    return ((nc.mNetworkCapabilities & networkCapabilities) == networkCapabilities);
}
#method_after
private boolean satisfiedByNetCapabilities(NetworkCapabilities nc, boolean onlyImmutable) {
    long networkCapabilities = this.mNetworkCapabilities;
    if (onlyImmutable) {
        networkCapabilities = networkCapabilities & ~MUTABLE_CAPABILITIES;
    }
    return ((nc.mNetworkCapabilities & networkCapabilities) == networkCapabilities);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == null || (obj instanceof NetworkCapabilities == false))
        return false;
    NetworkCapabilities that = (NetworkCapabilities) obj;
    return equalsNetCapabilities(that) && equalsTransportTypes(that) && equalsLinkBandwidths(that) && equalsSignalStrength(that) && equalsSpecifier(that) && equalsUids(that) && Objects.equals(mUnwantedNetworkCapabilities, that.mUnwantedNetworkCapabilities);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null || (obj instanceof NetworkCapabilities == false))
        return false;
    NetworkCapabilities that = (NetworkCapabilities) obj;
    return (equalsNetCapabilities(that) && equalsTransportTypes(that) && equalsLinkBandwidths(that) && equalsSignalStrength(that) && equalsSpecifier(that) && equalsUids(that));
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(mNetworkCapabilities, mTransportTypes, mLinkDownBandwidthKbps, mLinkUpBandwidthKbps, mNetworkSpecifier, mSignalStrength, mUids, mUnwantedNetworkCapabilities);
}
#method_after
@Override
public int hashCode() {
    return ((int) (mNetworkCapabilities & 0xFFFFFFFF) + ((int) (mNetworkCapabilities >> 32) * 3) + ((int) (mTransportTypes & 0xFFFFFFFF) * 5) + ((int) (mTransportTypes >> 32) * 7) + (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19) + Objects.hashCode(mUids) * 23);
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeLong(mNetworkCapabilities);
    dest.writeLong(mTransportTypes);
    dest.writeInt(mLinkUpBandwidthKbps);
    dest.writeInt(mLinkDownBandwidthKbps);
    dest.writeParcelable((Parcelable) mNetworkSpecifier, flags);
    dest.writeInt(mSignalStrength);
    dest.writeArraySet(mUids);
    dest.writeLong(mUnwantedNetworkCapabilities);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeLong(mNetworkCapabilities);
    dest.writeLong(mTransportTypes);
    dest.writeInt(mLinkUpBandwidthKbps);
    dest.writeInt(mLinkDownBandwidthKbps);
    dest.writeParcelable((Parcelable) mNetworkSpecifier, flags);
    dest.writeInt(mSignalStrength);
    dest.writeArraySet(mUids);
}
#end_block

#method_before
@Override
public String toString() {
    // TODO: enumerate bits for transports and capabilities instead of creating arrays.
    // TODO: use a StringBuilder instead of string concatenation.
    int[] types = getTransportTypes();
    String transports = (types.length > 0) ? " Transports: " + transportNamesOf(types) : "";
    types = getCapabilities();
    String capabilities = (types.length > 0 ? " Capabilities: " : "");
    for (int i = 0; i < types.length; ) {
        capabilities += capabilityNameOf(types[i]);
        if (++i < types.length)
            capabilities += "&";
    }
    types = BitUtils.unpackBits(mUnwantedNetworkCapabilities);
    String unwantedCapabilities = (types.length > 0 ? " UnwantedCapabilities: " : "");
    unwantedCapabilities += capabilityNamesOf(types);
    String upBand = ((mLinkUpBandwidthKbps > 0) ? " LinkUpBandwidth>=" + mLinkUpBandwidthKbps + "Kbps" : "");
    String dnBand = ((mLinkDownBandwidthKbps > 0) ? " LinkDnBandwidth>=" + mLinkDownBandwidthKbps + "Kbps" : "");
    String specifier = (mNetworkSpecifier == null ? "" : " Specifier: <" + mNetworkSpecifier + ">");
    String signalStrength = (hasSignalStrength() ? " SignalStrength: " + mSignalStrength : "");
    String uids = (null != mUids ? " Uids: <" + mUids + ">" : "");
    String establishingAppUid = " EstablishingAppUid: " + mEstablishingVpnAppUid;
    return "[" + transports + capabilities + upBand + dnBand + specifier + signalStrength + uids + establishingAppUid + unwantedCapabilities + "]";
}
#method_after
@Override
public String toString() {
    // TODO: enumerate bits for transports and capabilities instead of creating arrays.
    // TODO: use a StringBuilder instead of string concatenation.
    int[] types = getTransportTypes();
    String transports = (types.length > 0) ? " Transports: " + transportNamesOf(types) : "";
    types = getCapabilities();
    String capabilities = (types.length > 0 ? " Capabilities: " : "");
    for (int i = 0; i < types.length; ) {
        capabilities += capabilityNameOf(types[i]);
        if (++i < types.length)
            capabilities += "&";
    }
    String upBand = ((mLinkUpBandwidthKbps > 0) ? " LinkUpBandwidth>=" + mLinkUpBandwidthKbps + "Kbps" : "");
    String dnBand = ((mLinkDownBandwidthKbps > 0) ? " LinkDnBandwidth>=" + mLinkDownBandwidthKbps + "Kbps" : "");
    String specifier = (mNetworkSpecifier == null ? "" : " Specifier: <" + mNetworkSpecifier + ">");
    String signalStrength = (hasSignalStrength() ? " SignalStrength: " + mSignalStrength : "");
    String uids = (null != mUids ? " Uids: <" + mUids + ">" : "");
    String establishingAppUid = " EstablishingAppUid: " + mEstablishingVpnAppUid;
    return "[" + transports + capabilities + upBand + dnBand + specifier + signalStrength + uids + establishingAppUid + "]";
}
#end_block

#method_before
public static String capabilityNameOf(@NetCapability int capability) {
    switch(capability) {
        case NET_CAPABILITY_MMS:
            return "MMS";
        case NET_CAPABILITY_SUPL:
            return "SUPL";
        case NET_CAPABILITY_DUN:
            return "DUN";
        case NET_CAPABILITY_FOTA:
            return "FOTA";
        case NET_CAPABILITY_IMS:
            return "IMS";
        case NET_CAPABILITY_CBS:
            return "CBS";
        case NET_CAPABILITY_WIFI_P2P:
            return "WIFI_P2P";
        case NET_CAPABILITY_IA:
            return "IA";
        case NET_CAPABILITY_RCS:
            return "RCS";
        case NET_CAPABILITY_XCAP:
            return "XCAP";
        case NET_CAPABILITY_EIMS:
            return "EIMS";
        case NET_CAPABILITY_NOT_METERED:
            return "NOT_METERED";
        case NET_CAPABILITY_INTERNET:
            return "INTERNET";
        case NET_CAPABILITY_NOT_RESTRICTED:
            return "NOT_RESTRICTED";
        case NET_CAPABILITY_TRUSTED:
            return "TRUSTED";
        case NET_CAPABILITY_NOT_VPN:
            return "NOT_VPN";
        case NET_CAPABILITY_VALIDATED:
            return "VALIDATED";
        case NET_CAPABILITY_CAPTIVE_PORTAL:
            return "CAPTIVE_PORTAL";
        case NET_CAPABILITY_NOT_ROAMING:
            return "NOT_ROAMING";
        case NET_CAPABILITY_FOREGROUND:
            return "FOREGROUND";
        case NET_CAPABILITY_NOT_CONGESTED:
            return "NOT_CONGESTED";
        case NET_CAPABILITY_OEM_PAID:
            return "OEM_PAID";
        default:
            return Integer.toString(capability);
    }
}
#method_after
public static String capabilityNameOf(@NetCapability int capability) {
    switch(capability) {
        case NET_CAPABILITY_MMS:
            return "MMS";
        case NET_CAPABILITY_SUPL:
            return "SUPL";
        case NET_CAPABILITY_DUN:
            return "DUN";
        case NET_CAPABILITY_FOTA:
            return "FOTA";
        case NET_CAPABILITY_IMS:
            return "IMS";
        case NET_CAPABILITY_CBS:
            return "CBS";
        case NET_CAPABILITY_WIFI_P2P:
            return "WIFI_P2P";
        case NET_CAPABILITY_IA:
            return "IA";
        case NET_CAPABILITY_RCS:
            return "RCS";
        case NET_CAPABILITY_XCAP:
            return "XCAP";
        case NET_CAPABILITY_EIMS:
            return "EIMS";
        case NET_CAPABILITY_NOT_METERED:
            return "NOT_METERED";
        case NET_CAPABILITY_INTERNET:
            return "INTERNET";
        case NET_CAPABILITY_NOT_RESTRICTED:
            return "NOT_RESTRICTED";
        case NET_CAPABILITY_TRUSTED:
            return "TRUSTED";
        case NET_CAPABILITY_NOT_VPN:
            return "NOT_VPN";
        case NET_CAPABILITY_VALIDATED:
            return "VALIDATED";
        case NET_CAPABILITY_CAPTIVE_PORTAL:
            return "CAPTIVE_PORTAL";
        case NET_CAPABILITY_NOT_ROAMING:
            return "NOT_ROAMING";
        case NET_CAPABILITY_FOREGROUND:
            return "FOREGROUND";
        case NET_CAPABILITY_NOT_CONGESTED:
            return "NOT_CONGESTED";
        case NET_CAPABILITY_NOT_SUSPENDED:
            return "NOT_SUSPENDED";
        case NET_CAPABILITY_OEM_PAID:
            return "OEM_PAID";
        default:
            return Integer.toString(capability);
    }
}
#end_block

#method_before
@Test
public void testOemPaid() {
    NetworkCapabilities nc = new NetworkCapabilities();
    nc.addCapability(NET_CAPABILITY_INTERNET);
    NetworkCapabilities request = new NetworkCapabilities();
    // Network has Internet capability, but we do not explicitly ask for Internet in the
    // request and network capabilities should be satisfied.
    assertTrue(request.satisfiedByNetworkCapabilities(nc));
    // Now we adding capability that must be explicitly specified in the request.
    nc.addCapability(NET_CAPABILITY_OEM_PAID);
    // OEM_PAID wasn't requested
    assertFalse(request.satisfiedByNetworkCapabilities(nc));
    // Now explicitly requesting it.
    request.addCapability(NET_CAPABILITY_OEM_PAID);
    assertTrue(request.satisfiedByNetworkCapabilities(nc));
}
#method_after
@Test
public void testOemPaid() {
    NetworkCapabilities nc = new NetworkCapabilities();
    nc.maybeMarkCapabilitiesRestricted();
    assertFalse(nc.hasCapability(NET_CAPABILITY_OEM_PAID));
    assertTrue(nc.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    nc.addCapability(NET_CAPABILITY_OEM_PAID);
    nc.maybeMarkCapabilitiesRestricted();
    assertTrue(nc.hasCapability(NET_CAPABILITY_OEM_PAID));
    assertFalse(nc.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
}
#end_block

#method_before
private boolean shouldNumberBePlacedOnIms(boolean isEmergency, String number) {
    int processCallResult;
    try {
        if (mImsManager != null) {
            processCallResult = mImsManager.shouldProcessCall(isEmergency, new String[] { number });
            Rlog.i(LOG_TAG, "shouldProcessCall: number: " + Rlog.pii(LOG_TAG, number) + ", result: " + processCallResult);
        } else {
            Rlog.w(LOG_TAG, "ImsManager unavailable, shouldProcessCall returning false.");
            return false;
        }
    } catch (ImsException e) {
        Rlog.w(LOG_TAG, "ImsService unavailable, shouldProcessCall returning false.");
        return false;
    }
    // The ImsService wishes to place the call over IMS.
    if (processCallResult == MmTelFeature.PROCESS_CALL_IMS) {
        return true;
    } else if (processCallResult == MmTelFeature.PROCESS_CALL_CSFB) {
        Rlog.w(LOG_TAG, "shouldProcessCall: place over CSFB instead.");
        return false;
    } else {
        Rlog.w(LOG_TAG, "shouldProcessCall returned unknown result.");
        return false;
    }
}
#method_after
private boolean shouldNumberBePlacedOnIms(boolean isEmergency, String number) {
    int processCallResult;
    try {
        if (mImsManager != null) {
            processCallResult = mImsManager.shouldProcessCall(isEmergency, new String[] { number });
            Rlog.i(LOG_TAG, "shouldProcessCall: number: " + Rlog.pii(LOG_TAG, number) + ", result: " + processCallResult);
        } else {
            Rlog.w(LOG_TAG, "ImsManager unavailable, shouldProcessCall returning false.");
            return false;
        }
    } catch (ImsException e) {
        Rlog.w(LOG_TAG, "ImsService unavailable, shouldProcessCall returning false.");
        return false;
    }
    switch(processCallResult) {
        case MmTelFeature.PROCESS_CALL_IMS:
            {
                // The ImsService wishes to place the call over IMS
                return true;
            }
        case MmTelFeature.PROCESS_CALL_CSFB:
            {
                Rlog.i(LOG_TAG, "shouldProcessCall: place over CSFB instead.");
                return false;
            }
        default:
            {
                Rlog.w(LOG_TAG, "shouldProcessCall returned unknown result.");
                return false;
            }
    }
}
#end_block

#method_before
private Pair<Uri, Boolean> insertSingleRow(Uri url, ContentValues initialValues) {
    Uri result = null;
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    checkPermission();
    syncBearerBitmaskAndNetworkTypeBitmask(initialValues);
    boolean notify = false;
    SQLiteDatabase db = getWritableDatabase();
    int match = s_urlMatcher.match(url);
    switch(match) {
        case URL_TELEPHONY_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_TELEPHONY:
            {
                ContentValues values;
                if (initialValues != null) {
                    values = new ContentValues(initialValues);
                } else {
                    values = new ContentValues();
                }
                values.put(SUBSCRIPTION_ID, subId);
                values = DatabaseHelper.setDefaultValue(values);
                if (!values.containsKey(EDITED)) {
                    values.put(EDITED, CARRIER_EDITED);
                }
                // Owned_by should be others if inserted via general uri.
                values.put(OWNED_BY, OWNED_BY_OTHERS);
                Pair<Uri, Boolean> ret = insertRowWithValue(values);
                result = ret.first;
                notify = ret.second;
                break;
            }
        case URL_CURRENT_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in the query
            }
        case URL_CURRENT:
            {
                // zero out the previous operator
                db.update(CARRIERS_TABLE, s_currentNullMap, CURRENT + "!=0", null);
                String numeric = initialValues.getAsString(NUMERIC);
                int updated = db.update(CARRIERS_TABLE, s_currentSetMap, NUMERIC + " = '" + numeric + "'", null);
                if (updated > 0) {
                    if (VDBG)
                        log("Setting numeric '" + numeric + "' to be the current operator");
                } else {
                    loge("Failed setting numeric '" + numeric + "' to the current operator");
                }
                break;
            }
        case URL_PREFERAPN_USING_SUBID:
        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_PREFERAPN:
        case URL_PREFERAPN_NO_UPDATE:
            {
                if (initialValues != null) {
                    if (initialValues.containsKey(COLUMN_APN_ID)) {
                        setPreferredApnId(initialValues.getAsLong(COLUMN_APN_ID), subId, true);
                    }
                }
                break;
            }
        case URL_DPC:
            {
                ensureCallingFromSystemOrPhoneUid("URL_DPC called from non SYSTEM_UID.");
                ContentValues values;
                if (initialValues != null) {
                    values = new ContentValues(initialValues);
                } else {
                    values = new ContentValues();
                }
                // Owned_by should be DPC if inserted via URL_DPC.
                values.put(OWNED_BY, OWNED_BY_DPC);
                // DPC records should not be user editable.
                values.put(USER_EDITABLE, false);
                long rowID = db.insertWithOnConflict(CARRIERS_TABLE, null, values, SQLiteDatabase.CONFLICT_IGNORE);
                if (rowID >= 0) {
                    result = ContentUris.withAppendedId(CONTENT_URI, rowID);
                    notify = true;
                }
                if (VDBG)
                    log("insert: inserted " + values.toString() + " rowID = " + rowID);
                break;
            }
        case URL_SIMINFO:
            {
                long id = db.insert(SIMINFO_TABLE, null, initialValues);
                result = ContentUris.withAppendedId(SubscriptionManager.CONTENT_URI, id);
                break;
            }
    }
    return Pair.create(result, notify);
}
#method_after
private Pair<Uri, Boolean> insertSingleRow(Uri url, ContentValues initialValues) {
    Uri result = null;
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    checkPermission();
    syncBearerBitmaskAndNetworkTypeBitmask(initialValues);
    boolean notify = false;
    SQLiteDatabase db = getWritableDatabase();
    int match = s_urlMatcher.match(url);
    switch(match) {
        case URL_TELEPHONY_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_TELEPHONY:
            {
                ContentValues values;
                if (initialValues != null) {
                    values = new ContentValues(initialValues);
                } else {
                    values = new ContentValues();
                }
                values.put(SUBSCRIPTION_ID, subId);
                values = DatabaseHelper.setDefaultValue(values);
                if (!values.containsKey(EDITED)) {
                    values.put(EDITED, CARRIER_EDITED);
                }
                // Owned_by should be others if inserted via general uri.
                values.put(OWNED_BY, OWNED_BY_OTHERS);
                Pair<Uri, Boolean> ret = insertRowWithValue(values);
                result = ret.first;
                notify = ret.second;
                break;
            }
        case URL_CURRENT_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in the query
            }
        case URL_CURRENT:
            {
                // zero out the previous operator
                db.update(CARRIERS_TABLE, s_currentNullMap, CURRENT + "!=0", null);
                String numeric = initialValues.getAsString(NUMERIC);
                int updated = db.update(CARRIERS_TABLE, s_currentSetMap, NUMERIC + " = '" + numeric + "'", null);
                if (updated > 0) {
                    if (VDBG)
                        log("Setting numeric '" + numeric + "' to be the current operator");
                } else {
                    loge("Failed setting numeric '" + numeric + "' to the current operator");
                }
                break;
            }
        case URL_PREFERAPN_USING_SUBID:
        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_PREFERAPN:
        case URL_PREFERAPN_NO_UPDATE:
            {
                if (initialValues != null) {
                    if (initialValues.containsKey(COLUMN_APN_ID)) {
                        setPreferredApnId(initialValues.getAsLong(COLUMN_APN_ID), subId, true);
                    }
                }
                break;
            }
        case URL_DPC:
            {
                ensureCallingFromSystemOrPhoneUid("URL_DPC called from non SYSTEM_UID.");
                ContentValues values;
                if (initialValues != null) {
                    values = new ContentValues(initialValues);
                } else {
                    values = new ContentValues();
                }
                // Owned_by should be DPC if inserted via URL_DPC.
                values.put(OWNED_BY, OWNED_BY_DPC);
                // DPC records should not be user editable.
                values.put(USER_EDITABLE, false);
                final long rowID = db.insertWithOnConflict(CARRIERS_TABLE, null, values, SQLiteDatabase.CONFLICT_IGNORE);
                if (rowID >= 0) {
                    result = ContentUris.withAppendedId(CONTENT_URI, rowID);
                    notify = true;
                }
                if (VDBG)
                    log("insert: inserted " + values.toString() + " rowID = " + rowID);
                break;
            }
        case URL_SIMINFO:
            {
                long id = db.insert(SIMINFO_TABLE, null, initialValues);
                result = ContentUris.withAppendedId(SubscriptionManager.CONTENT_URI, id);
                break;
            }
    }
    return Pair.create(result, notify);
}
#end_block

#method_before
private int parseIdFromInsertedUri(Uri uri) throws NumberFormatException {
    int id = -1;
    if (uri != null) {
        id = Integer.parseInt(uri.getLastPathSegment());
    }
    return id;
}
#method_after
private int parseIdFromInsertedUri(Uri uri) throws NumberFormatException {
    return (uri != null) ? Integer.parseInt(uri.getLastPathSegment()) : -1;
}
#end_block

#method_before
@Test
@SmallTest
public void testEnforceManagedUri() {
    mTelephonyProviderTestable.fakeCallingUid(Process.SYSTEM_UID);
    final int current = 1;
    final String numeric = "123456789";
    // Insert DPC record.
    final String dpcRecordApn = "exampleApnNameDPC";
    final String dpcRecordName = "exampleNameDPC";
    int dpcRecordId = insertApnRecord(URI_DPC, dpcRecordApn, dpcRecordName, current, numeric);
    // Insert non-DPC record.
    final String othersRecordApn = "exampleApnNameOTHERS";
    final String othersRecordName = "exampleNameDPOTHERS";
    int othersRecordId = insertApnRecord(URI_TELEPHONY, othersRecordApn, othersRecordName, current, numeric);
    // Set enforced = false.
    ContentValues enforceManagedValue = new ContentValues();
    enforceManagedValue.put(ENFORCED_KEY, false);
    Log.d(TAG, "testEnforceManagedUri Updating enforced = false: " + enforceManagedValue);
    mContentResolver.update(URI_ENFORCE_MANAGED, enforceManagedValue, "", new String[] {});
    // Verify that enforced is set to false in TelephonyProvider.
    Cursor enforceCursor = mContentResolver.query(URI_ENFORCE_MANAGED, null, null, null, null);
    assertNotNull(enforceCursor);
    assertEquals(1, enforceCursor.getCount());
    enforceCursor.moveToFirst();
    assertEquals(0, enforceCursor.getInt(0));
    // Verify URL_FILTERED query only returns non-DPC record.
    final String[] testProjection = { Carriers._ID, Carriers.OWNED_BY };
    final String selection = Carriers.NUMERIC + "=?";
    String[] selectionArgs = { numeric };
    Cursor cursorNotEnforced = mContentResolver.query(URI_FILTERED, testProjection, selection, selectionArgs, null);
    assertNotNull(cursorNotEnforced);
    assertEquals(1, cursorNotEnforced.getCount());
    cursorNotEnforced.moveToFirst();
    assertEquals(othersRecordId, cursorNotEnforced.getInt(0));
    assertEquals(Carriers.OWNED_BY_OTHERS, cursorNotEnforced.getInt(1));
    // Verify that URL_FILTERED_ID cannot get DPC record.
    Cursor cursorNotEnforcedDpc = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(dpcRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedDpc);
    assertTrue(cursorNotEnforcedDpc.getCount() == 0);
    // Verify that URL_FILTERED_ID can get non-DPC record.
    Cursor cursorNotEnforcedOthers = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(othersRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedOthers);
    assertTrue(cursorNotEnforcedOthers.getCount() == 1);
    // Set enforced = true.
    enforceManagedValue.put(ENFORCED_KEY, true);
    Log.d(TAG, "testEnforceManagedUri Updating enforced = true: " + enforceManagedValue);
    mContentResolver.update(URI_ENFORCE_MANAGED, enforceManagedValue, "", new String[] {});
    // Verify that enforced is set to true in TelephonyProvider.
    enforceCursor = mContentResolver.query(URI_ENFORCE_MANAGED, null, null, null, null);
    assertNotNull(enforceCursor);
    assertEquals(1, enforceCursor.getCount());
    enforceCursor.moveToFirst();
    assertEquals(1, enforceCursor.getInt(0));
    // Verify URL_FILTERED query only returns DPC record.
    Cursor cursorEnforced = mContentResolver.query(URI_FILTERED, testProjection, selection, selectionArgs, null);
    assertNotNull(cursorEnforced);
    assertEquals(1, cursorEnforced.getCount());
    cursorEnforced.moveToFirst();
    assertEquals(dpcRecordId, cursorEnforced.getInt(0));
    assertEquals(Carriers.OWNED_BY_DPC, cursorEnforced.getInt(1));
    // Verify that URL_FILTERED_ID can get DPC record.
    cursorNotEnforcedDpc = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(dpcRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedDpc);
    assertTrue(cursorNotEnforcedDpc.getCount() == 1);
    // Verify that URL_FILTERED_ID cannot get non-DPC record.
    cursorNotEnforcedOthers = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(othersRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedOthers);
    assertTrue(cursorNotEnforcedOthers.getCount() == 0);
    // Delete testing records.
    int numRowsDeleted = mContentResolver.delete(URI_TELEPHONY, selection, selectionArgs);
    assertEquals(1, numRowsDeleted);
    numRowsDeleted = mContentResolver.delete(Uri.parse(URI_DPC + "/" + dpcRecordId), "", new String[] {});
    assertEquals(1, numRowsDeleted);
}
#method_after
@Test
@SmallTest
public void testEnforceManagedUri() {
    mTelephonyProviderTestable.fakeCallingUid(Process.SYSTEM_UID);
    final int current = 1;
    final String numeric = "123456789";
    // Insert DPC record.
    final String dpcRecordApn = "exampleApnNameDPC";
    final String dpcRecordName = "exampleNameDPC";
    final int dpcRecordId = insertApnRecord(URI_DPC, dpcRecordApn, dpcRecordName, current, numeric);
    // Insert non-DPC record.
    final String othersRecordApn = "exampleApnNameOTHERS";
    final String othersRecordName = "exampleNameDPOTHERS";
    final int othersRecordId = insertApnRecord(URI_TELEPHONY, othersRecordApn, othersRecordName, current, numeric);
    // Set enforced = false.
    ContentValues enforceManagedValue = new ContentValues();
    enforceManagedValue.put(ENFORCED_KEY, false);
    Log.d(TAG, "testEnforceManagedUri Updating enforced = false: " + enforceManagedValue);
    mContentResolver.update(URI_ENFORCE_MANAGED, enforceManagedValue, "", new String[] {});
    // Verify that enforced is set to false in TelephonyProvider.
    Cursor enforceCursor = mContentResolver.query(URI_ENFORCE_MANAGED, null, null, null, null);
    assertNotNull(enforceCursor);
    assertEquals(1, enforceCursor.getCount());
    enforceCursor.moveToFirst();
    assertEquals(0, enforceCursor.getInt(0));
    // Verify URL_FILTERED query only returns non-DPC record.
    final String[] testProjection = { Carriers._ID, Carriers.OWNED_BY };
    final String selection = Carriers.NUMERIC + "=?";
    final String[] selectionArgs = { numeric };
    final Cursor cursorNotEnforced = mContentResolver.query(URI_FILTERED, testProjection, selection, selectionArgs, null);
    assertNotNull(cursorNotEnforced);
    assertEquals(1, cursorNotEnforced.getCount());
    cursorNotEnforced.moveToFirst();
    assertEquals(othersRecordId, cursorNotEnforced.getInt(0));
    assertEquals(Carriers.OWNED_BY_OTHERS, cursorNotEnforced.getInt(1));
    // Verify that URL_FILTERED_ID cannot get DPC record.
    Cursor cursorNotEnforcedDpc = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(dpcRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedDpc);
    assertTrue(cursorNotEnforcedDpc.getCount() == 0);
    // Verify that URL_FILTERED_ID can get non-DPC record.
    Cursor cursorNotEnforcedOthers = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(othersRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedOthers);
    assertTrue(cursorNotEnforcedOthers.getCount() == 1);
    // Set enforced = true.
    enforceManagedValue.put(ENFORCED_KEY, true);
    Log.d(TAG, "testEnforceManagedUri Updating enforced = true: " + enforceManagedValue);
    mContentResolver.update(URI_ENFORCE_MANAGED, enforceManagedValue, "", new String[] {});
    // Verify that enforced is set to true in TelephonyProvider.
    enforceCursor = mContentResolver.query(URI_ENFORCE_MANAGED, null, null, null, null);
    assertNotNull(enforceCursor);
    assertEquals(1, enforceCursor.getCount());
    enforceCursor.moveToFirst();
    assertEquals(1, enforceCursor.getInt(0));
    // Verify URL_FILTERED query only returns DPC record.
    final Cursor cursorEnforced = mContentResolver.query(URI_FILTERED, testProjection, selection, selectionArgs, null);
    assertNotNull(cursorEnforced);
    assertEquals(1, cursorEnforced.getCount());
    cursorEnforced.moveToFirst();
    assertEquals(dpcRecordId, cursorEnforced.getInt(0));
    assertEquals(Carriers.OWNED_BY_DPC, cursorEnforced.getInt(1));
    // Verify that URL_FILTERED_ID can get DPC record.
    cursorNotEnforcedDpc = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(dpcRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedDpc);
    assertTrue(cursorNotEnforcedDpc.getCount() == 1);
    // Verify that URL_FILTERED_ID cannot get non-DPC record.
    cursorNotEnforcedOthers = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(othersRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedOthers);
    assertTrue(cursorNotEnforcedOthers.getCount() == 0);
    // Delete testing records.
    int numRowsDeleted = mContentResolver.delete(URI_TELEPHONY, selection, selectionArgs);
    assertEquals(1, numRowsDeleted);
    numRowsDeleted = mContentResolver.delete(ContentUris.withAppendedId(URI_DPC, dpcRecordId), "", null);
    assertEquals(1, numRowsDeleted);
}
#end_block

#method_before
@Test
@SmallTest
public /**
 * Test URL_TELEPHONY cannot insert, query, update or delete DPC records.
 */
void testTelephonyUriDpcRecordAccessControl() {
    mTelephonyProviderTestable.fakeCallingUid(Process.SYSTEM_UID);
    final int current = 1;
    final String numeric = "123456789";
    // Insert DPC record.
    final String dpcRecordApn = "exampleApnNameDPC";
    final String dpcRecordName = "exampleNameDPC";
    int dpcRecordId = insertApnRecord(URI_DPC, dpcRecordApn, dpcRecordName, current, numeric);
    // Insert non-DPC record.
    final String othersRecordApn = "exampleApnNameOTHERS";
    final String othersRecordName = "exampleNameDPOTHERS";
    int othersRecordId = insertApnRecord(URI_TELEPHONY, othersRecordApn, othersRecordName, current, numeric);
    // Verify URL_TELEPHONY query only returns non-DPC record.
    final String[] testProjection = { Carriers._ID, Carriers.APN, Carriers.NAME, Carriers.CURRENT, Carriers.OWNED_BY };
    final String selection = Carriers.NUMERIC + "=?";
    String[] selectionArgs = { numeric };
    Cursor cursorTelephony = mContentResolver.query(URI_TELEPHONY, testProjection, selection, selectionArgs, null);
    assertNotNull(cursorTelephony);
    assertEquals(1, cursorTelephony.getCount());
    cursorTelephony.moveToFirst();
    assertEquals(othersRecordId, cursorTelephony.getInt(0));
    assertEquals(othersRecordApn, cursorTelephony.getString(1));
    assertEquals(othersRecordName, cursorTelephony.getString(2));
    assertEquals(current, cursorTelephony.getInt(3));
    assertEquals(Carriers.OWNED_BY_OTHERS, cursorTelephony.getInt(4));
    // Verify URI_TELEPHONY updates only non-DPC records.
    ContentValues contentValuesOthersUpdate = new ContentValues();
    final String othersRecordUpdatedApn = "exampleApnNameOTHERSUpdated";
    final String othersRecordUpdatedName = "exampleNameOTHERSpdated";
    contentValuesOthersUpdate.put(Carriers.APN, othersRecordUpdatedApn);
    contentValuesOthersUpdate.put(Carriers.NAME, othersRecordUpdatedName);
    final int updateCount = mContentResolver.update(URI_TELEPHONY, contentValuesOthersUpdate, selection, selectionArgs);
    assertEquals(1, updateCount);
    Cursor cursorNonDPCUpdate = mContentResolver.query(URI_TELEPHONY, testProjection, selection, selectionArgs, null);
    Cursor cursorDPCUpdate = mContentResolver.query(URI_DPC, testProjection, selection, selectionArgs, null);
    // Verify that non-DPC records are updated.
    assertNotNull(cursorNonDPCUpdate);
    assertEquals(1, cursorNonDPCUpdate.getCount());
    cursorNonDPCUpdate.moveToFirst();
    assertEquals(othersRecordId, cursorNonDPCUpdate.getInt(0));
    assertEquals(othersRecordUpdatedApn, cursorNonDPCUpdate.getString(1));
    assertEquals(othersRecordUpdatedName, cursorNonDPCUpdate.getString(2));
    // Verify that DPC records are not updated.
    assertNotNull(cursorDPCUpdate);
    assertEquals(1, cursorDPCUpdate.getCount());
    cursorDPCUpdate.moveToFirst();
    assertEquals(dpcRecordId, cursorDPCUpdate.getInt(0));
    assertEquals(dpcRecordApn, cursorDPCUpdate.getString(1));
    assertEquals(dpcRecordName, cursorDPCUpdate.getString(2));
    // Verify URI_TELEPHONY deletes only non-DPC records.
    int numRowsDeleted = mContentResolver.delete(URI_TELEPHONY, selection, selectionArgs);
    assertEquals(1, numRowsDeleted);
    Cursor cursorTelephonyRemaining = mContentResolver.query(URI_TELEPHONY, testProjection, selection, selectionArgs, null);
    assertNotNull(cursorTelephonyRemaining);
    assertEquals(0, cursorTelephonyRemaining.getCount());
    Cursor cursorDPCDeleted = mContentResolver.query(URI_DPC, testProjection, selection, selectionArgs, null);
    assertNotNull(cursorDPCDeleted);
    assertEquals(1, cursorDPCDeleted.getCount());
    // Delete remaining test records.
    numRowsDeleted = mContentResolver.delete(Uri.parse(URI_DPC + "/" + dpcRecordId), "", new String[] {});
    assertEquals(1, numRowsDeleted);
}
#method_after
@Test
@SmallTest
public /**
 * Test URL_TELEPHONY cannot insert, query, update or delete DPC records.
 */
void testTelephonyUriDpcRecordAccessControl() {
    mTelephonyProviderTestable.fakeCallingUid(Process.SYSTEM_UID);
    final int current = 1;
    final String numeric = "123456789";
    final String selection = Carriers.NUMERIC + "=?";
    final String[] selectionArgs = { numeric };
    // Insert DPC record.
    final String dpcRecordApn = "exampleApnNameDPC";
    final String dpcRecordName = "exampleNameDPC";
    final int dpcRecordId = insertApnRecord(URI_DPC, dpcRecordApn, dpcRecordName, current, numeric);
    // Insert non-DPC record.
    final String othersRecordApn = "exampleApnNameOTHERS";
    final String othersRecordName = "exampleNameDPOTHERS";
    final int othersRecordId = insertApnRecord(URI_TELEPHONY, othersRecordApn, othersRecordName, current, numeric);
    // Verify URL_TELEPHONY query only returns non-DPC record.
    final Cursor cursorTelephony = queryFullTestApnRecord(URI_TELEPHONY, numeric);
    assertNotNull(cursorTelephony);
    assertEquals(1, cursorTelephony.getCount());
    cursorTelephony.moveToFirst();
    assertApnEquals(cursorTelephony, othersRecordId, othersRecordApn, othersRecordName, current, Carriers.OWNED_BY_OTHERS);
    // Verify URI_TELEPHONY updates only non-DPC records.
    ContentValues contentValuesOthersUpdate = new ContentValues();
    final String othersRecordUpdatedApn = "exampleApnNameOTHERSUpdated";
    final String othersRecordUpdatedName = "exampleNameOTHERSpdated";
    contentValuesOthersUpdate.put(Carriers.APN, othersRecordUpdatedApn);
    contentValuesOthersUpdate.put(Carriers.NAME, othersRecordUpdatedName);
    final int updateCount = mContentResolver.update(URI_TELEPHONY, contentValuesOthersUpdate, selection, selectionArgs);
    assertEquals(1, updateCount);
    final Cursor cursorNonDPCUpdate = queryFullTestApnRecord(URI_TELEPHONY, numeric);
    final Cursor cursorDPCUpdate = queryFullTestApnRecord(URI_DPC, numeric);
    // Verify that non-DPC records are updated.
    assertNotNull(cursorNonDPCUpdate);
    assertEquals(1, cursorNonDPCUpdate.getCount());
    cursorNonDPCUpdate.moveToFirst();
    assertApnEquals(cursorNonDPCUpdate, othersRecordId, othersRecordUpdatedApn, othersRecordUpdatedName);
    // Verify that DPC records are not updated.
    assertNotNull(cursorDPCUpdate);
    assertEquals(1, cursorDPCUpdate.getCount());
    cursorDPCUpdate.moveToFirst();
    assertApnEquals(cursorDPCUpdate, dpcRecordId, dpcRecordApn, dpcRecordName);
    // Verify URI_TELEPHONY deletes only non-DPC records.
    int numRowsDeleted = mContentResolver.delete(URI_TELEPHONY, selection, selectionArgs);
    assertEquals(1, numRowsDeleted);
    final Cursor cursorTelephonyRemaining = queryFullTestApnRecord(URI_TELEPHONY, numeric);
    assertNotNull(cursorTelephonyRemaining);
    assertEquals(0, cursorTelephonyRemaining.getCount());
    final Cursor cursorDPCDeleted = queryFullTestApnRecord(URI_DPC, numeric);
    assertNotNull(cursorDPCDeleted);
    assertEquals(1, cursorDPCDeleted.getCount());
    // Delete remaining test records.
    numRowsDeleted = mContentResolver.delete(ContentUris.withAppendedId(URI_DPC, dpcRecordId), "", null);
    assertEquals(1, numRowsDeleted);
}
#end_block

#method_before
@Test
@SmallTest
public void testDpcUri() {
    mTelephonyProviderTestable.fakeCallingUid(Process.SYSTEM_UID);
    final int current = 1;
    final String numeric = "123456789";
    // Insert DPC record.
    final String dpcRecordApn = "exampleApnNameDPC";
    final String dpcRecordName = "exampleNameDPC";
    int dpcRecordId = insertApnRecord(URI_DPC, dpcRecordApn, dpcRecordName, current, numeric);
    // Insert non-DPC record.
    final String othersRecordApn = "exampleApnNameOTHERS";
    final String othersRecordName = "exampleNameDPOTHERS";
    int othersRecordId = insertApnRecord(URI_TELEPHONY, othersRecordApn, othersRecordName, current, numeric);
    Log.d(TAG, "testDPCIdUri Id for inserted DPC record: " + dpcRecordId);
    Log.d(TAG, "testDPCIdUri Id for inserted non-DPC record: " + othersRecordId);
    // Verify that URI_DPC query only returns DPC records.
    // The columns to get in table.
    final String[] testProjection = { Carriers._ID, Carriers.APN, Carriers.NAME, Carriers.CURRENT, Carriers.OWNED_BY };
    final String selection = Carriers.NUMERIC + "=?";
    String[] selectionArgs = { numeric };
    Cursor cursorDPC = mContentResolver.query(URI_DPC, testProjection, selection, selectionArgs, null);
    // Verify that DPC query returns only DPC records.
    assertNotNull(cursorDPC);
    assertEquals(1, cursorDPC.getCount());
    cursorDPC.moveToFirst();
    assertEquals(dpcRecordId, cursorDPC.getInt(0));
    assertEquals(dpcRecordApn, cursorDPC.getString(1));
    assertEquals(dpcRecordName, cursorDPC.getString(2));
    assertEquals(current, cursorDPC.getInt(3));
    assertEquals(Carriers.OWNED_BY_DPC, cursorDPC.getInt(4));
    // Verify that URI_DPC_ID updates only DPC records.
    ContentValues contentValuesDpcUpdate = new ContentValues();
    final String dpcRecordUpdatedApn = "exampleApnNameDPCUpdated";
    final String dpcRecordUpdatedName = "exampleNameDPCUpdated";
    contentValuesDpcUpdate.put(Carriers.APN, dpcRecordUpdatedApn);
    contentValuesDpcUpdate.put(Carriers.NAME, dpcRecordUpdatedName);
    final int updateCount = mContentResolver.update(Uri.parse(URI_DPC + "/" + dpcRecordId), contentValuesDpcUpdate, null, null);
    assertEquals(1, updateCount);
    Cursor cursorNonDPCUpdate = mContentResolver.query(URI_TELEPHONY, testProjection, selection, selectionArgs, null);
    Cursor cursorDPCUpdate = mContentResolver.query(URI_DPC, testProjection, selection, selectionArgs, null);
    // Verify that non-DPC records are not updated.
    assertNotNull(cursorNonDPCUpdate);
    assertEquals(1, cursorNonDPCUpdate.getCount());
    cursorNonDPCUpdate.moveToFirst();
    assertEquals(othersRecordId, cursorNonDPCUpdate.getInt(0));
    assertEquals(othersRecordApn, cursorNonDPCUpdate.getString(1));
    assertEquals(othersRecordName, cursorNonDPCUpdate.getString(2));
    // Verify that DPC records are updated.
    assertNotNull(cursorDPCUpdate);
    assertEquals(1, cursorDPCUpdate.getCount());
    cursorDPCUpdate.moveToFirst();
    assertEquals(dpcRecordId, cursorDPCUpdate.getInt(0));
    assertEquals(dpcRecordUpdatedApn, cursorDPCUpdate.getString(1));
    assertEquals(dpcRecordUpdatedName, cursorDPCUpdate.getString(2));
    // Test URI_DPC_ID deletes only DPC records.
    int numRowsDeleted = mContentResolver.delete(Uri.parse(URI_DPC + "/" + dpcRecordId), null, new String[] {});
    assertEquals(1, numRowsDeleted);
    numRowsDeleted = mContentResolver.delete(Uri.parse(URI_DPC + "/" + dpcRecordId), null, new String[] {});
    assertEquals(0, numRowsDeleted);
    // Delete remaining test records.
    numRowsDeleted = mContentResolver.delete(Uri.parse(URI_TELEPHONY + "/" + othersRecordId), null, new String[] {});
    assertEquals(1, numRowsDeleted);
}
#method_after
@Test
@SmallTest
public void testDpcUri() {
    int dpcRecordId = 0, othersRecordId = 0;
    try {
        mTelephonyProviderTestable.fakeCallingUid(Process.SYSTEM_UID);
        final int current = 1;
        final String numeric = "123456789";
        // Insert DPC record.
        final String dpcRecordApn = "exampleApnNameDPC";
        final String dpcRecordName = "exampleNameDPC";
        dpcRecordId = insertApnRecord(URI_DPC, dpcRecordApn, dpcRecordName, current, numeric);
        // Insert non-DPC record.
        final String othersRecordApn = "exampleApnNameOTHERS";
        final String othersRecordName = "exampleNameDPOTHERS";
        othersRecordId = insertApnRecord(URI_TELEPHONY, othersRecordApn, othersRecordName, current, numeric);
        Log.d(TAG, "testDPCIdUri Id for inserted DPC record: " + dpcRecordId);
        Log.d(TAG, "testDPCIdUri Id for inserted non-DPC record: " + othersRecordId);
        // Verify that URI_DPC query only returns DPC records.
        final Cursor cursorDPC = queryFullTestApnRecord(URI_DPC, numeric);
        assertNotNull(cursorDPC);
        assertEquals(1, cursorDPC.getCount());
        cursorDPC.moveToFirst();
        assertApnEquals(cursorDPC, dpcRecordId, dpcRecordApn, dpcRecordName, current, Carriers.OWNED_BY_DPC);
        // Verify that URI_DPC_ID updates only DPC records.
        ContentValues contentValuesDpcUpdate = new ContentValues();
        final String dpcRecordUpdatedApn = "exampleApnNameDPCUpdated";
        final String dpcRecordUpdatedName = "exampleNameDPCUpdated";
        contentValuesDpcUpdate.put(Carriers.APN, dpcRecordUpdatedApn);
        contentValuesDpcUpdate.put(Carriers.NAME, dpcRecordUpdatedName);
        final int updateCount = mContentResolver.update(ContentUris.withAppendedId(URI_DPC, dpcRecordId), contentValuesDpcUpdate, null, null);
        assertEquals(1, updateCount);
        final Cursor cursorNonDPCUpdate = queryFullTestApnRecord(URI_TELEPHONY, numeric);
        final Cursor cursorDPCUpdate = queryFullTestApnRecord(URI_DPC, numeric);
        // Verify that non-DPC records are not updated.
        assertNotNull(cursorNonDPCUpdate);
        assertEquals(1, cursorNonDPCUpdate.getCount());
        cursorNonDPCUpdate.moveToFirst();
        assertApnEquals(cursorNonDPCUpdate, othersRecordId, othersRecordApn, othersRecordName);
        // Verify that DPC records are updated.
        assertNotNull(cursorDPCUpdate);
        assertEquals(1, cursorDPCUpdate.getCount());
        cursorDPCUpdate.moveToFirst();
        assertApnEquals(cursorDPCUpdate, dpcRecordId, dpcRecordUpdatedApn, dpcRecordUpdatedName);
        // Test URI_DPC_ID deletes only DPC records.
        int numRowsDeleted = mContentResolver.delete(ContentUris.withAppendedId(URI_DPC, dpcRecordId), null, null);
        assertEquals(1, numRowsDeleted);
        numRowsDeleted = mContentResolver.delete(ContentUris.withAppendedId(URI_DPC, dpcRecordId), null, null);
        assertEquals(0, numRowsDeleted);
    } finally {
        // Delete remaining test records.
        int numRowsDeleted = mContentResolver.delete(ContentUris.withAppendedId(URI_TELEPHONY, othersRecordId), null, null);
        assertEquals(1, numRowsDeleted);
    }
}
#end_block

#method_before
@Test
@SmallTest
public void testDpcUriOnConflict() {
    mTelephonyProviderTestable.fakeCallingUid(Process.SYSTEM_UID);
    final int current = 1;
    final String numeric = "123456789";
    // Insert DPC record 1.
    final String dpcRecordApn1 = "exampleApnNameDPC";
    final String dpcRecordName = "exampleNameDPC";
    int dpcRecordId1 = insertApnRecord(URI_DPC, dpcRecordApn1, dpcRecordName, current, numeric);
    Log.d(TAG, "testDpcUriOnConflict Id for DPC record 1: " + dpcRecordId1);
    // Insert conflicting DPC record.
    final String dpcRecordNameConflict = "exampleNameDPCConflict";
    int dpcRecordIdConflict = insertApnRecord(URI_DPC, dpcRecordApn1, dpcRecordNameConflict, current, numeric);
    // Verity that conflicting DPC record is not inserted.
    assertEquals(-1, dpcRecordIdConflict);
    // The columns to get in table.
    final String[] testProjection = { Carriers._ID, Carriers.APN, Carriers.NAME, Carriers.CURRENT, Carriers.OWNED_BY };
    final String selection = Carriers.NUMERIC + "=?";
    String[] selectionArgs = { numeric };
    Cursor cursorDPC1 = mContentResolver.query(URI_DPC, testProjection, selection, selectionArgs, null);
    // Verify that APN 1 is not replaced or updated.
    assertNotNull(cursorDPC1);
    assertEquals(1, cursorDPC1.getCount());
    cursorDPC1.moveToFirst();
    assertEquals(dpcRecordId1, cursorDPC1.getInt(0));
    assertEquals(dpcRecordApn1, cursorDPC1.getString(1));
    assertEquals(dpcRecordName, cursorDPC1.getString(2));
    assertEquals(current, cursorDPC1.getInt(3));
    assertEquals(Carriers.OWNED_BY_DPC, cursorDPC1.getInt(4));
    // Insert DPC record 2.
    final String dpcRecordApn2 = "exampleApnNameDPC2";
    int dpcRecordId2 = insertApnRecord(URI_DPC, dpcRecordApn2, dpcRecordName, current, numeric);
    Log.d(TAG, "testDpcUriOnConflict Id for DPC record 2: " + dpcRecordId2);
    // Update conflicting DPC record.
    ContentValues contentValuesDpcUpdate = new ContentValues();
    contentValuesDpcUpdate.put(Carriers.APN, dpcRecordApn1);
    contentValuesDpcUpdate.put(Carriers.NAME, dpcRecordNameConflict);
    final int updateCount = mContentResolver.update(Uri.parse(URI_DPC + "/" + dpcRecordId2), contentValuesDpcUpdate, null, null);
    // Verify that database is not updated.
    assertEquals(0, updateCount);
    Cursor cursorDPC2 = mContentResolver.query(URI_DPC, testProjection, selection, selectionArgs, null);
    assertNotNull(cursorDPC2);
    assertEquals(2, cursorDPC2.getCount());
    cursorDPC2.moveToFirst();
    assertEquals(dpcRecordId1, cursorDPC2.getInt(0));
    assertEquals(dpcRecordApn1, cursorDPC2.getString(1));
    assertEquals(dpcRecordName, cursorDPC2.getString(2));
    assertEquals(current, cursorDPC2.getInt(3));
    assertEquals(Carriers.OWNED_BY_DPC, cursorDPC2.getInt(4));
    cursorDPC2.moveToNext();
    assertEquals(dpcRecordId2, cursorDPC2.getInt(0));
    assertEquals(dpcRecordApn2, cursorDPC2.getString(1));
    assertEquals(dpcRecordName, cursorDPC2.getString(2));
    assertEquals(current, cursorDPC2.getInt(3));
    assertEquals(Carriers.OWNED_BY_DPC, cursorDPC2.getInt(4));
    // Delete test records.
    int numRowsDeleted = mContentResolver.delete(Uri.parse(URI_DPC + "/" + dpcRecordId1), null, null);
    assertEquals(1, numRowsDeleted);
    numRowsDeleted = mContentResolver.delete(Uri.parse(URI_DPC + "/" + dpcRecordId2), null, null);
    assertEquals(1, numRowsDeleted);
}
#method_after
@Test
@SmallTest
public void testDpcUriOnConflict() {
    int dpcRecordId1 = 0, dpcRecordId2 = 0;
    try {
        mTelephonyProviderTestable.fakeCallingUid(Process.SYSTEM_UID);
        final int current = 1;
        final String numeric = "123456789";
        // Insert DPC record 1.
        final String dpcRecordApn1 = "exampleApnNameDPC";
        final String dpcRecordName = "exampleNameDPC";
        dpcRecordId1 = insertApnRecord(URI_DPC, dpcRecordApn1, dpcRecordName, current, numeric);
        Log.d(TAG, "testDpcUriOnConflict Id for DPC record 1: " + dpcRecordId1);
        // Insert conflicting DPC record.
        final String dpcRecordNameConflict = "exampleNameDPCConflict";
        final int dpcRecordIdConflict = insertApnRecord(URI_DPC, dpcRecordApn1, dpcRecordNameConflict, current, numeric);
        // Verity that conflicting DPC record is not inserted.
        assertEquals(-1, dpcRecordIdConflict);
        // Verify that APN 1 is not replaced or updated.
        Cursor cursorDPC1 = queryFullTestApnRecord(URI_DPC, numeric);
        assertNotNull(cursorDPC1);
        assertEquals(1, cursorDPC1.getCount());
        cursorDPC1.moveToFirst();
        assertApnEquals(cursorDPC1, dpcRecordId1, dpcRecordApn1, dpcRecordName, current, Carriers.OWNED_BY_DPC);
        // Insert DPC record 2.
        final String dpcRecordApn2 = "exampleApnNameDPC2";
        dpcRecordId2 = insertApnRecord(URI_DPC, dpcRecordApn2, dpcRecordName, current, numeric);
        Log.d(TAG, "testDpcUriOnConflict Id for DPC record 2: " + dpcRecordId2);
        // Update DPC record 2 to the values of DPC record 1.
        ContentValues contentValuesDpcUpdate = new ContentValues();
        contentValuesDpcUpdate.put(Carriers.APN, dpcRecordApn1);
        contentValuesDpcUpdate.put(Carriers.NAME, dpcRecordNameConflict);
        final int updateCount = mContentResolver.update(ContentUris.withAppendedId(URI_DPC, dpcRecordId2), contentValuesDpcUpdate, null, null);
        // Verify that database is not updated.
        assertEquals(0, updateCount);
        Cursor cursorDPC2 = queryFullTestApnRecord(URI_DPC, numeric);
        assertNotNull(cursorDPC2);
        assertEquals(2, cursorDPC2.getCount());
        cursorDPC2.moveToFirst();
        assertApnEquals(cursorDPC2, dpcRecordId1, dpcRecordApn1, dpcRecordName, current, Carriers.OWNED_BY_DPC);
        cursorDPC2.moveToNext();
        assertApnEquals(cursorDPC2, dpcRecordId2, dpcRecordApn2, dpcRecordName, current, Carriers.OWNED_BY_DPC);
    } finally {
        // Delete test records.
        int numRowsDeleted = mContentResolver.delete(ContentUris.withAppendedId(URI_DPC, dpcRecordId1), null, null);
        assertEquals(1, numRowsDeleted);
        numRowsDeleted = mContentResolver.delete(ContentUris.withAppendedId(URI_DPC, dpcRecordId2), null, null);
        assertEquals(1, numRowsDeleted);
    }
}
#end_block

#method_before
@Override
public void run() {
    logWriter.println("Redirector started: " + name);
    try {
        String line = "";
        while (!doExit || br.ready()) {
            try {
                line = br.readLine();
                if (line == null)
                    break;
                logWriter.println(name + "> " + line);
            } catch (IllegalStateException e) {
            // logWriter.printError("Illegal state exception! " + e);
            // ignore
            }
        }
        logWriter.println("Redirector completed: " + name);
    } catch (IOException e) {
        logWriter.printError(e);
    }
}
#method_after
@Override
public void run() {
    logWriter.println("Redirector started: " + name);
    try {
        StringBuilder cur = new StringBuilder();
        while (!doExit || br.ready()) {
            try {
                int nc = br.read();
                if (nc == -1) {
                    if (cur.length() != 0) {
                        logWriter.println(name + "> " + cur.toString());
                        cur.setLength(0);
                    }
                    break;
                } else if (nc == (int) '\n') {
                    logWriter.println(name + "> " + cur.toString());
                    cur.setLength(0);
                } else {
                    cur.appendCodePoint(nc);
                }
            } catch (IllegalStateException e) {
            // logWriter.printError("Illegal state exception! " + e);
            // ignore
            }
        }
        if (cur.length() != 0) {
            logWriter.println(name + "> " + cur.toString());
            cur.setLength(0);
        }
        logWriter.println("Redirector completed: " + name);
    } catch (IOException e) {
        logWriter.printError(e);
    }
}
#end_block

#method_before
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    int combinedRegState = getCombinedRegState();
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled() && (combinedRegState == ServiceState.STATE_IN_SERVICE)) {
        // In Wi-Fi Calling mode show SPN or PLMN + WiFi Calling
        // 
        // 1) Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
        // is satisfied or SPN override is enabled for this carrier
        // 
        // 2) Show PLMN + Wi-Fi Calling if there is no valid SPN in case 1
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS) : 0;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            // Force display no service
            final boolean forceDisplayNoService = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_display_no_service_when_sim_unready) && !mIsSimReady;
            if (mEmergencyOnly && !forceDisplayNoService) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
                rule &= SIMRecords.SPN_RULE_SHOW_PLMN;
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
            // is satisfied or SPN override is enabled for this carrier.
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // Show PLMN + Wi-Fi Calling if there is no valid SPN in the above case
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlpha contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#method_after
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    int combinedRegState = getCombinedRegState();
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled() && (combinedRegState == ServiceState.STATE_IN_SERVICE)) {
        // In Wi-Fi Calling mode show SPN or PLMN + WiFi Calling
        // 
        // 1) Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
        // is satisfied or SPN override is enabled for this carrier
        // 
        // 2) Show PLMN + Wi-Fi Calling if there is no valid SPN in case 1
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS) : 0;
        boolean noService = false;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            // Force display no service
            final boolean forceDisplayNoService = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_display_no_service_when_sim_unready) && !mIsSimReady;
            if (mEmergencyOnly && !forceDisplayNoService) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
                noService = true;
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !noService && !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
            // is satisfied or SPN override is enabled for this carrier.
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // Show PLMN + Wi-Fi Calling if there is no valid SPN in the above case
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlpha contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#end_block

#method_before
@Override
public String toString() {
    return "DataProfile=" + mProfileId + "/" + mProtocol + "/" + mAuthType + "/" + ("user".equals(Build.TYPE) ? "***/***/***" : (mApn + "/" + mUserName + "/" + mPassword)) + "/" + mType + "/" + mMaxConnsTime + "/" + mMaxConns + "/" + mWaitTime + "/" + mEnabled + "/" + mSupportedApnTypesBitmap + "/" + mRoamingProtocol + "/" + mBearerBitmap + "/" + mMtu + "/" + mMvnoType + "/" + mMvnoMatchData + "/" + mModemCognitive;
}
#method_after
@Override
public String toString() {
    return "DataProfile=" + mProfileId + "/" + mProtocol + "/" + mAuthType + "/" + (Build.IS_USER ? "***/***/***" : (mApn + "/" + mUserName + "/" + mPassword)) + "/" + mType + "/" + mMaxConnsTime + "/" + mMaxConns + "/" + mWaitTime + "/" + mEnabled + "/" + mSupportedApnTypesBitmap + "/" + mRoamingProtocol + "/" + mBearerBitmap + "/" + mMtu + "/" + mMvnoType + "/" + mMvnoMatchData + "/" + mModemCognitive;
}
#end_block

#method_before
public void test_xattr_Errno() throws Exception {
    final String NAME_TEST = "user.meow";
    final byte[] VALUE_CAKE = "cake cake cake".getBytes(StandardCharsets.UTF_8);
    // ENOENT, No such file or directory.
    try {
        Libcore.os.getxattr("", NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    try {
        Libcore.os.listxattr("");
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    try {
        Libcore.os.removexattr("", NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    try {
        Libcore.os.setxattr("", NAME_TEST, VALUE_CAKE, OsConstants.XATTR_CREATE);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    // ENOTSUP, Extended attributes are not supported by the filesystem, or are disabled.
    final boolean root = (Libcore.os.getuid() == 0);
    final String path = "/proc/self/stat";
    try {
        Libcore.os.setxattr(path, NAME_TEST, VALUE_CAKE, OsConstants.XATTR_CREATE);
        fail();
    } catch (ErrnoException e) {
        // setxattr(2) requires root permission for writing to this file, will get EACCES otherwise.
        assertEquals(root ? ENOTSUP : EACCES, e.errno);
    }
    try {
        Libcore.os.getxattr(path, NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOTSUP, e.errno);
    }
    try {
        // Linux listxattr does not set errno.
        Libcore.os.listxattr(path);
    } catch (ErrnoException e) {
        fail();
    }
    try {
        Libcore.os.removexattr(path, NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertEquals(root ? ENOTSUP : EACCES, e.errno);
    }
}
#method_after
public void test_xattr_Errno() throws Exception {
    final String NAME_TEST = "user.meow";
    final byte[] VALUE_CAKE = "cake cake cake".getBytes(StandardCharsets.UTF_8);
    // ENOENT, No such file or directory.
    try {
        Libcore.os.getxattr("", NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    try {
        Libcore.os.listxattr("");
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    try {
        Libcore.os.removexattr("", NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    try {
        Libcore.os.setxattr("", NAME_TEST, VALUE_CAKE, OsConstants.XATTR_CREATE);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    // ENOTSUP, Extended attributes are not supported by the filesystem, or are disabled.
    // Since kernel version 4.9 (or some other version after 4.4), *xattr() methods
    // may set errno to EACCESS instead. This behavior change is likely related to
    // https://patchwork.kernel.org/patch/9294421/ which reimplemented getxattr, setxattr,
    // and removexattr on top of generic handlers.
    final String path = "/proc/self/stat";
    try {
        Libcore.os.setxattr(path, NAME_TEST, VALUE_CAKE, OsConstants.XATTR_CREATE);
        fail();
    } catch (ErrnoException e) {
        assertTrue("Unexpected errno: " + e.errno, e.errno == ENOTSUP || e.errno == EACCES);
    }
    try {
        Libcore.os.getxattr(path, NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOTSUP, e.errno);
    }
    try {
        // Linux listxattr does not set errno.
        Libcore.os.listxattr(path);
    } catch (ErrnoException e) {
        fail();
    }
    try {
        Libcore.os.removexattr(path, NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertTrue("Unexpected errno: " + e.errno, e.errno == ENOTSUP || e.errno == EACCES);
    }
}
#end_block

#method_before
@Override
public void run() {
    mCallbackHandler = new Handler(mLooper, this);
    while (true) {
        try {
            listenToSocket();
        } catch (Exception e) {
            loge("Error in NativeDaemonConnector: " + e);
            SystemClock.sleep(5000);
        }
        String shutdownAct = SystemProperties.get(ShutdownThread.SHUTDOWN_ACTION_PROPERTY, "");
        if (shutdownAct != null && shutdownAct.length() > 0) {
            // The device is in middle of shutdown.
            break;
        }
    }
}
#method_after
@Override
public void run() {
    mCallbackHandler = new Handler(mLooper, this);
    while (true) {
        if (isShuttingDown())
            break;
        try {
            listenToSocket();
        } catch (Exception e) {
            loge("Error in NativeDaemonConnector: " + e);
            if (isShuttingDown())
                break;
            SystemClock.sleep(5000);
        }
    }
}
#end_block

#method_before
private void sign(DataSource inputApk, DataSink outputApkOut, DataSource outputApkIn) throws IOException, ApkFormatException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    // Step 1. Find input APK's main ZIP sections
    ApkUtils.ZipSections inputZipSections;
    try {
        inputZipSections = ApkUtils.findZipSections(inputApk);
    } catch (ZipFormatException e) {
        throw new ApkFormatException("Malformed APK: not a ZIP archive", e);
    }
    long inputApkSigningBlockOffset = -1;
    DataSource inputApkSigningBlock = null;
    try {
        ApkUtils.ApkSigningBlock apkSigningBlockInfo = ApkUtils.findApkSigningBlock(inputApk, inputZipSections);
        inputApkSigningBlockOffset = apkSigningBlockInfo.getStartOffset();
        inputApkSigningBlock = apkSigningBlockInfo.getContents();
    } catch (ApkSigningBlockNotFoundException e) {
    // Input APK does not contain an APK Signing Block. That's OK. APKs are not required to
    // contain this block. It's only needed if the APK is signed using APK Signature Scheme
    // v2 and/or v3.
    }
    DataSource inputApkLfhSection = inputApk.slice(0, (inputApkSigningBlockOffset != -1) ? inputApkSigningBlockOffset : inputZipSections.getZipCentralDirectoryOffset());
    // Step 2. Parse the input APK's ZIP Central Directory
    ByteBuffer inputCd = getZipCentralDirectory(inputApk, inputZipSections);
    List<CentralDirectoryRecord> inputCdRecords = parseZipCentralDirectory(inputCd, inputZipSections);
    // Step 3. Obtain a signer engine instance
    ApkSignerEngine signerEngine;
    if (mSignerEngine != null) {
        // Use the provided signer engine
        signerEngine = mSignerEngine;
    } else {
        // Construct a signer engine from the provided parameters
        int minSdkVersion;
        if (mMinSdkVersion != null) {
            // No need to extract minSdkVersion from the APK's AndroidManifest.xml
            minSdkVersion = mMinSdkVersion;
        } else {
            // Need to extract minSdkVersion from the APK's AndroidManifest.xml
            minSdkVersion = getMinSdkVersionFromApk(inputCdRecords, inputApkLfhSection);
        }
        List<DefaultApkSignerEngine.SignerConfig> engineSignerConfigs = new ArrayList<>(mSignerConfigs.size());
        for (SignerConfig signerConfig : mSignerConfigs) {
            engineSignerConfigs.add(new DefaultApkSignerEngine.SignerConfig.Builder(signerConfig.getName(), signerConfig.getPrivateKey(), signerConfig.getCertificates()).build());
        }
        DefaultApkSignerEngine.Builder signerEngineBuilder = new DefaultApkSignerEngine.Builder(engineSignerConfigs, minSdkVersion).setV1SigningEnabled(mV1SigningEnabled).setV2SigningEnabled(mV2SigningEnabled).setV3SigningEnabled(mV2SigningEnabled).setDebuggableApkPermitted(mDebuggableApkPermitted).setOtherSignersSignaturesPreserved(mOtherSignersSignaturesPreserved);
        // If we are signing with an old signer for compatibility, make sure it is added too.
        if (mOldSignerConfig != null) {
            signerEngineBuilder = signerEngineBuilder.setOldSignerConfig(new DefaultApkSignerEngine.SignerConfig.Builder(mOldSignerConfig.getName(), mOldSignerConfig.getPrivateKey(), mOldSignerConfig.getCertificates()).build());
        }
        if (mCreatedBy != null) {
            signerEngineBuilder.setCreatedBy(mCreatedBy);
        }
        signerEngine = signerEngineBuilder.build();
    }
    // Step 4. Provide the signer engine with the input APK's APK Signing Block (if any)
    if (inputApkSigningBlock != null) {
        signerEngine.inputApkSigningBlock(inputApkSigningBlock);
    }
    // Step 5. Iterate over input APK's entries and output the Local File Header + data of those
    // entries which need to be output. Entries are iterated in the order in which their Local
    // File Header records are stored in the file. This is to achieve better data locality in
    // case Central Directory entries are in the wrong order.
    List<CentralDirectoryRecord> inputCdRecordsSortedByLfhOffset = new ArrayList<>(inputCdRecords);
    Collections.sort(inputCdRecordsSortedByLfhOffset, CentralDirectoryRecord.BY_LOCAL_FILE_HEADER_OFFSET_COMPARATOR);
    int lastModifiedDateForNewEntries = -1;
    int lastModifiedTimeForNewEntries = -1;
    long inputOffset = 0;
    long outputOffset = 0;
    Map<String, CentralDirectoryRecord> outputCdRecordsByName = new HashMap<>(inputCdRecords.size());
    for (final CentralDirectoryRecord inputCdRecord : inputCdRecordsSortedByLfhOffset) {
        String entryName = inputCdRecord.getName();
        ApkSignerEngine.InputJarEntryInstructions entryInstructions = signerEngine.inputJarEntry(entryName);
        boolean shouldOutput;
        switch(entryInstructions.getOutputPolicy()) {
            case OUTPUT:
                shouldOutput = true;
                break;
            case OUTPUT_BY_ENGINE:
            case SKIP:
                shouldOutput = false;
                break;
            default:
                throw new RuntimeException("Unknown output policy: " + entryInstructions.getOutputPolicy());
        }
        long inputLocalFileHeaderStartOffset = inputCdRecord.getLocalFileHeaderOffset();
        if (inputLocalFileHeaderStartOffset > inputOffset) {
            // Unprocessed data in input starting at inputOffset and ending and the start of
            // this record's LFH. We output this data verbatim because this signer is supposed
            // to preserve as much of input as possible.
            long chunkSize = inputLocalFileHeaderStartOffset - inputOffset;
            inputApkLfhSection.feed(inputOffset, chunkSize, outputApkOut);
            outputOffset += chunkSize;
            inputOffset = inputLocalFileHeaderStartOffset;
        }
        LocalFileRecord inputLocalFileRecord;
        try {
            inputLocalFileRecord = LocalFileRecord.getRecord(inputApkLfhSection, inputCdRecord, inputApkLfhSection.size());
        } catch (ZipFormatException e) {
            throw new ApkFormatException("Malformed ZIP entry: " + inputCdRecord.getName(), e);
        }
        inputOffset += inputLocalFileRecord.getSize();
        ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest = entryInstructions.getInspectJarEntryRequest();
        if (inspectEntryRequest != null) {
            fulfillInspectInputJarEntryRequest(inputApkLfhSection, inputLocalFileRecord, inspectEntryRequest);
        }
        if (shouldOutput) {
            // Find the max value of last modified, to be used for new entries added by the
            // signer.
            int lastModifiedDate = inputCdRecord.getLastModificationDate();
            int lastModifiedTime = inputCdRecord.getLastModificationTime();
            if ((lastModifiedDateForNewEntries == -1) || (lastModifiedDate > lastModifiedDateForNewEntries) || ((lastModifiedDate == lastModifiedDateForNewEntries) && (lastModifiedTime > lastModifiedTimeForNewEntries))) {
                lastModifiedDateForNewEntries = lastModifiedDate;
                lastModifiedTimeForNewEntries = lastModifiedTime;
            }
            inspectEntryRequest = signerEngine.outputJarEntry(entryName);
            if (inspectEntryRequest != null) {
                fulfillInspectInputJarEntryRequest(inputApkLfhSection, inputLocalFileRecord, inspectEntryRequest);
            }
            // Output entry's Local File Header + data
            long outputLocalFileHeaderOffset = outputOffset;
            long outputLocalFileRecordSize = outputInputJarEntryLfhRecordPreservingDataAlignment(inputApkLfhSection, inputLocalFileRecord, outputApkOut, outputLocalFileHeaderOffset);
            outputOffset += outputLocalFileRecordSize;
            // Enqueue entry's Central Directory record for output
            CentralDirectoryRecord outputCdRecord;
            if (outputLocalFileHeaderOffset == inputLocalFileRecord.getStartOffsetInArchive()) {
                outputCdRecord = inputCdRecord;
            } else {
                outputCdRecord = inputCdRecord.createWithModifiedLocalFileHeaderOffset(outputLocalFileHeaderOffset);
            }
            outputCdRecordsByName.put(entryName, outputCdRecord);
        }
    }
    long inputLfhSectionSize = inputApkLfhSection.size();
    if (inputOffset < inputLfhSectionSize) {
        // Unprocessed data in input starting at inputOffset and ending and the end of the input
        // APK's LFH section. We output this data verbatim because this signer is supposed
        // to preserve as much of input as possible.
        long chunkSize = inputLfhSectionSize - inputOffset;
        inputApkLfhSection.feed(inputOffset, chunkSize, outputApkOut);
        outputOffset += chunkSize;
        inputOffset = inputLfhSectionSize;
    }
    // Step 6. Sort output APK's Central Directory records in the order in which they should
    // appear in the output
    List<CentralDirectoryRecord> outputCdRecords = new ArrayList<>(inputCdRecords.size() + 10);
    for (CentralDirectoryRecord inputCdRecord : inputCdRecords) {
        String entryName = inputCdRecord.getName();
        CentralDirectoryRecord outputCdRecord = outputCdRecordsByName.get(entryName);
        if (outputCdRecord != null) {
            outputCdRecords.add(outputCdRecord);
        }
    }
    // Step 7. Generate and output JAR signatures, if necessary. This may output more Local File
    // Header + data entries and add to the list of output Central Directory records.
    ApkSignerEngine.OutputJarSignatureRequest outputJarSignatureRequest = signerEngine.outputJarEntries();
    if (outputJarSignatureRequest != null) {
        if (lastModifiedDateForNewEntries == -1) {
            // Jan 1 2009 (DOS)
            lastModifiedDateForNewEntries = 0x3a21;
            lastModifiedTimeForNewEntries = 0;
        }
        for (ApkSignerEngine.OutputJarSignatureRequest.JarEntry entry : outputJarSignatureRequest.getAdditionalJarEntries()) {
            String entryName = entry.getName();
            byte[] uncompressedData = entry.getData();
            ZipUtils.DeflateResult deflateResult = ZipUtils.deflate(ByteBuffer.wrap(uncompressedData));
            byte[] compressedData = deflateResult.output;
            long uncompressedDataCrc32 = deflateResult.inputCrc32;
            ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest = signerEngine.outputJarEntry(entryName);
            if (inspectEntryRequest != null) {
                inspectEntryRequest.getDataSink().consume(uncompressedData, 0, uncompressedData.length);
                inspectEntryRequest.done();
            }
            long localFileHeaderOffset = outputOffset;
            outputOffset += LocalFileRecord.outputRecordWithDeflateCompressedData(entryName, lastModifiedTimeForNewEntries, lastModifiedDateForNewEntries, compressedData, uncompressedDataCrc32, uncompressedData.length, outputApkOut);
            outputCdRecords.add(CentralDirectoryRecord.createWithDeflateCompressedData(entryName, lastModifiedTimeForNewEntries, lastModifiedDateForNewEntries, uncompressedDataCrc32, compressedData.length, uncompressedData.length, localFileHeaderOffset));
        }
        outputJarSignatureRequest.done();
    }
    // Step 8. Construct output ZIP Central Directory in an in-memory buffer
    long outputCentralDirSizeBytes = 0;
    for (CentralDirectoryRecord record : outputCdRecords) {
        outputCentralDirSizeBytes += record.getSize();
    }
    if (outputCentralDirSizeBytes > Integer.MAX_VALUE) {
        throw new IOException("Output ZIP Central Directory too large: " + outputCentralDirSizeBytes + " bytes");
    }
    ByteBuffer outputCentralDir = ByteBuffer.allocate((int) outputCentralDirSizeBytes);
    for (CentralDirectoryRecord record : outputCdRecords) {
        record.copyTo(outputCentralDir);
    }
    outputCentralDir.flip();
    DataSource outputCentralDirDataSource = new ByteBufferDataSource(outputCentralDir);
    long outputCentralDirStartOffset = outputOffset;
    int outputCentralDirRecordCount = outputCdRecords.size();
    // Step 9. Construct output ZIP End of Central Directory record in an in-memory buffer
    ByteBuffer outputEocd = EocdRecord.createWithModifiedCentralDirectoryInfo(inputZipSections.getZipEndOfCentralDirectory(), outputCentralDirRecordCount, outputCentralDirDataSource.size(), outputCentralDirStartOffset);
    // Step 10. Generate and output APK Signature Scheme v2 and/or v3 signatures, if necessary.
    // This may insert an APK Signing Block just before the output's ZIP Central Directory
    ApkSignerEngine.OutputApkSigningBlockRequest2 outputApkSigningBlockRequest = signerEngine.outputZipSections2(outputApkIn, outputCentralDirDataSource, DataSources.asDataSource(outputEocd));
    if (outputApkSigningBlockRequest != null) {
        int padding = outputApkSigningBlockRequest.getPaddingSizeBeforeApkSigningBlock();
        outputApkOut.consume(ByteBuffer.allocate(padding));
        byte[] outputApkSigningBlock = outputApkSigningBlockRequest.getApkSigningBlock();
        outputApkOut.consume(outputApkSigningBlock, 0, outputApkSigningBlock.length);
        ZipUtils.setZipEocdCentralDirectoryOffset(outputEocd, outputCentralDirStartOffset + padding + outputApkSigningBlock.length);
        outputApkSigningBlockRequest.done();
    }
    // Step 11. Output ZIP Central Directory and ZIP End of Central Directory
    outputCentralDirDataSource.feed(0, outputCentralDirDataSource.size(), outputApkOut);
    outputApkOut.consume(outputEocd);
    signerEngine.outputDone();
}
#method_after
private void sign(DataSource inputApk, DataSink outputApkOut, DataSource outputApkIn) throws IOException, ApkFormatException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    // Step 1. Find input APK's main ZIP sections
    ApkUtils.ZipSections inputZipSections;
    try {
        inputZipSections = ApkUtils.findZipSections(inputApk);
    } catch (ZipFormatException e) {
        throw new ApkFormatException("Malformed APK: not a ZIP archive", e);
    }
    long inputApkSigningBlockOffset = -1;
    DataSource inputApkSigningBlock = null;
    try {
        ApkUtils.ApkSigningBlock apkSigningBlockInfo = ApkUtils.findApkSigningBlock(inputApk, inputZipSections);
        inputApkSigningBlockOffset = apkSigningBlockInfo.getStartOffset();
        inputApkSigningBlock = apkSigningBlockInfo.getContents();
    } catch (ApkSigningBlockNotFoundException e) {
    // Input APK does not contain an APK Signing Block. That's OK. APKs are not required to
    // contain this block. It's only needed if the APK is signed using APK Signature Scheme
    // v2 and/or v3.
    }
    DataSource inputApkLfhSection = inputApk.slice(0, (inputApkSigningBlockOffset != -1) ? inputApkSigningBlockOffset : inputZipSections.getZipCentralDirectoryOffset());
    // Step 2. Parse the input APK's ZIP Central Directory
    ByteBuffer inputCd = getZipCentralDirectory(inputApk, inputZipSections);
    List<CentralDirectoryRecord> inputCdRecords = parseZipCentralDirectory(inputCd, inputZipSections);
    // Step 3. Obtain a signer engine instance
    ApkSignerEngine signerEngine;
    if (mSignerEngine != null) {
        // Use the provided signer engine
        signerEngine = mSignerEngine;
    } else {
        // Construct a signer engine from the provided parameters
        int minSdkVersion;
        if (mMinSdkVersion != null) {
            // No need to extract minSdkVersion from the APK's AndroidManifest.xml
            minSdkVersion = mMinSdkVersion;
        } else {
            // Need to extract minSdkVersion from the APK's AndroidManifest.xml
            minSdkVersion = getMinSdkVersionFromApk(inputCdRecords, inputApkLfhSection);
        }
        List<DefaultApkSignerEngine.SignerConfig> engineSignerConfigs = new ArrayList<>(mSignerConfigs.size());
        for (SignerConfig signerConfig : mSignerConfigs) {
            engineSignerConfigs.add(new DefaultApkSignerEngine.SignerConfig.Builder(signerConfig.getName(), signerConfig.getPrivateKey(), signerConfig.getCertificates()).build());
        }
        DefaultApkSignerEngine.Builder signerEngineBuilder = new DefaultApkSignerEngine.Builder(engineSignerConfigs, minSdkVersion).setV1SigningEnabled(mV1SigningEnabled).setV2SigningEnabled(mV2SigningEnabled).setV3SigningEnabled(mV3SigningEnabled).setDebuggableApkPermitted(mDebuggableApkPermitted).setOtherSignersSignaturesPreserved(mOtherSignersSignaturesPreserved);
        if (mCreatedBy != null) {
            signerEngineBuilder.setCreatedBy(mCreatedBy);
        }
        signerEngine = signerEngineBuilder.build();
    }
    // Step 4. Provide the signer engine with the input APK's APK Signing Block (if any)
    if (inputApkSigningBlock != null) {
        signerEngine.inputApkSigningBlock(inputApkSigningBlock);
    }
    // Step 5. Iterate over input APK's entries and output the Local File Header + data of those
    // entries which need to be output. Entries are iterated in the order in which their Local
    // File Header records are stored in the file. This is to achieve better data locality in
    // case Central Directory entries are in the wrong order.
    List<CentralDirectoryRecord> inputCdRecordsSortedByLfhOffset = new ArrayList<>(inputCdRecords);
    Collections.sort(inputCdRecordsSortedByLfhOffset, CentralDirectoryRecord.BY_LOCAL_FILE_HEADER_OFFSET_COMPARATOR);
    int lastModifiedDateForNewEntries = -1;
    int lastModifiedTimeForNewEntries = -1;
    long inputOffset = 0;
    long outputOffset = 0;
    Map<String, CentralDirectoryRecord> outputCdRecordsByName = new HashMap<>(inputCdRecords.size());
    for (final CentralDirectoryRecord inputCdRecord : inputCdRecordsSortedByLfhOffset) {
        String entryName = inputCdRecord.getName();
        ApkSignerEngine.InputJarEntryInstructions entryInstructions = signerEngine.inputJarEntry(entryName);
        boolean shouldOutput;
        switch(entryInstructions.getOutputPolicy()) {
            case OUTPUT:
                shouldOutput = true;
                break;
            case OUTPUT_BY_ENGINE:
            case SKIP:
                shouldOutput = false;
                break;
            default:
                throw new RuntimeException("Unknown output policy: " + entryInstructions.getOutputPolicy());
        }
        long inputLocalFileHeaderStartOffset = inputCdRecord.getLocalFileHeaderOffset();
        if (inputLocalFileHeaderStartOffset > inputOffset) {
            // Unprocessed data in input starting at inputOffset and ending and the start of
            // this record's LFH. We output this data verbatim because this signer is supposed
            // to preserve as much of input as possible.
            long chunkSize = inputLocalFileHeaderStartOffset - inputOffset;
            inputApkLfhSection.feed(inputOffset, chunkSize, outputApkOut);
            outputOffset += chunkSize;
            inputOffset = inputLocalFileHeaderStartOffset;
        }
        LocalFileRecord inputLocalFileRecord;
        try {
            inputLocalFileRecord = LocalFileRecord.getRecord(inputApkLfhSection, inputCdRecord, inputApkLfhSection.size());
        } catch (ZipFormatException e) {
            throw new ApkFormatException("Malformed ZIP entry: " + inputCdRecord.getName(), e);
        }
        inputOffset += inputLocalFileRecord.getSize();
        ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest = entryInstructions.getInspectJarEntryRequest();
        if (inspectEntryRequest != null) {
            fulfillInspectInputJarEntryRequest(inputApkLfhSection, inputLocalFileRecord, inspectEntryRequest);
        }
        if (shouldOutput) {
            // Find the max value of last modified, to be used for new entries added by the
            // signer.
            int lastModifiedDate = inputCdRecord.getLastModificationDate();
            int lastModifiedTime = inputCdRecord.getLastModificationTime();
            if ((lastModifiedDateForNewEntries == -1) || (lastModifiedDate > lastModifiedDateForNewEntries) || ((lastModifiedDate == lastModifiedDateForNewEntries) && (lastModifiedTime > lastModifiedTimeForNewEntries))) {
                lastModifiedDateForNewEntries = lastModifiedDate;
                lastModifiedTimeForNewEntries = lastModifiedTime;
            }
            inspectEntryRequest = signerEngine.outputJarEntry(entryName);
            if (inspectEntryRequest != null) {
                fulfillInspectInputJarEntryRequest(inputApkLfhSection, inputLocalFileRecord, inspectEntryRequest);
            }
            // Output entry's Local File Header + data
            long outputLocalFileHeaderOffset = outputOffset;
            long outputLocalFileRecordSize = outputInputJarEntryLfhRecordPreservingDataAlignment(inputApkLfhSection, inputLocalFileRecord, outputApkOut, outputLocalFileHeaderOffset);
            outputOffset += outputLocalFileRecordSize;
            // Enqueue entry's Central Directory record for output
            CentralDirectoryRecord outputCdRecord;
            if (outputLocalFileHeaderOffset == inputLocalFileRecord.getStartOffsetInArchive()) {
                outputCdRecord = inputCdRecord;
            } else {
                outputCdRecord = inputCdRecord.createWithModifiedLocalFileHeaderOffset(outputLocalFileHeaderOffset);
            }
            outputCdRecordsByName.put(entryName, outputCdRecord);
        }
    }
    long inputLfhSectionSize = inputApkLfhSection.size();
    if (inputOffset < inputLfhSectionSize) {
        // Unprocessed data in input starting at inputOffset and ending and the end of the input
        // APK's LFH section. We output this data verbatim because this signer is supposed
        // to preserve as much of input as possible.
        long chunkSize = inputLfhSectionSize - inputOffset;
        inputApkLfhSection.feed(inputOffset, chunkSize, outputApkOut);
        outputOffset += chunkSize;
        inputOffset = inputLfhSectionSize;
    }
    // Step 6. Sort output APK's Central Directory records in the order in which they should
    // appear in the output
    List<CentralDirectoryRecord> outputCdRecords = new ArrayList<>(inputCdRecords.size() + 10);
    for (CentralDirectoryRecord inputCdRecord : inputCdRecords) {
        String entryName = inputCdRecord.getName();
        CentralDirectoryRecord outputCdRecord = outputCdRecordsByName.get(entryName);
        if (outputCdRecord != null) {
            outputCdRecords.add(outputCdRecord);
        }
    }
    // Step 7. Generate and output JAR signatures, if necessary. This may output more Local File
    // Header + data entries and add to the list of output Central Directory records.
    ApkSignerEngine.OutputJarSignatureRequest outputJarSignatureRequest = signerEngine.outputJarEntries();
    if (outputJarSignatureRequest != null) {
        if (lastModifiedDateForNewEntries == -1) {
            // Jan 1 2009 (DOS)
            lastModifiedDateForNewEntries = 0x3a21;
            lastModifiedTimeForNewEntries = 0;
        }
        for (ApkSignerEngine.OutputJarSignatureRequest.JarEntry entry : outputJarSignatureRequest.getAdditionalJarEntries()) {
            String entryName = entry.getName();
            byte[] uncompressedData = entry.getData();
            ZipUtils.DeflateResult deflateResult = ZipUtils.deflate(ByteBuffer.wrap(uncompressedData));
            byte[] compressedData = deflateResult.output;
            long uncompressedDataCrc32 = deflateResult.inputCrc32;
            ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest = signerEngine.outputJarEntry(entryName);
            if (inspectEntryRequest != null) {
                inspectEntryRequest.getDataSink().consume(uncompressedData, 0, uncompressedData.length);
                inspectEntryRequest.done();
            }
            long localFileHeaderOffset = outputOffset;
            outputOffset += LocalFileRecord.outputRecordWithDeflateCompressedData(entryName, lastModifiedTimeForNewEntries, lastModifiedDateForNewEntries, compressedData, uncompressedDataCrc32, uncompressedData.length, outputApkOut);
            outputCdRecords.add(CentralDirectoryRecord.createWithDeflateCompressedData(entryName, lastModifiedTimeForNewEntries, lastModifiedDateForNewEntries, uncompressedDataCrc32, compressedData.length, uncompressedData.length, localFileHeaderOffset));
        }
        outputJarSignatureRequest.done();
    }
    // Step 8. Construct output ZIP Central Directory in an in-memory buffer
    long outputCentralDirSizeBytes = 0;
    for (CentralDirectoryRecord record : outputCdRecords) {
        outputCentralDirSizeBytes += record.getSize();
    }
    if (outputCentralDirSizeBytes > Integer.MAX_VALUE) {
        throw new IOException("Output ZIP Central Directory too large: " + outputCentralDirSizeBytes + " bytes");
    }
    ByteBuffer outputCentralDir = ByteBuffer.allocate((int) outputCentralDirSizeBytes);
    for (CentralDirectoryRecord record : outputCdRecords) {
        record.copyTo(outputCentralDir);
    }
    outputCentralDir.flip();
    DataSource outputCentralDirDataSource = new ByteBufferDataSource(outputCentralDir);
    long outputCentralDirStartOffset = outputOffset;
    int outputCentralDirRecordCount = outputCdRecords.size();
    // Step 9. Construct output ZIP End of Central Directory record in an in-memory buffer
    ByteBuffer outputEocd = EocdRecord.createWithModifiedCentralDirectoryInfo(inputZipSections.getZipEndOfCentralDirectory(), outputCentralDirRecordCount, outputCentralDirDataSource.size(), outputCentralDirStartOffset);
    // Step 10. Generate and output APK Signature Scheme v2 and/or v3 signatures, if necessary.
    // This may insert an APK Signing Block just before the output's ZIP Central Directory
    ApkSignerEngine.OutputApkSigningBlockRequest2 outputApkSigningBlockRequest = signerEngine.outputZipSections2(outputApkIn, outputCentralDirDataSource, DataSources.asDataSource(outputEocd));
    if (outputApkSigningBlockRequest != null) {
        int padding = outputApkSigningBlockRequest.getPaddingSizeBeforeApkSigningBlock();
        outputApkOut.consume(ByteBuffer.allocate(padding));
        byte[] outputApkSigningBlock = outputApkSigningBlockRequest.getApkSigningBlock();
        outputApkOut.consume(outputApkSigningBlock, 0, outputApkSigningBlock.length);
        ZipUtils.setZipEocdCentralDirectoryOffset(outputEocd, outputCentralDirStartOffset + padding + outputApkSigningBlock.length);
        outputApkSigningBlockRequest.done();
    }
    // Step 11. Output ZIP Central Directory and ZIP End of Central Directory
    outputCentralDirDataSource.feed(0, outputCentralDirDataSource.size(), outputApkOut);
    outputApkOut.consume(outputEocd);
    signerEngine.outputDone();
}
#end_block

#method_before
public ApkSigner build() {
    return new ApkSigner(mSignerConfigs, mOldSignerConfig, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mV3SigningEnabled, mDebuggableApkPermitted, mOtherSignersSignaturesPreserved, mCreatedBy, mSignerEngine, mInputApkFile, mInputApkDataSource, mOutputApkFile, mOutputApkDataSink, mOutputApkDataSource);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mName, mPrivateKey, mCertificates);
}
#end_block

#method_before
public Builder setV3SigningEnabled(boolean enabled) {
    checkInitializedWithoutEngine();
    if (enabled && mSignerConfigs != null && mSignerConfigs.size() > 1) {
        throw new IllegalArgumentException("APK Signature Scheme v3 cannot be used with " + "multiple signers.");
    }
    mV3SigningEnabled = enabled;
    return this;
}
#method_after
public Builder setV3SigningEnabled(boolean enabled) {
    checkInitializedWithoutEngine();
    mV3SigningEnabled = enabled;
    if (enabled) {
        mV3SigningExplicitlyEnabled = true;
    } else {
        mV3SigningExplicitlyDisabled = true;
    }
    return this;
}
#end_block

#method_before
public ApkSigner build() {
    return new ApkSigner(mSignerConfigs, mOldSignerConfig, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mV3SigningEnabled, mDebuggableApkPermitted, mOtherSignersSignaturesPreserved, mCreatedBy, mSignerEngine, mInputApkFile, mInputApkDataSource, mOutputApkFile, mOutputApkDataSink, mOutputApkDataSource);
}
#method_after
public ApkSigner build() {
    if (mV3SigningExplicitlyDisabled && mV3SigningExplicitlyEnabled) {
        throw new IllegalStateException("Builder configured to both enable and disable APK " + "Signature Scheme v3 signing");
    }
    if (mV3SigningExplicitlyDisabled) {
        mV3SigningEnabled = false;
    }
    if (mV3SigningExplicitlyEnabled) {
        mV3SigningEnabled = true;
    }
    return new ApkSigner(mSignerConfigs, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mV3SigningEnabled, mDebuggableApkPermitted, mOtherSignersSignaturesPreserved, mCreatedBy, mSignerEngine, mInputApkFile, mInputApkDataSource, mOutputApkFile, mOutputApkDataSink, mOutputApkDataSource, mSigningCertificateLineage);
}
#end_block

#method_before
private static Pair<byte[], Integer> generateApkSignatureSchemeV3Block(List<SignerConfig> signerConfigs, Map<ContentDigestAlgorithm, byte[]> contentDigests) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    // TODO: Support multiple signers for different platform versions.
    if (signerConfigs.size() > 1) {
        throw new IllegalArgumentException("APK Signature Scheme v3 cannot be used with " + "multiple signers");
    }
    List<byte[]> signerBlocks = new ArrayList<>(signerConfigs.size());
    int signerNumber = 0;
    for (SignerConfig signerConfig : signerConfigs) {
        signerNumber++;
        byte[] signerBlock;
        try {
            signerBlock = generateSignerBlock(signerConfig, contentDigests);
        } catch (InvalidKeyException e) {
            throw new InvalidKeyException("Signer #" + signerNumber + " failed", e);
        } catch (SignatureException e) {
            throw new SignatureException("Signer #" + signerNumber + " failed", e);
        }
        signerBlocks.add(signerBlock);
    }
    return Pair.of(encodeAsSequenceOfLengthPrefixedElements(new byte[][] { encodeAsSequenceOfLengthPrefixedElements(signerBlocks) }), APK_SIGNATURE_SCHEME_V3_BLOCK_ID);
}
#method_after
private static Pair<byte[], Integer> generateApkSignatureSchemeV3Block(List<SignerConfig> signerConfigs, Map<ContentDigestAlgorithm, byte[]> contentDigests) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    // FORMAT:
    // * length-prefixed sequence of length-prefixed signer blocks.
    List<byte[]> signerBlocks = new ArrayList<>(signerConfigs.size());
    int signerNumber = 0;
    for (SignerConfig signerConfig : signerConfigs) {
        signerNumber++;
        byte[] signerBlock;
        try {
            signerBlock = generateSignerBlock(signerConfig, contentDigests);
        } catch (InvalidKeyException e) {
            throw new InvalidKeyException("Signer #" + signerNumber + " failed", e);
        } catch (SignatureException e) {
            throw new SignatureException("Signer #" + signerNumber + " failed", e);
        }
        signerBlocks.add(signerBlock);
    }
    return Pair.of(encodeAsSequenceOfLengthPrefixedElements(new byte[][] { encodeAsSequenceOfLengthPrefixedElements(signerBlocks) }), APK_SIGNATURE_SCHEME_V3_BLOCK_ID);
}
#end_block

#method_before
private static byte[] generateSignerBlock(SignerConfig signerConfig, Map<ContentDigestAlgorithm, byte[]> contentDigests) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    if (signerConfig.certificates.isEmpty()) {
        throw new SignatureException("No certificates configured for signer");
    }
    PublicKey publicKey = signerConfig.certificates.get(0).getPublicKey();
    byte[] encodedPublicKey = encodePublicKey(publicKey);
    V3SignatureSchemeBlock.SignedData signedData = new V3SignatureSchemeBlock.SignedData();
    try {
        signedData.certificates = encodeCertificates(signerConfig.certificates);
    } catch (CertificateEncodingException e) {
        throw new SignatureException("Failed to encode certificates", e);
    }
    List<Pair<Integer, byte[]>> digests = new ArrayList<>(signerConfig.signatureAlgorithms.size());
    for (SignatureAlgorithm signatureAlgorithm : signerConfig.signatureAlgorithms) {
        ContentDigestAlgorithm contentDigestAlgorithm = signatureAlgorithm.getContentDigestAlgorithm();
        byte[] contentDigest = contentDigests.get(contentDigestAlgorithm);
        if (contentDigest == null) {
            throw new RuntimeException(contentDigestAlgorithm + " content digest for " + signatureAlgorithm + " not computed");
        }
        digests.add(Pair.of(signatureAlgorithm.getId(), contentDigest));
    }
    signedData.digests = digests;
    signedData.minSdkVersion = signerConfig.minSdkVersion;
    signedData.maxSdkVersion = signerConfig.maxSdkVersion;
    signedData.additionalAttributes = generateAdditionalAttributes(signerConfig);
    V3SignatureSchemeBlock.Signer signer = new V3SignatureSchemeBlock.Signer();
    // FORMAT:
    // * length-prefixed sequence of length-prefixed digests:
    // * uint32: signature algorithm ID
    // * length-prefixed bytes: digest of contents
    // * length-prefixed sequence of certificates:
    // * length-prefixed bytes: X.509 certificate (ASN.1 DER encoded).
    // * uint-32: minSdkVersion
    // * uint-32: maxSdkVersion
    // * length-prefixed sequence of length-prefixed additional attributes:
    // * uint32: ID
    // * (length - 4) bytes: value
    // * uint32: Proof-of-rotation ID: 0x3ba06f8c
    // * length-prefixed roof-of-rotation structure
    signer.signedData = encodeAsSequenceOfLengthPrefixedElements(new byte[][] { encodeAsSequenceOfLengthPrefixedPairsOfIntAndLengthPrefixedBytes(signedData.digests), encodeAsSequenceOfLengthPrefixedElements(signedData.certificates), signedData.additionalAttributes });
    signer.minSdkVersion = signerConfig.minSdkVersion;
    signer.maxSdkVersion = signerConfig.maxSdkVersion;
    signer.publicKey = encodedPublicKey;
    signer.signatures = new ArrayList<>(signerConfig.signatureAlgorithms.size());
    for (SignatureAlgorithm signatureAlgorithm : signerConfig.signatureAlgorithms) {
        Pair<String, ? extends AlgorithmParameterSpec> sigAlgAndParams = signatureAlgorithm.getJcaSignatureAlgorithmAndParams();
        String jcaSignatureAlgorithm = sigAlgAndParams.getFirst();
        AlgorithmParameterSpec jcaSignatureAlgorithmParams = sigAlgAndParams.getSecond();
        byte[] signatureBytes;
        try {
            Signature signature = Signature.getInstance(jcaSignatureAlgorithm);
            signature.initSign(signerConfig.privateKey);
            if (jcaSignatureAlgorithmParams != null) {
                signature.setParameter(jcaSignatureAlgorithmParams);
            }
            signature.update(signer.signedData);
            signatureBytes = signature.sign();
        } catch (InvalidKeyException e) {
            throw new InvalidKeyException("Failed to sign using " + jcaSignatureAlgorithm, e);
        } catch (InvalidAlgorithmParameterException | SignatureException e) {
            throw new SignatureException("Failed to sign using " + jcaSignatureAlgorithm, e);
        }
        try {
            Signature signature = Signature.getInstance(jcaSignatureAlgorithm);
            signature.initVerify(publicKey);
            if (jcaSignatureAlgorithmParams != null) {
                signature.setParameter(jcaSignatureAlgorithmParams);
            }
            signature.update(signer.signedData);
            if (!signature.verify(signatureBytes)) {
                throw new SignatureException("Signature did not verify");
            }
        } catch (InvalidKeyException e) {
            throw new InvalidKeyException("Failed to verify generated " + jcaSignatureAlgorithm + " signature using" + " public key from certificate", e);
        } catch (InvalidAlgorithmParameterException | SignatureException e) {
            throw new SignatureException("Failed to verify generated " + jcaSignatureAlgorithm + " signature using" + " public key from certificate", e);
        }
        signer.signatures.add(Pair.of(signatureAlgorithm.getId(), signatureBytes));
    }
    // * length-prefixed bytes: public key (X.509 SubjectPublicKeyInfo, ASN.1 DER encoded)
    return encodeAsSequenceOfLengthPrefixedElements(new byte[][] { signer.signedData, encodeAsSequenceOfLengthPrefixedPairsOfIntAndLengthPrefixedBytes(signer.signatures), signer.publicKey });
}
#method_after
private static byte[] generateSignerBlock(SignerConfig signerConfig, Map<ContentDigestAlgorithm, byte[]> contentDigests) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    if (signerConfig.certificates.isEmpty()) {
        throw new SignatureException("No certificates configured for signer");
    }
    PublicKey publicKey = signerConfig.certificates.get(0).getPublicKey();
    byte[] encodedPublicKey = encodePublicKey(publicKey);
    V3SignatureSchemeBlock.SignedData signedData = new V3SignatureSchemeBlock.SignedData();
    try {
        signedData.certificates = encodeCertificates(signerConfig.certificates);
    } catch (CertificateEncodingException e) {
        throw new SignatureException("Failed to encode certificates", e);
    }
    List<Pair<Integer, byte[]>> digests = new ArrayList<>(signerConfig.signatureAlgorithms.size());
    for (SignatureAlgorithm signatureAlgorithm : signerConfig.signatureAlgorithms) {
        ContentDigestAlgorithm contentDigestAlgorithm = signatureAlgorithm.getContentDigestAlgorithm();
        byte[] contentDigest = contentDigests.get(contentDigestAlgorithm);
        if (contentDigest == null) {
            throw new RuntimeException(contentDigestAlgorithm + " content digest for " + signatureAlgorithm + " not computed");
        }
        digests.add(Pair.of(signatureAlgorithm.getId(), contentDigest));
    }
    signedData.digests = digests;
    signedData.minSdkVersion = signerConfig.minSdkVersion;
    signedData.maxSdkVersion = signerConfig.maxSdkVersion;
    signedData.additionalAttributes = generateAdditionalAttributes(signerConfig);
    V3SignatureSchemeBlock.Signer signer = new V3SignatureSchemeBlock.Signer();
    signer.signedData = encodeSignedData(signedData);
    signer.minSdkVersion = signerConfig.minSdkVersion;
    signer.maxSdkVersion = signerConfig.maxSdkVersion;
    signer.publicKey = encodedPublicKey;
    signer.signatures = new ArrayList<>(signerConfig.signatureAlgorithms.size());
    for (SignatureAlgorithm signatureAlgorithm : signerConfig.signatureAlgorithms) {
        Pair<String, ? extends AlgorithmParameterSpec> sigAlgAndParams = signatureAlgorithm.getJcaSignatureAlgorithmAndParams();
        String jcaSignatureAlgorithm = sigAlgAndParams.getFirst();
        AlgorithmParameterSpec jcaSignatureAlgorithmParams = sigAlgAndParams.getSecond();
        byte[] signatureBytes;
        try {
            Signature signature = Signature.getInstance(jcaSignatureAlgorithm);
            signature.initSign(signerConfig.privateKey);
            if (jcaSignatureAlgorithmParams != null) {
                signature.setParameter(jcaSignatureAlgorithmParams);
            }
            signature.update(signer.signedData);
            signatureBytes = signature.sign();
        } catch (InvalidKeyException e) {
            throw new InvalidKeyException("Failed to sign using " + jcaSignatureAlgorithm, e);
        } catch (InvalidAlgorithmParameterException | SignatureException e) {
            throw new SignatureException("Failed to sign using " + jcaSignatureAlgorithm, e);
        }
        try {
            Signature signature = Signature.getInstance(jcaSignatureAlgorithm);
            signature.initVerify(publicKey);
            if (jcaSignatureAlgorithmParams != null) {
                signature.setParameter(jcaSignatureAlgorithmParams);
            }
            signature.update(signer.signedData);
            if (!signature.verify(signatureBytes)) {
                throw new SignatureException("Signature did not verify");
            }
        } catch (InvalidKeyException e) {
            throw new InvalidKeyException("Failed to verify generated " + jcaSignatureAlgorithm + " signature using" + " public key from certificate", e);
        } catch (InvalidAlgorithmParameterException | SignatureException e) {
            throw new SignatureException("Failed to verify generated " + jcaSignatureAlgorithm + " signature using" + " public key from certificate", e);
        }
        signer.signatures.add(Pair.of(signatureAlgorithm.getId(), signatureBytes));
    }
    return encodeSigner(signer);
}
#end_block

#method_before
private static byte[] generateAdditionalAttributes(SignerConfig signerConfig) {
    if (signerConfig.apkSignerLineage == null) {
        return new byte[0];
    }
    // wrap with an attribute.
    throw new NotImplementedException();
}
#method_after
private static byte[] generateAdditionalAttributes(SignerConfig signerConfig) {
    if (signerConfig.mSigningCertificateLineage == null) {
        return new byte[0];
    }
    // wrap with an attribute.
    throw new UnsupportedOperationException();
}
#end_block

#method_before
private List<ApkSigningBlockUtils.SignerConfig> createV2SignerConfigs(boolean apkSigningBlockPaddingSupported) throws InvalidKeyException {
    if (mOldSignerConfig != null) {
        // we've been given a different SignerConfig to use explicitly for v1 and v2 signing
        List<ApkSigningBlockUtils.SignerConfig> signerConfig = new ArrayList<>();
        signerConfig.add(createSigningBLockSignerConfig(mOldSignerConfig, apkSigningBlockPaddingSupported, ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2));
        return signerConfig;
    } else {
        return createSigningBLockSignerConfigs(apkSigningBlockPaddingSupported, ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2);
    }
}
#method_after
private List<ApkSigningBlockUtils.SignerConfig> createV2SignerConfigs(boolean apkSigningBlockPaddingSupported) throws InvalidKeyException {
    if (mV3SigningEnabled) {
        // v3 signing only supports single signers, of which the oldest (first) will be the one
        // to use for v1 and v2 signing
        List<ApkSigningBlockUtils.SignerConfig> signerConfig = new ArrayList<>();
        signerConfig.add(createSigningBlockSignerConfig(mSignerConfigs.get(0), apkSigningBlockPaddingSupported, ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2));
        return signerConfig;
    } else {
        return createSigningBlockSignerConfigs(apkSigningBlockPaddingSupported, ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2);
    }
}
#end_block

#method_before
@Override
public OutputJarSignatureRequest outputJarEntries() throws ApkFormatException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    checkNotClosed();
    if (!mV1SignaturePending) {
        return null;
    }
    if ((mInputJarManifestEntryDataRequest != null) && (!mInputJarManifestEntryDataRequest.isDone())) {
        throw new IllegalStateException("Still waiting to inspect input APK's " + mInputJarManifestEntryDataRequest.getEntryName());
    }
    for (GetJarEntryDataDigestRequest digestRequest : mOutputJarEntryDigestRequests.values()) {
        String entryName = digestRequest.getEntryName();
        if (!digestRequest.isDone()) {
            throw new IllegalStateException("Still waiting to inspect output APK's " + entryName);
        }
        mOutputJarEntryDigests.put(entryName, digestRequest.getDigest());
    }
    mOutputJarEntryDigestRequests.clear();
    for (GetJarEntryDataRequest dataRequest : mOutputSignatureJarEntryDataRequests.values()) {
        if (!dataRequest.isDone()) {
            throw new IllegalStateException("Still waiting to inspect output APK's " + dataRequest.getEntryName());
        }
    }
    List<Integer> apkSigningSchemeIds = (mV2SigningEnabled) ? Collections.singletonList(2) : Collections.emptyList();
    byte[] inputJarManifest = (mInputJarManifestEntryDataRequest != null) ? mInputJarManifestEntryDataRequest.getData() : null;
    // Check whether the most recently used signature (if present) is still fine.
    checkOutputApkNotDebuggableIfDebuggableMustBeRejected();
    List<Pair<String, byte[]>> signatureZipEntries;
    if ((mAddV1SignatureRequest == null) || (!mAddV1SignatureRequest.isDone())) {
        try {
            signatureZipEntries = V1SchemeSigner.sign(mV1SignerConfigs, mV1ContentDigestAlgorithm, mOutputJarEntryDigests, apkSigningSchemeIds, inputJarManifest, mCreatedBy);
        } catch (CertificateException e) {
            throw new SignatureException("Failed to generate v1 signature", e);
        }
    } else {
        V1SchemeSigner.OutputManifestFile newManifest = V1SchemeSigner.generateManifestFile(mV1ContentDigestAlgorithm, mOutputJarEntryDigests, inputJarManifest);
        byte[] emittedSignatureManifest = mEmittedSignatureJarEntryData.get(V1SchemeSigner.MANIFEST_ENTRY_NAME);
        if (!Arrays.equals(newManifest.contents, emittedSignatureManifest)) {
            // Emitted v1 signature is no longer valid.
            try {
                signatureZipEntries = V1SchemeSigner.signManifest(mV1SignerConfigs, mV1ContentDigestAlgorithm, apkSigningSchemeIds, mCreatedBy, newManifest);
            } catch (CertificateException e) {
                throw new SignatureException("Failed to generate v1 signature", e);
            }
        } else {
            // Emitted v1 signature is still valid. Check whether the signature is there in the
            // output.
            signatureZipEntries = new ArrayList<>();
            for (Map.Entry<String, byte[]> expectedOutputEntry : mEmittedSignatureJarEntryData.entrySet()) {
                String entryName = expectedOutputEntry.getKey();
                byte[] expectedData = expectedOutputEntry.getValue();
                GetJarEntryDataRequest actualDataRequest = mOutputSignatureJarEntryDataRequests.get(entryName);
                if (actualDataRequest == null) {
                    // This signature entry hasn't been output.
                    signatureZipEntries.add(Pair.of(entryName, expectedData));
                    continue;
                }
                byte[] actualData = actualDataRequest.getData();
                if (!Arrays.equals(expectedData, actualData)) {
                    signatureZipEntries.add(Pair.of(entryName, expectedData));
                }
            }
            if (signatureZipEntries.isEmpty()) {
                // v1 signature in the output is valid
                return null;
            }
        // v1 signature in the output is not valid.
        }
    }
    if (signatureZipEntries.isEmpty()) {
        // v1 signature in the output is valid
        mV1SignaturePending = false;
        return null;
    }
    List<OutputJarSignatureRequest.JarEntry> sigEntries = new ArrayList<>(signatureZipEntries.size());
    for (Pair<String, byte[]> entry : signatureZipEntries) {
        String entryName = entry.getFirst();
        byte[] entryData = entry.getSecond();
        sigEntries.add(new OutputJarSignatureRequest.JarEntry(entryName, entryData));
        mEmittedSignatureJarEntryData.put(entryName, entryData);
    }
    mAddV1SignatureRequest = new OutputJarSignatureRequestImpl(sigEntries);
    return mAddV1SignatureRequest;
}
#method_after
@Override
public OutputJarSignatureRequest outputJarEntries() throws ApkFormatException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    checkNotClosed();
    if (!mV1SignaturePending) {
        return null;
    }
    if ((mInputJarManifestEntryDataRequest != null) && (!mInputJarManifestEntryDataRequest.isDone())) {
        throw new IllegalStateException("Still waiting to inspect input APK's " + mInputJarManifestEntryDataRequest.getEntryName());
    }
    for (GetJarEntryDataDigestRequest digestRequest : mOutputJarEntryDigestRequests.values()) {
        String entryName = digestRequest.getEntryName();
        if (!digestRequest.isDone()) {
            throw new IllegalStateException("Still waiting to inspect output APK's " + entryName);
        }
        mOutputJarEntryDigests.put(entryName, digestRequest.getDigest());
    }
    mOutputJarEntryDigestRequests.clear();
    for (GetJarEntryDataRequest dataRequest : mOutputSignatureJarEntryDataRequests.values()) {
        if (!dataRequest.isDone()) {
            throw new IllegalStateException("Still waiting to inspect output APK's " + dataRequest.getEntryName());
        }
    }
    List<Integer> apkSigningSchemeIds = new ArrayList<>();
    if (mV2SigningEnabled) {
        apkSigningSchemeIds.add(ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2);
    }
    if (mV3SigningEnabled) {
        apkSigningSchemeIds.add(ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3);
    }
    byte[] inputJarManifest = (mInputJarManifestEntryDataRequest != null) ? mInputJarManifestEntryDataRequest.getData() : null;
    // Check whether the most recently used signature (if present) is still fine.
    checkOutputApkNotDebuggableIfDebuggableMustBeRejected();
    List<Pair<String, byte[]>> signatureZipEntries;
    if ((mAddV1SignatureRequest == null) || (!mAddV1SignatureRequest.isDone())) {
        try {
            signatureZipEntries = V1SchemeSigner.sign(mV1SignerConfigs, mV1ContentDigestAlgorithm, mOutputJarEntryDigests, apkSigningSchemeIds, inputJarManifest, mCreatedBy);
        } catch (CertificateException e) {
            throw new SignatureException("Failed to generate v1 signature", e);
        }
    } else {
        V1SchemeSigner.OutputManifestFile newManifest = V1SchemeSigner.generateManifestFile(mV1ContentDigestAlgorithm, mOutputJarEntryDigests, inputJarManifest);
        byte[] emittedSignatureManifest = mEmittedSignatureJarEntryData.get(V1SchemeSigner.MANIFEST_ENTRY_NAME);
        if (!Arrays.equals(newManifest.contents, emittedSignatureManifest)) {
            // Emitted v1 signature is no longer valid.
            try {
                signatureZipEntries = V1SchemeSigner.signManifest(mV1SignerConfigs, mV1ContentDigestAlgorithm, apkSigningSchemeIds, mCreatedBy, newManifest);
            } catch (CertificateException e) {
                throw new SignatureException("Failed to generate v1 signature", e);
            }
        } else {
            // Emitted v1 signature is still valid. Check whether the signature is there in the
            // output.
            signatureZipEntries = new ArrayList<>();
            for (Map.Entry<String, byte[]> expectedOutputEntry : mEmittedSignatureJarEntryData.entrySet()) {
                String entryName = expectedOutputEntry.getKey();
                byte[] expectedData = expectedOutputEntry.getValue();
                GetJarEntryDataRequest actualDataRequest = mOutputSignatureJarEntryDataRequests.get(entryName);
                if (actualDataRequest == null) {
                    // This signature entry hasn't been output.
                    signatureZipEntries.add(Pair.of(entryName, expectedData));
                    continue;
                }
                byte[] actualData = actualDataRequest.getData();
                if (!Arrays.equals(expectedData, actualData)) {
                    signatureZipEntries.add(Pair.of(entryName, expectedData));
                }
            }
            if (signatureZipEntries.isEmpty()) {
                // v1 signature in the output is valid
                return null;
            }
        // v1 signature in the output is not valid.
        }
    }
    if (signatureZipEntries.isEmpty()) {
        // v1 signature in the output is valid
        mV1SignaturePending = false;
        return null;
    }
    List<OutputJarSignatureRequest.JarEntry> sigEntries = new ArrayList<>(signatureZipEntries.size());
    for (Pair<String, byte[]> entry : signatureZipEntries) {
        String entryName = entry.getFirst();
        byte[] entryData = entry.getSecond();
        sigEntries.add(new OutputJarSignatureRequest.JarEntry(entryName, entryData));
        mEmittedSignatureJarEntryData.put(entryName, entryData);
    }
    mAddV1SignatureRequest = new OutputJarSignatureRequestImpl(sigEntries);
    return mAddV1SignatureRequest;
}
#end_block

#method_before
private OutputApkSigningBlockRequestImpl outputZipSectionsInternal(DataSource zipEntries, DataSource zipCentralDirectory, DataSource zipEocd, boolean apkSigningBlockPaddingSupported) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    checkNotClosed();
    checkV1SigningDoneIfEnabled();
    if (!mV2SigningEnabled && !mV3SigningEnabled) {
        return null;
    }
    checkOutputApkNotDebuggableIfDebuggableMustBeRejected();
    // adjust to proper padding
    Pair<DataSource, Integer> paddingPair = ApkSigningBlockUtils.generateApkSigningBlockPadding(zipEntries, apkSigningBlockPaddingSupported);
    DataSource beforeCentralDir = paddingPair.getFirst();
    int padSizeBeforeApkSigningBlock = paddingPair.getSecond();
    DataSource eocd = ApkSigningBlockUtils.copyWithModifiedCDOffset(beforeCentralDir, zipEocd);
    List<Pair<byte[], Integer>> signingSchemeBlocks = new ArrayList<>();
    // create APK Signature Scheme V2 Signature if requested
    if (mV2SigningEnabled) {
        invalidateV2Signature();
        List<ApkSigningBlockUtils.SignerConfig> v2SignerConfigs = createV2SignerConfigs(apkSigningBlockPaddingSupported);
        signingSchemeBlocks.add(V2SchemeSigner.generateApkSignatureSchemeV2Block(beforeCentralDir, zipCentralDirectory, eocd, v2SignerConfigs));
    }
    if (mV3SigningEnabled) {
        invalidateV3Signature();
        List<ApkSigningBlockUtils.SignerConfig> v3SignerConfig = createV3SignerConfig(apkSigningBlockPaddingSupported);
        signingSchemeBlocks.add(V3SchemeSigner.generateApkSignatureSchemeV3Block(beforeCentralDir, zipCentralDirectory, eocd, v3SignerConfig));
    }
    // create APK Signing Block with v2
    byte[] apkSigningBlock = ApkSigningBlockUtils.generateApkSigningBlock(signingSchemeBlocks);
    mAddSigningBlockRequest = new OutputApkSigningBlockRequestImpl(apkSigningBlock, padSizeBeforeApkSigningBlock);
    return mAddSigningBlockRequest;
}
#method_after
private OutputApkSigningBlockRequestImpl outputZipSectionsInternal(DataSource zipEntries, DataSource zipCentralDirectory, DataSource zipEocd, boolean apkSigningBlockPaddingSupported) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    checkNotClosed();
    checkV1SigningDoneIfEnabled();
    if (!mV2SigningEnabled && !mV3SigningEnabled) {
        return null;
    }
    checkOutputApkNotDebuggableIfDebuggableMustBeRejected();
    // adjust to proper padding
    Pair<DataSource, Integer> paddingPair = ApkSigningBlockUtils.generateApkSigningBlockPadding(zipEntries, apkSigningBlockPaddingSupported);
    DataSource beforeCentralDir = paddingPair.getFirst();
    int padSizeBeforeApkSigningBlock = paddingPair.getSecond();
    DataSource eocd = ApkSigningBlockUtils.copyWithModifiedCDOffset(beforeCentralDir, zipEocd);
    List<Pair<byte[], Integer>> signingSchemeBlocks = new ArrayList<>();
    // create APK Signature Scheme V2 Signature if requested
    if (mV2SigningEnabled) {
        invalidateV2Signature();
        List<ApkSigningBlockUtils.SignerConfig> v2SignerConfigs = createV2SignerConfigs(apkSigningBlockPaddingSupported);
        signingSchemeBlocks.add(V2SchemeSigner.generateApkSignatureSchemeV2Block(beforeCentralDir, zipCentralDirectory, eocd, v2SignerConfigs, mV3SigningEnabled));
    }
    if (mV3SigningEnabled) {
        invalidateV3Signature();
        List<ApkSigningBlockUtils.SignerConfig> v3SignerConfig = createV3SignerConfigs(apkSigningBlockPaddingSupported);
        signingSchemeBlocks.add(V3SchemeSigner.generateApkSignatureSchemeV3Block(beforeCentralDir, zipCentralDirectory, eocd, v3SignerConfig));
    }
    // create APK Signing Block
    byte[] apkSigningBlock = ApkSigningBlockUtils.generateApkSigningBlock(signingSchemeBlocks);
    mAddSigningBlockRequest = new OutputApkSigningBlockRequestImpl(apkSigningBlock, padSizeBeforeApkSigningBlock);
    return mAddSigningBlockRequest;
}
#end_block

#method_before
private void checkSigningBlockDoneIfEnabled() {
    if (!mV2SignaturePending || !mV3SignaturePending) {
        return;
    }
    if (mAddSigningBlockRequest == null) {
        throw new IllegalStateException("Signed APK Signing BLock not yet generated. Skipped outputZipSections()?");
    }
    if (!mAddSigningBlockRequest.isDone()) {
        throw new IllegalStateException("APK Signing Block addition of signature(s) requested by" + " outputZipSections() hasn't been fulfilled yet");
    }
    mAddSigningBlockRequest = null;
    mV2SignaturePending = false;
    mV3SignaturePending = false;
}
#method_after
private void checkSigningBlockDoneIfEnabled() {
    if (!mV2SignaturePending && !mV3SignaturePending) {
        return;
    }
    if (mAddSigningBlockRequest == null) {
        throw new IllegalStateException("Signed APK Signing BLock not yet generated. Skipped outputZipSections()?");
    }
    if (!mAddSigningBlockRequest.isDone()) {
        throw new IllegalStateException("APK Signing Block addition of signature(s) requested by" + " outputZipSections() hasn't been fulfilled yet");
    }
    mAddSigningBlockRequest = null;
    mV2SignaturePending = false;
    mV3SignaturePending = false;
}
#end_block

#method_before
public DefaultApkSignerEngine build() throws InvalidKeyException {
    return new DefaultApkSignerEngine(mSignerConfigs, mOldSignerConfig, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mV3SigningEnabled, mDebuggableApkPermitted, mOtherSignersSignaturesPreserved, mCreatedBy);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mName, mPrivateKey, mCertificates);
}
#end_block

#method_before
public DefaultApkSignerEngine build() throws InvalidKeyException {
    return new DefaultApkSignerEngine(mSignerConfigs, mOldSignerConfig, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mV3SigningEnabled, mDebuggableApkPermitted, mOtherSignersSignaturesPreserved, mCreatedBy);
}
#method_after
public DefaultApkSignerEngine build() throws InvalidKeyException {
    if (mV3SigningExplicitlyDisabled && mV3SigningExplicitlyEnabled) {
        throw new IllegalStateException("Builder configured to both enable and disable APK " + "Signature Scheme v3 signing");
    }
    if (mV3SigningExplicitlyDisabled) {
        mV3SigningEnabled = false;
    } else if (mV3SigningExplicitlyEnabled) {
        mV3SigningEnabled = true;
    }
    // make sure our signers are appropriately setup
    if (mSigningCertificateLineage != null) {
        try {
            mSignerConfigs = mSigningCertificateLineage.sortSignerConfigs(mSignerConfigs);
            if (!mV3SigningEnabled && mSignerConfigs.size() > 1) {
                // which signer the user intended to sign
                throw new IllegalStateException("Provided multiple signers which are part " + "of the SigningCertificateLineage, but not signing with APK " + "Signature Scheme v3");
            }
        } catch (IllegalArgumentException e) {
            throw new IllegalStateException("Provided signer configs do not match the " + "provided SigningCertificateLineage", e);
        }
    } else if (mV3SigningEnabled && mSignerConfigs.size() > 1) {
        throw new IllegalStateException("Multiple signing certificates provided for use " + "with APK Signature Scheme v3 without an accompanying SigningCertificateLineage");
    }
    return new DefaultApkSignerEngine(mSignerConfigs, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mV3SigningEnabled, mDebuggableApkPermitted, mOtherSignersSignaturesPreserved, mCreatedBy, mSigningCertificateLineage);
}
#end_block

#method_before
public Builder setV3SigningEnabled(boolean enabled) {
    if (enabled && mSignerConfigs.size() > 1) {
        throw new IllegalArgumentException("APK Signature Scheme v3 cannot be used with " + "multiple signers.");
    }
    mV3SigningEnabled = enabled;
    return this;
}
#method_after
public Builder setV3SigningEnabled(boolean enabled) {
    mV3SigningEnabled = enabled;
    if (enabled) {
        mV3SigningExplicitlyEnabled = true;
    } else {
        mV3SigningExplicitlyDisabled = true;
    }
    return this;
}
#end_block

